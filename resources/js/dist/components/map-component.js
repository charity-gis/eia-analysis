var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/ol/events/Event.js
var BaseEvent = class {
  /**
   * @param {string} type Type.
   */
  constructor(type) {
    this.propagationStopped;
    this.defaultPrevented;
    this.type = type;
    this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = true;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
};
var Event_default = BaseEvent;

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};

// node_modules/ol/Disposable.js
var Disposable = class {
  constructor() {
    this.disposed = false;
  }
  /**
   * Clean up.
   */
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
};
var Disposable_default = Disposable;

// node_modules/ol/array.js
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!lastArgs || this !== lastThis || !equals(nextArgs, lastArgs)) {
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}

// node_modules/ol/events/Target.js
var Target = class extends Disposable_default {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(target) {
    super();
    this.eventTarget_ = target;
    this.pendingRemovals_ = null;
    this.dispatching_ = null;
    this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(event) {
    const isString = typeof event === "string";
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }
    const evt = isString ? new Event_default(event) : (
      /** @type {Event} */
      event
    );
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ("handleEvent" in listeners[i]) {
        propagate = /** @type {import("../events.js").ListenerObject} */
        listeners[i].handleEvent(evt);
      } else {
        propagate = /** @type {import("../events.js").ListenerFunction} */
        listeners[i].call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && clear(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(type) {
    return this.listeners_ && this.listeners_[type] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(type, listener) {
    if (!this.listeners_) {
      return;
    }
    const listeners = this.listeners_[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      if (this.pendingRemovals_ && type in this.pendingRemovals_) {
        listeners[index] = VOID;
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  }
};
var Target_default = Target;

// node_modules/ol/events/EventType.js
var EventType_default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(thisArg ?? this, arguments);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}

// node_modules/ol/Observable.js
var Observable = class extends Target_default {
  constructor() {
    super();
    this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal;
    this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal;
    this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal;
    this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_;
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys[i] = listen(this, type[i], listener);
      }
      return keys;
    }
    return listen(
      this,
      /** @type {string} */
      type,
      listener
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = listenOnce(this, type[i], listener);
      }
    } else {
      key = listenOnce(
        this,
        /** @type {string} */
        type,
        listener
      );
    }
    listener.ol_key = key;
    return key;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(type, listener) {
    const key = (
      /** @type {Object} */
      listener.ol_key
    );
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
};
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable_default = Observable;

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
var uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

// node_modules/ol/Object.js
var ObjectEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(type, key, oldValue) {
    super(type);
    this.key = key;
    this.oldValue = oldValue;
  }
};
var BaseObject = class extends Observable_default {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(values) {
    super();
    this.on;
    this.once;
    this.un;
    getUid(this);
    this.values_ = null;
    if (values !== void 0) {
      this.setProperties(values);
    }
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = ObjectEventType_default.PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(key, value, silent) {
    const values = this.values_ || (this.values_ = {});
    if (silent) {
      values[key] = value;
    } else {
      const oldValue = values[key];
      values[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(values, silent) {
    for (const key in values) {
      this.set(key, values[key], silent);
    }
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if (isEmpty(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
};
var Object_default = BaseObject;

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
};

// node_modules/ol/Collection.js
var Property = {
  LENGTH: "length"
};
var CollectionEvent = class extends Event_default {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(type, element, index) {
    super(type);
    this.element = element;
    this.index = index;
  }
};
var Collection = class extends Object_default {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(array, options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options || {};
    this.unique_ = !!options.unique;
    this.array_ = array ? array : [];
    if (this.unique_) {
      for (let i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    while (this.getLength() > 0) {
      this.pop();
    }
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(arr) {
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(f) {
    const array = this.array_;
    for (let i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(index) {
    return this.array_[index];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Property.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(index, elem) {
    if (index < 0 || index > this.getLength()) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(CollectionEventType_default.ADD, elem, index)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    const n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(elem) {
    const arr = this.array_;
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return void 0;
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(index) {
    if (index < 0 || index >= this.getLength()) {
      return void 0;
    }
    const prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
    );
    return prev;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(index, elem) {
    const n = this.getLength();
    if (index >= n) {
      this.insertAt(index, elem);
      return;
    }
    if (index < 0) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    const prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
    );
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType_default.ADD, elem, index)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Property.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(elem, except) {
    for (let i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== except) {
        throw new Error("Duplicate item added to a unique collection");
      }
    }
  }
};
var Collection_default = Collection;

// node_modules/ol/layer/Property.js
var Property_default = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}

// node_modules/ol/layer/Base.js
var BaseLayer = class extends Object_default {
  /**
   * @param {Options} options Layer options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.background_ = options.background;
    const properties = Object.assign({}, options);
    if (typeof options.properties === "object") {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }
    properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
    assert(
      typeof properties[Property_default.OPACITY] === "number",
      "Layer opacity must be a number"
    );
    properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
    properties[Property_default.Z_INDEX] = options.zIndex;
    properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
    properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
    properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
    properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
    this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
    delete properties.className;
    this.setProperties(properties);
    this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(managed) {
    const state = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: managed === void 0 ? true : managed
    };
    const zIndex = this.getZIndex();
    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    return abstract();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    return abstract();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Property_default.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Property_default.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Property_default.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Property_default.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Property_default.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Property_default.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return abstract();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Property_default.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(Property_default.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(extent) {
    this.set(Property_default.EXTENT, extent);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(maxResolution) {
    this.set(Property_default.MAX_RESOLUTION, maxResolution);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(minResolution) {
    this.set(Property_default.MIN_RESOLUTION, minResolution);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(maxZoom) {
    this.set(Property_default.MAX_ZOOM, maxZoom);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(minZoom) {
    this.set(Property_default.MIN_ZOOM, minZoom);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(opacity) {
    assert(typeof opacity === "number", "Layer opacity must be a number");
    this.set(Property_default.OPACITY, opacity);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(visible) {
    this.set(Property_default.VISIBLE, visible);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(zindex) {
    this.set(Property_default.Z_INDEX, zindex);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
};
var Base_default = BaseLayer;

// node_modules/ol/render/EventType.js
var EventType_default2 = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};

// node_modules/ol/ViewHint.js
var ViewHint_default = {
  ANIMATING: 0,
  INTERACTING: 1
};

// node_modules/ol/ViewProperty.js
var ViewProperty_default = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM = 42;
var DEFAULT_TILE_SIZE = 256;

// node_modules/ol/proj/Units.js
var METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  "radians": 6370997 / (2 * Math.PI),
  "degrees": 2 * Math.PI * 6370997 / 360,
  "ft": 0.3048,
  "m": 1,
  "us-ft": 1200 / 3937
};

// node_modules/ol/proj/Projection.js
var Projection = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(options) {
    this.code_ = options.code;
    this.units_ = /** @type {import("./Units.js").Units} */
    options.units;
    this.extent_ = options.extent !== void 0 ? options.extent : null;
    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
    this.global_ = options.global !== void 0 ? options.global : false;
    this.canWrapX_ = !!(this.global_ && this.extent_);
    this.getPointResolutionFunc_ = options.getPointResolution;
    this.defaultTileGrid_ = null;
    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
var Projection_default = Projection;

// node_modules/ol/proj/epsg3857.js
var RADIUS = 6378137;
var HALF_SIZE = Math.PI * RADIUS;
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
var WORLD_EXTENT = [-180, -85, 180, 85];
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
var EPSG3857Projection = class extends Projection_default {
  /**
   * @param {string} code Code.
   */
  constructor(code) {
    super({
      code,
      units: "m",
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      }
    });
  }
};
var PROJECTIONS = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

// node_modules/ol/proj/epsg4326.js
var RADIUS2 = 6378137;
var EXTENT2 = [-180, -90, 180, 90];
var METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
var EPSG4326Projection = class extends Projection_default {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(code, axisOrientation) {
    super({
      code,
      units: "degrees",
      extent: EXTENT2,
      axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT2,
      worldExtent: EXTENT2
    });
  }
};
var PROJECTIONS2 = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];

// node_modules/ol/proj/projections.js
var cache = {};
function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add(code, projection) {
  cache[code] = projection;
}

// node_modules/ol/proj/transforms.js
var transforms = {};
function add2(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get2(sourceCode, destinationCode) {
  let transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}

// node_modules/ol/extent/Relationship.js
var Relationship_default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty2(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start, end) {
  let intersects3 = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects3 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
    if (!intersects3 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
  }
  return intersects3;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth && !multiWorld) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}

// node_modules/ol/coordinate.js
function add3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals3(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
function scale(coordinate, scale4) {
  coordinate[0] *= scale4;
  coordinate[1] *= scale4;
  return coordinate;
}
function wrapX2(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}

// node_modules/ol/sphere.js
var DEFAULT_RADIUS = 63710088e-1;
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

// node_modules/ol/console.js
var levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
var level = levels.info;
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}

// node_modules/ol/proj.js
var showCoordinateWarning = true;
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output) {
  if (output !== void 0 && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add(projection.getCode(), projection);
  add2(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  return typeof projectionLike === "string" ? get(
    /** @type {string} */
    projectionLike
  ) : (
    /** @type {Projection} */
    projectionLike || null
  );
}
function getPointResolution(projection, resolution, point, units) {
  projection = get3(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get3("EPSG:4326")
      );
      if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add2(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add2(projection1, projection2, forwardTransform);
      add2(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
var userProjection = null;
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
addCommon();

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none(center) {
  return center;
}

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}

// node_modules/ol/easing.js
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
  return t;
}

// node_modules/ol/transform.js
var tmp_ = new Array(6);
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function apply(transform2, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
var matrixPrecision = [1e6, 1e6, 1e6, 1e6, 2, 2];
function toString(mat) {
  const transformString = "matrix(" + mat.map(
    (value, i) => Math.round(value * matrixPrecision[i]) / matrixPrecision[i]
  ).join(", ") + ")";
  return transformString;
}

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset, end, stride, transform2, dest, destinationStride) {
  dest = dest ? dest : [];
  destinationStride = destinationStride ? destinationStride : 2;
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
    for (let k = 2; k < destinationStride; k++) {
      dest[i++] = flatCoordinates[j + k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate2(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale2(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

// node_modules/ol/geom/Geometry.js
var tmpTransform = create();
var Geometry = class extends Object_default {
  constructor() {
    super();
    this.extent_ = createEmpty();
    this.extentRevision_ = -1;
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = 0;
    this.simplifyTransformedInternal = memoizeOne(
      (revision, squaredTolerance, transform2) => {
        if (!transform2) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        const clone2 = this.clone();
        clone2.applyTransform(transform2);
        return clone2.getSimplifiedGeometry(squaredTolerance);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform2) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform2
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return abstract();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return abstract();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return abstract();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent2 = this.computeExtent(this.extent_);
      if (isNaN(extent2[0]) || isNaN(extent2[1])) {
        createOrUpdateEmpty(extent2);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, extent);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    abstract();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    abstract();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return abstract();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return abstract();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(transformFn) {
    abstract();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(extent) {
    return abstract();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    abstract();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(source, destination) {
    const sourceProj = get3(source);
    const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
      const pixelExtent = sourceProj.getExtent();
      const projectedExtent = sourceProj.getWorldExtent();
      const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform,
        projectedExtent[0],
        projectedExtent[3],
        scale4,
        -scale4,
        0,
        0,
        0
      );
      transform2D(
        inCoordinates,
        0,
        inCoordinates.length,
        stride,
        tmpTransform,
        outCoordinates
      );
      return getTransform(sourceProj, destination)(
        inCoordinates,
        outCoordinates,
        stride
      );
    } : getTransform(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
};
var Geometry_default = Geometry;

// node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = class extends Geometry_default {
  constructor() {
    super();
    this.layout = "XY";
    this.stride = 2;
    this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return createOrUpdateFromFlatCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return abstract();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @override
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(coordinates2, layout) {
    abstract();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(layout, coordinates2, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates2.length === 0) {
          this.layout = "XY";
          this.stride = 2;
          return;
        }
        coordinates2 = /** @type {Array<unknown>} */
        coordinates2[0];
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(
        this.flatCoordinates,
        this.flatCoordinates,
        this.layout.startsWith("XYZ") ? 3 : 2,
        this.stride
      );
      this.changed();
    }
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      rotate2(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(sx, sy, anchor) {
    if (sy === void 0) {
      sy = sx;
    }
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      scale2(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      translate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
};
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
var SimpleGeometry_default = SimpleGeometry;

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = end;
  }
  return minSquaredDistance;
}

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance2 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance2 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance2;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  const x0 = flatCoordinates[end - stride];
  const y0 = flatCoordinates[end - stride + 1];
  let dx1 = 0;
  let dy1 = 0;
  for (; offset < end; offset += stride) {
    const dx2 = flatCoordinates[offset] - x0;
    const dy2 = flatCoordinates[offset + 1] - y0;
    twiceArea += dy1 * dx2 - dx1 * dy2;
    dx1 = dx2;
    dy1 = dy2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}

// node_modules/ol/geom/LinearRing.js
var LinearRing = class _LinearRing extends SimpleGeometry_default {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   * @override
   */
  clone() {
    return new _LinearRing(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        maxSquaredDelta(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRing(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new _LinearRing(simplifiedFlatCoordinates, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return false;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var LinearRing_default = LinearRing;

// node_modules/ol/geom/Point.js
var Point = class _Point extends SimpleGeometry_default {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.setCoordinates(coordinates2, layout);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   * @override
   */
  clone() {
    const point = new _Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var Point_default = Point;

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  const coordinatesExtent = extendFlatCoordinates(
    createEmpty(),
    flatCoordinates,
    offset,
    end,
    stride
  );
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}

// node_modules/ol/geom/Polygon.js
var Polygon = class _Polygon extends SimpleGeometry_default {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.flatInteriorPointRevision_ = -1;
    this.flatInteriorPoint_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (layout !== void 0 && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   * @override
   */
  clone() {
    const polygon = new _Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        arrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(x, y) {
    return linearRingsContainsXY(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRings(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Point_default(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new LinearRing_default(
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings2 = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing2 = new LinearRing_default(
        flatCoordinates.slice(offset, end),
        layout
      );
      linearRings2.push(linearRing2);
      offset = end;
    }
    return linearRings2;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return intersectsLinearRingArray(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
var Polygon_default = Polygon;
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}

// node_modules/ol/View.js
var DEFAULT_MIN_ZOOM = 0;
var View = class extends Object_default {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = Object.assign({}, options);
    this.hints_ = [0, 0];
    this.animations_ = [];
    this.updateAnimationKey_;
    this.projection_ = createProjection(options.projection, "EPSG:3857");
    this.viewportSize_ = [100, 100];
    this.targetCenter_ = null;
    this.targetResolution_;
    this.targetRotation_;
    this.nextCenter_ = null;
    this.nextResolution_;
    this.nextRotation_;
    this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, this.projection_);
    }
    this.applyOptions_(options);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in ViewProperty_default) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    const resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(
      options.center !== void 0 ? options.center : null
    );
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenterInternal();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return Object.assign({}, options, newOptions);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i = 0; i < args.length; ++i) {
      let options = arguments[i];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = fromUserCoordinate(
          options.center,
          this.getProjection()
        );
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = fromUserCoordinate(
          options.anchor,
          this.getProjection()
        );
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    let i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      const state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    let start = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i < animationCount; ++i) {
      const options = (
        /** @type {AnimationOptions} */
        arguments[i]
      );
      const animation = {
        start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint_default.ANIMATING, 1);
    this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[ViewHint_default.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[ViewHint_default.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
    let anchor;
    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
      const series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j = 0, jj = series.length; j < jj; ++j) {
          const animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now = Date.now();
    let more = false;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const series = this.animations_[i];
      let seriesComplete = true;
      for (let j = 0, jj = series.length; j < jj; ++j) {
        const animation = series[j];
        if (animation.complete) {
          continue;
        }
        const elapsed = now - animation.start;
        let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x = x0 + progress * (x1 - x0);
          const y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(
              resolution,
              0,
              size,
              true
            );
            this.targetCenter_ = this.calculateCenterZoom(
              constrainedResolution,
              animation.anchor
            );
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(
              rotation,
              true
            );
            this.targetCenter_ = this.calculateCenterRotate(
              constrainedRotation,
              animation.anchor
            );
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(ViewHint_default.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      );
    }
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate(center, rotation - this.getRotation());
      add3(center, anchor);
    }
    return center;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(rotation) {
    const size = this.viewportSize_;
    if (rotation) {
      const w = size[0];
      const h = size[1];
      return [
        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
      ];
    }
    return size;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(size) {
    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ViewProperty_default.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(hints) {
    if (hints !== void 0) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(size) {
    const extent = this.calculateExtentInternal(size);
    return toUserExtent(extent, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(size) {
    size = size || this.getViewportSizeMinusPadding_();
    const center = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    assert(center, "The view center is not defined");
    const resolution = (
      /** @type {!number} */
      this.getResolution()
    );
    assert(resolution !== void 0, "The view resolution is not defined");
    const rotation = (
      /** @type {!number} */
      this.getRotation()
    );
    assert(rotation !== void 0, "The view rotation is not defined");
    return getForViewAndSize(center, resolution, rotation, size);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(ViewProperty_default.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(extent, size) {
    return this.getResolutionForExtentInternal(
      fromUserExtent(extent, this.getProjection()),
      size
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(extent, size) {
    size = size || this.getViewportSizeMinusPadding_();
    const xResolution = getWidth(extent) / size[0];
    const yResolution = getHeight(extent) / size[1];
    return Math.max(xResolution, yResolution);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(value) {
        const resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(ViewProperty_default.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(resolution) {
        const value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(rotation) {
    let size = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ];
    }
    return size;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(
        center,
        this.getViewportSize_(),
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(resolution) {
    let offset = this.minZoom_ || 0;
    let max, zoomFactor;
    if (this.resolutions_) {
      const nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(zoom) {
    if (this.resolutions_?.length) {
      if (this.resolutions_.length === 1) {
        return this.resolutions_[0];
      }
      const baseLevel = clamp(
        Math.floor(zoom),
        0,
        this.resolutions_.length - 2
      );
      const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(geometryOrExtent, options) {
    let geometry;
    assert(
      Array.isArray(geometryOrExtent) || typeof /** @type {?} */
      geometryOrExtent.getSimplifiedGeometry === "function",
      "Invalid extent or geometry provided as `geometry`"
    );
    if (Array.isArray(geometryOrExtent)) {
      assert(
        !isEmpty2(geometryOrExtent),
        "Cannot fit empty extent provided as `geometry`"
      );
      const extent = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent);
    } else if (geometryOrExtent.getType() === "Circle") {
      const extent = fromUserExtent(
        geometryOrExtent.getExtent(),
        this.getProjection()
      );
      geometry = fromExtent(extent);
      geometry.rotate(this.getRotation(), getCenter(extent));
    } else {
      const userProjection2 = getUserProjection();
      if (userProjection2) {
        geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
        geometryOrExtent.clone().transform(userProjection2, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, options);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = Infinity;
    let minRotY = Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i = 0, ii = coords.length; i < ii; i += stride) {
      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(geometry, options) {
    options = options || {};
    let size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== void 0 ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    const rotatedExtent = this.rotatedExtentForGeometry(geometry);
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal(
        {
          resolution,
          center,
          duration: options.duration,
          easing: options.easing
        },
        callback
      );
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(coordinate, size, position) {
    this.centerOnInternal(
      fromUserCoordinate(coordinate, this.getProjection()),
      size,
      position
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(coordinate, size, position) {
    this.setCenterInternal(
      calculateCenterOn(
        coordinate,
        size,
        position,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(center, resolution, rotation, size) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(
        center,
        size,
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(deltaCoordinates) {
    const center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(ratio, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(
      this.targetResolution_ * ratio,
      0,
      size,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = fromUserCoordinate(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(
      this.targetRotation_ + delta,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(center) {
    this.setCenterInternal(
      center ? fromUserCoordinate(center, this.getProjection()) : center
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
    const newRotation = this.constraints_.rotation(
      this.targetRotation_,
      isMoving
    );
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      0,
      size,
      isMoving
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      isMoving,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
      this.set(ViewProperty_default.ROTATION, newRotation);
    }
    if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
      this.set(ViewProperty_default.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
      this.set(ViewProperty_default.CENTER, newCenter);
    }
    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(duration, resolutionDirection, anchor) {
    duration = duration !== void 0 ? duration : 200;
    const direction = resolutionDirection || 0;
    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      direction,
      size
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      false,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration,
        easing: easeOut,
        anchor
      });
    }
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0);
    this.setHint(ViewHint_default.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(duration, resolutionDirection, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.endInteractionInternal(duration, resolutionDirection, anchor);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(duration, resolutionDirection, anchor) {
    if (!this.getInteracting()) {
      return;
    }
    this.setHint(ViewHint_default.INTERACTING, -1);
    this.resolveConstraints(duration, resolutionDirection, anchor);
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(targetCenter, targetResolution) {
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      targetCenter,
      targetResolution || this.getResolution(),
      size
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(targetZoom, direction) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(
      this.getConstrainedResolution(targetRes, direction)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(targetResolution, direction) {
    direction = direction || 0;
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  }
};
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var View_default = View;

// node_modules/ol/layer/Layer.js
var Layer = class extends Base_default {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.mapPrecomposeKey_ = null;
    this.mapRenderKey_ = null;
    this.sourceChangeKey_ = null;
    this.renderer_ = null;
    this.sourceReady_ = false;
    this.rendered = false;
    if (options.render) {
      this.render = options.render;
    }
    if (options.map) {
      this.setMap(options.map);
    }
    this.addChangeListener(
      Property_default.SOURCE,
      this.handleSourcePropertyChange_
    );
    const source = options.source ? (
      /** @type {SourceType} */
      options.source
    ) : null;
    this.setSource(source);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Property_default.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const source = this.getSource();
    return !source ? "undefined" : source.getState();
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== "ready") {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent("sourceready");
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      unlistenByKey(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = listen(
        source,
        EventType_default.CHANGE,
        this.handleSourceChange_,
        this
      );
      if (source.getState() === "ready") {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent("sourceready");
        }, 0);
      }
    }
    this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(view) {
    let frameState;
    const map = this.getMapInternal();
    if (!view && map) {
      view = map.getView();
    }
    if (view instanceof View_default) {
      frameState = {
        viewState: view.getState(),
        extent: view.calculateExtent()
      };
    } else {
      frameState = view;
    }
    if (!frameState.layerStatesArray && map) {
      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
    }
    let layerState;
    if (frameState.layerStatesArray) {
      layerState = frameState.layerStatesArray.find(
        (layerState2) => layerState2.layer === this
      );
    } else {
      layerState = this.getLayerState();
    }
    const layerExtent = this.getExtent();
    return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(view) {
    if (!this.isVisible(view)) {
      return [];
    }
    const getAttributions = this.getSource()?.getAttributions();
    if (!getAttributions) {
      return [];
    }
    const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
    let attributions = getAttributions(frameState);
    if (!Array.isArray(attributions)) {
      attributions = [attributions];
    }
    return attributions;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(frameState, target) {
    const layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
    return null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = false;
  }
  /** @return {string} Declutter */
  getDeclutter() {
    return void 0;
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(frameState, layerState) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(frameState) {
    const layerRenderer = this.getRenderer();
    if (!layerRenderer) {
      return;
    }
    layerRenderer.renderDeferred(frameState);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(map) {
    if (!map) {
      this.unrender();
    }
    this.set(Property_default.MAP, map);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Property_default.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.mapPrecomposeKey_) {
      unlistenByKey(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      unlistenByKey(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = listen(
        map,
        EventType_default2.PRECOMPOSE,
        this.handlePrecompose_,
        this
      );
      this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
      this.changed();
    }
  }
  /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */
  handlePrecompose_(renderEvent) {
    const layerStatesArray = (
      /** @type {import("../render/Event.js").default} */
      renderEvent.frameState.layerStatesArray
    );
    const layerState = this.getLayerState(false);
    assert(
      !layerStatesArray.some(
        (arrayLayerState) => arrayLayerState.layer === layerState.layer
      ),
      "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
    );
    layerStatesArray.push(layerState);
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(source) {
    this.set(Property_default.SOURCE, source);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
    this.setSource(null);
    super.disposeInternal();
  }
};
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer_default = Layer;

// node_modules/quickselect/index.js
function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight, compare);
    }
    const t = arr[k];
    let i = left;
    let j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0) i++;
      while (compare(arr[j], t) > 0) j--;
    }
    if (compare(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

// node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects2(bbox, node)) return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects2(bbox, childBBox)) {
          if (node.leaf) result.push(child);
          else if (contains(bbox, childBBox)) this._all(child, result);
          else nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects2(bbox, node)) return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects2(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length)) return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item) return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf) result.push(...node.children);
      else nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level2, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level2) break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level2, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level2, insertPath);
    node.children.push(item);
    extend3(node, bbox);
    while (level2 >= 0) {
      if (insertPath[level2].children.length > this._maxEntries) {
        this._split(insertPath, level2);
        level2--;
      } else break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level2);
  }
  // split overflowed node into two
  _split(insertPath, level2) {
    const node = insertPath[level2];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level2) insertPath[level2 - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin) node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend3(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend3(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level2) {
    for (let i = level2; i >= 0; i--) {
      extend3(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend3(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend3(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects2(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

// node_modules/ol/ImageState.js
var ImageState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/size.js
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale3(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}

// node_modules/ol/style/Image.js
var ImageStyle = class _ImageStyle {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    this.opacity_ = options.opacity;
    this.rotateWithView_ = options.rotateWithView;
    this.rotation_ = options.rotation;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale);
    this.displacement_ = options.displacement;
    this.declutterMode_ = options.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const scale4 = this.getScale();
    return new _ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return abstract();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(pixelRatio) {
    return abstract();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return abstract();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return abstract();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return abstract();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return abstract();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return abstract();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale4) {
    this.scale_ = scale4;
    this.scaleArray_ = toSize(scale4);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    abstract();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    abstract();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    abstract();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
};
var Image_default = ImageStyle;

// node_modules/color-space/rgb.js
var rgb_default = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
};

// node_modules/color-space/xyz.js
var xyz = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"]
};
xyz.whitepoint = {
  //1931 2
  2: {
    //incadescent
    A: [109.85, 100, 35.585],
    // B:[],
    C: [98.074, 100, 118.232],
    D50: [96.422, 100, 82.521],
    D55: [95.682, 100, 92.149],
    //daylight
    D65: [95.045592705167, 100, 108.9057750759878],
    D75: [94.972, 100, 122.638],
    //flourescent
    // F1: [],
    F2: [99.187, 100, 67.395],
    // F3: [],
    // F4: [],
    // F5: [],
    // F6:[],
    F7: [95.044, 100, 108.755],
    // F8: [],
    // F9: [],
    // F10: [],
    F11: [100.966, 100, 64.37],
    // F12: [],
    E: [100, 100, 100]
  },
  //1964  10
  10: {
    //incadescent
    A: [111.144, 100, 35.2],
    C: [97.285, 100, 116.145],
    D50: [96.72, 100, 81.427],
    D55: [95.799, 100, 90.926],
    //daylight
    D65: [94.811, 100, 107.304],
    D75: [94.416, 100, 120.641],
    //flourescent
    F2: [103.28, 100, 69.026],
    F7: [95.792, 100, 107.687],
    F11: [103.866, 100, 65.627],
    E: [100, 100, 100]
  }
};
xyz.max = xyz.whitepoint[2].D65;
xyz.rgb = function(_xyz, white) {
  white = white || xyz.whitepoint[2].E;
  var x = _xyz[0] / white[0], y = _xyz[1] / white[1], z = _xyz[2] / white[2], r, g, b;
  r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
  g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
  b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
  r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92;
  g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g = g * 12.92;
  b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b = b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};
rgb_default.xyz = function(rgb, white) {
  var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
  var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
  var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
  white = white || xyz.whitepoint[2].E;
  return [x * white[0], y * white[1], z * white[2]];
};
var xyz_default = xyz;

// node_modules/color-space/luv.js
var luv_default = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(arg, i, o) {
    var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
    l = arg[0], u = arg[1], v = arg[2];
    if (l === 0) return [0, 0, 0];
    var k = 0.0011070564598794539;
    i = i || "D65";
    o = o || 2;
    xn = xyz_default.whitepoint[o][i][0];
    yn = xyz_default.whitepoint[o][i][1];
    zn = xyz_default.whitepoint[o][i][2];
    un = 4 * xn / (xn + 15 * yn + 3 * zn);
    vn = 9 * yn / (xn + 15 * yn + 3 * zn);
    _u = u / (13 * l) + un || 0;
    _v = v / (13 * l) + vn || 0;
    y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;
    x = y * 9 * _u / (4 * _v) || 0;
    z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;
    return [x, y, z];
  }
};
xyz_default.luv = function(arg, i, o) {
  var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
  var e = 0.008856451679035631;
  var k = 903.2962962962961;
  i = i || "D65";
  o = o || 2;
  xn = xyz_default.whitepoint[o][i][0];
  yn = xyz_default.whitepoint[o][i][1];
  zn = xyz_default.whitepoint[o][i][2];
  un = 4 * xn / (xn + 15 * yn + 3 * zn);
  vn = 9 * yn / (xn + 15 * yn + 3 * zn);
  x = arg[0], y = arg[1], z = arg[2];
  _u = 4 * x / (x + 15 * y + 3 * z) || 0;
  _v = 9 * y / (x + 15 * y + 3 * z) || 0;
  var yr = y / yn;
  l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
  u = 13 * l * (_u - un);
  v = 13 * l * (_v - vn);
  return [l, u, v];
};

// node_modules/color-space/lchuv.js
var lchuv = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(luv) {
    var l = luv[0], c = luv[1], h = luv[2], u, v, hr;
    hr = h / 360 * 2 * Math.PI;
    u = c * Math.cos(hr);
    v = c * Math.sin(hr);
    return [l, u, v];
  },
  xyz: function(arg) {
    return luv_default.xyz(lchuv.luv(arg));
  }
};
var lchuv_default = lchuv;
luv_default.lchuv = function(luv) {
  var l = luv[0], u = luv[1], v = luv[2];
  var c = Math.sqrt(u * u + v * v);
  var hr = Math.atan2(v, u);
  var h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  return [l, c, h];
};
xyz_default.lchuv = function(arg) {
  return luv_default.lchuv(xyz_default.luv(arg));
};

// node_modules/color-parse/node_modules/color-name/index.js
var color_name_default = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

// node_modules/color-parse/index.js
var color_parse_default = parse;
var baseHues = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function parse(cstr) {
  var m, parts = [], alpha = 1, space;
  if (typeof cstr === "number") {
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  }
  if (typeof cstr === "number") return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  cstr = String(cstr).toLowerCase();
  if (color_name_default[cstr]) {
    parts = color_name_default[cstr].slice();
    space = "rgb";
  } else if (cstr === "transparent") {
    alpha = 0;
    space = "rgb";
    parts = [0, 0, 0];
  } else if (cstr[0] === "#") {
    var base = cstr.slice(1);
    var size = base.length;
    var isShort = size <= 4;
    alpha = 1;
    if (isShort) {
      parts = [
        parseInt(base[0] + base[0], 16),
        parseInt(base[1] + base[1], 16),
        parseInt(base[2] + base[2], 16)
      ];
      if (size === 4) {
        alpha = parseInt(base[3] + base[3], 16) / 255;
      }
    } else {
      parts = [
        parseInt(base[0] + base[1], 16),
        parseInt(base[2] + base[3], 16),
        parseInt(base[4] + base[5], 16)
      ];
      if (size === 8) {
        alpha = parseInt(base[6] + base[7], 16) / 255;
      }
    }
    if (!parts[0]) parts[0] = 0;
    if (!parts[1]) parts[1] = 0;
    if (!parts[2]) parts[2] = 0;
    space = "rgb";
  } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name = m[1];
    space = name.replace(/a$/, "");
    var dims = space === "cmyk" ? 4 : space === "gray" ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
    if (space === "color") space = parts.shift();
    parts = parts.map(function(x, i) {
      if (x[x.length - 1] === "%") {
        x = parseFloat(x) / 100;
        if (i === 3) return x;
        if (space === "rgb") return x * 255;
        if (space[0] === "h") return x * 100;
        if (space[0] === "l" && !i) return x * 100;
        if (space === "lab") return x * 125;
        if (space === "lch") return i < 2 ? x * 150 : x * 360;
        if (space[0] === "o" && !i) return x;
        if (space === "oklab") return x * 0.4;
        if (space === "oklch") return i < 2 ? x * 0.4 : x * 360;
        return x;
      }
      if (space[i] === "h" || i === 2 && space[space.length - 1] === "h") {
        if (baseHues[x] !== void 0) return baseHues[x];
        if (x.endsWith("deg")) return parseFloat(x);
        if (x.endsWith("turn")) return parseFloat(x) * 360;
        if (x.endsWith("grad")) return parseFloat(x) * 360 / 400;
        if (x.endsWith("rad")) return parseFloat(x) * 180 / Math.PI;
      }
      if (x === "none") return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function(value) {
      return parseFloat(value);
    });
    space = cstr.match(/([a-z])/ig)?.join("")?.toLowerCase() || "rgb";
  }
  return {
    space,
    values: parts,
    alpha
  };
}

// node_modules/color-space/hsl.js
var hsl_default = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(hsl) {
    var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
    if (s === 0) return val = l * 255, [val, val, val];
    t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (; i < 3; ) {
      t3 = h + 1 / 3 * -(i - 1);
      t3 < 0 ? t3++ : t3 > 1 && t3--;
      val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
      rgb[i++] = val * 255;
    }
    return rgb;
  }
};
rgb_default.hsl = function(rgb) {
  var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  return [h, s * 100, l * 100];
};

// node_modules/color-rgba/index.js
function rgba(color) {
  if (Array.isArray(color) && color.raw) color = String.raw(...arguments);
  if (color instanceof Number) color = +color;
  var values, i, l;
  var parsed = color_parse_default(color);
  if (!parsed.space) return [];
  const min = parsed.space[0] === "h" ? hsl_default.min : rgb_default.min;
  const max = parsed.space[0] === "h" ? hsl_default.max : rgb_default.max;
  values = Array(3);
  values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
  values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
  values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
  if (parsed.space[0] === "h") {
    values = hsl_default.rgb(values);
  }
  values.push(Math.min(Math.max(parsed.alpha, 0), 1));
  return values;
}

// node_modules/ol/color.js
var NO_COLOR = [NaN, NaN, NaN, 0];
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
var MAX_CACHE_SIZE = 1024;
var cache2 = {};
var cacheSize = 0;
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}
function rgbaToLcha(color) {
  const output = xyz_default.lchuv(rgb_default.xyz(color));
  output[3] = color[3];
  return output;
}
function lchaToRgba(color) {
  const output = xyz_default.rgb(lchuv_default.xyz(color));
  output[3] = color[3];
  return output;
}
function fromString(s) {
  if (s === "none") {
    return NO_COLOR;
  }
  if (cache2.hasOwnProperty(s)) {
    return cache2[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key in cache2) {
      if ((i++ & 3) === 0) {
        delete cache2[key];
        --cacheSize;
      }
    }
  }
  const color = rgba(s);
  if (color.length !== 4) {
    throw new Error('failed to parse "' + s + '" as color');
  }
  for (const c of color) {
    if (isNaN(c)) {
      throw new Error('failed to parse "' + s + '" as color');
    }
  }
  normalize(color);
  cache2[s] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString2(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 1e3) / 1e3;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}

// node_modules/ol/has.js
var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
var FIREFOX = ua.includes("firefox");
var SAFARI = ua.includes("safari") && !ua.includes("chrom");
var SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
var WEBKIT = ua.includes("webkit") && !ua.includes("edge");
var MAC = ua.includes("macintosh");
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
var PASSIVE_EVENT_LISTENERS = function() {
  let passive = false;
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch (error) {
  }
  return passive;
}();

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool2, settings) {
  let canvas;
  if (canvasPool2 && canvasPool2.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool2.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
var sharedCanvasContext;
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeChildren(node) {
  while (node.lastChild) {
    node.lastChild.remove();
  }
}
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;
  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }
    node.insertBefore(newChild, oldChild);
  }
}

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e) => image.complete && image.width ? resolve(image) : reject(e)
    )
  ) : load(image);
}

// node_modules/ol/style/IconImageCache.js
var IconImageCache = class {
  constructor() {
    this.cache_ = {};
    this.patternCache_ = {};
    this.cacheSize_ = 0;
    this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {};
    this.patternCache_ = {};
    this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let i = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          delete this.patternCache_[key];
          --this.cacheSize_;
        }
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(src, crossOrigin, color) {
    const key = getCacheKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(src, crossOrigin, color) {
    const key = getCacheKey(src, crossOrigin, color);
    return key in this.patternCache_ ? this.patternCache_[key] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(src, crossOrigin, color, iconImage, pattern) {
    const key = getCacheKey(src, crossOrigin, color);
    const update = key in this.cache_;
    this.cache_[key] = iconImage;
    if (pattern) {
      if (iconImage.getImageState() === ImageState_default.IDLE) {
        iconImage.load();
      }
      if (iconImage.getImageState() === ImageState_default.LOADING) {
        iconImage.ready().then(() => {
          this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
            iconImage.getImage(1),
            "repeat"
          );
        });
      } else {
        this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
          iconImage.getImage(1),
          "repeat"
        );
      }
    }
    if (!update) {
      ++this.cacheSize_;
    }
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
};
function getCacheKey(src, crossOrigin, color) {
  const colorString = color ? asArray(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var shared = new IconImageCache();

// node_modules/ol/style/IconImage.js
var taintedTestContext = null;
var IconImage = class extends Target_default {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(image, src, crossOrigin, imageState, color) {
    super();
    this.hitDetectionImage_ = null;
    this.image_ = image;
    this.crossOrigin_ = crossOrigin;
    this.canvas_ = {};
    this.color_ = color;
    this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
    this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
    this.src_ = src;
    this.tainted_;
    this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = createCanvasContext2D(1, 1, void 0, {
          willReadFrequently: true
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = ImageState_default.ERROR;
    this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = ImageState_default.LOADED;
    this.size_ = [this.image_.width, this.image_.height];
    this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = createCanvasContext2D(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ !== ImageState_default.IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }
    this.imageState_ = ImageState_default.LOADING;
    try {
      if (this.src_ !== void 0) {
        this.image_.src = this.src_;
      }
    } catch (e) {
      this.handleImageError_();
    }
    if (this.image_ instanceof HTMLImageElement) {
      decodeFallback(this.image_, this.src_).then((image) => {
        this.image_ = image;
        this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
      return;
    }
    const image = this.image_;
    const ctx = createCanvasContext2D(
      Math.ceil(image.width * pixelRatio),
      Math.ceil(image.height * pixelRatio)
    );
    const canvas = ctx.canvas;
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = asString(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(image, 0, 0);
    this.canvas_[pixelRatio] = canvas;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    if (!this.ready_) {
      this.ready_ = new Promise((resolve) => {
        if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
          resolve();
        } else {
          const onChange = () => {
            if (this.imageState_ === ImageState_default.LOADED || this.imageState_ === ImageState_default.ERROR) {
              this.removeEventListener(EventType_default.CHANGE, onChange);
              resolve();
            }
          };
          this.addEventListener(EventType_default.CHANGE, onChange);
        }
      });
    }
    return this.ready_;
  }
};
function get4(image, cacheKey, crossOrigin, imageState, color, pattern) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && "src" in image ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  if (pattern && iconImage && !shared.getPattern(cacheKey, crossOrigin, color)) {
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  return iconImage;
}

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return toString2(color);
  }
  if (typeof color === "object" && "src" in color) {
    return asCanvasPattern(color);
  }
  return color;
}
function asCanvasPattern(pattern) {
  if (!pattern.offset || !pattern.size) {
    return shared.getPattern(pattern.src, "anonymous", pattern.color);
  }
  const cacheKey = pattern.src + ":" + pattern.offset;
  const canvasPattern = shared.getPattern(
    cacheKey,
    void 0,
    pattern.color
  );
  if (canvasPattern) {
    return canvasPattern;
  }
  const iconImage = shared.get(pattern.src, "anonymous", null);
  if (iconImage.getImageState() !== ImageState_default.LOADED) {
    return null;
  }
  const patternCanvasContext = createCanvasContext2D(
    pattern.size[0],
    pattern.size[1]
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern.offset[0],
    pattern.offset[1],
    pattern.size[0],
    pattern.size[1],
    0,
    0,
    pattern.size[0],
    pattern.size[1]
  );
  get4(
    patternCanvasContext.canvas,
    cacheKey,
    void 0,
    ImageState_default.LOADED,
    pattern.color,
    true
  );
  return shared.getPattern(cacheKey, void 0, pattern.color);
}

// node_modules/ol/css.js
var CLASS_HIDDEN = "ol-hidden";
var CLASS_UNSELECTABLE = "ol-unselectable";
var CLASS_CONTROL = "ol-control";
var CLASS_COLLAPSED = "ol-collapsed";
var fontRegEx = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
);
var fontRegExMatchIndex = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
];
var getFontParameters = function(fontSpec) {
  const match = fontSpec.match(fontRegEx);
  if (!match) {
    return null;
  }
  const style = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    const value = match[i + 1];
    if (value !== void 0) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }
  style.families = style.family.split(/,\s?/);
  return style;
};

// node_modules/ol/render/canvas.js
var defaultFillStyle = "#000";
var defaultLineCap = "round";
var defaultLineJoin = "round";
var defaultMiterLimit = 10;
var defaultStrokeStyle = "#000";
var defaultLineWidth = 1;
var checkedFonts = new Object_default();
var measureContext = null;
var measureFont;
var textHeights = {};
var registerFont = function() {
  const retries = 100;
  const size = "32px ";
  const referenceFonts = ["monospace", "serif"];
  const len = referenceFonts.length;
  const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
  let interval, referenceWidth;
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    let available = true;
    for (let i = 0; i < len; ++i) {
      const referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(
        fontStyle + " " + fontWeight + " " + size + referenceFont,
        text
      );
      if (fontFamily != referenceFont) {
        const width = measureTextWidth(
          fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
          text
        );
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check() {
    let done = true;
    const fonts = checkedFonts.getKeys();
    for (let i = 0, ii = fonts.length; i < ii; ++i) {
      const font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        const [style, weight, family] = font.split("\n");
        if (isAvailable(style, weight, family)) {
          clear(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    const font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    const families = font.families;
    for (let i = 0, ii = families.length; i < ii; ++i) {
      const family = families[i];
      const key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}

// node_modules/ol/style/RegularShape.js
var RegularShape = class _RegularShape extends Image_default {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    super({
      opacity: 1,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      scale: options.scale !== void 0 ? options.scale : 1,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
    this.canvases_;
    this.hitDetectionCanvas_ = null;
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.origin_ = [0, 0];
    this.points_ = options.points;
    this.radius = options.radius;
    this.radius2_ = options.radius2;
    this.angle_ = options.angle !== void 0 ? options.angle : 0;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.size_;
    this.renderOptions_;
    this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState_default.LOADING : ImageState_default.LOADED;
    if (this.imageState_ === ImageState_default.LOADING) {
      this.ready().then(() => this.imageState_ = ImageState_default.LOADED);
    }
    this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale4 = this.getScale();
    const style = new _RegularShape({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    const size = this.size_;
    const displacement = this.getDisplacement();
    const scale4 = this.getScaleArray();
    return [
      size[0] / 2 - displacement[0] / scale4[0],
      size[1] / 2 + displacement[1] / scale4[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   * @override
   */
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
        this.renderOptions_
      );
    }
    return this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    let image = this.canvases_[pixelRatio];
    if (!image) {
      const renderOptions = this.renderOptions_;
      const context = createCanvasContext2D(
        renderOptions.size * pixelRatio,
        renderOptions.size * pixelRatio
      );
      this.draw_(renderOptions, context, pixelRatio);
      image = context.canvas;
      this.canvases_[pixelRatio] = image;
    }
    return image;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   * @override
   */
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   * @override
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
      return strokeWidth;
    }
    let r1 = this.radius;
    let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
    const alpha = 2 * Math.PI / points;
    const a = r2 * Math.sin(alpha);
    const b = Math.sqrt(r2 * r2 - a * a);
    const d = r1 - b;
    const e = Math.sqrt(a * a + d * d);
    const miterRatio = e / a;
    if (lineJoin === "miter" && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    const k = strokeWidth / 2 / miterRatio;
    const l = strokeWidth / 2 * (d / e);
    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === void 0 || lineJoin === "bevel") {
      return bevelAdd * 2;
    }
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let lineCap = defaultLineCap;
    let lineJoin = defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;
    if (this.stroke_) {
      strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
      strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
      lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
      lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
      miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
    }
    const add4 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add4);
    return {
      strokeStyle,
      strokeWidth,
      size,
      lineCap,
      lineDash,
      lineDashOffset,
      lineJoin,
      miterLimit
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.canvases_ = {};
    this.hitDetectionCanvas_ = null;
    this.size_ = [size, size];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    if (this.fill_) {
      let color = this.fill_.getColor();
      if (color === null) {
        color = defaultFillStyle;
      }
      context.fillStyle = asColorLike(color);
      context.fill();
    }
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(renderOptions) {
    let context;
    if (this.fill_) {
      let color = this.fill_.getColor();
      let opacity = 0;
      if (typeof color === "string") {
        color = asArray(color);
      }
      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }
      if (opacity === 0) {
        context = createCanvasContext2D(renderOptions.size, renderOptions.size);
        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    return context ? context.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(context) {
    let points = this.points_;
    const radius = this.radius;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
      if (this.radius2_ !== void 0) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = 2 * Math.PI / points;
      for (let i = 0; i < points; i++) {
        const angle0 = startAngle + i * step;
        const radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(renderOptions, context) {
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    context.fillStyle = defaultFillStyle;
    context.fill();
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
  /**
   * @override
   */
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
};
var RegularShape_default = RegularShape;

// node_modules/ol/style/Circle.js
var CircleStyle = class _CircleStyle extends RegularShape_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : { radius: 5 };
    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== void 0 ? options.scale : 1,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale4 = this.getScale();
    const style = new _CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(radius) {
    this.radius = radius;
    this.render();
  }
};
var Circle_default = CircleStyle;

// node_modules/ol/style/Fill.js
var Fill = class _Fill {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.patternImage_ = null;
    this.color_ = null;
    if (options.color !== void 0) {
      this.setColor(options.color);
    }
  }
  /**
   * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new _Fill({
      color: Array.isArray(color) ? color.slice() : color || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(color) {
    if (color !== null && typeof color === "object" && "src" in color) {
      const patternImage = get4(
        null,
        color.src,
        "anonymous",
        void 0,
        color.offset ? null : color.color ? color.color : null,
        !(color.offset && color.size)
      );
      patternImage.ready().then(() => {
        this.patternImage_ = null;
      });
      if (patternImage.getImageState() === ImageState_default.IDLE) {
        patternImage.load();
      }
      if (patternImage.getImageState() === ImageState_default.LOADING) {
        this.patternImage_ = patternImage;
      }
    }
    this.color_ = color;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
};
var Fill_default = Fill;

// node_modules/ol/style/Stroke.js
var Stroke = class _Stroke {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
    this.lineCap_ = options.lineCap;
    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
    this.lineDashOffset_ = options.lineDashOffset;
    this.lineJoin_ = options.lineJoin;
    this.miterLimit_ = options.miterLimit;
    this.width_ = options.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new _Stroke({
      color: Array.isArray(color) ? color.slice() : color || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(width) {
    this.width_ = width;
  }
};
var Stroke_default = Stroke;

// node_modules/ol/style/Style.js
var Style = class _Style {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(options) {
    options = options || {};
    this.geometry_ = null;
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== void 0) {
      this.setGeometry(options.geometry);
    }
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.image_ = options.image !== void 0 ? options.image : null;
    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.text_ = options.text !== void 0 ? options.text : null;
    this.zIndex_ = options.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === "object") {
      geometry = /** @type {import("../geom/Geometry.js").default} */
      geometry.clone();
    }
    return new _Style({
      geometry: geometry ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(image) {
    this.image_ = image;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(geometry) {
    if (typeof geometry === "function") {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== void 0) {
      this.geometryFunction_ = function() {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          geometry
        );
      };
    }
    this.geometry_ = geometry;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
};
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `Style` or an array of `Style`"
      );
      const style = (
        /** @type {Style} */
        obj
      );
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
var defaultStyles = null;
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style_default = Style;

// node_modules/ol/style/Icon.js
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
var Icon = class _Icon extends Image_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    const opacity = options.opacity !== void 0 ? options.opacity : 1;
    const rotation = options.rotation !== void 0 ? options.rotation : 0;
    const scale4 = options.scale !== void 0 ? options.scale : 1;
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity,
      rotation,
      scale: scale4,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      rotateWithView,
      declutterMode: options.declutterMode
    });
    this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
    this.normalizedAnchor_ = null;
    this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
    this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
    this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    const image = options.img !== void 0 ? options.img : null;
    let cacheKey = options.src;
    assert(
      !(cacheKey !== void 0 && image),
      "`image` and `src` cannot be provided at the same time"
    );
    if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
      cacheKey = /** @type {HTMLImageElement} */
      image.src || getUid(image);
    }
    assert(
      cacheKey !== void 0 && cacheKey.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    );
    assert(
      !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let imageState;
    if (options.src !== void 0) {
      imageState = ImageState_default.IDLE;
    } else if (image !== void 0) {
      if ("complete" in image) {
        if (image.complete) {
          imageState = image.src ? ImageState_default.LOADED : ImageState_default.IDLE;
        } else {
          imageState = ImageState_default.LOADING;
        }
      } else {
        imageState = ImageState_default.LOADED;
      }
    }
    this.color_ = options.color !== void 0 ? asArray(options.color) : null;
    this.iconImage_ = get4(
      image,
      /** @type {string} */
      cacheKey,
      this.crossOrigin_,
      imageState,
      this.color_
    );
    this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
    this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
    this.origin_ = null;
    this.size_ = options.size !== void 0 ? options.size : null;
    this.initialOptions_;
    if (options.width !== void 0 || options.height !== void 0) {
      let width, height;
      if (options.size) {
        [width, height] = options.size;
      } else {
        const image2 = this.getImage(1);
        if (image2.width && image2.height) {
          width = image2.width;
          height = image2.height;
        } else if (image2 instanceof HTMLImageElement) {
          this.initialOptions_ = options;
          const onload = () => {
            this.unlistenImageChange(onload);
            if (!this.initialOptions_) {
              return;
            }
            const imageSize = this.iconImage_.getSize();
            this.setScale(
              calculateScale(
                imageSize[0],
                imageSize[1],
                options.width,
                options.height
              )
            );
          };
          this.listenImageChange(onload);
          return;
        }
      }
      if (width !== void 0) {
        this.setScale(
          calculateScale(width, height, options.width, options.height)
        );
      }
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   * @override
   */
  clone() {
    let scale4, width, height;
    if (this.initialOptions_) {
      width = this.initialOptions_.width;
      height = this.initialOptions_.height;
    } else {
      scale4 = this.getScale();
      scale4 = Array.isArray(scale4) ? scale4.slice() : scale4;
    }
    return new _Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: scale4,
      width,
      height,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == "fraction") {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == "fraction") {
          anchor[1] *= size[1];
        }
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
          anchor[0] = -anchor[0] + size[0];
        }
        if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale4 = this.getScaleArray();
    return [
      anchor[0] - displacement[0] / scale4[0],
      anchor[1] + displacement[1] / scale4[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   * @override
   */
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   * @override
   */
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const scale4 = this.getScaleArray();
    if (this.size_) {
      return this.size_[0] * scale4[0];
    }
    if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
      return this.iconImage_.getSize()[0] * scale4[0];
    }
    return void 0;
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const scale4 = this.getScaleArray();
    if (this.size_) {
      return this.size_[1] * scale4[1];
    }
    if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
      return this.iconImage_.getSize()[1] * scale4[1];
    }
    return void 0;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   * @override
   */
  setScale(scale4) {
    delete this.initialOptions_;
    super.setScale(scale4);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {
    this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   * @override
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
  }
  /**
   * @override
   */
  ready() {
    return this.iconImage_.ready();
  }
};
var Icon_default = Icon;

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR = "#333";
var Text = class _Text {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.font_ = options.font;
    this.rotation_ = options.rotation;
    this.rotateWithView_ = options.rotateWithView;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
    this.text_ = options.text;
    this.textAlign_ = options.textAlign;
    this.justify_ = options.justify;
    this.repeat_ = options.repeat;
    this.textBaseline_ = options.textBaseline;
    this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
    this.placement_ = options.placement !== void 0 ? options.placement : "point";
    this.overflow_ = !!options.overflow;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    this.padding_ = options.padding === void 0 ? null : options.padding;
    this.declutterMode_ = options.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const scale4 = this.getScale();
    return new _Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(font) {
    this.font_ = font;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(placement) {
    this.placement_ = placement;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(scale4) {
    this.scale_ = scale4;
    this.scaleArray_ = toSize(scale4 !== void 0 ? scale4 : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(justify) {
    this.justify_ = justify;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(padding) {
    this.padding_ = padding;
  }
};
var Text_default = Text;

// node_modules/ol/expr/expression.js
var numTypes = 0;
var BooleanType = 1 << numTypes++;
var NumberType = 1 << numTypes++;
var StringType = 1 << numTypes++;
var ColorType = 1 << numTypes++;
var NumberArrayType = 1 << numTypes++;
var SizeType = 1 << numTypes++;
var AnyType = Math.pow(2, numTypes) - 1;
var typeNames = {
  [BooleanType]: "boolean",
  [NumberType]: "number",
  [StringType]: "string",
  [ColorType]: "color",
  [NumberArrayType]: "number[]",
  [SizeType]: "size"
};
var namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
function isSpecific(type) {
  return type in typeNames;
}
function typeName(type) {
  const names = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names.push(typeNames[namedType]);
    }
  }
  if (names.length === 0) {
    return "untyped";
  }
  if (names.length < 3) {
    return names.join(" or ");
  }
  return names.slice(0, -1).join(", ") + ", or " + names[names.length - 1];
}
function includesType(broad, specific) {
  return (broad & specific) === specific;
}
function isType(type, expected) {
  return type === expected;
}
var LiteralExpression = class {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(type, value) {
    if (!isSpecific(type)) {
      throw new Error(
        `literal expressions must have a specific type, got ${typeName(type)}`
      );
    }
    this.type = type;
    this.value = value;
  }
};
var CallExpression = class {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(type, operator, ...args) {
    this.type = type;
    this.operator = operator;
    this.args = args;
  }
};
function newParsingContext() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: false,
    geometryType: false
  };
}
function parse2(encoded, expectedType, context) {
  switch (typeof encoded) {
    case "boolean": {
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded ? "true" : "false");
      }
      if (!includesType(expectedType, BooleanType)) {
        throw new Error(
          `got a boolean, but expected ${typeName(expectedType)}`
        );
      }
      return new LiteralExpression(BooleanType, encoded);
    }
    case "number": {
      if (isType(expectedType, SizeType)) {
        return new LiteralExpression(SizeType, toSize(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded.toString());
      }
      if (!includesType(expectedType, NumberType)) {
        throw new Error(`got a number, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(NumberType, encoded);
    }
    case "string": {
      if (isType(expectedType, ColorType)) {
        return new LiteralExpression(ColorType, fromString(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (!includesType(expectedType, StringType)) {
        throw new Error(`got a string, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(StringType, encoded);
    }
    default: {
    }
  }
  if (!Array.isArray(encoded)) {
    throw new Error("expression must be an array or a primitive value");
  }
  if (encoded.length === 0) {
    throw new Error("empty expression");
  }
  if (typeof encoded[0] === "string") {
    return parseCallExpression(encoded, expectedType, context);
  }
  for (const item of encoded) {
    if (typeof item !== "number") {
      throw new Error("expected an array of numbers");
    }
  }
  if (isType(expectedType, SizeType)) {
    if (encoded.length !== 2) {
      throw new Error(
        `expected an array of two values for a size, got ${encoded.length}`
      );
    }
    return new LiteralExpression(SizeType, encoded);
  }
  if (isType(expectedType, ColorType)) {
    if (encoded.length === 3) {
      return new LiteralExpression(ColorType, [...encoded, 1]);
    }
    if (encoded.length === 4) {
      return new LiteralExpression(ColorType, encoded);
    }
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${encoded.length}`
    );
  }
  if (!includesType(expectedType, NumberArrayType)) {
    throw new Error(
      `got an array of numbers, but expected ${typeName(expectedType)}`
    );
  }
  return new LiteralExpression(NumberArrayType, encoded);
}
var Ops = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  LineMetric: "line-metric",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string",
  Has: "has"
};
var parsers = {
  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),
  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),
  [Ops.Concat]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(StringType)
  ),
  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),
  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),
  [Ops.Resolution]: createCallExpressionParser(withNoArgs),
  [Ops.Zoom]: createCallExpressionParser(withNoArgs),
  [Ops.Time]: createCallExpressionParser(withNoArgs),
  [Ops.Any]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType)
  ),
  [Ops.All]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType)
  ),
  [Ops.Not]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType)
  ),
  [Ops.Equal]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType)
  ),
  [Ops.NotEqual]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType)
  ),
  [Ops.GreaterThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.LessThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.LessThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Multiply]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType
  ),
  [Ops.Coalesce]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType
  ),
  [Ops.Divide]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Add]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(NumberType)
  ),
  [Ops.Subtract]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Clamp]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Mod]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Pow]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Abs]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Floor]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Ceil]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Round]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Sin]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Cos]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Atan]: createCallExpressionParser(
    hasArgsCount(1, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Sqrt]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Match]: createCallExpressionParser(
    hasArgsCount(4, Infinity),
    hasEvenArgs,
    withMatchArgs
  ),
  [Ops.Between]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Interpolate]: createCallExpressionParser(
    hasArgsCount(6, Infinity),
    hasEvenArgs,
    withInterpolateArgs
  ),
  [Ops.Case]: createCallExpressionParser(
    hasArgsCount(3, Infinity),
    hasOddArgs,
    withCaseArgs
  ),
  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),
  [Ops.Number]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType)
  ),
  [Ops.String]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType)
  ),
  [Ops.Array]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(NumberType)
  ),
  [Ops.Color]: createCallExpressionParser(
    hasArgsCount(1, 4),
    withArgsOfType(NumberType)
  ),
  [Ops.Band]: createCallExpressionParser(
    hasArgsCount(1, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Palette]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withPaletteArgs
  ),
  [Ops.ToString]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType | NumberType | StringType | ColorType)
  )
};
function withGetArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const args = new Array(argsCount);
  for (let i = 0; i < argsCount; ++i) {
    const key = encoded[i + 1];
    switch (typeof key) {
      case "number": {
        args[i] = new LiteralExpression(NumberType, key);
        break;
      }
      case "string": {
        args[i] = new LiteralExpression(StringType, key);
        break;
      }
      default: {
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${key}`
        );
      }
    }
    if (i === 0) {
      context.properties.add(String(key));
    }
  }
  return args;
}
function withVarArgs(encoded, returnType, context) {
  const name = encoded[1];
  if (typeof name !== "string") {
    throw new Error("expected a string argument for var operation");
  }
  context.variables.add(name);
  return [new LiteralExpression(StringType, name)];
}
function usesFeatureId(encoded, returnType, context) {
  context.featureId = true;
}
function usesGeometryType(encoded, returnType, context) {
  context.geometryType = true;
}
function withNoArgs(encoded, returnType, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`expected no arguments for ${operation} operation`);
  }
  return [];
}
function hasArgsCount(minArgs, maxArgs) {
  return function(encoded, returnType, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? "" : "s";
        throw new Error(
          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `expected ${range} arguments for ${operation}, got ${argCount}`
      );
    }
  };
}
function withArgsOfReturnType(encoded, returnType, context) {
  const argCount = encoded.length - 1;
  const args = new Array(argCount);
  for (let i = 0; i < argCount; ++i) {
    const expression = parse2(encoded[i + 1], returnType, context);
    args[i] = expression;
  }
  return args;
}
function withArgsOfType(argType) {
  return function(encoded, returnType, context) {
    const argCount = encoded.length - 1;
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse2(encoded[i + 1], argType, context);
      args[i] = expression;
    }
    return args;
  };
}
function hasOddArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `expected an odd number of arguments for ${operation}, got ${argCount} instead`
    );
  }
}
function hasEvenArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`
    );
  }
}
function withMatchArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const inputType = StringType | NumberType | BooleanType;
  const input = parse2(encoded[1], inputType, context);
  const fallback = parse2(encoded[encoded.length - 1], returnType, context);
  const args = new Array(argsCount - 2);
  for (let i = 0; i < argsCount - 2; i += 2) {
    try {
      const match = parse2(encoded[i + 2], input.type, context);
      args[i] = match;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of match expression: ${err.message}`
      );
    }
    try {
      const output = parse2(encoded[i + 3], fallback.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} of match expression: ${err.message}`
      );
    }
  }
  return [input, ...args, fallback];
}
function withInterpolateArgs(encoded, returnType, context) {
  const interpolationType = encoded[1];
  let base;
  switch (interpolationType[0]) {
    case "linear":
      base = 1;
      break;
    case "exponential":
      const b = interpolationType[1];
      if (typeof b !== "number" || b <= 0) {
        throw new Error(
          `expected a number base for exponential interpolation, got ${JSON.stringify(b)} instead`
        );
      }
      base = b;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(interpolationType)}`
      );
  }
  const interpolation = new LiteralExpression(NumberType, base);
  let input;
  try {
    input = parse2(encoded[2], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${err.message}`
    );
  }
  const args = new Array(encoded.length - 3);
  for (let i = 0; i < args.length; i += 2) {
    try {
      const stop = parse2(encoded[i + 3], NumberType, context);
      args[i] = stop;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`
      );
    }
    try {
      const output = parse2(encoded[i + 4], returnType, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`
      );
    }
  }
  return [interpolation, input, ...args];
}
function withCaseArgs(encoded, returnType, context) {
  const fallback = parse2(encoded[encoded.length - 1], returnType, context);
  const args = new Array(encoded.length - 1);
  for (let i = 0; i < args.length - 1; i += 2) {
    try {
      const condition = parse2(encoded[i + 1], BooleanType, context);
      args[i] = condition;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i} of case expression: ${err.message}`
      );
    }
    try {
      const output = parse2(encoded[i + 2], fallback.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of case expression: ${err.message}`
      );
    }
  }
  args[args.length - 1] = fallback;
  return args;
}
function withInArgs(encoded, returnType, context) {
  let haystack = encoded[2];
  if (!Array.isArray(haystack)) {
    throw new Error(
      `the second argument for the "in" operator must be an array`
    );
  }
  let needleType;
  if (typeof haystack[0] === "string") {
    if (haystack[0] !== "literal") {
      throw new Error(
        `for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions`
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `failed to parse "in" expression: the literal operator must be followed by an array`
      );
    }
    haystack = haystack[1];
    needleType = StringType;
  } else {
    needleType = NumberType;
  }
  const args = new Array(haystack.length);
  for (let i = 0; i < args.length; i++) {
    try {
      const arg = parse2(haystack[i], needleType, context);
      args[i] = arg;
    } catch (err) {
      throw new Error(
        `failed to parse haystack item ${i} for "in" expression: ${err.message}`
      );
    }
  }
  const needle = parse2(encoded[1], needleType, context);
  return [needle, ...args];
}
function withPaletteArgs(encoded, returnType, context) {
  let index;
  try {
    index = parse2(encoded[1], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse first argument in palette expression: ${err.message}`
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error("the second argument of palette must be an array");
  }
  const parsedColors = new Array(colors.length);
  for (let i = 0; i < parsedColors.length; i++) {
    let color;
    try {
      color = parse2(colors[i], ColorType, context);
    } catch (err) {
      throw new Error(
        `failed to parse color at index ${i} in palette expression: ${err.message}`
      );
    }
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `the palette color at index ${i} must be a literal value`
      );
    }
    parsedColors[i] = color;
  }
  return [index, ...parsedColors];
}
function createCallExpressionParser(...validators) {
  return function(encoded, returnType, context) {
    const operator = encoded[0];
    let args;
    for (let i = 0; i < validators.length; i++) {
      const parsed = validators[i](encoded, returnType, context);
      if (i == validators.length - 1) {
        if (!parsed) {
          throw new Error(
            "expected last argument validator to return the parsed args"
          );
        }
        args = parsed;
      }
    }
    return new CallExpression(returnType, operator, ...args);
  };
}
function parseCallExpression(encoded, returnType, context) {
  const operator = encoded[0];
  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`unknown operator: ${operator}`);
  }
  return parser(encoded, returnType, context);
}
function computeGeometryType(geometry) {
  if (!geometry) {
    return "";
  }
  const type = geometry.getType();
  switch (type) {
    case "Point":
    case "LineString":
    case "Polygon":
      return type;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        type.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return computeGeometryType(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry.getGeometries()[0]
      );
    default:
      return "";
  }
}

// node_modules/ol/expr/cpu.js
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function buildExpression(encoded, type, context) {
  const expression = parse2(encoded, type, context);
  return compileExpression(expression, context);
}
function compileExpression(expression, context) {
  if (expression instanceof LiteralExpression) {
    if (expression.type === ColorType && typeof expression.value === "string") {
      const colorValue = fromString(expression.value);
      return function() {
        return colorValue;
      };
    }
    return function() {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case Ops.Number:
    case Ops.String:
    case Ops.Coalesce: {
      return compileAssertionExpression(expression, context);
    }
    case Ops.Get:
    case Ops.Var:
    case Ops.Has: {
      return compileAccessorExpression(expression, context);
    }
    case Ops.Id: {
      return (context2) => context2.featureId;
    }
    case Ops.GeometryType: {
      return (context2) => context2.geometryType;
    }
    case Ops.Concat: {
      const args = expression.args.map((e) => compileExpression(e, context));
      return (context2) => "".concat(...args.map((arg) => arg(context2).toString()));
    }
    case Ops.Resolution: {
      return (context2) => context2.resolution;
    }
    case Ops.Any:
    case Ops.All:
    case Ops.Between:
    case Ops.In:
    case Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case Ops.Case: {
      return compileCaseExpression(expression, context);
    }
    case Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    case Ops.Interpolate: {
      return compileInterpolateExpression(expression, context);
    }
    case Ops.ToString: {
      return compileConvertExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case Ops.Coalesce: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value !== "undefined" && value !== null) {
            return value;
          }
        }
        throw new Error("Expected one of the values to be non-null");
      };
    }
    case Ops.Number:
    case Ops.String: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}
function compileAccessorExpression(expression, context) {
  const nameExpression = (
    /** @type {LiteralExpression} */
    expression.args[0]
  );
  const name = (
    /** @type {string} */
    nameExpression.value
  );
  switch (expression.operator) {
    case Ops.Get: {
      return (context2) => {
        const args = expression.args;
        let value = context2.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          value = value[key];
        }
        return value;
      };
    }
    case Ops.Var: {
      return (context2) => context2.variables[name];
    }
    case Ops.Has: {
      return (context2) => {
        const args = expression.args;
        if (!(name in context2.properties)) {
          return false;
        }
        let value = context2.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          if (!value || !Object.hasOwn(value, key)) {
            return false;
          }
          value = value[key];
        }
        return true;
      };
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case Ops.Equal: {
      return (context2) => left(context2) === right(context2);
    }
    case Ops.NotEqual: {
      return (context2) => left(context2) !== right(context2);
    }
    case Ops.LessThan: {
      return (context2) => left(context2) < right(context2);
    }
    case Ops.LessThanOrEqualTo: {
      return (context2) => left(context2) <= right(context2);
    }
    case Ops.GreaterThan: {
      return (context2) => left(context2) > right(context2);
    }
    case Ops.GreaterThanOrEqualTo: {
      return (context2) => left(context2) >= right(context2);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Any: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.All: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context2)) {
            return false;
          }
        }
        return true;
      };
    }
    case Ops.Between: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        const max = args[2](context2);
        return value >= min && value <= max;
      };
    }
    case Ops.In: {
      return (context2) => {
        const value = args[0](context2);
        for (let i = 1; i < length; ++i) {
          if (value === args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.Not: {
      return (context2) => !args[0](context2);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Multiply: {
      return (context2) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context2);
        }
        return value;
      };
    }
    case Ops.Divide: {
      return (context2) => args[0](context2) / args[1](context2);
    }
    case Ops.Add: {
      return (context2) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context2);
        }
        return value;
      };
    }
    case Ops.Subtract: {
      return (context2) => args[0](context2) - args[1](context2);
    }
    case Ops.Clamp: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        if (value < min) {
          return min;
        }
        const max = args[2](context2);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case Ops.Mod: {
      return (context2) => args[0](context2) % args[1](context2);
    }
    case Ops.Pow: {
      return (context2) => Math.pow(args[0](context2), args[1](context2));
    }
    case Ops.Abs: {
      return (context2) => Math.abs(args[0](context2));
    }
    case Ops.Floor: {
      return (context2) => Math.floor(args[0](context2));
    }
    case Ops.Ceil: {
      return (context2) => Math.ceil(args[0](context2));
    }
    case Ops.Round: {
      return (context2) => Math.round(args[0](context2));
    }
    case Ops.Sin: {
      return (context2) => Math.sin(args[0](context2));
    }
    case Ops.Cos: {
      return (context2) => Math.cos(args[0](context2));
    }
    case Ops.Atan: {
      if (length === 2) {
        return (context2) => Math.atan2(args[0](context2), args[1](context2));
      }
      return (context2) => Math.atan(args[0](context2));
    }
    case Ops.Sqrt: {
      return (context2) => Math.sqrt(args[0](context2));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}
function compileCaseExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    for (let i = 0; i < length - 1; i += 2) {
      const condition = args[i](context2);
      if (condition) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const value = args[0](context2);
    for (let i = 1; i < length; i += 2) {
      if (value === args[i](context2)) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const base = args[0](context2);
    const value = args[1](context2);
    let previousInput;
    let previousOutput;
    for (let i = 2; i < length; i += 2) {
      const input = args[i](context2);
      let output = args[i + 1](context2);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = withAlpha(output);
      }
      if (input >= value) {
        if (i === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}
function compileConvertExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.ToString: {
      return (context2) => {
        const value = args[0](context2);
        if (expression.args[0].type === ColorType) {
          return toString2(value);
        }
        return value.toString();
      };
    }
    default: {
      throw new Error(`Unsupported convert operator ${op}`);
    }
  }
}
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = rgbaToLcha(rgba1);
  const lcha2 = rgbaToLcha(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
  ];
  return normalize(lchaToRgba(lcha));
}

// node_modules/ol/render/canvas/style.js
function always(context) {
  return true;
}
function rulesToStyleFunction(rules) {
  const parsingContext = newParsingContext();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = newEvaluationContext();
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    if (parsingContext.geometryType) {
      evaluationContext.geometryType = computeGeometryType(
        feature.getGeometry()
      );
    }
    return evaluator(evaluationContext);
  };
}
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = newParsingContext();
  const length = flatStyles.length;
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = newEvaluationContext();
  const styles = new Array(length);
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i = 0; i < length; ++i) {
      const style = evaluators[i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}
function buildRuleSet(rules, context) {
  const length = rules.length;
  const compiledRules = new Array(length);
  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always;
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i] = { filter, styles };
  }
  return function(context2) {
    const styles = [];
    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context2)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context2);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }
    return styles;
  };
}
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, "", context);
  const evaluateStroke = buildStroke(flatStyle, "", context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle)
    );
  }
  const style = new Style_default();
  return function(context2) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context2);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context2);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context2);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context2);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context2));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}
function buildFill(flatStyle, prefix, context) {
  let evaluateColor;
  if (prefix + "fill-pattern-src" in flatStyle) {
    evaluateColor = patternEvaluator(flatStyle, prefix + "fill-", context);
  } else {
    if (flatStyle[prefix + "fill-color"] === "none") {
      return (context2) => null;
    }
    evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + "fill-color",
      context
    );
  }
  if (!evaluateColor) {
    return null;
  }
  const fill = new Fill_default();
  return function(context2) {
    const color = evaluateColor(context2);
    if (color === NO_COLOR) {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + "stroke-width",
    context
  );
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "stroke-color",
    context
  );
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-cap",
    context
  );
  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-join",
    context
  );
  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + "stroke-line-dash",
    context
  );
  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + "stroke-line-dash-offset",
    context
  );
  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + "stroke-miter-limit",
    context
  );
  const stroke = new Stroke_default();
  return function(context2) {
    if (evaluateColor) {
      const color = evaluateColor(context2);
      if (color === NO_COLOR) {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context2));
    }
    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context2);
      if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
        throw new Error("Expected butt, round, or square line cap");
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context2);
      if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
        throw new Error("Expected bevel, round, or miter line join");
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context2));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context2));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context2));
    }
    return stroke;
  };
}
function buildText(flatStyle, context) {
  const prefix = "text-";
  const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
  if (!evaluateValue) {
    return null;
  }
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + "max-angle",
    context
  );
  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + "offset-x",
    context
  );
  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + "offset-y",
    context
  );
  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + "overflow",
    context
  );
  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + "placement",
    context
  );
  const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + "justify",
    context
  );
  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + "baseline",
    context
  );
  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + "padding",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const text = new Text_default({ declutterMode });
  return function(context2) {
    text.setText(evaluateValue(context2));
    if (evaluateFill) {
      text.setFill(evaluateFill(context2));
    }
    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context2));
    }
    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context2));
    }
    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context2));
    }
    if (evaluateFont) {
      text.setFont(evaluateFont(context2));
    }
    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context2));
    }
    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context2));
    }
    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context2));
    }
    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context2));
    }
    if (evaluatePlacement) {
      const placement = evaluatePlacement(context2);
      if (placement !== "point" && placement !== "line") {
        throw new Error("Expected point or line for text-placement");
      }
      text.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context2));
    }
    if (evaluateScale) {
      text.setScale(evaluateScale(context2));
    }
    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context2));
    }
    if (evaluateAlign) {
      const textAlign = evaluateAlign(context2);
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      }
      text.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      const justify = evaluateJustify(context2);
      if (justify !== "left" && justify !== "right" && justify !== "center") {
        throw new Error("Expected left, right, or center for text-justify");
      }
      text.setJustify(justify);
    }
    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context2);
      if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      }
      text.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context2));
    }
    return text;
  };
}
function buildImage(flatStyle, context) {
  if ("icon-src" in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ("shape-points" in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ("circle-radius" in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}
function buildIcon(flatStyle, context) {
  const prefix = "icon-";
  const srcName = prefix + "src";
  const src = requireString(flatStyle[srcName], srcName);
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + "anchor",
    context
  );
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + "opacity",
    context
  );
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-x-units"
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-y-units"
  );
  const color = optionalColorLike(flatStyle, prefix + "color");
  const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
  const offset = optionalNumberArray(flatStyle, prefix + "offset");
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
  const width = optionalNumber(flatStyle, prefix + "width");
  const height = optionalNumber(flatStyle, prefix + "height");
  const size = optionalSize(flatStyle, prefix + "size");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const icon = new Icon_default({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode
  });
  return function(context2) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context2));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context2));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context2));
    }
    return icon;
  };
}
function buildShape(flatStyle, context) {
  const prefix = "shape-";
  const pointsName = prefix + "points";
  const radiusName = prefix + "radius";
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const radius = requireNumber(flatStyle[radiusName], radiusName);
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const radius2 = optionalNumber(flatStyle, prefix + "radius2");
  const angle = optionalNumber(flatStyle, prefix + "angle");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const shape = new RegularShape_default({
    points,
    radius,
    radius2,
    angle,
    declutterMode
  });
  return function(context2) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context2));
    }
    return shape;
  };
}
function buildCircle(flatStyle, context) {
  const prefix = "circle-";
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const circle = new Circle_default({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode
  });
  return function(context2) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context2));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context2));
    }
    return circle;
  };
}
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return void 0;
  }
  const evaluator = buildExpression(flatStyle[name], NumberType, context);
  return function(context2) {
    return requireNumber(evaluator(context2), name);
  };
}
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], StringType, context);
  return function(context2) {
    return requireString(evaluator(context2), name);
  };
}
function patternEvaluator(flatStyle, prefix, context) {
  const srcEvaluator = stringEvaluator(
    flatStyle,
    prefix + "pattern-src",
    context
  );
  const offsetEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-offset",
    context
  );
  const patternSizeEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-size",
    context
  );
  const colorEvaluator = colorLikeEvaluator(
    flatStyle,
    prefix + "color",
    context
  );
  return function(context2) {
    return {
      src: srcEvaluator(context2),
      offset: offsetEvaluator && offsetEvaluator(context2),
      size: patternSizeEvaluator && patternSizeEvaluator(context2),
      color: colorEvaluator && colorEvaluator(context2)
    };
  };
}
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], BooleanType, context);
  return function(context2) {
    const value = evaluator(context2);
    if (typeof value !== "boolean") {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], ColorType, context);
  return function(context2) {
    return requireColorLike(evaluator(context2), name);
  };
}
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireNumberArray(evaluator(context2), name);
  };
}
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    const array = requireNumberArray(evaluator(context2), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}
function sizeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireSize(evaluator(context2), name);
  };
}
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    NumberArrayType | NumberType,
    context
  );
  return function(context2) {
    return requireSizeLike(evaluator(context2), name);
  };
}
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === void 0) {
    return void 0;
  }
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded === "number") {
    return toSize(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "pixels" && encoded !== "fraction") {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireNumberArray(encoded, property);
}
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireColorLike(encoded, property);
}
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== "number") {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}
function requireString(value, property) {
  if (typeof value !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}
function requireNumber(value, property) {
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function requireColorLike(value, property) {
  if (typeof value === "string") {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}
function requireSize(value, property) {
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}
function requireSizeLike(value, property) {
  if (typeof value === "number") {
    return value;
  }
  return requireSize(value, property);
}

// node_modules/ol/layer/BaseVector.js
var Property2 = {
  RENDER_ORDER: "renderOrder"
};
var BaseVectorLayer = class extends Layer_default {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);
    this.declutter_ = options.declutter ? String(options.declutter) : void 0;
    this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.setStyle(options.style);
    this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
    this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
  }
  /**
   * @return {string} Declutter group.
   * @override
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Property2.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */
  renderDeclutter(frameState, layerState) {
    const declutterGroup = this.getDeclutter();
    if (declutterGroup in frameState.declutter === false) {
      frameState.declutter[declutterGroup] = new RBush(9);
    }
    this.getRenderer().renderDeclutter(frameState, layerState);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(renderOrder) {
    this.set(Property2.RENDER_ORDER, renderOrder);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(style) {
    this.style_ = style === void 0 ? createDefaultStyle : style;
    const styleLike = toStyleLike(style);
    this.styleFunction_ = style === null ? void 0 : toFunction(styleLike);
    this.changed();
  }
};
function toStyleLike(style) {
  if (style === void 0) {
    return createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === "function") {
    return style;
  }
  if (style instanceof Style_default) {
    return style;
  }
  if (!Array.isArray(style)) {
    return flatStylesToStyleFunction([style]);
  }
  if (style.length === 0) {
    return [];
  }
  const length = style.length;
  const first = style[0];
  if (first instanceof Style_default) {
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof Style_default)) {
        throw new Error("Expected a list of style instances");
      }
      styles[i] = candidate;
    }
    return styles;
  }
  if ("style" in first) {
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!("style" in candidate)) {
        throw new Error("Expected a list of rules with a style property");
      }
      rules[i] = candidate;
    }
    return rulesToStyleFunction(rules);
  }
  const flatStyles = (
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    style
  );
  return flatStylesToStyleFunction(flatStyles);
}
var BaseVector_default = BaseVectorLayer;

// node_modules/ol/renderer/Map.js
var MapRenderer = class extends Disposable_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();
    this.map_ = map;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX2(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = (
      /** @type {Array<HitMatch<T>>} */
      []
    );
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates2[0] + offsets[i][0];
            tmpCoord[1] = coordinates2[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback2,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => m.distanceSq += i * order);
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      TRUE,
      this,
      layerFilter,
      thisArg
    );
    return hasFeature !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
};
function expireIconCache(map, frameState) {
  shared.expire();
}
var Map_default = MapRenderer;

// node_modules/ol/render/Event.js
var RenderEvent = class extends Event_default {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(type, inversePixelTransform, frameState, context) {
    super(type);
    this.inversePixelTransform = inversePixelTransform;
    this.frameState = frameState;
    this.context = context;
  }
};
var Event_default2 = RenderEvent;

// node_modules/ol/renderer/Composite.js
var CompositeMapRenderer = class extends Map_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(
      checkedFonts,
      ObjectEventType_default.PROPERTYCHANGE,
      map.redrawText,
      map
    );
    this.element_ = document.createElement("div");
    const style = this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new Event_default2(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.remove();
    super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(EventType_default2.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(
      (a, b) => a.zIndex - b.zIndex
    );
    const declutter = layerStatesArray.some(
      (layerState) => layerState.layer instanceof BaseVector_default && layerState.layer.getDeclutter()
    );
    if (declutter) {
      frameState.declutter = {};
    }
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const renderedLayerStates = [];
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      renderedLayerStates.push(layerState);
    }
    this.declutter(frameState, renderedLayerStates);
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(EventType_default2.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(frameState, layerStates) {
    if (!frameState.declutter) {
      return;
    }
    for (let i = layerStates.length - 1; i >= 0; --i) {
      const layerState = layerStates[i];
      const layer = layerState.layer;
      if (layer.getDeclutter()) {
        layer.renderDeclutter(frameState, layerState);
      }
    }
    layerStates.forEach(
      (layerState) => layerState.layer.renderDeferred(frameState)
    );
  }
};
var Composite_default = CompositeMapRenderer;

// node_modules/ol/layer/Group.js
var GroupEvent = class extends Event_default {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
};
var Property3 = {
  LAYERS: "layers"
};
var LayerGroup = class _LayerGroup extends Base_default {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = (
      /** @type {Options} */
      Object.assign({}, options)
    );
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property3.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection_default(layers.slice(), { unique: true });
      } else {
        assert(
          typeof /** @type {?} */
          layers.getArray === "function",
          "Expected `layers` to be an array or a `Collection`"
        );
      }
    } else {
      layers = new Collection_default(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
      listen(
        layers,
        CollectionEventType_default.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(
        layer,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof _LayerGroup) {
      listenerKeys.push(
        listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
        listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
      );
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Property3.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
      }
    }
    this.set(Property3.LAYERS, layers);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    return "ready";
  }
};
var Group_default = LayerGroup;

// node_modules/ol/MapEvent.js
var MapEvent = class extends Event_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
};
var MapEvent_default = MapEvent;

// node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent = class extends MapEvent_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
};
var MapBrowserEvent_default = MapBrowserEvent;

// node_modules/ol/MapBrowserEventType.js
var MapBrowserEventType_default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: EventType_default.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: EventType_default.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/pointer/EventType.js
var EventType_default3 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/MapBrowserEventHandler.js
var MapBrowserEventHandler = class extends Target_default {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(
      element,
      EventType_default3.POINTERDOWN,
      this.handlePointerDown_,
      this
    );
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(
      element,
      EventType_default3.POINTERMOVE,
      this.relayMoveEvent_,
      this
    );
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_,
      PASSIVE_EVENT_LISTENERS ? { passive: false } : false
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent_default(
          MapBrowserEventType_default.SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERUP,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERDOWN,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, "target", {
      writable: false,
      value: pointerEvent.target
    });
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(
          doc,
          MapBrowserEventType_default.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        listen(
          this.element_,
          MapBrowserEventType_default.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          listen(
            this.element_.getRootNode(),
            MapBrowserEventType_default.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_
    );
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
};
var MapBrowserEventHandler_default = MapBrowserEventHandler;

// node_modules/ol/MapEventType.js
var MapEventType_default = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
};

// node_modules/ol/MapProperty.js
var MapProperty_default = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};

// node_modules/ol/structs/PriorityQueue.js
var DROP = Infinity;
var PriorityQueue = class {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = /** @type {T} */
      elements.pop();
      priorities[0] = /** @type {number} */
      priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    assert(
      !(this.keyFunction_(element) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return index - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;
    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];
    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
};
var PriorityQueue_default = PriorityQueue;

// node_modules/ol/TileState.js
var TileState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/TileQueue.js
var TileQueue = class extends PriorityQueue_default {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (
          /** @type {import("./Tile.js").default} */
          element[0].getKey()
        );
      }
    );
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile = element[0];
      tile.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("./Tile.js").default} */
      event.target
    );
    const state = tile.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
      if (state !== TileState_default.ERROR) {
        tile.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      const tile = this.dequeue()[0];
      const tileKey = tile.getKey();
      const state = tile.getState();
      if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
};
var TileQueue_default = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

// node_modules/ol/control/Control.js
var Control = class extends Object_default {
  /**
   * @param {Options} options Control options.
   */
  constructor(options) {
    super();
    const element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = "auto";
    }
    this.element = element ? element : null;
    this.target_ = null;
    this.map_ = null;
    this.listenerKeys = [];
    if (options.render) {
      this.render = options.render;
    }
    if (options.target) {
      this.setTarget(options.target);
    }
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.element?.remove();
    super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.map_) {
      this.element?.remove();
    }
    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      unlistenByKey(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      const target = this.target_ ?? map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== VOID) {
        this.listenerKeys.push(
          listen(map, MapEventType_default.POSTRENDER, this.render, this)
        );
      }
      map.render();
    }
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(mapEvent) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(target) {
    this.target_ = typeof target === "string" ? document.getElementById(target) : target;
  }
};
var Control_default = Control;

// node_modules/ol/control/Attribution.js
var Attribution = class extends Control_default {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    this.attributions_ = options.attributions;
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const layers = this.getMap().getAllLayers();
    const visibleAttributions = new Set(
      layers.flatMap((layer) => layer.getAttributions(frameState))
    );
    if (this.attributions_ !== void 0) {
      Array.isArray(this.attributions_) ? this.attributions_.forEach((item) => visibleAttributions.add(item)) : visibleAttributions.add(this.attributions_);
    }
    if (!this.overrideCollapsible_) {
      const collapsible = !layers.some(
        (layer) => layer.getSource()?.getAttributionsCollapsible() === false
      );
      this.setCollapsible(collapsible);
    }
    return Array.from(visibleAttributions);
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = await Promise.all(
      this.collectSourceAttributions_(frameState).map(
        (attribution) => toPromise(() => attribution)
      )
    );
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
};
var Attribution_default = Attribution;

// node_modules/ol/control/Rotate.js
var Rotate = class extends Control_default {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "\u21E7";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
};
var Rotate_default = Rotate;

// node_modules/ol/control/Zoom.js
var Zoom = class extends Control_default {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
    );
    inElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, delta),
      false
    );
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );
    outElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
};
var Zoom_default = Zoom;

// node_modules/ol/control/defaults.js
function defaults(options) {
  options = options ? options : {};
  const controls = new Collection_default();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom_default(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate_default(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution_default(options.attributionOptions));
  }
  return controls;
}

// node_modules/ol/interaction/Property.js
var Property_default2 = {
  ACTIVE: "active"
};

// node_modules/ol/interaction/Interaction.js
var Interaction = class extends Object_default {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Property_default2.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(Property_default2.ACTIVE, active);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
};
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== void 0 ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration !== void 0 ? duration : 250,
    easing: easeOut
  });
}
var Interaction_default = Interaction;

// node_modules/ol/interaction/DoubleClickZoom.js
var DoubleClickZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
      const browserEvent = (
        /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
};
var DoubleClickZoom_default = DoubleClickZoom;

// node_modules/ol/interaction/Pointer.js
var PointerInteraction = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
};
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return { clientX: clientX / length, clientY: clientY / length };
}
var Pointer_default = PointerInteraction;

// node_modules/ol/events/condition.js
function all(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
var altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return rootNode instanceof ShadowRoot ? rootNode.host.contains(activeElement) : targetElement.contains(activeElement);
};
var focusWithTabindex = function(event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const tabIndexCandidate = rootNode instanceof ShadowRoot ? rootNode.host : targetElement;
  return tabIndexCandidate.hasAttribute("tabindex") ? focus(event) : true;
};
var always2 = TRUE;
var mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
var noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKey = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  const tagName = (
    /** @type {Element} */
    originalEvent.target.tagName
  );
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};
var mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.pointerType == "mouse";
};
var primaryAction = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

// node_modules/ol/interaction/DragPan.js
var DragPan = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid2 = map.getEventPixel(centroid(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid2[0], centroid2[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid2[0],
          centroid2[1] - this.lastCentroid[1]
        ];
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        scale(delta, view.getResolution());
        rotate(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid2;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
};
var DragPan_default = DragPan;

// node_modules/ol/interaction/DragRotate.js
var DragRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
};
var DragRotate_default = DragRotate;

// node_modules/ol/render/Box.js
var RenderBox = class extends Disposable_default {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_) {
      return;
    }
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon_default([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
};
var Box_default = RenderBox;

// node_modules/ol/interaction/DragBox.js
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
};
var DragBox = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ?? {};
    this.box_ = new Box_default(options.className || "ol-dragbox");
    this.minArea_ = options.minArea ?? 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ?? mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ?? this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return;
    }
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return false;
    }
    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    this.box_.setMap(null);
    this.startPixel_ = null;
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(active) {
    if (!active) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null)
        );
        this.startPixel_ = null;
      }
    }
    super.setActive(active);
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */
  setMap(map) {
    const oldMap = this.getMap();
    if (oldMap) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null)
        );
        this.startPixel_ = null;
      }
    }
    super.setMap(map);
  }
};
var DragBox_default = DragBox;

// node_modules/ol/interaction/DragZoom.js
var DragZoom = class extends DragBox_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = (
      /** @type {!import("../View.js").default} */
      map.getView()
    );
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
};
var DragZoom_default = DragZoom;

// node_modules/ol/events/Key.js
var Key_default = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};

// node_modules/ol/interaction/KeyboardPan.js
var KeyboardPan = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key == Key_default.DOWN || key == Key_default.LEFT || key == Key_default.RIGHT || key == Key_default.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (key == Key_default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == Key_default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == Key_default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardPan_default = KeyboardPan;

// node_modules/ol/interaction/KeyboardZoom.js
var KeyboardZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
        const map = mapBrowserEvent.map;
        const delta = key === "+" ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardZoom_default = KeyboardZoom;

// node_modules/ol/Kinetic.js
var Kinetic = class {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
};
var Kinetic_default = Kinetic;

// node_modules/ol/interaction/MouseWheelZoom.js
var MouseWheelZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always2;
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType_default.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = (
      /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.pixel;
    }
    let delta;
    if (mapBrowserEvent.type == EventType_default.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(
        -delta / this.deltaPerZoom_,
        this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null
      );
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );
    return false;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(
      view,
      delta,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,
      this.duration_
    );
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
};
var MouseWheelZoom_default = MouseWheelZoom;

// node_modules/ol/interaction/PinchRotate.js
var PinchRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchRotate_default = PinchRotate;

// node_modules/ol/interaction/PinchZoom.js
var PinchZoom = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchZoom_default = PinchZoom;

// node_modules/ol/interaction/defaults.js
function defaults2(options) {
  options = options ? options : {};
  const interactions = new Collection_default();
  const kinetic = new Kinetic_default(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate_default());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new DoubleClickZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new DragPan_default({
        onFocusOnly: options.onFocusOnly,
        kinetic
      })
    );
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate_default());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new PinchZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan_default());
    interactions.push(
      new KeyboardZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new MouseWheelZoom_default({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      })
    );
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new DragZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  return interactions;
}

// node_modules/ol/Map.js
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof Group_default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof Group_default) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
var Map = class extends Object_default {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_ = false;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create();
    this.pixelToCoordinateTransform_ = create();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.targetElement_ = null;
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
    this.controls = optionsInternal.controls || defaults();
    this.interactions = optionsInternal.interactions || defaults2({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue_default(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );
    this.addChangeListener(
      MapProperty_default.LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(MapProperty_default.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty_default.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty_default.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View_default)) {
      options.view.then(function(viewOptions) {
        map.setView(new View_default(viewOptions));
      });
    }
    this.controls.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.controls.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );
    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      }
    );
    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      }
    );
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  /**
   *
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function(feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof Group_default) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in event ? (
        /** @type {TouchEvent} */
        event.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        event
      )
    );
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(MapProperty_default.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(MapProperty_default.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection_default) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(MapProperty_default.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(MapProperty_default.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(
      this.frameState_,
      tile,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = (
      /** @type {PointerEvent} */
      mapBrowserEvent.originalEvent
    );
    const eventType = originalEvent.type;
    if (eventType === EventType_default3.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = (
        /** @type {Node} */
        originalEvent.target
      );
      const currentDoc = rootNode instanceof ShadowRoot ? rootNode.host === target ? rootNode.host.ownerDocument : rootNode : rootNode === doc ? doc.documentElement : rootNode;
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !currentDoc.contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_) {
        if (this.hasListener(EventType_default2.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            EventType_default2.RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.LOADSTART, this, frameState)
        );
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      this.viewport_.remove();
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(void 0);
    }
    const target = this.getTarget();
    const targetElement = typeof target === "string" ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new Composite_default(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(
        this,
        this.moveTolerance_
      );
      for (const key in MapBrowserEventType_default) {
        this.mapBrowserEventHandler_.addEventListener(
          MapBrowserEventType_default[key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
      let keyboardEventTarget;
      if (!this.keyboardEventTarget_) {
        const targetRoot = targetElement.getRootNode();
        const targetCandidate = targetRoot instanceof ShadowRoot ? targetRoot.host : targetElement;
        keyboardEventTarget = targetCandidate;
      } else {
        keyboardEventTarget = this.keyboardEventTarget_;
      }
      this.targetChangeHandlerKeys_ = [
        listen(
          keyboardEventTarget,
          EventType_default.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        listen(
          keyboardEventTarget,
          EventType_default.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_(this.getSize());
      this.viewPropertyListenerKey_ = listen(
        view,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = listen(
        view,
        EventType_default.CHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      view.resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType_default.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: getForViewAndSize(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty2(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.MOVEEND, this, frameState)
        );
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
    this.renderComplete_ = (this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default2.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady();
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty_default.LAYERGROUP, layerGroup);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(MapProperty_default.SIZE, size);
  }
  /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(MapProperty_default.TARGET, target);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof View_default) {
      this.set(MapProperty_default.VIEW, view);
      return;
    }
    this.set(MapProperty_default.VIEW, new View_default());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View_default(viewOptions));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [Math.max(0, width), Math.max(0, height)];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          warn(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }
    const oldSize = this.getSize();
    if (size && (!oldSize || !equals(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_(size);
    }
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(size) {
    const view = this.getView();
    if (view) {
      view.setViewportSize(size);
    }
  }
};
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values = {};
  const layerGroup = options.layers && typeof /** @type {?} */
  options.layers.getLayers === "function" ? (
    /** @type {LayerGroup} */
    options.layers
  ) : new Group_default({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      options.layers
    )
  });
  values[MapProperty_default.LAYERGROUP] = layerGroup;
  values[MapProperty_default.TARGET] = options.target;
  values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection_default(options.controls.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.controls.getArray === "function",
        "Expected `controls` to be an array or an `ol/Collection.js`"
      );
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection_default(options.interactions.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.interactions.getArray === "function",
        "Expected `interactions` to be an array or an `ol/Collection.js`"
      );
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection_default(options.overlays.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.overlays.getArray === "function",
        "Expected `overlays` to be an array or an `ol/Collection.js`"
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection_default();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
var Map_default2 = Map;

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
var BaseTileLayer = class extends Layer_default {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    const cacheSize2 = options.cacheSize;
    delete options.cacheSize;
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.cacheSize_ = cacheSize2;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
    );
  }
  /**
   * @return {number|undefined} The suggested cache size
   * @protected
   */
  getCacheSize() {
    return this.cacheSize_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(TileProperty_default.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(pixel) {
    return super.getData(pixel);
  }
};
var BaseTile_default = BaseTileLayer;

// node_modules/ol/renderer/Layer.js
var maxStaleKeys = 5;
var LayerRenderer = class extends Observable_default {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super();
    this.ready = true;
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
    this.layer_ = layer;
    this.staleKeys_ = new Array();
    this.maxStaleKeys = maxStaleKeys;
  }
  /**
   * @return {Array<string>} Get the list of stale keys.
   */
  getStaleKeys() {
    return this.staleKeys_;
  }
  /**
   * @param {string} key The new stale key.
   */
  prependStaleKey(key) {
    this.staleKeys_.unshift(key);
    if (this.staleKeys_.length > this.maxStaleKeys) {
      this.staleKeys_.length = this.maxStaleKeys;
    }
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    return abstract();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return abstract();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(frameState, target) {
    return abstract();
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    return void 0;
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(event) {
    const image = (
      /** @type {import("../Image.js").default} */
      event.target
    );
    if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
      this.renderIfReadyAndVisible();
    }
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(image) {
    let imageState = image.getState();
    if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
      image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == ImageState_default.IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == ImageState_default.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
      layer.changed();
    }
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(frameState) {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
};
var Layer_default2 = LayerRenderer;

// node_modules/ol/render/canvas/ZIndexContext.js
var ZIndexContext = class {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    __publicField(this, "pushMethodArgs_", (...args) => {
      this.instructions_[this.zIndex + this.offset_].push(args);
      return this;
    });
    this.instructions_ = [];
    this.zIndex = 0;
    this.offset_ = 0;
    this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(getSharedCanvasContext2D(), {
      get: (target, property) => {
        if (typeof /** @type {*} */
        getSharedCanvasContext2D()[property] !== "function") {
          return void 0;
        }
        if (!this.instructions_[this.zIndex + this.offset_]) {
          this.instructions_[this.zIndex + this.offset_] = [];
        }
        this.instructions_[this.zIndex + this.offset_].push(property);
        return this.pushMethodArgs_;
      },
      set: (target, property, value) => {
        if (!this.instructions_[this.zIndex + this.offset_]) {
          this.instructions_[this.zIndex + this.offset_] = [];
        }
        this.instructions_[this.zIndex + this.offset_].push(property, value);
        return true;
      }
    });
  }
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(render2) {
    this.instructions_[this.zIndex + this.offset_].push(render2);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(context) {
    this.instructions_.forEach((instructionsAtIndex) => {
      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {
        const property = instructionsAtIndex[i];
        if (typeof property === "function") {
          property(context);
          continue;
        }
        const instructionAtIndex = instructionsAtIndex[++i];
        if (typeof /** @type {*} */
        context[property] === "function") {
          context[property](...instructionAtIndex);
        } else {
          if (typeof instructionAtIndex === "function") {
            context[property] = instructionAtIndex(context);
            continue;
          }
          context[property] = instructionAtIndex;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0;
    this.zIndex = 0;
    this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length;
    this.zIndex = 0;
  }
};
var ZIndexContext_default = ZIndexContext;

// node_modules/ol/renderer/canvas/Layer.js
var pixelContext = null;
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var CanvasLayerRenderer = class extends Layer_default2 {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super(layer);
    this.container = null;
    this.renderedResolution;
    this.tempTransform = create();
    this.pixelTransform = create();
    this.inversePixelTransform = create();
    this.context = null;
    this.deferredContext_ = null;
    this.containerReused = false;
    this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    let data;
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      pixelContext = null;
      return null;
    }
    return data;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === "function") {
      background = background(frameState.viewState.resolution);
    }
    return background || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(target, transform2, backgroundColor) {
    const layerClassName = this.getLayer().getClassName();
    let container, context;
    if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
      asArray(target.style.backgroundColor),
      asArray(backgroundColor)
    ))) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext("2d");
      }
    }
    if (context && context.canvas.style.transform === transform2) {
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      this.container = null;
      this.context = null;
      this.containerReused = false;
    } else if (this.container) {
      this.container.style.backgroundColor = null;
    }
    if (!this.container) {
      container = document.createElement("div");
      container.className = layerClassName;
      let style = container.style;
      style.position = "absolute";
      style.width = "100%";
      style.height = "100%";
      context = createCanvasContext2D();
      const canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = "absolute";
      style.left = "0";
      style.transformOrigin = "top left";
      this.container = container;
      this.context = context;
    }
    if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
      this.container.style.backgroundColor = backgroundColor;
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(context, frameState, extent) {
    const topLeft = getTopLeft(extent);
    const topRight = getTopRight(extent);
    const bottomRight = getBottomRight(extent);
    const bottomLeft = getBottomLeft(extent);
    apply(frameState.coordinateToPixelTransform, topLeft);
    apply(frameState.coordinateToPixelTransform, topRight);
    apply(frameState.coordinateToPixelTransform, bottomRight);
    apply(frameState.coordinateToPixelTransform, bottomLeft);
    const inverted = this.inversePixelTransform;
    apply(inverted, topLeft);
    apply(inverted, topRight);
    apply(inverted, bottomRight);
    apply(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(frameState, target) {
    const extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const width = Math.round(getWidth(extent) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent) / resolution * pixelRatio);
    compose(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    const canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    if (!this.containerReused) {
      const canvas = this.context.canvas;
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      } else {
        this.context.clearRect(0, 0, width, height);
      }
      if (canvasTransform !== canvas.style.transform) {
        canvas.style.transform = canvasTransform;
      }
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new Event_default2(
        type,
        this.inversePixelTransform,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(context, frameState) {
    this.frameState = frameState;
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(context, frameState) {
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(frameState) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(frameState) {
    if (frameState.declutter && !this.deferredContext_) {
      this.deferredContext_ = new ZIndexContext_default();
    }
    return frameState.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(frameState) {
    if (!frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(
      EventType_default2.PRERENDER,
      this.context,
      frameState
    );
    if (frameState.declutter && this.deferredContext_) {
      this.deferredContext_.draw(this.context);
      this.deferredContext_.clear();
    }
    this.renderDeferredInternal(frameState);
    this.dispatchRenderEvent_(
      EventType_default2.POSTRENDER,
      this.context,
      frameState
    );
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return compose(
      this.tempTransform,
      dx1,
      dy1,
      sx,
      sy,
      -rotation,
      dx2,
      dy2
    );
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
};
var Layer_default3 = CanvasLayerRenderer;

// node_modules/ol/Tile.js
var Tile = class extends Target_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === TileState_default.ERROR) {
      this.setState(TileState_default.EMPTY);
    }
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== TileState_default.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    abstract();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }
    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }
    const delta = time - start + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    this.release();
    super.disposeInternal();
  }
};
var Tile_default = Tile;

// node_modules/ol/DataTile.js
function asImageLike(data) {
  return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;
}
function asArrayLike(data) {
  return data instanceof Uint8Array || data instanceof Uint8ClampedArray || data instanceof Float32Array || data instanceof DataView ? data : null;
}
var disposedError = new Error("disposed");
var sharedContext = null;
function toArray(image) {
  if (!sharedContext) {
    sharedContext = createCanvasContext2D(
      image.width,
      image.height,
      void 0,
      { willReadFrequently: true }
    );
  }
  const canvas = sharedContext.canvas;
  const width = image.width;
  if (canvas.width !== width) {
    canvas.width = width;
  }
  const height = image.height;
  if (canvas.height !== height) {
    canvas.height = height;
  }
  sharedContext.clearRect(0, 0, width, height);
  sharedContext.drawImage(image, 0, 0);
  return sharedContext.getImageData(0, 0, width, height).data;
}
var defaultSize = [256, 256];
var DataTile = class extends Tile_default {
  /**
   * @param {Options} options Tile options.
   */
  constructor(options) {
    const state = TileState_default.IDLE;
    super(options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    });
    this.loader_ = options.loader;
    this.data_ = null;
    this.error_ = null;
    this.size_ = options.size || null;
    this.controller_ = options.controller || null;
  }
  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_) {
      return this.size_;
    }
    const imageData = asImageLike(this.data_);
    if (imageData) {
      return [imageData.width, imageData.height];
    }
    return defaultSize;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }
  /**
   * Load the tile data.
   * @api
   * @override
   */
  load() {
    if (this.state !== TileState_default.IDLE && this.state !== TileState_default.ERROR) {
      return;
    }
    this.state = TileState_default.LOADING;
    this.changed();
    const self2 = this;
    this.loader_().then(function(data) {
      self2.data_ = data;
      self2.state = TileState_default.LOADED;
      self2.changed();
    }).catch(function(error) {
      self2.error_ = error;
      self2.state = TileState_default.ERROR;
      self2.changed();
    });
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.controller_) {
      this.controller_.abort(disposedError);
      this.controller_ = null;
    }
    super.disposeInternal();
  }
};
var DataTile_default = DataTile;

// node_modules/ol/ImageTile.js
var ImageTile = class extends Tile_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = TileState_default.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = TileState_default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    if (image.naturalWidth && image.naturalHeight) {
      this.state = TileState_default.LOADED;
    } else {
      this.state = TileState_default.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   * @api
   * @override
   */
  load() {
    if (this.state == TileState_default.ERROR) {
      this.state = TileState_default.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    this.unlistenImage_();
    this.image_ = null;
    super.disposeInternal();
  }
};
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile_default = ImageTile;

// node_modules/ol/structs/LRUCache.js
var LRUCache = class {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
   * the entry will be disposed.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      const entry = this.pop();
      if (entry instanceof Disposable_default) {
        entry.dispose();
      }
    }
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */
      entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(key) {
    return this.entries_[key]?.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */
    entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    assert(
      !(key in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
};
var LRUCache_default = LRUCache;

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD = 0.5;

// node_modules/ol/reproj/Triangulation.js
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = class {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c) {
      const key = c[0] + "/" + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
        )
      )
    ) : 0);
    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        ) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = (
      /** @type {number} */
      this.sourceWorldWidth_
    );
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a, b, c, d]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = createEmpty();
    this.triangles_.forEach(function(triangle, i, arr) {
      const src = triangle.source;
      extendCoordinate(extent, src[0]);
      extendCoordinate(extent, src[1]);
      extendCoordinate(extent, src[2]);
    });
    return extent;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
};
var Triangulation_default = Triangulation;

// node_modules/ol/reproj.js
var brokenDiagonalRendering_;
var canvasPool = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend2(sourceDataExtent, src.extent);
  });
  let stitchContext;
  const stitchScale = pixelRatio / sourceResolution;
  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchContext = createCanvasContext2D(
      Math.round(getWidth(sourceDataExtent) * stitchScale),
      Math.round(getHeight(sourceDataExtent) * stitchScale),
      canvasPool
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    if (sourceExtent && clipExtent) {
      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;
      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;
      const width2 = getWidth(sourceExtent) * stitchScale;
      const height2 = getHeight(sourceExtent) * stitchScale;
      stitchContext.rect(xPos, yPos, width2, height2);
      stitchContext.clip();
    }
    sources.forEach(function(src, i, arr) {
      if (src.image.width > 0 && src.image.height > 0) {
        if (src.clipExtent) {
          stitchContext.save();
          const xPos2 = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          const yPos2 = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          const width2 = getWidth(src.clipExtent) * stitchScale;
          const height2 = getHeight(src.clipExtent) * stitchScale;
          stitchContext.rect(
            interpolate ? xPos2 : Math.round(xPos2),
            interpolate ? yPos2 : Math.round(yPos2),
            interpolate ? width2 : Math.round(xPos2 + width2) - Math.round(xPos2),
            interpolate ? height2 : Math.round(yPos2 + height2) - Math.round(yPos2)
          );
          stitchContext.clip();
        }
        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        const srcWidth = getWidth(src.extent) * stitchScale;
        const srcHeight = getHeight(src.extent) * stitchScale;
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),
          interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos)
        );
        if (src.clipExtent) {
          stitchContext.restore();
        }
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(inverseScale, -inverseScale);
    } else {
      const source2 = sources[0];
      const extent = source2.extent;
      image = source2.image;
      context.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}

// node_modules/ol/reproj/DataTile.js
var ReprojDataTile = class extends DataTile_default {
  /**
   * @param {Options} options Tile options.
   */
  constructor(options) {
    super({
      tileCoord: options.tileCoord,
      loader: () => Promise.resolve(new Uint8ClampedArray(4)),
      interpolate: options.interpolate,
      transition: options.transition
    });
    this.pixelRatio_ = options.pixelRatio;
    this.gutter_ = options.gutter;
    this.reprojData_ = null;
    this.reprojError_ = null;
    this.reprojSize_ = void 0;
    this.sourceTileGrid_ = options.sourceTileGrid;
    this.targetTileGrid_ = options.targetTileGrid;
    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    const sourceProj = options.sourceProj;
    const sourceProjExtent = sourceProj.getExtent();
    const sourceTileGridExtent = options.sourceTileGrid.getExtent();
    this.clipExtent_ = sourceProj.canWrapX() ? sourceTileGridExtent ? getIntersection(sourceProjExtent, sourceTileGridExtent) : sourceProjExtent : sourceTileGridExtent;
    const targetExtent = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = this.targetTileGrid_.getResolution(
      this.wrappedTileCoord_[0]
    );
    const targetProj = options.targetProj;
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const errorThresholdInPixels = options.errorThreshold !== void 0 ? options.errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState_default.EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = getWidth(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
        );
      }
      const sourceExtents = wrapAndSliceX(
        sourceExtent.slice(),
        sourceProj,
        true
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_
        );
        const getTile = options.getTileFunction;
        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);
            if (tile) {
              const offset = worldsAway * worldWidth;
              this.sourceTiles_.push({ tile, offset });
            }
          }
        }
        ++worldsAway;
      });
      if (this.sourceTiles_.length === 0) {
        this.state = TileState_default.EMPTY;
      }
    }
  }
  /**
   * Get the tile size.
   * @return {import('../size.js').Size} Tile size.
   * @override
   */
  getSize() {
    return this.reprojSize_;
  }
  /**
   * Get the data for the tile.
   * @return {import("../DataTile.js").Data} Tile data.
   * @override
   */
  getData() {
    return this.reprojData_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @override
   */
  getError() {
    return this.reprojError_;
  }
  /**
   * @private
   */
  reproject_() {
    const dataSources = [];
    let imageLike = false;
    this.sourceTiles_.forEach((source) => {
      const tile = source.tile;
      if (!tile || tile.getState() !== TileState_default.LOADED) {
        return;
      }
      const size2 = tile.getSize();
      const gutter = this.gutter_;
      let tileData;
      const arrayData = asArrayLike(tile.getData());
      if (arrayData) {
        tileData = arrayData;
      } else {
        imageLike = true;
        tileData = toArray(asImageLike(tile.getData()));
      }
      const pixelSize = [size2[0] + 2 * gutter, size2[1] + 2 * gutter];
      const isFloat = tileData instanceof Float32Array;
      const pixelCount = pixelSize[0] * pixelSize[1];
      const DataType = isFloat ? Float32Array : Uint8ClampedArray;
      const tileDataR = new DataType(tileData.buffer);
      const bytesPerElement = DataType.BYTES_PER_ELEMENT;
      const bytesPerPixel2 = bytesPerElement * tileDataR.length / pixelCount;
      const bytesPerRow = tileDataR.byteLength / pixelSize[1];
      const bandCount = Math.floor(
        bytesPerRow / bytesPerElement / pixelSize[0]
      );
      const packedLength = pixelCount * bandCount;
      let packedData = tileDataR;
      if (tileDataR.length !== packedLength) {
        packedData = new DataType(packedLength);
        let dataIndex = 0;
        let rowOffset = 0;
        const colCount = pixelSize[0] * bandCount;
        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
          for (let colIndex = 0; colIndex < colCount; ++colIndex) {
            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];
          }
          rowOffset += bytesPerRow / bytesPerElement;
        }
      }
      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
      extent[0] += source.offset;
      extent[2] += source.offset;
      const clipExtent = this.clipExtent_?.slice();
      if (clipExtent) {
        clipExtent[0] += source.offset;
        clipExtent[2] += source.offset;
      }
      dataSources.push({
        extent,
        clipExtent,
        data: new Uint8ClampedArray(packedData.buffer),
        dataType: DataType,
        bytesPerPixel: bytesPerPixel2,
        pixelSize
      });
    });
    this.sourceTiles_.length = 0;
    if (dataSources.length === 0) {
      this.state = TileState_default.ERROR;
      this.changed();
      return;
    }
    const z = this.wrappedTileCoord_[0];
    const size = this.targetTileGrid_.getTileSize(z);
    const targetWidth = typeof size === "number" ? size : size[0];
    const targetHeight = typeof size === "number" ? size : size[1];
    const targetResolution = this.targetTileGrid_.getResolution(z);
    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
    const targetExtent = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    let dataR, dataU;
    const bytesPerPixel = dataSources[0].bytesPerPixel;
    const reprojs = Math.ceil(bytesPerPixel / 3);
    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {
      const sources = [];
      for (let i = 0, len = dataSources.length; i < len; ++i) {
        const dataSource = dataSources[i];
        const buffer = dataSource.data;
        const pixelSize = dataSource.pixelSize;
        const width = pixelSize[0];
        const height = pixelSize[1];
        const context2 = createCanvasContext2D(width, height, canvasPool);
        const imageData2 = context2.createImageData(width, height);
        const data2 = imageData2.data;
        let offset2 = reproj * 3;
        for (let j = 0, len2 = data2.length; j < len2; j += 4) {
          data2[j] = buffer[offset2];
          data2[j + 1] = buffer[offset2 + 1];
          data2[j + 2] = buffer[offset2 + 2];
          data2[j + 3] = 255;
          offset2 += bytesPerPixel;
        }
        context2.putImageData(imageData2, 0, 0);
        sources.push({
          extent: dataSource.extent,
          clipExtent: dataSource.clipExtent,
          image: context2.canvas
        });
      }
      const canvas = render(
        targetWidth,
        targetHeight,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        false,
        false,
        false
      );
      for (let i = 0, len = sources.length; i < len; ++i) {
        const canvas2 = sources[i].image;
        const context2 = canvas2.getContext("2d");
        releaseCanvas(context2);
        canvasPool.push(context2.canvas);
      }
      const context = canvas.getContext("2d");
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      releaseCanvas(context);
      canvasPool.push(canvas);
      if (!dataR) {
        dataU = new Uint8ClampedArray(
          bytesPerPixel * imageData.width * imageData.height
        );
        dataR = new dataSources[0].dataType(dataU.buffer);
      }
      const data = imageData.data;
      let offset = reproj * 3;
      for (let i = 0, len = data.length; i < len; i += 4) {
        if (data[i + 3] === 255) {
          dataU[offset] = data[i];
          dataU[offset + 1] = data[i + 1];
          dataU[offset + 2] = data[i + 2];
        } else {
          dataU[offset] = 0;
          dataU[offset + 1] = 0;
          dataU[offset + 2] = 0;
        }
        offset += bytesPerPixel;
      }
    }
    if (imageLike) {
      const context = createCanvasContext2D(targetWidth, targetHeight);
      const imageData = new ImageData(dataR, targetWidth);
      context.putImageData(imageData, 0, 0);
      this.reprojData_ = context.canvas;
    } else {
      this.reprojData_ = dataR;
    }
    this.reprojSize_ = [
      Math.round(targetWidth * this.pixelRatio_),
      Math.round(targetHeight * this.pixelRatio_)
    ];
    this.state = TileState_default.LOADED;
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state !== TileState_default.IDLE && this.state !== TileState_default.ERROR) {
      return;
    }
    this.state = TileState_default.LOADING;
    this.changed();
    let leftToLoad = 0;
    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(({ tile }) => {
      const state = tile.getState();
      if (state !== TileState_default.IDLE && state !== TileState_default.LOADING) {
        return;
      }
      leftToLoad++;
      const sourceListenKey = listen(tile, EventType_default.CHANGE, () => {
        const state2 = tile.getState();
        if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
          unlistenByKey(sourceListenKey);
          leftToLoad--;
          if (leftToLoad === 0) {
            this.unlistenSources_();
            this.reproject_();
          }
        }
      });
      this.sourcesListenerKeys_.push(sourceListenKey);
    });
    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    } else {
      this.sourceTiles_.forEach(function({ tile }) {
        const state = tile.getState();
        if (state == TileState_default.IDLE) {
          tile.load();
        }
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
};
var DataTile_default2 = ReprojDataTile;

// node_modules/ol/reproj/Tile.js
var ReprojTile = class extends Tile_default {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
    super(tileCoord, TileState_default.IDLE, options);
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : void 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState_default.EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = getWidth(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
        );
      }
      const sourceExtents = wrapAndSliceX(
        sourceExtent.slice(),
        sourceProj,
        true
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_
        );
        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
            if (tile) {
              const offset = worldsAway * worldWidth;
              this.sourceTiles_.push({ tile, offset });
            }
          }
        }
        ++worldsAway;
      });
      if (this.sourceTiles_.length === 0) {
        this.state = TileState_default.EMPTY;
      }
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((source) => {
      const tile = source.tile;
      if (tile && tile.getState() == TileState_default.LOADED) {
        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
        extent[0] += source.offset;
        extent[2] += source.offset;
        const clipExtent = this.clipExtent_?.slice();
        if (clipExtent) {
          clipExtent[0] += source.offset;
          clipExtent[2] += source.offset;
        }
        sources.push({
          extent,
          clipExtent,
          image: tile.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState_default.ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = render(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );
      this.state = TileState_default.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(({ tile }) => {
        const state = tile.getState();
        if (state == TileState_default.IDLE || state == TileState_default.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(tile, EventType_default.CHANGE, (e) => {
            const state2 = tile.getState();
            if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
              unlistenByKey(sourceListenKey);
              leftToLoad--;
              if (leftToLoad === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          });
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function({ tile }, i, arr) {
          const state = tile.getState();
          if (state == TileState_default.IDLE) {
            tile.load();
          }
        });
      }
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    if (this.canvas_) {
      releaseCanvas(this.canvas_.getContext("2d"));
      canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
};
var Tile_default2 = ReprojTile;

// node_modules/ol/TileRange.js
var TileRange = class {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
};
function createOrUpdate2(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange_default = TileRange;

// node_modules/ol/tilecoord.js
function createOrUpdate3(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function hash(tileCoord) {
  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function hashZXY(z, x, y) {
  return (x << z) + y;
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}

// node_modules/ol/renderer/canvas/TileLayer.js
function getCacheKey2(sourceKey, z, x, y) {
  return `${sourceKey},${getKeyZXY(z, x, y)}`;
}
function addTileToLookup(tilesByZ, tile, z) {
  if (!(z in tilesByZ)) {
    tilesByZ[z] = /* @__PURE__ */ new Set([tile]);
    return true;
  }
  const set = tilesByZ[z];
  const existing = set.has(tile);
  if (!existing) {
    set.add(tile);
  }
  return !existing;
}
function removeTileFromLookup(tilesByZ, tile, z) {
  const set = tilesByZ[z];
  if (set) {
    return set.delete(tile);
  }
  return false;
}
function getRenderExtent(frameState, extent) {
  const layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = getIntersection(
      extent,
      fromUserExtent(layerState.extent, frameState.viewState.projection)
    );
  }
  const source = (
    /** @type {import("../../source/Tile.js").default} */
    layerState.layer.getRenderSource()
  );
  if (!source.getWrapX()) {
    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = getIntersection(extent, gridExtent);
    }
  }
  return extent;
}
var CanvasTileLayerRenderer = class extends Layer_default3 {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} [options] Options.
   */
  constructor(tileLayer, options) {
    super(tileLayer);
    options = options || {};
    this.extentChanged = true;
    this.renderComplete = false;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision;
    this.renderedTiles = [];
    this.renderedSourceKey_;
    this.renderedSourceRevision_;
    this.tempExtent = createEmpty();
    this.tempTileRange_ = new TileRange_default(0, 0, 0, 0);
    this.tempTileCoord_ = createOrUpdate3(0, 0, 0);
    const cacheSize2 = options.cacheSize !== void 0 ? options.cacheSize : 512;
    this.tileCache_ = new LRUCache_default(cacheSize2);
    this.renderedProjection_ = void 0;
    this.maxStaleKeys = cacheSize2 * 0.5;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getTileCache() {
    return this.tileCache_;
  }
  /**
   * Get a tile from the cache or create one if needed.
   *
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getOrCreateTile(z, x, y, frameState) {
    const tileCache = this.tileCache_;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const cacheKey = getCacheKey2(tileSource.getKey(), z, x, y);
    let tile;
    if (tileCache.containsKey(cacheKey)) {
      tile = tileCache.get(cacheKey);
    } else {
      tile = tileSource.getTile(
        z,
        x,
        y,
        frameState.pixelRatio,
        frameState.viewState.projection
      );
      if (!tile) {
        return null;
      }
      tileCache.set(cacheKey, tile);
    }
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getTile(z, x, y, frameState) {
    const tile = this.getOrCreateTile(z, x, y, frameState);
    if (!tile) {
      return null;
    }
    return tile;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);
      if (!tile || tile.getState() !== TileState_default.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = toSize(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);
      let image;
      if (tile instanceof ImageTile_default || tile instanceof Tile_default2) {
        image = tile.getImage();
      } else if (tile instanceof DataTile_default) {
        image = asImageLike(tile.getData());
        if (!image) {
          continue;
        }
      } else {
        continue;
      }
      const col = Math.floor(
        tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
      );
      const row = Math.floor(
        tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
      );
      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );
      return this.getImageData(image, col + gutter, row + gutter);
    }
    return null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(frameState) {
    if (!this.renderedProjection_) {
      this.renderedProjection_ = frameState.viewState.projection;
    } else if (frameState.viewState.projection !== this.renderedProjection_) {
      this.tileCache_.clear();
      this.renderedProjection_ = frameState.viewState.projection;
    }
    const source = this.getLayer().getSource();
    if (!source) {
      return false;
    }
    const sourceRevision = source.getRevision();
    if (!this.renderedRevision_) {
      this.renderedRevision_ = sourceRevision;
    } else if (this.renderedRevision_ !== sourceRevision) {
      this.renderedRevision_ = sourceRevision;
      if (this.renderedSourceKey_ === source.getKey()) {
        this.tileCache_.clear();
      }
    }
    return true;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {
    const viewState = frameState.viewState;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getRenderSource();
    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const map = tileLayer.getMapInternal();
    const minZ = Math.max(
      initialZ - preload,
      tileGrid.getMinZoom(),
      tileGrid.getZForResolution(
        Math.min(
          tileLayer.getMaxResolution(),
          map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)
        ),
        tileSource.zDirection
      )
    );
    for (let z = initialZ; z >= minZ; --z) {
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        extent,
        z,
        this.tempTileRange_
      );
      const tileResolution = tileGrid.getResolution(z);
      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
          const tile = this.getTile(z, x, y, frameState);
          if (!tile) {
            continue;
          }
          const added = addTileToLookup(tilesByZ, tile, z);
          if (!added) {
            continue;
          }
          const tileQueueKey = tile.getKey();
          wantedTiles[tileQueueKey] = true;
          if (tile.getState() === TileState_default.IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              const tileCoord = createOrUpdate3(z, x, y, this.tempTileCoord_);
              frameState.tileQueue.enqueue([
                tile,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution
              ]);
            }
          }
        }
      }
    }
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findStaleTile_(tileCoord, tilesByZ) {
    const tileCache = this.tileCache_;
    const z = tileCoord[0];
    const x = tileCoord[1];
    const y = tileCoord[2];
    const staleKeys = this.getStaleKeys();
    for (let i = 0; i < staleKeys.length; ++i) {
      const cacheKey = getCacheKey2(staleKeys[i], z, x, y);
      if (tileCache.containsKey(cacheKey)) {
        const tile = tileCache.get(cacheKey);
        if (tile.getState() === TileState_default.LOADED) {
          tile.endTransition(getUid(this));
          addTileToLookup(tilesByZ, tile, z);
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {
    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(
      tileCoord,
      altZ,
      this.tempTileRange_
    );
    if (!tileRange) {
      return false;
    }
    let covered = true;
    const tileCache = this.tileCache_;
    const source = this.getLayer().getRenderSource();
    const sourceKey = source.getKey();
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        const cacheKey = getCacheKey2(sourceKey, altZ, x, y);
        let loaded = false;
        if (tileCache.containsKey(cacheKey)) {
          const tile = tileCache.get(cacheKey);
          if (tile.getState() === TileState_default.LOADED) {
            addTileToLookup(tilesByZ, tile, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  /**
   * Render the layer.
   *
   * The frame rendering logic has three parts:
   *
   *  1. Enqueue tiles
   *  2. Find alt tiles for those that are not yet loaded
   *  3. Render loaded tiles
   *
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(frameState, target) {
    this.renderComplete = true;
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    const sourceKey = tileSource.getKey();
    if (!this.renderedSourceKey_) {
      this.renderedSourceKey_ = sourceKey;
    } else if (this.renderedSourceKey_ !== sourceKey) {
      this.prependStaleKey(this.renderedSourceKey_);
      this.renderedSourceKey_ = sourceKey;
    }
    let frameExtent = frameState.extent;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    this.prepareContainer(frameState, target);
    const width = this.context.canvas.width;
    const height = this.context.canvas.height;
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
    if (layerExtent) {
      frameExtent = getIntersection(
        frameExtent,
        fromUserExtent(layerState.extent, projection)
      );
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tilesByZ = {};
    this.renderedTiles.length = 0;
    const preload = tileLayer.getPreload();
    if (frameState.nextExtent) {
      const targetZ = tileGrid.getZForResolution(
        viewState.nextResolution,
        tileSource.zDirection
      );
      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);
    }
    const renderExtent = getRenderExtent(frameState, frameExtent);
    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);
    if (preload > 0) {
      setTimeout(() => {
        this.enqueueTiles(
          frameState,
          renderExtent,
          z - 1,
          tilesByZ,
          preload - 1
        );
      }, 0);
    }
    if (!(z in tilesByZ)) {
      return this.container;
    }
    const uid = getUid(this);
    const time = frameState.time;
    for (const tile of tilesByZ[z]) {
      const tileState = tile.getState();
      if ((tile instanceof Tile_default2 || tile instanceof DataTile_default2) && tileState === TileState_default.EMPTY) {
        continue;
      }
      const tileCoord = tile.tileCoord;
      if (tileState === TileState_default.LOADED) {
        const alpha = tile.getAlpha(uid, time);
        if (alpha === 1) {
          tile.endTransition(uid);
          continue;
        }
      }
      this.renderComplete = false;
      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);
      if (hasStaleTile) {
        removeTileFromLookup(tilesByZ, tile, z);
        frameState.animate = true;
        continue;
      }
      const coveredByChildren = this.findAltTiles_(
        tileGrid,
        tileCoord,
        z + 1,
        tilesByZ
      );
      if (coveredByChildren) {
        continue;
      }
      const minZoom = tileGrid.getMinZoom();
      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {
        const coveredByParent = this.findAltTiles_(
          tileGrid,
          tileCoord,
          parentZ,
          tilesByZ
        );
        if (coveredByParent) {
          break;
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    const context = this.getRenderContext(frameState);
    compose(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );
    if (layerState.extent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    const zs = Object.keys(tilesByZ).map(Number);
    zs.sort(ascending);
    let currentClip;
    const clips = [];
    const clipZs = [];
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        getTopLeft(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      for (const tile of tilesByZ[currentZ]) {
        if (tile.getState() !== TileState_default.LOADED) {
          continue;
        }
        const tileCoord = tile.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x = Math.round(origin[0] - xIndex * dx2);
        const y = Math.round(origin[1] - yIndex * dy2);
        const w = nextX - x;
        const h = nextY - y;
        const transition = zs.length === 1;
        let contextSaved = false;
        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
        for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
          if (!transition && currentZ < clipZs[i2]) {
            const clip = clips[i2];
            if (intersects(
              [x, y, x + w, y + h],
              [clip[0], clip[3], clip[4], clip[7]]
            )) {
              if (!contextSaved) {
                context.save();
                contextSaved = true;
              }
              context.beginPath();
              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]);
              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
        }
        clips.push(currentClip);
        clipZs.push(currentZ);
        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);
        if (contextSaved) {
          context.restore();
        }
        this.renderedTiles.unshift(tile);
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.postRender(this.context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    const postRenderFunction = (map, frameState2) => {
      const tileSourceKey = getUid(tileSource);
      const wantedTiles = frameState2.wantedTiles[tileSourceKey];
      const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;
      this.updateCacheSize(tilesCount);
      this.tileCache_.expireCache();
    };
    frameState.postRenderFunctions.push(postRenderFunction);
    return this.container;
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   */
  updateCacheSize(tileCount) {
    this.tileCache_.highWaterMark = Math.max(
      this.tileCache_.highWaterMark,
      tileCount * 2
    );
  }
  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @protected
   */
  drawTile(tile, frameState, x, y, w, h, gutter, transition) {
    let image;
    if (tile instanceof DataTile_default) {
      image = asImageLike(tile.getData());
      if (!image) {
        throw new Error("Rendering array data is not yet supported");
      }
    } else {
      image = this.getTileImage(
        /** @type {import("../../ImageTile.js").default} */
        tile
      );
    }
    if (!image) {
      return;
    }
    const context = this.getRenderContext(frameState);
    const uid = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== context.globalAlpha;
    if (alphaChanged) {
      context.save();
      context.globalAlpha = alpha;
    }
    context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );
    if (alphaChanged) {
      context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile) {
    return tile.getImage();
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }
};
var TileLayer_default = CanvasTileLayerRenderer;

// node_modules/ol/layer/Tile.js
var TileLayer = class extends BaseTile_default {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }
  /**
   * @override
   */
  createRenderer() {
    return new TileLayer_default(this, {
      cacheSize: this.getCacheSize()
    });
  }
};
var Tile_default3 = TileLayer;

// node_modules/ol/source/TileEventType.js
var TileEventType_default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};

// node_modules/ol/source/Source.js
var Source = class extends Object_default {
  /**
   * @param {Options} options Source options.
   */
  constructor(options) {
    super();
    this.projection = get3(options.projection);
    this.attributions_ = adaptAttributions(options.attributions);
    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;
    this.loading = false;
    this.state_ = options.state !== void 0 ? options.state : "ready";
    this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
    this.interpolate_ = !!options.interpolate;
    this.viewResolver = null;
    this.viewRejector = null;
    const self2 = this;
    this.viewPromise_ = new Promise(function(resolve, reject) {
      self2.viewResolver = resolve;
      self2.viewRejector = reject;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(state) {
    this.state_ = state;
    this.changed();
  }
};
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  if (!Array.isArray(attributionLike)) {
    attributionLike = [attributionLike];
  }
  return (frameState) => attributionLike;
}
var Source_default = Source;

// node_modules/ol/tilegrid/TileGrid.js
var tmpTileCoord = [0, 0, 0];
var DECIMALS = 5;
var TileGrid = class {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(
      isSorted(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, b) => b - a,
        true
      ),
      "`resolutions` must be sorted in descending order"
    );
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      );
    }
    const extent = options.extent;
    if (extent !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }
    assert(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    );
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      );
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    );
    this.extent_ = extent !== void 0 ? extent : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map((size, z) => {
        const tileRange = new TileRange_default(
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (x !== void 0 && y !== void 0) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = createOrUpdate2(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate2(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z === tileCoordZ) {
      return createOrUpdate2(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return createOrUpdate2(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z = this.getZForResolution(resolution);
    const scale4 = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = scale4 * (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale4 * (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    return this.fullTileRanges_[z];
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = linearFindNearest(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return clamp(z, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
};
var TileGrid_default = TileGrid;

// node_modules/ol/tilegrid.js
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX3(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options) {
  const xyzOptions = options || {};
  const extent = xyzOptions.extent || get3("EPSG:3857").getExtent();
  const gridOptions = {
    extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    )
  };
  return new TileGrid_default(gridOptions);
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get3(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }
  return extent;
}

// node_modules/ol/source/Tile.js
var TileSource = class extends Source_default {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tmpSize = [0, 0];
    this.key_ = options.key || getUid(this);
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {TileType|null} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale3(tileSize, tilePixelRatio, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX3(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  /**
   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
   * @api
   */
  clear() {
  }
  /**
   * @override
   */
  refresh() {
    this.clear();
    super.refresh();
  }
};
var TileSourceEvent = class extends Event_default {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile) {
    super(type);
    this.tile = tile;
  }
};
var Tile_default4 = TileSource;

// node_modules/ol/uri.js
var zRegEx = /\{z\}/g;
var xRegEx = /\{x\}/g;
var yRegEx = /\{y\}/g;
var dashYRegEx = /\{-y\}/g;
function renderXYZTemplate(template, z, x, y, maxY) {
  return template.replace(zRegEx, z.toString()).replace(xRegEx, x.toString()).replace(yRegEx, y.toString()).replace(dashYRegEx, function() {
    if (maxY === void 0) {
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    }
    return (maxY - y).toString();
  });
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

// node_modules/ol/tileurlfunction.js
function createFromTemplate(template, tileGrid) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      let maxY;
      const z = tileCoord[0];
      if (tileGrid) {
        const range = tileGrid.getFullTileRange(z);
        if (range) {
          maxY = range.getHeight() - 1;
        }
      }
      return renderXYZTemplate(template, z, tileCoord[1], tileCoord[2], maxY);
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h = hash(tileCoord);
      const index = modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}

// node_modules/ol/source/UrlTile.js
var UrlTile = class _UrlTile extends Tile_default4 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === _UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("../Tile.js").default} */
      event.target
    );
    const uid = getUid(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == TileState_default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType_default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile));
    }
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
};
var UrlTile_default = UrlTile;

// node_modules/ol/source/TileImage.js
var TileImage = class extends UrlTile_default {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile_default;
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
      tileUrl !== void 0 ? tileUrl : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile.key = key;
    tile.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @override
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const tileCoord = [z, x, y];
    const key = this.getKey();
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tile = new Tile_default2(
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    tile.key = key;
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    const key = this.getKey();
    return this.createTile_(z, x, y, pixelRatio, projection, key);
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    this.changed();
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = get3(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage_default = TileImage;

// node_modules/ol/source/XYZ.js
var XYZ = class extends TileImage_default {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};
    const projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
    const tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
      extent: extentFromProjection(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
};
var XYZ_default = XYZ;

// node_modules/ol/source/OSM.js
var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
var OSM = class extends XYZ_default {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(options) {
    options = options || {};
    let attributions;
    if (options.attributions !== void 0) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    const crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    const url = options.url !== void 0 ? options.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });
  }
};
var OSM_default = OSM;

// resources/js/components/map-component.js
function mapComponent() {
  return {
    legendOpened: false,
    map: {},
    features: [],
    init() {
      this.map = new Map_default2({
        target: this.$refs.map,
        layers: [
          new Tile_default3({
            source: new OSM_default(),
            label: "OpenStreetMap"
          })
        ],
        view: new View_default({
          projection: "EPSG:4326",
          center: [0, 0],
          zoom: 2
        })
      });
    },
    styleFunction(feature, resolution) {
      return new Style_default({
        image: new Circle_default({
          radius: 4,
          fill: new Fill_default({
            color: "rgba(0, 255, 255, 1)"
          }),
          stroke: new Stroke_default({
            color: "rgba(192, 192, 192, 1)",
            width: 2
          })
        }),
        text: new Text_default({
          font: "12px sans-serif",
          textAlign: "left",
          text: feature.get("name"),
          offsetY: -15,
          offsetX: 5,
          backgroundFill: new Fill_default({
            color: "rgba(255, 255, 255, 0.5)"
          }),
          backgroundStroke: new Stroke_default({
            color: "rgba(227, 227, 227, 1)"
          }),
          padding: [5, 2, 2, 5]
        })
      });
    },
    gotoFeature(feature) {
      this.map.getView().animate({
        center: feature.getGeometry().getCoordinates(),
        zoom: 10,
        duration: 2e3
      });
    }
  };
}
export {
  mapComponent as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0RXZlbnRUeXBlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZnVuY3Rpb25zLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9vYmouanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9UYXJnZXQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudFR5cGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JzZXJ2YWJsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvdXRpbC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Qcm9wZXJ0eS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvYXNzZXJ0cy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvbWF0aC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0V2ZW50VHlwZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvVmlld0hpbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL1ZpZXdQcm9wZXJ0eS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQvY29tbW9uLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1Byb2plY3Rpb24uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzM4NTcuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzQzMjYuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovcHJvamVjdGlvbnMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ovdHJhbnNmb3Jtcy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb29yZGluYXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9zcGhlcmUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnNvbGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Byb2ouanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NlbnRlcmNvbnN0cmFpbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3Jlc29sdXRpb25jb25zdHJhaW50LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9yb3RhdGlvbmNvbnN0cmFpbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2Vhc2luZy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvdHJhbnNmb3JtLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0dlb21ldHJ5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvY2xvc2VzdC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2RlZmxhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9zaW1wbGlmeS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2luZmxhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9hcmVhLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0xpbmVhclJpbmcuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9pbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jb250YWlucy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVyaW9ycG9pbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9zZWdtZW50cy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9yZXZlcnNlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvb3JpZW50LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1BvbHlnb24uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL1ZpZXcuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0xheWVyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9xdWlja3NlbGVjdC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL0ltYWdlU3RhdGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NpemUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ltYWdlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9yZ2IuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL3h5ei5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29sb3Itc3BhY2UvbHV2LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9sY2h1di5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29sb3ItcGFyc2Uvbm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXBhcnNlL2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9oc2wuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXJnYmEvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbG9yLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9oYXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2RvbS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2UuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uSW1hZ2UuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbG9ybGlrZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvY3NzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9SZWd1bGFyU2hhcGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0NpcmNsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvRmlsbC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvU3Ryb2tlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9TdHlsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvVGV4dC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZXhwci9leHByZXNzaW9uLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9leHByL2NwdS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9zdHlsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZVZlY3Rvci5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvTWFwLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvRXZlbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL0NvbXBvc2l0ZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvR3JvdXAuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEJyb3dzZXJFdmVudFR5cGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvRXZlbnRUeXBlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXBFdmVudFR5cGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcFByb3BlcnR5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL1RpbGVTdGF0ZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZVF1ZXVlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL0NvbnRyb2wuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvQXR0cmlidXRpb24uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvUm90YXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1pvb20uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1Byb3BlcnR5LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvY29uZGl0aW9uLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvQm94LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnQm94LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnWm9vbS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0tleS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW4uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvS2luZXRpYy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFpvb20uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL2RlZmF1bHRzLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9NYXAuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1RpbGVQcm9wZXJ0eS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZVRpbGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL0xheWVyLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL1pJbmRleENvbnRleHQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9MYXllci5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvRGF0YVRpbGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL0ltYWdlVGlsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9MUlVDYWNoZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL2NvbW1vbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RyaWFuZ3VsYXRpb24uanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL0RhdGFUaWxlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVGlsZS5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZVJhbmdlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC90aWxlY29vcmQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXIuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1RpbGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlRXZlbnRUeXBlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU291cmNlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9UaWxlR3JpZC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vbC91cmkuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RpbGV1cmxmdW5jdGlvbi5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1VybFRpbGUuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlSW1hZ2UuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9YWVouanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9PU00uanMiLCAiLi4vLi4vY29tcG9uZW50cy9tYXAtY29tcG9uZW50LmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTdHJpcHBlZCBkb3duIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLWludGVyZmFjZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9ubHkgcHJvdmlkZXMgYHR5cGVgIGFuZCBgdGFyZ2V0YCBwcm9wZXJ0aWVzLCBhbmRcbiAqIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG1ldGhvZHMuIEl0IGlzIG1lYW50IGFzIGJhc2UgY2xhc3NcbiAqIGZvciBoaWdoZXIgbGV2ZWwgZXZlbnRzIGRlZmluZWQgaW4gdGhlIGxpYnJhcnksIGFuZCB3b3JrcyB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9UYXJnZXR+VGFyZ2V0fS5cbiAqL1xuY2xhc3MgQmFzZUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudCBkZWZhdWx0LiBUaGlzIG1lYW5zIHRoYXQgbm8gZW11bGF0ZWQgYGNsaWNrYCwgYHNpbmdsZWNsaWNrYCBvciBgZG91YmxlY2xpY2tgIGV2ZW50c1xuICAgKiB3aWxsIGJlIGZpcmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZ0KSB7XG4gIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldnQpIHtcbiAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VFdmVudDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0RXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvT2JqZWN0Lk9iamVjdEV2ZW50I3Byb3BlcnR5Y2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIFBST1BFUlRZQ0hBTkdFOiAncHJvcGVydHljaGFuZ2UnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3Byb3BlcnR5Y2hhbmdlJ30gVHlwZXNcbiAqL1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9EaXNwb3NhYmxlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBPYmplY3RzIHRoYXQgbmVlZCB0byBjbGVhbiB1cCBhZnRlciB0aGVtc2VsdmVzLlxuICovXG5jbGFzcyBEaXNwb3NhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5kaXNwb3NlZCkge1xuICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbnNpb24gcG9pbnQgZm9yIGRpc3Bvc2FibGUgb2JqZWN0cy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzcG9zYWJsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvYXJyYXlcbiAqL1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcHJvdmlkZWQgc29ydGVkIGxpc3QgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLiBJZiBpdCBjYW4ndCBiZSBmb3VuZCBpdCdsbCByZXR1cm4gLTEuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9iaW5hcnktc2VhcmNoXG4gKlxuICogQHBhcmFtIHtBcnJheTwqPn0gaGF5c3RhY2sgSXRlbXMgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0geyp9IG5lZWRsZSBUaGUgaXRlbSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBDb21wYXJhdG9yIGZ1bmN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gaWYgZm91bmQsIC0xIGlmIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBjb21wYXJhdG9yKSB7XG4gIGxldCBtaWQsIGNtcDtcbiAgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgfHwgYXNjZW5kaW5nO1xuICBsZXQgbG93ID0gMDtcbiAgbGV0IGhpZ2ggPSBoYXlzdGFjay5sZW5ndGg7XG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgLyogTm90ZSB0aGF0IFwiKGxvdyArIGhpZ2gpID4+PiAxXCIgbWF5IG92ZXJmbG93LCBhbmQgcmVzdWx0cyBpbiBhIHR5cGVjYXN0XG4gICAgICogdG8gZG91YmxlICh3aGljaCBnaXZlcyB0aGUgd3JvbmcgcmVzdWx0cykuICovXG4gICAgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICBjbXAgPSArY29tcGFyYXRvcihoYXlzdGFja1ttaWRdLCBuZWVkbGUpO1xuXG4gICAgaWYgKGNtcCA8IDAuMCkge1xuICAgICAgLyogVG9vIGxvdy4gKi9cbiAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIEtleSBmb3VuZCBvciB0b28gaGlnaCAqL1xuICAgICAgaGlnaCA9IG1pZDtcbiAgICAgIGZvdW5kID0gIWNtcDtcbiAgICB9XG4gIH1cblxuICAvKiBLZXkgbm90IGZvdW5kLiAqL1xuICByZXR1cm4gZm91bmQgPyBsb3cgOiB+bG93O1xufVxuXG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gc29ydGluZyBhcnJheXMgaW4gYXNjZW5kaW5nIG9yZGVyLiAgU2FmZSB0byB1c2UgZm9yIG51bWVyaWMgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBhcyB0aGUgZmlyc3RcbiAqICAgICBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cblxuLyoqXG4gKiBDb21wYXJlIGZ1bmN0aW9uIHNvcnRpbmcgYXJyYXlzIGluIGRlc2NlbmRpbmcgb3JkZXIuICBTYWZlIHRvIHVzZSBmb3IgbnVtZXJpYyB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGFzIHRoZSBmaXJzdFxuICogICAgIGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiwgZXF1YWwgdG8sIG9yIGxlc3MgdGhhbiB0aGUgc2Vjb25kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IDEgOiBhID4gYiA/IC0xIDogMDtcbn1cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkflRpbGVHcmlkI2dldFpGb3JSZXNvbHV0aW9ufSBjYW4gdXNlIGEgZnVuY3Rpb25cbiAqIG9mIHRoaXMgdHlwZSB0byBkZXRlcm1pbmUgd2hpY2ggbmVhcmVzdCByZXNvbHV0aW9uIHRvIHVzZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgYSB2YWx1ZSBiZXR3ZWVuIHR3byBhcnJheSBlbnRyaWVzLFxuICogYSBge251bWJlcn1gIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhlIG5lYXJlc3QgaGlnaGVyIGVudHJ5IGFuZFxuICogYSBge251bWJlcn1gIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhlIG5lYXJlc3QgbG93ZXIgZW50cnlcbiAqIGFzIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhIGB7bnVtYmVyfWAuIElmIGEgbmVnYXRpdmUgbnVtYmVyIG9yIHplcm8gaXMgcmV0dXJuZWRcbiAqIHRoZSBsb3dlciB2YWx1ZSB3aWxsIGJlIHVzZWQsIGlmIGEgcG9zaXRpdmUgbnVtYmVyIGlzIHJldHVybmVkIHRoZSBoaWdoZXIgdmFsdWVcbiAqIHdpbGwgYmUgdXNlZC5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgbnVtYmVyKTogbnVtYmVyfSBOZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyIEFycmF5IGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfE5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gZGlyZWN0aW9uXG4gKiAgICAwIG1lYW5zIHJldHVybiB0aGUgbmVhcmVzdCxcbiAqICAgID4gMCBtZWFucyByZXR1cm4gdGhlIGxhcmdlc3QgbmVhcmVzdCxcbiAqICAgIDwgMCBtZWFucyByZXR1cm4gdGhlIHNtYWxsZXN0IG5lYXJlc3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyRmluZE5lYXJlc3QoYXJyLCB0YXJnZXQsIGRpcmVjdGlvbikge1xuICBpZiAoYXJyWzBdIDw9IHRhcmdldCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgbiA9IGFyci5sZW5ndGg7XG4gIGlmICh0YXJnZXQgPD0gYXJyW24gLSAxXSkge1xuICAgIHJldHVybiBuIC0gMTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGlyZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGFycltpXTtcbiAgICAgIGlmIChjYW5kaWRhdGUgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUgPCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbih0YXJnZXQsIGFycltpIC0gMV0sIGNhbmRpZGF0ZSkgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbiAtIDE7XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoYXJyW2ldIDwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG5cbiAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGFycltpXSA8PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuIC0gMTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBpZiAoYXJyW2ldIDwgdGFyZ2V0KSB7XG4gICAgICBpZiAoYXJyW2kgLSAxXSAtIHRhcmdldCA8IHRhcmdldCAtIGFycltpXSkge1xuICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4gLSAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyciBBcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbiBCZWdpbiBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVN1YkFycmF5KGFyciwgYmVnaW4sIGVuZCkge1xuICB3aGlsZSAoYmVnaW4gPCBlbmQpIHtcbiAgICBjb25zdCB0bXAgPSBhcnJbYmVnaW5dO1xuICAgIGFycltiZWdpbl0gPSBhcnJbZW5kXTtcbiAgICBhcnJbZW5kXSA9IHRtcDtcbiAgICArK2JlZ2luO1xuICAgIC0tZW5kO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHshQXJyYXk8VkFMVUU+fFZBTFVFfSBkYXRhIFRoZSBlbGVtZW50cyBvciBhcnJheXMgb2YgZWxlbWVudHMgdG8gYWRkIHRvIGFyci5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGFyciwgZGF0YSkge1xuICBjb25zdCBleHRlbnNpb24gPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcbiAgY29uc3QgbGVuZ3RoID0gZXh0ZW5zaW9uLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFyclthcnIubGVuZ3RoXSA9IGV4dGVuc2lvbltpXTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7VkFMVUV9IG9iaiBUaGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGFyciwgb2JqKSB7XG4gIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihvYmopO1xuICBjb25zdCBmb3VuZCA9IGkgPiAtMTtcbiAgaWYgKGZvdW5kKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIxIFRoZSBmaXJzdCBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheTxhbnk+fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGFycjEsIGFycjIpIHtcbiAgY29uc3QgbGVuMSA9IGFycjEubGVuZ3RoO1xuICBpZiAobGVuMSAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBwYXNzZWQgYXJyYXkgc3VjaCB0aGF0IHRoZSByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBlbGVtZW50cyBpcyBwcmVzZXJ2ZWQuXG4gKiBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29ydGluZ19hbGdvcml0aG0jU3RhYmlsaXR5IGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIFRoZSBhcnJheSB0byBzb3J0IChtb2RpZmllcyBvcmlnaW5hbCkuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigqLCAqKTogbnVtYmVyfSBjb21wYXJlRm5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZUZuYykge1xuICBjb25zdCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICBjb25zdCB0bXAgPSBBcnJheShhcnIubGVuZ3RoKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRtcFtpXSA9IHtpbmRleDogaSwgdmFsdWU6IGFycltpXX07XG4gIH1cbiAgdG1wLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZUZuYyhhLnZhbHVlLCBiLnZhbHVlKSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgfSk7XG4gIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaV0gPSB0bXBbaV0udmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHRlc3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZnVuY10gQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmljdF0gU3RyaWN0bHkgc29ydGVkIChkZWZhdWx0IGZhbHNlKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU29ydGVkKGFyciwgZnVuYywgc3RyaWN0KSB7XG4gIGNvbnN0IGNvbXBhcmUgPSBmdW5jIHx8IGFzY2VuZGluZztcbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbiAoY3VycmVudFZhbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBjb21wYXJlKGFycltpbmRleCAtIDFdLCBjdXJyZW50VmFsKTtcbiAgICByZXR1cm4gIShyZXMgPiAwIHx8IChzdHJpY3QgJiYgcmVzID09PSAwKSk7XG4gIH0pO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9mdW5jdGlvbnNcbiAqL1xuXG5pbXBvcnQge2VxdWFscyBhcyBhcnJheUVxdWFsc30gZnJvbSAnLi9hcnJheS5qcyc7XG5cbi8qKlxuICogQWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUUlVFKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJucyBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRkFMU0UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHJldXNhYmxlIGZ1bmN0aW9uLCB1c2VkIGUuZy4gYXMgYSBkZWZhdWx0IGZvciBjYWxsYmFja3MuXG4gKlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZPSUQoKSB7fVxuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBpbiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgcmVtZW1iZXJzIHRoZSBsYXN0IHJldHVybi4gIElmIHRoZVxuICogcmV0dXJuZWQgZnVuY3Rpb24gaXMgY2FsbGVkIHR3aWNlIGluIGEgcm93IHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCB0aGUgc2FtZVxuICogdGhpcyBvYmplY3QsIGl0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBjYWxsIGluIHRoZSBzZWNvbmQgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueSk6IFJldHVyblR5cGV9IGZuIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplLlxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uYW55KTogUmV0dXJuVHlwZX0gVGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFJldHVyblR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemVPbmUoZm4pIHtcbiAgLyoqIEB0eXBlIHtSZXR1cm5UeXBlfSAqL1xuICBsZXQgbGFzdFJlc3VsdDtcblxuICAvKiogQHR5cGUge0FycmF5PGFueT58dW5kZWZpbmVkfSAqL1xuICBsZXQgbGFzdEFyZ3M7XG5cbiAgbGV0IGxhc3RUaGlzO1xuXG4gIC8qKlxuICAgKiBAdGhpcyB7Kn0gT25seSBuZWVkIHRvIGtub3cgaWYgYHRoaXNgIGNoYW5nZWQsIGRvbid0IGNhcmUgd2hhdCB0eXBlXG4gICAqIEByZXR1cm4ge1JldHVyblR5cGV9IE1lbW9pemVkIHZhbHVlXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG5leHRBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoIWxhc3RBcmdzIHx8IHRoaXMgIT09IGxhc3RUaGlzIHx8ICFhcnJheUVxdWFscyhuZXh0QXJncywgbGFzdEFyZ3MpKSB7XG4gICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICBsYXN0QXJncyA9IG5leHRBcmdzO1xuICAgICAgbGFzdFJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IChUIHwgUHJvbWlzZTxUPil9IGdldHRlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlIG9yIGEgcHJvbWlzZSBmb3IgYSB2YWx1ZS5cbiAqIEByZXR1cm4ge1Byb21pc2U8VD59IEEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9taXNlKGdldHRlcikge1xuICBmdW5jdGlvbiBwcm9taXNlR2V0dGVyKCkge1xuICAgIGxldCB2YWx1ZTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9taXNlR2V0dGVyKCk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL29ialxuICovXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgdW5rbm93bj59IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIob2JqZWN0KSB7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhbnkgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBvYmplY3QgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuICBsZXQgcHJvcGVydHk7XG4gIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhcHJvcGVydHk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9UYXJnZXRcbiAqL1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9FdmVudC5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFdmVudFRhcmdldHxUYXJnZXR9IEV2ZW50VGFyZ2V0TGlrZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnRUYXJnZXQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1FdmVudHMtMjAwMDExMTMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gaW1wb3J0YW50IHNpbXBsaWZpY2F0aW9ucyBjb21wYXJlZCB0byB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqXG4gKiAxLiBUaGUgaGFuZGxpbmcgb2YgYHVzZUNhcHR1cmVgIGluIGBhZGRFdmVudExpc3RlbmVyYCBhbmRcbiAqICAgIGByZW1vdmVFdmVudExpc3RlbmVyYC4gVGhlcmUgaXMgbm8gcmVhbCBjYXB0dXJlIG1vZGVsLlxuICogMi4gVGhlIGhhbmRsaW5nIG9mIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG9uIGBkaXNwYXRjaEV2ZW50YC5cbiAqICAgIFRoZXJlIGlzIG5vIGV2ZW50IHRhcmdldCBoaWVyYXJjaHkuIFdoZW4gYSBsaXN0ZW5lciBjYWxsc1xuICogICAgYHN0b3BQcm9wYWdhdGlvbmAgb3IgYHByZXZlbnREZWZhdWx0YCBvbiBhbiBldmVudCBvYmplY3QsIGl0IG1lYW5zIHRoYXQgbm9cbiAqICAgIG1vcmUgbGlzdGVuZXJzIGFmdGVyIHRoaXMgb25lIHdpbGwgYmUgY2FsbGVkLiBTYW1lIGFzIHdoZW4gdGhlIGxpc3RlbmVyXG4gKiAgICByZXR1cm5zIGZhbHNlLlxuICovXG5jbGFzcyBUYXJnZXQgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gW3RhcmdldF0gRGVmYXVsdCBldmVudCB0YXJnZXQgZm9yIGRpc3BhdGNoZWQgZXZlbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy5ldmVudFRhcmdldF8gPSB0YXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3BhdGNoaW5nXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXI+PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJzXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXJ9IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdHlwZSB8fCAhbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfIHx8ICh0aGlzLmxpc3RlbmVyc18gPSB7fSk7XG4gICAgY29uc3QgbGlzdGVuZXJzRm9yVHlwZSA9IGxpc3RlbmVyc1t0eXBlXSB8fCAobGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICAgIGlmICghbGlzdGVuZXJzRm9yVHlwZS5pbmNsdWRlcyhsaXN0ZW5lcikpIHtcbiAgICAgIGxpc3RlbmVyc0ZvclR5cGUucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIGNhbGxzIGFsbCBsaXN0ZW5lcnMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICogb2YgdGhpcyB0eXBlLiBUaGUgZXZlbnQgcGFyYW1ldGVyIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYW5cbiAgICogT2JqZWN0IHdpdGggYSBgdHlwZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fHN0cmluZ30gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gYGZhbHNlYCBpZiBhbnlvbmUgY2FsbGVkIHByZXZlbnREZWZhdWx0IG9uIHRoZVxuICAgKiAgICAgZXZlbnQgb2JqZWN0IG9yIGlmIGFueSBvZiB0aGUgbGlzdGVuZXJzIHJldHVybmVkIGZhbHNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0cmluZyA/IGV2ZW50IDogZXZlbnQudHlwZTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc18gJiYgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXZ0ID0gaXNTdHJpbmcgPyBuZXcgRXZlbnQoZXZlbnQpIDogLyoqIEB0eXBlIHtFdmVudH0gKi8gKGV2ZW50KTtcbiAgICBpZiAoIWV2dC50YXJnZXQpIHtcbiAgICAgIGV2dC50YXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0XyB8fCB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBkaXNwYXRjaGluZyA9IHRoaXMuZGlzcGF0Y2hpbmdfIHx8ICh0aGlzLmRpc3BhdGNoaW5nXyA9IHt9KTtcbiAgICBjb25zdCBwZW5kaW5nUmVtb3ZhbHMgPVxuICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfIHx8ICh0aGlzLnBlbmRpbmdSZW1vdmFsc18gPSB7fSk7XG4gICAgaWYgKCEodHlwZSBpbiBkaXNwYXRjaGluZykpIHtcbiAgICAgIGRpc3BhdGNoaW5nW3R5cGVdID0gMDtcbiAgICAgIHBlbmRpbmdSZW1vdmFsc1t0eXBlXSA9IDA7XG4gICAgfVxuICAgICsrZGlzcGF0Y2hpbmdbdHlwZV07XG4gICAgbGV0IHByb3BhZ2F0ZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKCdoYW5kbGVFdmVudCcgaW4gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyT2JqZWN0fSAqLyAoXG4gICAgICAgICAgbGlzdGVuZXJzW2ldXG4gICAgICAgICkuaGFuZGxlRXZlbnQoZXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb259ICovIChcbiAgICAgICAgICBsaXN0ZW5lcnNbaV1cbiAgICAgICAgKS5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcGFnYXRlID09PSBmYWxzZSB8fCBldnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgIHByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKC0tZGlzcGF0Y2hpbmdbdHlwZV0gPT09IDApIHtcbiAgICAgIGxldCBwciA9IHBlbmRpbmdSZW1vdmFsc1t0eXBlXTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVtb3ZhbHNbdHlwZV07XG4gICAgICB3aGlsZSAocHItLSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgVk9JRCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgZGlzcGF0Y2hpbmdbdHlwZV07XG4gICAgfVxuICAgIHJldHVybiBwcm9wYWdhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMubGlzdGVuZXJzXyAmJiBjbGVhcih0aGlzLmxpc3RlbmVyc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLiBMaXN0ZW5lcnMgYXJlIHJldHVybmVkIGluIHRoZVxuICAgKiBvcmRlciB0aGF0IHRoZXkgd2lsbCBiZSBjYWxsZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lcj58dW5kZWZpbmVkfSBMaXN0ZW5lcnMuXG4gICAqL1xuICBnZXRMaXN0ZW5lcnModHlwZSkge1xuICAgIHJldHVybiAodGhpcy5saXN0ZW5lcnNfICYmIHRoaXMubGlzdGVuZXJzX1t0eXBlXSkgfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVHlwZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgYHRydWVgIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhpcyBldmVudCB0YXJnZXQgaGFzIGFueSBsaXN0ZW5lcnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEhhcyBsaXN0ZW5lcnMuXG4gICAqL1xuICBoYXNMaXN0ZW5lcih0eXBlKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc18pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVcbiAgICAgID8gdHlwZSBpbiB0aGlzLmxpc3RlbmVyc19cbiAgICAgIDogT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnNfKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ1JlbW92YWxzXyAmJiB0eXBlIGluIHRoaXMucGVuZGluZ1JlbW92YWxzXykge1xuICAgICAgICAvLyBtYWtlIGxpc3RlbmVyIGEgbm8tb3AsIGFuZCByZW1vdmUgbGF0ZXIgaW4gI2Rpc3BhdGNoRXZlbnQoKVxuICAgICAgICBsaXN0ZW5lcnNbaW5kZXhdID0gVk9JRDtcbiAgICAgICAgKyt0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRhcmdldDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBHZW5lcmljIGNoYW5nZSBldmVudC4gVHJpZ2dlcmVkIHdoZW4gdGhlIHJldmlzaW9uIGNvdW50ZXIgaXMgaW5jcmVhc2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5CYXNlRXZlbnQjY2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIENIQU5HRTogJ2NoYW5nZScsXG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgZXJyb3IgZXZlbnQuIFRyaWdnZXJlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+QmFzZUV2ZW50I2Vycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIEVSUk9SOiAnZXJyb3InLFxuXG4gIEJMVVI6ICdibHVyJyxcbiAgQ0xFQVI6ICdjbGVhcicsXG4gIENPTlRFWFRNRU5VOiAnY29udGV4dG1lbnUnLFxuICBDTElDSzogJ2NsaWNrJyxcbiAgREJMQ0xJQ0s6ICdkYmxjbGljaycsXG4gIERSQUdFTlRFUjogJ2RyYWdlbnRlcicsXG4gIERSQUdPVkVSOiAnZHJhZ292ZXInLFxuICBEUk9QOiAnZHJvcCcsXG4gIEZPQ1VTOiAnZm9jdXMnLFxuICBLRVlET1dOOiAna2V5ZG93bicsXG4gIEtFWVBSRVNTOiAna2V5cHJlc3MnLFxuICBMT0FEOiAnbG9hZCcsXG4gIFJFU0laRTogJ3Jlc2l6ZScsXG4gIFRPVUNITU9WRTogJ3RvdWNobW92ZScsXG4gIFdIRUVMOiAnd2hlZWwnLFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzXG4gKi9cbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4vb2JqLmpzJztcblxuLyoqXG4gKiBLZXkgdG8gdXNlIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlLnVuQnlLZXl9LlxuICogQHR5cGVkZWYge09iamVjdH0gRXZlbnRzS2V5XG4gKiBAcHJvcGVydHkge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGFyZ2V0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIExpc3RlbmVyIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFuIGV2ZW50IG9iamVjdCBhcyBhcmd1bWVudC5cbiAqIFdoZW4gdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgZXZlbnQgcHJvcGFnYXRpb24gd2lsbCBzdG9wLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCkpOiAodm9pZHxib29sZWFuKX0gTGlzdGVuZXJGdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTGlzdGVuZXJPYmplY3RcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJGdW5jdGlvbn0gaGFuZGxlRXZlbnQgSGFuZGxlRXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7TGlzdGVuZXJGdW5jdGlvbnxMaXN0ZW5lck9iamVjdH0gTGlzdGVuZXJcbiAqL1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGVmZmljaWVudGx5IGJpbmRzIGEgYGxpc3RlbmVyYCB0byBhIGB0aGlzYCBvYmplY3QsIGFuZCByZXR1cm5zXG4gKiBhIGtleSBmb3IgdXNlIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMudW5saXN0ZW5CeUtleX0uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW3RoaXNBcmddIE9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBgdGhpc2Aga2V5d29yZCBpbiB0aGVcbiAqICAgICBsaXN0ZW5lci4gRGVmYXVsdCBpcyB0aGUgYHRhcmdldGAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlXSBJZiB0cnVlLCBhZGQgdGhlIGxpc3RlbmVyIGFzIG9uZS1vZmYgbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHtFdmVudHNLZXl9IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB0aGlzQXJnLCBvbmNlKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIC8qKlxuICAgICAqIEB0aGlzIHt0eXBlb2YgdGFyZ2V0fVxuICAgICAqL1xuICAgIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgb3JpZ2luYWxMaXN0ZW5lci5hcHBseSh0aGlzQXJnID8/IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0aGlzQXJnICYmIHRoaXNBcmcgIT09IHRhcmdldCkge1xuICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuYmluZCh0aGlzQXJnKTtcbiAgfVxuICBjb25zdCBldmVudHNLZXkgPSB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gIH07XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIGV2ZW50c0tleTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBvbmUtb2ZmIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIGFzIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lclxuICogdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJucyBhIGtleSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzLnVubGlzdGVuQnlLZXl9IGluIGNhc2UgdGhlIGxpc3RlbmVyIG5lZWRzIHRvIGJlXG4gKiB1bnJlZ2lzdGVyZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBXaGVuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzLmxpc3Rlbn0gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFmdGVyIHRoaXNcbiAqIGZ1bmN0aW9uLCB0aGUgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyIHdpbGwgYmUgdHVybmVkIGludG8gYSBwZXJtYW5lbnRcbiAqIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IEV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IFt0aGlzQXJnXSBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHJldHVybiB7RXZlbnRzS2V5fSBLZXkgZm9yIHVubGlzdGVuQnlLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5PbmNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB0aGlzQXJnLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBrZXkgcmV0dXJuZWQgZnJvbVxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMubGlzdGVufSBvciB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy5saXN0ZW5PbmNlfS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50c0tleX0ga2V5IFRoZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkJ5S2V5KGtleSkge1xuICBpZiAoa2V5ICYmIGtleS50YXJnZXQpIHtcbiAgICBrZXkudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LnR5cGUsIGtleS5saXN0ZW5lcik7XG4gICAgY2xlYXIoa2V5KTtcbiAgfVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9PYnNlcnZhYmxlXG4gKi9cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIGxpc3Rlbk9uY2UsIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcblxuLyoqKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFR5cGVcbiAqIEB0ZW1wbGF0ZSB7RXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gRXZlbnRDbGFzc1xuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYgeyh0eXBlOiBUeXBlLCBsaXN0ZW5lcjogKGV2ZW50OiBFdmVudENsYXNzKSA9PiA/KSA9PiBSZXR1cm59IE9uU2lnbmF0dXJlXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFR5cGVcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHsodHlwZTogVHlwZVtdLCBsaXN0ZW5lcjogKGV2ZW50OiBFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSA9PiA/KSA9PiBSZXR1cm4gZXh0ZW5kcyB2b2lkID8gdm9pZCA6IFJldHVybltdfSBDb21iaW5lZE9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2NoYW5nZSd8J2Vycm9yJ30gRXZlbnRUeXBlc1xuICovXG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtPblNpZ25hdHVyZTxFdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICYgQ29tYmluZWRPblNpZ25hdHVyZTxFdmVudFR5cGVzLCBSZXR1cm4+fSBPYnNlcnZhYmxlT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEFuIGV2ZW50IHRhcmdldCBwcm92aWRpbmcgY29udmVuaWVudCBtZXRob2RzIGZvciBsaXN0ZW5lciByZWdpc3RyYXRpb25cbiAqIGFuZCB1bnJlZ2lzdHJhdGlvbi4gQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIGFsd2F5cyBhdmFpbGFibGUgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfk9ic2VydmFibGUjY2hhbmdlZH0uXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub24gPVxuICAgICAgLyoqIEB0eXBlIHtPYnNlcnZhYmxlT25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn0gKi8gKFxuICAgICAgICB0aGlzLm9uSW50ZXJuYWxcbiAgICAgICk7XG5cbiAgICB0aGlzLm9uY2UgPVxuICAgICAgLyoqIEB0eXBlIHtPYnNlcnZhYmxlT25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn0gKi8gKFxuICAgICAgICB0aGlzLm9uY2VJbnRlcm5hbFxuICAgICAgKTtcblxuICAgIHRoaXMudW4gPSAvKiogQHR5cGUge09ic2VydmFibGVPblNpZ25hdHVyZTx2b2lkPn0gKi8gKHRoaXMudW5JbnRlcm5hbCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXZpc2lvbl8gPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlcyB0aGUgcmV2aXNpb24gY291bnRlciBhbmQgZGlzcGF0Y2hlcyBhICdjaGFuZ2UnIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBjaGFuZ2VkKCkge1xuICAgICsrdGhpcy5yZXZpc2lvbl87XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50VHlwZS5DSEFOR0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmVyc2lvbiBudW1iZXIgZm9yIHRoaXMgb2JqZWN0LiAgRWFjaCB0aW1lIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsXG4gICAqIGl0cyB2ZXJzaW9uIG51bWJlciB3aWxsIGJlIGluY3JlbWVudGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJldmlzaW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXZpc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZpc2lvbl87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSk6ID99IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gRXZlbnQga2V5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBvbkludGVybmFsKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGNvbnN0IGxlbiA9IHR5cGUubGVuZ3RoO1xuICAgICAgY29uc3Qga2V5cyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXlzW2ldID0gbGlzdGVuKHRoaXMsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpKTogP30gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBFdmVudCBrZXkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG9uY2VJbnRlcm5hbCh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGxldCBrZXk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGNvbnN0IGxlbiA9IHR5cGUubGVuZ3RoO1xuICAgICAga2V5ID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleVtpXSA9IGxpc3Rlbk9uY2UodGhpcywgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBsaXN0ZW5PbmNlKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtPYmplY3R9ICovIChsaXN0ZW5lcikub2xfa2V5ID0ga2V5O1xuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICAvKipcbiAgICogVW5saXN0ZW4gZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpKTogP30gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHVuSW50ZXJuYWwodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBrZXkgPSAvKiogQHR5cGUge09iamVjdH0gKi8gKGxpc3RlbmVyKS5vbF9rZXk7XG4gICAgaWYgKGtleSkge1xuICAgICAgdW5CeUtleShrZXkpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdHlwZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpKTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci4gSWZcbiAqICAgICBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCB0eXBlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSByZXR1cm5cbiAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gKiBAYXBpXG4gKi9cbk9ic2VydmFibGUucHJvdG90eXBlLm9uO1xuXG4vKipcbiAqIExpc3RlbiBvbmNlIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpKTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci4gSWZcbiAqICAgICBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCB0eXBlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSByZXR1cm5cbiAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gKiBAYXBpXG4gKi9cbk9ic2VydmFibGUucHJvdG90eXBlLm9uY2U7XG5cbi8qKlxuICogVW5saXN0ZW4gZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cbk9ic2VydmFibGUucHJvdG90eXBlLnVuO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgdXNpbmcgdGhlIGtleSByZXR1cm5lZCBieSBgb24oKWAgb3IgYG9uY2UoKWAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBrZXkgVGhlIGtleSByZXR1cm5lZCBieSBgb24oKWBcbiAqICAgICBvciBgb25jZSgpYCAob3IgYW4gYXJyYXkgb2Yga2V5cykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bkJ5S2V5KGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0ga2V5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkoa2V5W2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdW5saXN0ZW5CeUtleSgvKiogQHR5cGUge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX0gKi8gKGtleSkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9ic2VydmFibGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3V0aWxcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge25ldmVyfSBBbnkgcmV0dXJuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QuJyk7XG59XG5cbi8qKlxuICogQ291bnRlciBmb3IgZ2V0VWlkLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB1aWRDb3VudGVyXyA9IDA7XG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFVuaXF1ZSBJRHMgYXJlIGdlbmVyYXRlZFxuICogYXMgYSBzdHJpY3RseSBpbmNyZWFzaW5nIHNlcXVlbmNlLiBBZGFwdGVkIGZyb20gZ29vZy5nZXRVaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVpZChvYmopIHtcbiAgcmV0dXJuIG9iai5vbF91aWQgfHwgKG9iai5vbF91aWQgPSBTdHJpbmcoKyt1aWRDb3VudGVyXykpO1xufVxuXG4vKipcbiAqIE9wZW5MYXllcnMgdmVyc2lvbi5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzEwLjIuMSc7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL09iamVjdFxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuL09ic2VydmFibGUuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4vb2JqLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgZm9yIGBrZXlgLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwga2V5LCBvbGRWYWx1ZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIGNoYW5naW5nLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0ga2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9sZCB2YWx1ZS4gVG8gZ2V0IHRoZSBuZXcgdmFsdWUgdXNlIGBlLnRhcmdldC5nZXQoZS5rZXkpYCB3aGVyZVxuICAgICAqIGBlYCBpcyB0aGUgZXZlbnQgb2JqZWN0LlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gIH1cbn1cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXMsIE9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzLCBSZXR1cm4+fSBPYmplY3RPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTW9zdCBub24tdHJpdmlhbCBjbGFzc2VzIGluaGVyaXQgZnJvbSB0aGlzLlxuICpcbiAqIFRoaXMgZXh0ZW5kcyB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZX0gd2l0aCBvYnNlcnZhYmxlXG4gKiBwcm9wZXJ0aWVzLCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIG9ic2VydmFibGUgYXMgd2VsbCBhcyB0aGUgb2JqZWN0IGFzIGFcbiAqIHdob2xlLlxuICpcbiAqIENsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyBoYXZlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMsIHRvIHdoaWNoIHlvdSBjYW5cbiAqIGFkZCB5b3VyIG93bnMuIFRoZSBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzIGFyZSBsaXN0ZWQgaW4gdGhpcyBkb2N1bWVudGF0aW9uIGFzXG4gKiAnT2JzZXJ2YWJsZSBQcm9wZXJ0aWVzJywgYW5kIGhhdmUgdGhlaXIgb3duIGFjY2Vzc29yczsgZm9yIGV4YW1wbGUsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGhhcyBhIGB0YXJnZXRgIHByb3BlcnR5LCBhY2Nlc3NlZCB3aXRoXG4gKiBgZ2V0VGFyZ2V0KClgIGFuZCBjaGFuZ2VkIHdpdGggYHNldFRhcmdldCgpYC4gTm90IGFsbCBwcm9wZXJ0aWVzIGFyZSBob3dldmVyXG4gKiBzZXR0YWJsZS4gVGhlcmUgYXJlIGFsc28gZ2VuZXJhbC1wdXJwb3NlIGFjY2Vzc29ycyBgZ2V0KClgIGFuZCBgc2V0KClgLiBGb3JcbiAqIGV4YW1wbGUsIGBnZXQoJ3RhcmdldCcpYCBpcyBlcXVpdmFsZW50IHRvIGBnZXRUYXJnZXQoKWAuXG4gKlxuICogVGhlIGBzZXRgIGFjY2Vzc29ycyB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCBhbmQgeW91IGNhbiBtb25pdG9yIHRoaXMgYnlcbiAqIHJlZ2lzdGVyaW5nIGEgbGlzdGVuZXIuIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL1ZpZXd+Vmlld30gaGFzIGFcbiAqIGBjZW50ZXJgIHByb3BlcnR5LCBzbyBgdmlldy5vbignY2hhbmdlOmNlbnRlcicsIGZ1bmN0aW9uKGV2dCkgey4uLn0pO2Agd291bGRcbiAqIGNhbGwgdGhlIGZ1bmN0aW9uIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgY2VudGVyIHByb3BlcnR5IGNoYW5nZXMuIFdpdGhpblxuICogdGhlIGZ1bmN0aW9uLCBgZXZ0LnRhcmdldGAgd291bGQgYmUgdGhlIHZpZXcsIHNvIGBldnQudGFyZ2V0LmdldENlbnRlcigpYFxuICogd291bGQgcmV0dXJuIHRoZSBuZXcgY2VudGVyLlxuICpcbiAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG9ic2VydmFibGUgcHJvcGVydGllcyB3aXRoXG4gKiBgb2JqZWN0LnNldCgncHJvcCcsICd2YWx1ZScpYCwgYW5kIHJldHJpZXZlIHRoYXQgd2l0aCBgb2JqZWN0LmdldCgncHJvcCcpYC5cbiAqIFlvdSBjYW4gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoYXQgcHJvcGVydHkgdmFsdWUgd2l0aFxuICogYG9iamVjdC5vbignY2hhbmdlOnByb3AnLCBsaXN0ZW5lcilgLiBZb3UgY2FuIGdldCBhIGxpc3Qgb2YgYWxsXG4gKiBwcm9wZXJ0aWVzIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdCNnZXRQcm9wZXJ0aWVzfS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG9ic2VydmFibGUgcHJvcGVydGllcyBhcmUgc2VwYXJhdGUgZnJvbSBzdGFuZGFyZCBKUyBwcm9wZXJ0aWVzLlxuICogWW91IGNhbiwgZm9yIGV4YW1wbGUsIGdpdmUgeW91ciBtYXAgb2JqZWN0IGEgdGl0bGUgd2l0aFxuICogYG1hcC50aXRsZT0nTmV3IHRpdGxlJ2AgYW5kIHdpdGggYG1hcC5zZXQoJ3RpdGxlJywgJ0Fub3RoZXIgdGl0bGUnKWAuIFRoZVxuICogZmlyc3Qgd2lsbCBiZSBhIGBoYXNPd25Qcm9wZXJ0eWA7IHRoZSBzZWNvbmQgd2lsbCBhcHBlYXIgaW5cbiAqIGBnZXRQcm9wZXJ0aWVzKClgLiBPbmx5IHRoZSBzZWNvbmQgaXMgb2JzZXJ2YWJsZS5cbiAqXG4gKiBQcm9wZXJ0aWVzIGNhbiBiZSBkZWxldGVkIGJ5IHVzaW5nIHRoZSB1bnNldCBtZXRob2QuIEUuZy5cbiAqIG9iamVjdC51bnNldCgnZm9vJykuXG4gKlxuICogQGZpcmVzIE9iamVjdEV2ZW50XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEJhc2VPYmplY3QgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj59IFt2YWx1ZXNdIEFuIG9iamVjdCB3aXRoIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge09iamVjdE9uU2lnbmF0dXJlPGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0T25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge09iamVjdE9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvLyBDYWxsIHtAbGluayBtb2R1bGU6b2wvdXRpbC5nZXRVaWR9IHRvIGVuc3VyZSB0aGF0IHRoZSBvcmRlciBvZiBvYmplY3RzJyBpZHMgaXNcbiAgICAvLyB0aGUgc2FtZSBhcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGNyZWF0ZWQuICBUaGlzIGFsc28gaGVscHMgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBvYmplY3QgcHJvcGVydGllcyBhcmUgYWx3YXlzIGFkZGVkIGluIHRoZSBzYW1lIG9yZGVyLCB3aGljaFxuICAgIC8vIGhlbHBzIG1hbnkgSmF2YVNjcmlwdCBlbmdpbmVzIGdlbmVyYXRlIGZhc3RlciBjb2RlLlxuICAgIGdldFVpZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNfID0gbnVsbDtcblxuICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHJldHVybiB7Kn0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiB0aGlzLnZhbHVlc18uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2Ygb2JqZWN0IHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBMaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiAodGhpcy52YWx1ZXNfICYmIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzXykpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3Qgb2YgYWxsIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsICo+fSBPYmplY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnZhbHVlc18gJiYgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZXNfKSkgfHwge307XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy5cbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgKj4/fSBPYmplY3QuXG4gICAqL1xuICBnZXRQcm9wZXJ0aWVzSW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGhhcyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgaGFzUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gISF0aGlzLnZhbHVlc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBPbGQgdmFsdWUuXG4gICAqL1xuICBub3RpZnkoa2V5LCBvbGRWYWx1ZSkge1xuICAgIGxldCBldmVudFR5cGU7XG4gICAgZXZlbnRUeXBlID0gYGNoYW5nZToke2tleX1gO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gICAgfVxuICAgIGV2ZW50VHlwZSA9IE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcihldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE9iamVjdEV2ZW50KGV2ZW50VHlwZSwga2V5LCBvbGRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIGFkZENoYW5nZUxpc3RlbmVyKGtleSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYGNoYW5nZToke2tleX1gLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5MaXN0ZW5lcn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcihrZXksIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGBjaGFuZ2U6JHtrZXl9YCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSk7XG4gICAgaWYgKHNpbGVudCkge1xuICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY29sbGVjdGlvbiBvZiBrZXktdmFsdWUgcGFpcnMuICBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIGFueSBleGlzdGluZ1xuICAgKiBwcm9wZXJ0aWVzIGFuZCBhZGRzIG5ldyBvbmVzIChpdCBkb2VzIG5vdCByZW1vdmUgYW55IGV4aXN0aW5nIHByb3BlcnRpZXMpLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnRdIFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFByb3BlcnRpZXModmFsdWVzLCBzaWxlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWVzW2tleV0sIHNpbGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGFueSBwcm9wZXJ0aWVzIGZyb20gYW5vdGhlciBvYmplY3Qgd2l0aG91dCB0cmlnZ2VyaW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIHtCYXNlT2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGFwcGx5UHJvcGVydGllcyhzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZS52YWx1ZXNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSksIHNvdXJjZS52YWx1ZXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNldHMgYSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVbnNldCB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHVuc2V0KGtleSwgc2lsZW50KSB7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiBrZXkgaW4gdGhpcy52YWx1ZXNfKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgZGVsZXRlIHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgaWYgKGlzRW1wdHkodGhpcy52YWx1ZXNfKSkge1xuICAgICAgICB0aGlzLnZhbHVlc18gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0NvbGxlY3Rpb25FdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBldmVudCBtb2R1bGU6b2wvQ29sbGVjdGlvbi5Db2xsZWN0aW9uRXZlbnQjYWRkXG4gICAqIEBhcGlcbiAgICovXG4gIEFERDogJ2FkZCcsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBpdGVtIGlzIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9Db2xsZWN0aW9uLkNvbGxlY3Rpb25FdmVudCNyZW1vdmVcbiAgICogQGFwaVxuICAgKi9cbiAgUkVNT1ZFOiAncmVtb3ZlJyxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0NvbGxlY3Rpb25cbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFByb3BlcnR5ID0ge1xuICBMRU5HVEg6ICdsZW5ndGgnLFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHlwZS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBhZGRlZCBvciByZW1vdmVkIGVsZW1lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBlbGVtZW50LCBpbmRleCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCBpcyBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHR5cGUge1R9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGFkZGVkIG9yIHJlbW92ZWQgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cblxuLyoqKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8J2NoYW5nZTpsZW5ndGgnLCBpbXBvcnQoXCIuL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTwnYWRkJ3wncmVtb3ZlJywgQ29sbGVjdGlvbkV2ZW50PFQ+LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTpsZW5ndGgnfCdhZGQnfCdyZW1vdmUnLFJldHVybj59IENvbGxlY3Rpb25PblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbdW5pcXVlPWZhbHNlXSBEaXNhbGxvdyB0aGUgc2FtZSBpdGVtIGZyb20gYmVpbmcgYWRkZWQgdG9cbiAqIHRoZSBjb2xsZWN0aW9uIHR3aWNlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQW4gZXhwYW5kZWQgdmVyc2lvbiBvZiBzdGFuZGFyZCBKUyBBcnJheSwgYWRkaW5nIGNvbnZlbmllbmNlIG1ldGhvZHMgZm9yXG4gKiBtYW5pcHVsYXRpb24uIEFkZCBhbmQgcmVtb3ZlIGNoYW5nZXMgdG8gdGhlIENvbGxlY3Rpb24gdHJpZ2dlciBhIENvbGxlY3Rpb25cbiAqIGV2ZW50LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBjb3ZlciBjaGFuZ2VzIHRvIHRoZSBvYmplY3RzIF93aXRoaW5fIHRoZVxuICogQ29sbGVjdGlvbjsgdGhleSB0cmlnZ2VyIGV2ZW50cyBvbiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0LCBub3Qgb24gdGhlXG4gKiBDb2xsZWN0aW9uIGFzIGEgd2hvbGUuXG4gKlxuICogQGZpcmVzIENvbGxlY3Rpb25FdmVudFxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IFthcnJheV0gQXJyYXkuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIENvbGxlY3Rpb24gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFycmF5LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbk9uU2lnbmF0dXJlPFQsIGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbk9uU2lnbmF0dXJlPFQsIGltcG9ydChcIi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uT25TaWduYXR1cmU8VCwgdm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuaXF1ZV8gPSAhIW9wdGlvbnMudW5pcXVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PFQ+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyYXlfID0gYXJyYXkgPyBhcnJheSA6IFtdO1xuXG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0aGlzLmFzc2VydFVuaXF1ZV8odGhpcy5hcnJheV9baV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTGVuZ3RoXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgd2hpbGUgKHRoaXMuZ2V0TGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudHMgdG8gdGhlIGNvbGxlY3Rpb24uICBUaGlzIHB1c2hlcyBlYWNoIGl0ZW0gaW4gdGhlIHByb3ZpZGVkIGFycmF5XG4gICAqIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PFQ+fSBhcnIgQXJyYXkuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248VD59IFRoaXMgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZXh0ZW5kKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGFyci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0aGlzLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggZWxlbWVudCwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCwgbnVtYmVyLCBBcnJheTxUPik6ICp9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogICAgIGZvciBldmVyeSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uIHRha2VzIDMgYXJndW1lbnRzICh0aGUgZWxlbWVudCwgdGhlXG4gICAqICAgICBpbmRleCBhbmQgdGhlIGFycmF5KS4gVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoKGYpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuYXJyYXlfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGYoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5IG9iamVjdC4gV2FybmluZzogaWYgdGhlIGFycmF5XG4gICAqIGlzIG11dGF0ZWQsIG5vIGV2ZW50cyB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGNvbGxlY3Rpb24sIGFuZCB0aGVcbiAgICogY29sbGVjdGlvbidzIFwibGVuZ3RoXCIgcHJvcGVydHkgd29uJ3QgYmUgaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbGVuZ3RoXG4gICAqIG9mIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7IUFycmF5PFQ+fSBBcnJheS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7VH0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgaXRlbShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5X1tpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsZW5ndGggb2YgdGhpcyBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFByb3BlcnR5LkxFTkdUSCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGFuIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBpbnNlcnRBdChpbmRleCwgZWxlbSkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmdldExlbmd0aCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiBib3VuZHM6ICcgKyBpbmRleCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtKTtcbiAgICB9XG4gICAgdGhpcy5hcnJheV8uc3BsaWNlKGluZGV4LCAwLCBlbGVtKTtcbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuQURELCBlbGVtLCBpbmRleCksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiBhbmQgcmV0dXJuIGl0LlxuICAgKiBSZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBwb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQodGhpcy5nZXRMZW5ndGgoKSAtIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0aGUgcHJvdmlkZWQgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBOZXcgbGVuZ3RoIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBwdXNoKGVsZW0pIHtcbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICB0aGlzLmFzc2VydFVuaXF1ZV8oZWxlbSk7XG4gICAgfVxuICAgIGNvbnN0IG4gPSB0aGlzLmdldExlbmd0aCgpO1xuICAgIHRoaXMuaW5zZXJ0QXQobiwgZWxlbSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiBub25lIGZvdW5kLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmUoZWxlbSkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuYXJyYXlfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGFyci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAoYXJyW2ldID09PSBlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXggYW5kIHJldHVybiBpdC5cbiAgICogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSBjb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhpcyBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUF0KGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmdldExlbmd0aCgpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBwcmV2ID0gdGhpcy5hcnJheV9baW5kZXhdO1xuICAgIHRoaXMuYXJyYXlfLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uRXZlbnQ8VD59ICovIChcbiAgICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSwgcHJldiwgaW5kZXgpXG4gICAgICApLFxuICAgICk7XG4gICAgcmV0dXJuIHByZXY7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0QXQoaW5kZXgsIGVsZW0pIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICBpZiAoaW5kZXggPj0gbikge1xuICAgICAgdGhpcy5pbnNlcnRBdChpbmRleCwgZWxlbSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggb3V0IG9mIGJvdW5kczogJyArIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0sIGluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgcHJldiA9IHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgICB0aGlzLmFycmF5X1tpbmRleF0gPSBlbGVtO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbkV2ZW50PFQ+fSAqLyAoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHByZXYsIGluZGV4KVxuICAgICAgKSxcbiAgICApO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbkV2ZW50PFQ+fSAqLyAoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsIGVsZW0sIGluZGV4KVxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVMZW5ndGhfKCkge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkxFTkdUSCwgdGhpcy5hcnJheV8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtleGNlcHRdIE9wdGlvbmFsIGluZGV4IHRvIGlnbm9yZS5cbiAgICovXG4gIGFzc2VydFVuaXF1ZV8oZWxlbSwgZXhjZXB0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKHRoaXMuYXJyYXlfW2ldID09PSBlbGVtICYmIGkgIT09IGV4Y2VwdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSBpdGVtIGFkZGVkIHRvIGEgdW5pcXVlIGNvbGxlY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGVjdGlvbjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgT1BBQ0lUWTogJ29wYWNpdHknLFxuICBWSVNJQkxFOiAndmlzaWJsZScsXG4gIEVYVEVOVDogJ2V4dGVudCcsXG4gIFpfSU5ERVg6ICd6SW5kZXgnLFxuICBNQVhfUkVTT0xVVElPTjogJ21heFJlc29sdXRpb24nLFxuICBNSU5fUkVTT0xVVElPTjogJ21pblJlc29sdXRpb24nLFxuICBNQVhfWk9PTTogJ21heFpvb20nLFxuICBNSU5fWk9PTTogJ21pblpvb20nLFxuICBTT1VSQ0U6ICdzb3VyY2UnLFxuICBNQVA6ICdtYXAnLFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvYXNzZXJ0c1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBhc3NlcnRpb24gQXNzZXJ0aW9uIHdlIGV4cGVjdGVkIHRvIGJlIHRydXRoeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvck1lc3NhZ2UgRXJyb3IgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb24sIGVycm9yTWVzc2FnZSkge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL21hdGhcbiAqL1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCAoeCwgeSkgYW5kIHRoZVxuICogbGluZSBzZWdtZW50ICh4MSwgeTEpIHRvICh4MiwgeTIpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkU2VnbWVudERpc3RhbmNlKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICBjb25zdCB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoeCwgeSwgeDEsIHkxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBTb2x2ZXMgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgdXNpbmcgR2F1c3NpYW4gZWxpbWluYXRpb24gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdCBBdWdtZW50ZWQgbWF0cml4IChuIHggbiArIDEgY29sdW1uKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gcm93LW1ham9yIG9yZGVyLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBUaGUgcmVzdWx0aW5nIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvbHZlTGluZWFyU3lzdGVtKG1hdCkge1xuICBjb25zdCBuID0gbWF0Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIC8vIEZpbmQgbWF4IGluIHRoZSBpLXRoIGNvbHVtbiAoaWdub3JpbmcgaSAtIDEgZmlyc3Qgcm93cylcbiAgICBsZXQgbWF4Um93ID0gaTtcbiAgICBsZXQgbWF4RWwgPSBNYXRoLmFicyhtYXRbaV1baV0pO1xuICAgIGZvciAobGV0IHIgPSBpICsgMTsgciA8IG47IHIrKykge1xuICAgICAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhtYXRbcl1baV0pO1xuICAgICAgaWYgKGFic1ZhbHVlID4gbWF4RWwpIHtcbiAgICAgICAgbWF4RWwgPSBhYnNWYWx1ZTtcbiAgICAgICAgbWF4Um93ID0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4RWwgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBtYXRyaXggaXMgc2luZ3VsYXJcbiAgICB9XG5cbiAgICAvLyBTd2FwIG1heCByb3cgd2l0aCBpLXRoIChjdXJyZW50KSByb3dcbiAgICBjb25zdCB0bXAgPSBtYXRbbWF4Um93XTtcbiAgICBtYXRbbWF4Um93XSA9IG1hdFtpXTtcbiAgICBtYXRbaV0gPSB0bXA7XG5cbiAgICAvLyBTdWJ0cmFjdCB0aGUgaS10aCByb3cgdG8gbWFrZSBhbGwgdGhlIHJlbWFpbmluZyByb3dzIDAgaW4gdGhlIGktdGggY29sdW1uXG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICBjb25zdCBjb2VmID0gLW1hdFtqXVtpXSAvIG1hdFtpXVtpXTtcbiAgICAgIGZvciAobGV0IGsgPSBpOyBrIDwgbiArIDE7IGsrKykge1xuICAgICAgICBpZiAoaSA9PSBrKSB7XG4gICAgICAgICAgbWF0W2pdW2tdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRbal1ba10gKz0gY29lZiAqIG1hdFtpXVtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbHZlIEF4PWIgZm9yIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IEEgKG1hdClcbiAgY29uc3QgeCA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgbCA9IG4gLSAxOyBsID49IDA7IGwtLSkge1xuICAgIHhbbF0gPSBtYXRbbF1bbl0gLyBtYXRbbF1bbF07XG4gICAgZm9yIChsZXQgbSA9IGwgLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgbWF0W21dW25dIC09IG1hdFttXVtsXSAqIHhbbF07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHJhZGlhbnMgdG8gdG8gZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgQW5nbGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhhbmdsZUluUmFkaWFucykge1xuICByZXR1cm4gKGFuZ2xlSW5SYWRpYW5zICogMTgwKSAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluRGVncmVlcyBBbmdsZSBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiByYWRpYW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW5zKGFuZ2xlSW5EZWdyZWVzKSB7XG4gIHJldHVybiAoYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb2R1bG8gb2YgYSAvIGIsIGRlcGVuZGluZyBvbiB0aGUgc2lnbiBvZiBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIERpdmlkZW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgRGl2aXNvci5cbiAqIEByZXR1cm4ge251bWJlcn0gTW9kdWxvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxvKGEsIGIpIHtcbiAgY29uc3QgciA9IGEgJSBiO1xuICByZXR1cm4gciAqIGIgPCAwID8gciArIGIgOiByO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxpbmVhcmx5IGludGVycG9sYXRlZCB2YWx1ZSBvZiB4IGJldHdlZW4gYSBhbmQgYi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IHggVmFsdWUgdG8gYmUgaW50ZXJwb2xhdGVkLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKGEsIGIsIHgpIHtcbiAgcmV0dXJuIGEgKyB4ICogKGIgLSBhKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIHdpdGggYSBsaW1pdGVkIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5wdXQgbnVtYmVyIHdpdGggYSBsaW1pdGVkIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRml4ZWQobiwgZGVjaW1hbHMpIHtcbiAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQobiAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5cbi8qKlxuICogUm91bmRzIGEgbnVtYmVyIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgdmFsdWUgY29uc2lkZXJpbmcgb25seSB0aGUgZ2l2ZW4gbnVtYmVyXG4gKiBvZiBkZWNpbWFsIGRpZ2l0cyAod2l0aCByb3VuZGluZyBvbiB0aGUgZmluYWwgZGlnaXQpLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZWFyZXN0IGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChuLCBkZWNpbWFscykge1xuICByZXR1cm4gTWF0aC5yb3VuZCh0b0ZpeGVkKG4sIGRlY2ltYWxzKSk7XG59XG5cbi8qKlxuICogUm91bmRzIGEgbnVtYmVyIHRvIHRoZSBuZXh0IHNtYWxsZXIgaW50ZWdlciBjb25zaWRlcmluZyBvbmx5IHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGRlY2ltYWwgZGlnaXRzICh3aXRoIHJvdW5kaW5nIG9uIHRoZSBmaW5hbCBkaWdpdCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5leHQgc21hbGxlciBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3IobiwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodG9GaXhlZChuLCBkZWNpbWFscykpO1xufVxuXG4vKipcbiAqIFJvdW5kcyBhIG51bWJlciB0byB0aGUgbmV4dCBiaWdnZXIgaW50ZWdlciBjb25zaWRlcmluZyBvbmx5IHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGRlY2ltYWwgZGlnaXRzICh3aXRoIHJvdW5kaW5nIG9uIHRoZSBmaW5hbCBkaWdpdCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG5leHQgYmlnZ2VyIGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG4sIGRlY2ltYWxzKSB7XG4gIHJldHVybiBNYXRoLmNlaWwodG9GaXhlZChuLCBkZWNpbWFscykpO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgTGF5ZXJQcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQSBjc3MgY29sb3IsIG9yIGEgZnVuY3Rpb24gY2FsbGVkIHdpdGggYSB2aWV3IHJlc29sdXRpb24gcmV0dXJuaW5nIGEgY3NzIGNvbG9yLlxuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd8ZnVuY3Rpb24obnVtYmVyKTpzdHJpbmd9IEJhY2tncm91bmRDb2xvclxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmV4dGVudCd8J2NoYW5nZTptYXhSZXNvbHV0aW9uJ3wnY2hhbmdlOm1heFpvb20nfFxuICogICAgJ2NoYW5nZTptaW5SZXNvbHV0aW9uJ3wnY2hhbmdlOm1pblpvb20nfCdjaGFuZ2U6b3BhY2l0eSd8J2NoYW5nZTp2aXNpYmxlJ3wnY2hhbmdlOnpJbmRleCd9IEJhc2VMYXllck9iamVjdEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxCYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfEJhc2VMYXllck9iamVjdEV2ZW50VHlwZXMsIFJldHVybj59IEJhc2VMYXllck9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbGF5ZXInXSBBIENTUyBjbGFzcyBuYW1lIHRvIHNldCB0byB0aGUgbGF5ZXIgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXIgfCB1bmRlZmluZWR9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtCYWNrZ3JvdW5kQ29sb3J9IFtiYWNrZ3JvdW5kXSBCYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgbGF5ZXIuIElmIG5vdCBzcGVjaWZpZWQsIG5vIGJhY2tncm91bmRcbiAqIHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSBbcHJvcGVydGllc10gQXJiaXRyYXJ5IG9ic2VydmFibGUgcHJvcGVydGllcy4gQ2FuIGJlIGFjY2Vzc2VkIHdpdGggYCNnZXQoKWAgYW5kIGAjc2V0KClgLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTm90ZSB0aGF0IHdpdGgge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfkJhc2VMYXllcn0gYW5kIGFsbCBpdHMgc3ViY2xhc3NlcywgYW55IHByb3BlcnR5IHNldCBpblxuICogdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH0gcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdCwgc29cbiAqIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBCYXNlTGF5ZXIgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBMYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZUxheWVyT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCYWNrZ3JvdW5kQ29sb3J8ZmFsc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJhY2tncm91bmRfID0gb3B0aW9ucy5iYWNrZ3JvdW5kO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvcGVydGllcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLnByb3BlcnRpZXM7XG4gICAgICBPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIG9wdGlvbnMucHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk9QQUNJVFldID1cbiAgICAgIG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFjaXR5IDogMTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2YgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk9QQUNJVFldID09PSAnbnVtYmVyJyxcbiAgICAgICdMYXllciBvcGFjaXR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICk7XG5cbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuVklTSUJMRV0gPVxuICAgICAgb3B0aW9ucy52aXNpYmxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZpc2libGUgOiB0cnVlO1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5aX0lOREVYXSA9IG9wdGlvbnMuekluZGV4O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTl0gPVxuICAgICAgb3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFJlc29sdXRpb24gOiBJbmZpbml0eTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUlOX1JFU09MVVRJT05dID1cbiAgICAgIG9wdGlvbnMubWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5SZXNvbHV0aW9uIDogMDtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUlOX1pPT01dID1cbiAgICAgIG9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5ab29tIDogLUluZmluaXR5O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfWk9PTV0gPVxuICAgICAgb3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFpvb20gOiBJbmZpbml0eTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNsYXNzTmFtZV8gPVxuICAgICAgcHJvcGVydGllcy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IHByb3BlcnRpZXMuY2xhc3NOYW1lIDogJ29sLWxheWVyJztcbiAgICBkZWxldGUgcHJvcGVydGllcy5jbGFzc05hbWU7XG5cbiAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgZm9yIHRoaXMgbGF5ZXIuXG4gICAqIEByZXR1cm4ge0JhY2tncm91bmRDb2xvcnxmYWxzZX0gTGF5ZXIgYmFja2dyb3VuZC5cbiAgICovXG4gIGdldEJhY2tncm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBDU1MgY2xhc3MgbmFtZS5cbiAgICovXG4gIGdldENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc05hbWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBtZWFudCB0byBiZSBjYWxsZWQgYnkgbGF5ZXJzIG9yIGxheWVyIHJlbmRlcmVycyBiZWNhdXNlIHRoZSBzdGF0ZVxuICAgKiBpcyBpbmNvcnJlY3QgaWYgdGhlIGxheWVyIGlzIGluY2x1ZGVkIGluIGEgbGF5ZXIgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbmFnZWRdIExheWVyIGlzIG1hbmFnZWQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGV9IExheWVyIHN0YXRlLlxuICAgKi9cbiAgZ2V0TGF5ZXJTdGF0ZShtYW5hZ2VkKSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfSAqL1xuICAgIGNvbnN0IHN0YXRlID1cbiAgICAgIHRoaXMuc3RhdGVfIHx8XG4gICAgICAvKiogQHR5cGUgez99ICovICh7XG4gICAgICAgIGxheWVyOiB0aGlzLFxuICAgICAgICBtYW5hZ2VkOiBtYW5hZ2VkID09PSB1bmRlZmluZWQgPyB0cnVlIDogbWFuYWdlZCxcbiAgICAgIH0pO1xuICAgIGNvbnN0IHpJbmRleCA9IHRoaXMuZ2V0WkluZGV4KCk7XG4gICAgc3RhdGUub3BhY2l0eSA9IGNsYW1wKE1hdGgucm91bmQodGhpcy5nZXRPcGFjaXR5KCkgKiAxMDApIC8gMTAwLCAwLCAxKTtcbiAgICBzdGF0ZS52aXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlKCk7XG4gICAgc3RhdGUuZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBzdGF0ZS56SW5kZXggPSB6SW5kZXggPT09IHVuZGVmaW5lZCAmJiAhc3RhdGUubWFuYWdlZCA/IEluZmluaXR5IDogekluZGV4O1xuICAgIHN0YXRlLm1heFJlc29sdXRpb24gPSB0aGlzLmdldE1heFJlc29sdXRpb24oKTtcbiAgICBzdGF0ZS5taW5SZXNvbHV0aW9uID0gTWF0aC5tYXgodGhpcy5nZXRNaW5SZXNvbHV0aW9uKCksIDApO1xuICAgIHN0YXRlLm1pblpvb20gPSB0aGlzLmdldE1pblpvb20oKTtcbiAgICBzdGF0ZS5tYXhab29tID0gdGhpcy5nZXRNYXhab29tKCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBbYXJyYXldIEFycmF5IG9mIGxheWVycyAodG8gYmVcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gQXJyYXkgb2YgbGF5ZXJzLlxuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gW3N0YXRlc10gT3B0aW9uYWwgbGlzdCBvZiBsYXllclxuICAgKiAgICAgc3RhdGVzICh0byBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+fSBMaXN0IG9mIGxheWVyIHN0YXRlcy5cbiAgICovXG4gIGdldExheWVyU3RhdGVzQXJyYXkoc3RhdGVzKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQgZXh0ZW50fSBvZiB0aGUgbGF5ZXIgb3IgYHVuZGVmaW5lZGAgaWYgaXRcbiAgICogd2lsbCBiZSB2aXNpYmxlIHJlZ2FyZGxlc3Mgb2YgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH0gVGhlIGxheWVyIGV4dGVudC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChMYXllclByb3BlcnR5LkVYVEVOVClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci4gUmV0dXJucyBJbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1heGltdW0gcmVzb2x1dGlvbiBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci4gUmV0dXJucyAwIGlmXG4gICAqIHRoZSBsYXllciBoYXMgbm8gbWluaW11bSByZXNvbHV0aW9uIHNldC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluUmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIGxheWVyLiBSZXR1cm5zIC1JbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1pbmltdW0gem9vbSBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fWk9PTSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBsYXllci4gUmV0dXJucyBJbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1heGltdW0gem9vbSBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfWk9PTSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIgKGJldHdlZW4gMCBhbmQgMSkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcGFjaXR5KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuT1BBQ0lUWSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLlN0YXRlfSBTb3VyY2Ugc3RhdGUuXG4gICAqL1xuICBnZXRTb3VyY2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgbGF5ZXIncyBgdmlzaWJsZWAgcHJvcGVydHkuIFRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIGxheWVyXG4gICAqIGlzIHZpc2libGUgb24gYSBtYXAsIHVzZSBgaXNWaXNpYmxlKClgIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2YWx1ZSBvZiB0aGUgYHZpc2libGVgIHByb3BlcnR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VmlzaWJsZSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlXG4gICAqIHJlbmRlcmluZy4gUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGxheWVyIGlzIHVubWFuYWdlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIFotaW5kZXggb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaSW5kZXgoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAqIEBwYXJhbSB7QmFja2dyb3VuZENvbG9yfSBbYmFja2dyb3VuZF0gQmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIHNldEJhY2tncm91bmQoYmFja2dyb3VuZCkge1xuICAgIHRoaXMuYmFja2dyb3VuZF8gPSBiYWNrZ3JvdW5kO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXh0ZW50IGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLiAgSWYgYHVuZGVmaW5lZGAsIHRoZSBsYXllclxuICAgKiB3aWxsIGJlIHZpc2libGUgYXQgYWxsIGV4dGVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IGV4dGVudCBUaGUgZXh0ZW50IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RXh0ZW50KGV4dGVudCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuRVhURU5ULCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBUaGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4UmVzb2x1dGlvbihtYXhSZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTiwgbWF4UmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaW5SZXNvbHV0aW9uKG1pblJlc29sdXRpb24pIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OLCBtaW5SZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSAoZXhjbHVzaXZlKSBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICogTm90ZSB0aGF0IHRoZSB6b29tIGxldmVscyBmb3IgbGF5ZXIgdmlzaWJpbGl0eSBhcmUgYmFzZWQgb24gdGhlXG4gICAqIHZpZXcgem9vbSBsZXZlbCwgd2hpY2ggbWF5IGJlIGRpZmZlcmVudCBmcm9tIGEgdGlsZSBzb3VyY2Ugem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFpvb20gVGhlIG1heGltdW0gem9vbSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1heFpvb20obWF4Wm9vbSkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUFYX1pPT00sIG1heFpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWluaW11bSB6b29tIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBOb3RlIHRoYXQgdGhlIHpvb20gbGV2ZWxzIGZvciBsYXllciB2aXNpYmlsaXR5IGFyZSBiYXNlZCBvbiB0aGVcbiAgICogdmlldyB6b29tIGxldmVsLCB3aGljaCBtYXkgYmUgZGlmZmVyZW50IGZyb20gYSB0aWxlIHNvdXJjZSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWm9vbSBUaGUgbWluaW11bSB6b29tIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWluWm9vbShtaW5ab29tKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fWk9PTSwgbWluWm9vbSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllciwgYWxsb3dlZCB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IFRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJywgJ0xheWVyIG9wYWNpdHkgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuT1BBQ0lUWSwgb3BhY2l0eSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllciAoYHRydWVgIG9yIGBmYWxzZWApLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRWaXNpYmxlKHZpc2libGUpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlZJU0lCTEUsIHZpc2libGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlIHJlbmRlcmluZy5cbiAgICogVGhlIGRlZmF1bHQgWi1pbmRleCBpcyAwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gemluZGV4IFRoZSB6LWluZGV4IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0WkluZGV4KHppbmRleCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCwgemluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVfKSB7XG4gICAgICB0aGlzLnN0YXRlXy5sYXllciA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRlXyA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VMYXllcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGJlZm9yZSBhIGxheWVyIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwcmVyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUFJFUkVOREVSOiAncHJlcmVuZGVyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbGF5ZXIgaXMgcmVuZGVyZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYmVmb3JlIGxheWVycyBhcmUgY29tcG9zZWQuICBXaGVuIGRpc3BhdGNoZWQgYnkgdGhlIG1hcCwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIG5vdCBoYXZlXG4gICAqIGEgYGNvbnRleHRgIHNldC4gIFdoZW4gZGlzcGF0Y2hlZCBieSBhIGxheWVyLCB0aGUgZXZlbnQgb2JqZWN0IHdpbGwgaGF2ZSBhIGBjb250ZXh0YCBzZXQuICBPbmx5XG4gICAqIFdlYkdMIGxheWVycyBjdXJyZW50bHkgZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUkVDT01QT1NFOiAncHJlY29tcG9zZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciBsYXllcnMgYXJlIGNvbXBvc2VkLiAgV2hlbiBkaXNwYXRjaGVkIGJ5IHRoZSBtYXAsIHRoZSBldmVudCBvYmplY3Qgd2lsbCBub3QgaGF2ZVxuICAgKiBhIGBjb250ZXh0YCBzZXQuICBXaGVuIGRpc3BhdGNoZWQgYnkgYSBsYXllciwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIGhhdmUgYSBgY29udGV4dGAgc2V0LiAgT25seVxuICAgKiBXZWJHTCBsYXllcnMgY3VycmVudGx5IGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3Rjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RDT01QT1NFOiAncG9zdGNvbXBvc2UnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiByZW5kZXJpbmcgaXMgY29tcGxldGUsIGkuZS4gYWxsIHNvdXJjZXMgYW5kIHRpbGVzIGhhdmVcbiAgICogZmluaXNoZWQgbG9hZGluZyBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQsIGFuZCBhbGwgdGlsZXMgYXJlIGZhZGVkIGluLlxuICAgKiBUaGUgZXZlbnQgb2JqZWN0IHdpbGwgbm90IGhhdmUgYSBgY29udGV4dGAgc2V0LlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNyZW5kZXJjb21wbGV0ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU5ERVJDT01QTEVURTogJ3JlbmRlcmNvbXBsZXRlJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeydwb3N0cmVuZGVyJ3wncHJlY29tcG9zZSd8J3Bvc3Rjb21wb3NlJ3wncmVuZGVyY29tcGxldGUnfSBNYXBSZW5kZXJFdmVudFR5cGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3Bvc3RyZW5kZXInfCdwcmVyZW5kZXInfSBMYXllclJlbmRlckV2ZW50VHlwZXNcbiAqL1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9WaWV3SGludFxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBBTklNQVRJTkc6IDAsXG4gIElOVEVSQUNUSU5HOiAxLFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvVmlld1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIENFTlRFUjogJ2NlbnRlcicsXG4gIFJFU09MVVRJT046ICdyZXNvbHV0aW9uJyxcbiAgUk9UQVRJT046ICdyb3RhdGlvbicsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9jb21tb25cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSB6b29tIGZvciBkZWZhdWx0IHRpbGUgZ3JpZHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfWk9PTSA9IDQyO1xuXG4vKipcbiAqIERlZmF1bHQgdGlsZSBzaXplLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElMRV9TSVpFID0gMjU2O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1VuaXRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3JhZGlhbnMnIHwgJ2RlZ3JlZXMnIHwgJ2Z0JyB8ICdtJyB8ICdwaXhlbHMnIHwgJ3RpbGUtcGl4ZWxzJyB8ICd1cy1mdCd9IFVuaXRzXG4gKiBQcm9qZWN0aW9uIHVuaXRzLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHA6Ly9kdWZmLmVzcy53YXNoaW5ndG9uLmVkdS9kYXRhL3Jhc3Rlci9kcmcvZG9jcy9nZW90aWZmLnR4dFxuICogQHR5cGUge09iamVjdDxudW1iZXIsIFVuaXRzPn1cbiAqL1xuY29uc3QgdW5pdEJ5Q29kZSA9IHtcbiAgJzkwMDEnOiAnbScsXG4gICc5MDAyJzogJ2Z0JyxcbiAgJzkwMDMnOiAndXMtZnQnLFxuICAnOTEwMSc6ICdyYWRpYW5zJyxcbiAgJzkxMDInOiAnZGVncmVlcycsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIFVuaXQgY29kZS5cbiAqIEByZXR1cm4ge1VuaXRzfSBVbml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Db2RlKGNvZGUpIHtcbiAgcmV0dXJuIHVuaXRCeUNvZGVbY29kZV07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0ZXJzUGVyVW5pdExvb2t1cFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGlhbnMgUmFkaWFuc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZ0ICBGZWV0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBNZXRlcnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cy1mdCBVUyBmZWV0XG4gKi9cblxuLyoqXG4gKiBNZXRlcnMgcGVyIHVuaXQgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7TWV0ZXJzUGVyVW5pdExvb2t1cH1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IHtcbiAgLy8gdXNlIHRoZSByYWRpdXMgb2YgdGhlIE5vcm1hbCBzcGhlcmVcbiAgJ3JhZGlhbnMnOiA2MzcwOTk3IC8gKDIgKiBNYXRoLlBJKSxcbiAgJ2RlZ3JlZXMnOiAoMiAqIE1hdGguUEkgKiA2MzcwOTk3KSAvIDM2MCxcbiAgJ2Z0JzogMC4zMDQ4LFxuICAnbSc6IDEsXG4gICd1cy1mdCc6IDEyMDAgLyAzOTM3LFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9Qcm9qZWN0aW9uXG4gKi9cbmltcG9ydCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL1VuaXRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29kZSBUaGUgU1JTIGlkZW50aWZpZXIgY29kZSwgZS5nLiBgRVBTRzo0MzI2YC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c30gW3VuaXRzXSBVbml0cy4gUmVxdWlyZWQgdW5sZXNzIGFcbiAqIHByb2o0IHByb2plY3Rpb24gaXMgZGVmaW5lZCBmb3IgYGNvZGVgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtheGlzT3JpZW50YXRpb249J2VudSddIFRoZSBheGlzIG9yaWVudGF0aW9uIGFzIHNwZWNpZmllZCBpbiBQcm9qNC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dsb2JhbD1mYWxzZV0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZCBmb3IgdGhlIHdob2xlIGdsb2JlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttZXRlcnNQZXJVbml0XSBUaGUgbWV0ZXJzIHBlciB1bml0IGZvciB0aGUgU1JTLlxuICogSWYgbm90IHByb3ZpZGVkLCB0aGUgYHVuaXRzYCBhcmUgdXNlZCB0byBnZXQgdGhlIG1ldGVycyBwZXIgdW5pdCBmcm9tIHRoZSB7QGxpbmsgTUVURVJTX1BFUl9VTklUfVxuICogbG9va3VwIHRhYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbd29ybGRFeHRlbnRdIFRoZSB3b3JsZCBleHRlbnQgZm9yIHRoZSBTUlMuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ9IFtnZXRQb2ludFJlc29sdXRpb25dXG4gKiBGdW5jdGlvbiB0byBkZXRlcm1pbmUgcmVzb2x1dGlvbiBhdCBhIHBvaW50LiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICogYG51bWJlcmAgdmlldyByZXNvbHV0aW9uIGFuZCBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zXG4gKiB0aGUgYG51bWJlcmAgcmVzb2x1dGlvbiBpbiBwcm9qZWN0aW9uIHVuaXRzIGF0IHRoZSBwYXNzZWQgY29vcmRpbmF0ZS4gSWYgdGhpcyBpcyBgdW5kZWZpbmVkYCxcbiAqIHRoZSBkZWZhdWx0IHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXRQb2ludFJlc29sdXRpb259IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gZGVmaW5pdGlvbiBjbGFzcy4gT25lIG9mIHRoZXNlIGlzIGNyZWF0ZWQgZm9yIGVhY2ggcHJvamVjdGlvblxuICogc3VwcG9ydGVkIGluIHRoZSBhcHBsaWNhdGlvbiBhbmQgc3RvcmVkIGluIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p9IG5hbWVzcGFjZS5cbiAqIFlvdSBjYW4gdXNlIHRoZXNlIGluIGFwcGxpY2F0aW9ucywgYnV0IHRoaXMgaXMgbm90IHJlcXVpcmVkLCBhcyBBUEkgcGFyYW1zXG4gKiBhbmQgb3B0aW9ucyB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSB3aGljaCBtZWFucyB0aGUgc2ltcGxlIHN0cmluZ1xuICogY29kZSB3aWxsIHN1ZmZpY2UuXG4gKlxuICogWW91IGNhbiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmdldH0gdG8gcmV0cmlldmUgdGhlIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyXG4gKiBwcm9qZWN0aW9uLlxuICpcbiAqIFRoZSBsaWJyYXJ5IGluY2x1ZGVzIGRlZmluaXRpb25zIGZvciBgRVBTRzo0MzI2YCBhbmQgYEVQU0c6Mzg1N2AsIHRvZ2V0aGVyXG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgYWxpYXNlczpcbiAqICogYEVQU0c6NDMyNmA6IENSUzo4NCwgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni42OjQzMjYsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQsIHVybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCxcbiAqICAgICBodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNixcbiAqICAgICB1cm46eC1vZ2M6ZGVmOmNyczpFUFNHOjQzMjZcbiAqICogYEVQU0c6Mzg1N2A6IEVQU0c6MTAyMTAwLCBFUFNHOjEwMjExMywgRVBTRzo5MDA5MTMsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni4xODozOjM4NTcsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTdcbiAqXG4gKiBJZiB5b3UgdXNlIFtwcm9qNGpzXShodHRwczovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzKSwgYWxpYXNlcyBjYW5cbiAqIGJlIGFkZGVkIHVzaW5nIGBwcm9qNC5kZWZzKClgLiBBZnRlciBhbGwgcmVxdWlyZWQgcHJvamVjdGlvbiBkZWZpbml0aW9ucyBhcmVcbiAqIGFkZGVkLCBjYWxsIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovcHJvajQucmVnaXN0ZXJ9IGZ1bmN0aW9uLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgUHJvamVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvZGVfID0gb3B0aW9ucy5jb2RlO1xuXG4gICAgLyoqXG4gICAgICogVW5pdHMgb2YgcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBXaGVuIHNldCB0byBgVElMRV9QSVhFTFNgLCBhXG4gICAgICogYHRoaXMuZXh0ZW50X2AgYW5kIGB0aGlzLndvcmxkRXh0ZW50X2AgbXVzdCBiZSBjb25maWd1cmVkIHByb3Blcmx5IGZvciBlYWNoXG4gICAgICogdGlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMudW5pdHNfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfSAqLyAob3B0aW9ucy51bml0cyk7XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGl0eSBleHRlbnQgb2YgdGhlIHByb2plY3Rpb24gaW4gcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBGb3IgcHJvamVjdGlvbnNcbiAgICAgKiB3aXRoIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgICAqIHRpbGUgcGl4ZWwgc3BhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBvcHRpb25zLmV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRlbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW50IG9mIHRoZSB3b3JsZCBpbiBFUFNHOjQzMjYuIEZvciBwcm9qZWN0aW9ucyB3aXRoXG4gICAgICogYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAgICogcHJvamVjdGVkIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkRXh0ZW50XyA9XG4gICAgICBvcHRpb25zLndvcmxkRXh0ZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndvcmxkRXh0ZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNPcmllbnRhdGlvbl8gPVxuICAgICAgb3B0aW9ucy5heGlzT3JpZW50YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXhpc09yaWVudGF0aW9uIDogJ2VudSc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsXyA9IG9wdGlvbnMuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdsb2JhbCA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiB0aGlzLmV4dGVudF8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IG9wdGlvbnMuZ2V0UG9pbnRSZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGVyc1BlclVuaXRfID0gb3B0aW9ucy5tZXRlcnNQZXJVbml0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBwcm9qZWN0aW9uIGlzIHN1aXRhYmxlIGZvciB3cmFwcGluZyB0aGUgeC1heGlzXG4gICAqL1xuICBjYW5XcmFwWCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5XcmFwWF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb2RlIGZvciB0aGlzIHByb2plY3Rpb24sIGUuZy4gJ0VQU0c6NDMyNicuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29kZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV4dGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5pdHMgb2YgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfSBVbml0cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VW5pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pdHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW1vdW50IG9mIG1ldGVycyBwZXIgdW5pdCBvZiB0aGlzIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBpc1xuICAgKiBub3QgY29uZmlndXJlZCB3aXRoIGBtZXRlcnNQZXJVbml0YCBvciBhIHVuaXRzIGlkZW50aWZpZXIsIHRoZSByZXR1cm4gaXNcbiAgICogYHVuZGVmaW5lZGAuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1ldGVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWV0ZXJzUGVyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRlcnNQZXJVbml0XyB8fCBNRVRFUlNfUEVSX1VOSVRbdGhpcy51bml0c19dO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd29ybGQgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0V29ybGRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud29ybGRFeHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXhpcyBvcmllbnRhdGlvbiBvZiB0aGlzIHByb2plY3Rpb24uXG4gICAqIEV4YW1wbGUgdmFsdWVzIGFyZTpcbiAgICogZW51IC0gdGhlIGRlZmF1bHQgZWFzdGluZywgbm9ydGhpbmcsIGVsZXZhdGlvbi5cbiAgICogbmV1IC0gbm9ydGhpbmcsIGVhc3RpbmcsIHVwIC0gdXNlZnVsIGZvciBcImxhdC9sb25nXCIgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyxcbiAgICogICAgIG9yIHNvdXRoIG9yaWVudGF0ZWQgdHJhbnN2ZXJzZSBtZXJjYXRvci5cbiAgICogd251IC0gd2VzdGluZywgbm9ydGhpbmcsIHVwIC0gc29tZSBwbGFuZXRhcnkgY29vcmRpbmF0ZSBzeXN0ZW1zIGhhdmVcbiAgICogICAgIFwid2VzdCBwb3NpdGl2ZVwiIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEF4aXMgb3JpZW50YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF4aXNPcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzT3JpZW50YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgcHJvamVjdGlvbiBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZD9cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGlzR2xvYmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGlmIHRoZSBwcm9qZWN0aW9uIGlzIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2xvYmFsIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHbG9iYWwoZ2xvYmFsKSB7XG4gICAgdGhpcy5nbG9iYWxfID0gZ2xvYmFsO1xuICAgIHRoaXMuY2FuV3JhcFhfID0gISEoZ2xvYmFsICYmIHRoaXMuZXh0ZW50Xyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRUaWxlR3JpZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gICAqL1xuICBzZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpIHtcbiAgICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSB0aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEV4dGVudChleHRlbnQpIHtcbiAgICB0aGlzLmV4dGVudF8gPSBleHRlbnQ7XG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IHdvcmxkRXh0ZW50IFdvcmxkIGV4dGVudFxuICAgKiAgICAgW21pbmxvbiwgbWlubGF0LCBtYXhsb24sIG1heGxhdF0uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFdvcmxkRXh0ZW50KHdvcmxkRXh0ZW50KSB7XG4gICAgdGhpcy53b3JsZEV4dGVudF8gPSB3b3JsZEV4dGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGdldFBvaW50UmVzb2x1dGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXRQb2ludFJlc29sdXRpb259XG4gICAqIGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcn0gZnVuYyBGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZXRQb2ludFJlc29sdXRpb24oZnVuYykge1xuICAgIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBmdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHBvaW50IHJlc29sdXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgcHJvamVjdGlvbiAoaWYgc2V0KS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9IFRoZSBjdXN0b20gcG9pbnRcbiAgICogcmVzb2x1dGlvbiBmdW5jdGlvbiAoaWYgc2V0KS5cbiAgICovXG4gIGdldFBvaW50UmVzb2x1dGlvbkZ1bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvamVjdGlvbjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnMzg1N1xuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL1Byb2plY3Rpb24uanMnO1xuXG4vKipcbiAqIFJhZGl1cyBvZiBXR1M4NCBzcGhlcmVcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEhBTEZfU0laRSA9IE1hdGguUEkgKiBSQURJVVM7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVYVEVOVCA9IFstSEFMRl9TSVpFLCAtSEFMRl9TSVpFLCBIQUxGX1NJWkUsIEhBTEZfU0laRV07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IFdPUkxEX0VYVEVOVCA9IFstMTgwLCAtODUsIDE4MCwgODVdO1xuXG4vKipcbiAqIE1heGltdW0gc2FmZSB2YWx1ZSBpbiB5IGRpcmVjdGlvblxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfWSA9IFJBRElVUyAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyAyKSk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIHdlYi9zcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKi9cbmNsYXNzIEVQU0czODU3UHJvamVjdGlvbiBleHRlbmRzIFByb2plY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgQ29kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICBzdXBlcih7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgdW5pdHM6ICdtJyxcbiAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgd29ybGRFeHRlbnQ6IFdPUkxEX0VYVEVOVCxcbiAgICAgIGdldFBvaW50UmVzb2x1dGlvbjogZnVuY3Rpb24gKHJlc29sdXRpb24sIHBvaW50KSB7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uIC8gTWF0aC5jb3NoKHBvaW50WzFdIC8gUkFESVVTKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjM4NTcuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgY29uc3QgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjEwMCcpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjExMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjkwMDkxMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvRVBTRy8wLzM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTcnKSxcbl07XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjQzMjYgdG8gRVBTRzozODU3LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaWRlXSBTdHJpZGUgKGRlZmF1bHQgaXMgYGRpbWVuc2lvbmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUVQU0c0MzI2KGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbiwgc3RyaWRlKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgZGltZW5zaW9uID0gZGltZW5zaW9uID4gMSA/IGRpbWVuc2lvbiA6IDI7XG4gIHN0cmlkZSA9IHN0cmlkZSA/PyBkaW1lbnNpb247XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkaW1lbnNpb24gPiAyKSB7XG4gICAgICAvLyBwcmVzZXJ2ZSB2YWx1ZXMgYmV5b25kIHNlY29uZCBkaW1lbnNpb25cbiAgICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBzdHJpZGUpIHtcbiAgICBvdXRwdXRbaV0gPSAoSEFMRl9TSVpFICogaW5wdXRbaV0pIC8gMTgwO1xuICAgIGxldCB5ID0gUkFESVVTICogTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgKiAoK2lucHV0W2kgKyAxXSArIDkwKSkgLyAzNjApKTtcbiAgICBpZiAoeSA+IE1BWF9TQUZFX1kpIHtcbiAgICAgIHkgPSBNQVhfU0FGRV9ZO1xuICAgIH0gZWxzZSBpZiAoeSA8IC1NQVhfU0FGRV9ZKSB7XG4gICAgICB5ID0gLU1BWF9TQUZFX1k7XG4gICAgfVxuICAgIG91dHB1dFtpICsgMV0gPSB5O1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjM4NTcgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaWRlXSBTdHJpZGUgKGRlZmF1bHQgaXMgYGRpbWVuc2lvbmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9FUFNHNDMyNihpbnB1dCwgb3V0cHV0LCBkaW1lbnNpb24sIHN0cmlkZSkge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiA+IDEgPyBkaW1lbnNpb24gOiAyO1xuICBzdHJpZGUgPSBzdHJpZGUgPz8gZGltZW5zaW9uO1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgb3V0cHV0W2ldID0gKDE4MCAqIGlucHV0W2ldKSAvIEhBTEZfU0laRTtcbiAgICBvdXRwdXRbaSArIDFdID1cbiAgICAgICgzNjAgKiBNYXRoLmF0YW4oTWF0aC5leHAoaW5wdXRbaSArIDFdIC8gUkFESVVTKSkpIC8gTWF0aC5QSSAtIDkwO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovZXBzZzQzMjZcbiAqL1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9Qcm9qZWN0aW9uLmpzJztcblxuLyoqXG4gKiBTZW1pLW1ham9yIHJhZGl1cyBvZiB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFJBRElVUyA9IDYzNzgxMzc7XG5cbi8qKlxuICogRXh0ZW50IG9mIHRoZSBFUFNHOjQzMjYgcHJvamVjdGlvbiB3aGljaCBpcyB0aGUgd2hvbGUgd29ybGQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVYVEVOVCA9IFstMTgwLCAtOTAsIDE4MCwgOTBdO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IChNYXRoLlBJICogUkFESVVTKSAvIDE4MDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIG9iamVjdCBmb3IgV0dTODQgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyAoRVBTRzo0MzI2KS5cbiAqXG4gKiBOb3RlIHRoYXQgT3BlbkxheWVycyBkb2VzIG5vdCBzdHJpY3RseSBjb21wbHkgd2l0aCB0aGUgRVBTRyBkZWZpbml0aW9uLlxuICogVGhlIEVQU0cgcmVnaXN0cnkgZGVmaW5lcyA0MzI2IGFzIGEgQ1JTIGZvciBMYXRpdHVkZSxMb25naXR1ZGUgKHkseCkuXG4gKiBPcGVuTGF5ZXJzIHRyZWF0cyBFUFNHOjQzMjYgYXMgYSBwc2V1ZG8tcHJvamVjdGlvbiwgd2l0aCB4LHkgY29vcmRpbmF0ZXMuXG4gKi9cbmNsYXNzIEVQU0c0MzI2UHJvamVjdGlvbiBleHRlbmRzIFByb2plY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgQ29kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtheGlzT3JpZW50YXRpb25dIEF4aXMgb3JpZW50YXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBheGlzT3JpZW50YXRpb24pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgdW5pdHM6ICdkZWdyZWVzJyxcbiAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgYXhpc09yaWVudGF0aW9uOiBheGlzT3JpZW50YXRpb24sXG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICBtZXRlcnNQZXJVbml0OiBNRVRFUlNfUEVSX1VOSVQsXG4gICAgICB3b3JsZEV4dGVudDogRVhURU5ULFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUHJvamVjdGlvbnMgZXF1YWwgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBST0pFQ1RJT05TID0gW1xuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdDUlM6ODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignRVBTRzo0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvY3JzL09HQy8xLjMvQ1JTODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2Nycy9FUFNHLzAvNDMyNicsICduZXUnKSxcbl07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovcHJvamVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmxldCBjYWNoZSA9IHt9O1xuXG4vKipcbiAqIENsZWFyIHRoZSBwcm9qZWN0aW9ucyBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICBjYWNoZSA9IHt9O1xufVxuXG4vKipcbiAqIEdldCBhIGNhY2hlZCBwcm9qZWN0aW9uIGJ5IGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBUaGUgY29kZSBmb3IgdGhlIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gVGhlIHByb2plY3Rpb24gKGlmIGNhY2hlZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoY29kZSkge1xuICByZXR1cm4gKFxuICAgIGNhY2hlW2NvZGVdIHx8XG4gICAgY2FjaGVbY29kZS5yZXBsYWNlKC91cm46KHgtKT9vZ2M6ZGVmOmNyczpFUFNHOiguKjopPyhcXHcrKSQvLCAnRVBTRzokMycpXSB8fFxuICAgIG51bGxcbiAgKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBwcm9qZWN0aW9uIHRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBwcm9qZWN0aW9uIGNvZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uIHRvIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvZGUsIHByb2plY3Rpb24pIHtcbiAgY2FjaGVbY29kZV0gPSBwcm9qZWN0aW9uO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3RyYW5zZm9ybXNcbiAqL1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb24+Pn1cbiAqL1xubGV0IHRyYW5zZm9ybXMgPSB7fTtcblxuLyoqXG4gKiBDbGVhciB0aGUgdHJhbnNmb3JtIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIHRyYW5zZm9ybXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZGVzdGluYXRpb24sIHRyYW5zZm9ybUZuKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGlmICghKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcykpIHtcbiAgICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdID0ge307XG4gIH1cbiAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdID0gdHJhbnNmb3JtRm47XG59XG5cbi8qKlxuICogVW5yZWdpc3RlcnMgdGhlIGNvbnZlcnNpb24gZnVuY3Rpb24gdG8gY29udmVydCBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNsZWFuIHVwXG4gKiBjYWNoZWQgdHJhbnNmb3JtcyBkdXJpbmcgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVGhlIHVucmVnaXN0ZXJlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgY29uc3QgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGRlbGV0ZSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGlmIChpc0VtcHR5KHRyYW5zZm9ybXNbc291cmNlQ29kZV0pKSB7XG4gICAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLyoqXG4gKiBHZXQgYSB0cmFuc2Zvcm0gZ2l2ZW4gYSBzb3VyY2UgY29kZSBhbmQgYSBkZXN0aW5hdGlvbiBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZUNvZGUgVGhlIGNvZGUgZm9yIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbkNvZGUgVGhlIGNvZGUgZm9yIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbnx1bmRlZmluZWR9IFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKGlmIGZvdW5kKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpIHtcbiAgbGV0IHRyYW5zZm9ybTtcbiAgaWYgKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcyAmJiBkZXN0aW5hdGlvbkNvZGUgaW4gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkge1xuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnQvUmVsYXRpb25zaGlwXG4gKi9cblxuLyoqXG4gKiBSZWxhdGlvbnNoaXAgdG8gYW4gZXh0ZW50LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBVTktOT1dOOiAwLFxuICBJTlRFUlNFQ1RJTkc6IDEsXG4gIEFCT1ZFOiAyLFxuICBSSUdIVDogNCxcbiAgQkVMT1c6IDgsXG4gIExFRlQ6IDE2LFxufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50XG4gKi9cbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhbiBleHRlbnQ6IGBbbWlueCwgbWlueSwgbWF4eCwgbWF4eV1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IEV4dGVudFxuICogQGFwaVxuICovXG5cbi8qKlxuICogRXh0ZW50IGNvcm5lci5cbiAqIEB0eXBlZGVmIHsnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1yaWdodCcgfCAndG9wLWxlZnQnIHwgJ3RvcC1yaWdodCd9IENvcm5lclxuICovXG5cbi8qKlxuICogQnVpbGQgYW4gZXh0ZW50IHRoYXQgaW5jbHVkZXMgYWxsIGdpdmVuIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0V4dGVudH0gQm91bmRpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmRpbmdFeHRlbnQoY29vcmRpbmF0ZXMpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHhzIFhzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5cyBZcy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5mdW5jdGlvbiBfYm91bmRpbmdFeHRlbnRYWXMoeHMsIHlzLCBkZXN0KSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbi5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLm1pbi5hcHBseShudWxsLCB5cyk7XG4gIGNvbnN0IG1heFggPSBNYXRoLm1heC5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heC5hcHBseShudWxsLCB5cyk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBkZXN0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gZXh0ZW50IGluY3JlYXNlZCBieSB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBleHRlbnQgc2hvdWxkIGJlIGJ1ZmZlcmVkLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihleHRlbnQsIHZhbHVlLCBkZXN0KSB7XG4gIGlmIChkZXN0KSB7XG4gICAgZGVzdFswXSA9IGV4dGVudFswXSAtIHZhbHVlO1xuICAgIGRlc3RbMV0gPSBleHRlbnRbMV0gLSB2YWx1ZTtcbiAgICBkZXN0WzJdID0gZXh0ZW50WzJdICsgdmFsdWU7XG4gICAgZGVzdFszXSA9IGV4dGVudFszXSArIHZhbHVlO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBbXG4gICAgZXh0ZW50WzBdIC0gdmFsdWUsXG4gICAgZXh0ZW50WzFdIC0gdmFsdWUsXG4gICAgZXh0ZW50WzJdICsgdmFsdWUsXG4gICAgZXh0ZW50WzNdICsgdmFsdWUsXG4gIF07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGFuIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBUaGUgY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShleHRlbnQsIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gZXh0ZW50WzBdO1xuICAgIGRlc3RbMV0gPSBleHRlbnRbMV07XG4gICAgZGVzdFsyXSA9IGV4dGVudFsyXTtcbiAgICBkZXN0WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBleHRlbnQuc2xpY2UoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7bnVtYmVyfSBDbG9zZXN0IHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGxldCBkeCwgZHk7XG4gIGlmICh4IDwgZXh0ZW50WzBdKSB7XG4gICAgZHggPSBleHRlbnRbMF0gLSB4O1xuICB9IGVsc2UgaWYgKGV4dGVudFsyXSA8IHgpIHtcbiAgICBkeCA9IHggLSBleHRlbnRbMl07XG4gIH0gZWxzZSB7XG4gICAgZHggPSAwO1xuICB9XG4gIGlmICh5IDwgZXh0ZW50WzFdKSB7XG4gICAgZHkgPSBleHRlbnRbMV0gLSB5O1xuICB9IGVsc2UgaWYgKGV4dGVudFszXSA8IHkpIHtcbiAgICBkeSA9IHkgLSBleHRlbnRbM107XG4gIH0gZWxzZSB7XG4gICAgZHkgPSAwO1xuICB9XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgaW4gdGhlIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBvbmUgZXh0ZW50IGNvbnRhaW5zIGFub3RoZXIuXG4gKlxuICogQW4gZXh0ZW50IGlzIGRlZW1lZCBjb250YWluZWQgaWYgaXQgbGllcyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgb3RoZXIgZXh0ZW50LFxuICogaW5jbHVkaW5nIGlmIHRoZXkgc2hhcmUgb25lIG9yIG1vcmUgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWNvbmQgZXh0ZW50IGlzIGNvbnRhaW5lZCBieSBvciBvbiB0aGUgZWRnZSBvZiB0aGVcbiAqICAgICBmaXJzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRXh0ZW50KGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIChcbiAgICBleHRlbnQxWzBdIDw9IGV4dGVudDJbMF0gJiZcbiAgICBleHRlbnQyWzJdIDw9IGV4dGVudDFbMl0gJiZcbiAgICBleHRlbnQxWzFdIDw9IGV4dGVudDJbMV0gJiZcbiAgICBleHRlbnQyWzNdIDw9IGV4dGVudDFbM11cbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgeCwgeSB2YWx1ZXMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNYWShleHRlbnQsIHgsIHkpIHtcbiAgcmV0dXJuIGV4dGVudFswXSA8PSB4ICYmIHggPD0gZXh0ZW50WzJdICYmIGV4dGVudFsxXSA8PSB5ICYmIHkgPD0gZXh0ZW50WzNdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYSBjb29yZGluYXRlIGFuZCBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzXCIpLmRlZmF1bHR9IFRoZSByZWxhdGlvbnNoaXAgKGJpdHdpc2UgY29tcGFyZSB3aXRoXG4gKiAgICAgaW1wb3J0KFwiLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzXCIpLlJlbGF0aW9uc2hpcCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICBjb25zdCBtaW5YID0gZXh0ZW50WzBdO1xuICBjb25zdCBtaW5ZID0gZXh0ZW50WzFdO1xuICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICBjb25zdCBtYXhZID0gZXh0ZW50WzNdO1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIGxldCByZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXAuVU5LTk9XTjtcbiAgaWYgKHggPCBtaW5YKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkxFRlQ7XG4gIH0gZWxzZSBpZiAoeCA+IG1heFgpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkJFTE9XO1xuICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkFCT1ZFO1xuICB9XG4gIGlmIChyZWxhdGlvbnNoaXAgPT09IFJlbGF0aW9uc2hpcC5VTktOT1dOKSB7XG4gICAgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORztcbiAgfVxuICByZXR1cm4gcmVsYXRpb25zaGlwO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbXB0eSBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEVtcHR5IGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5KCkge1xuICByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBleHRlbnQgb3IgdXBkYXRlIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWSBNaW5pbXVtIFkuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WCBNYXhpbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgZGVzdCkge1xuICBpZiAoZGVzdCkge1xuICAgIGRlc3RbMF0gPSBtaW5YO1xuICAgIGRlc3RbMV0gPSBtaW5ZO1xuICAgIGRlc3RbMl0gPSBtYXhYO1xuICAgIGRlc3RbM10gPSBtYXhZO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVtcHR5IGV4dGVudCBvciBtYWtlIHRoZSBwcm92aWRlZCBvbmUgZW1wdHkuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KSB7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5LCBkZXN0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlLCBkZXN0KSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKHgsIHksIHgsIHksIGRlc3QpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlcywgZGVzdCkge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlc3QpO1xuICByZXR1cm4gZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCBjb29yZGluYXRlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgZGVzdCxcbikge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlc3QpO1xuICByZXR1cm4gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbVJpbmdzKHJpbmdzLCBkZXN0KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIHJldHVybiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGFyZSBlcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIChcbiAgICBleHRlbnQxWzBdID09IGV4dGVudDJbMF0gJiZcbiAgICBleHRlbnQxWzJdID09IGV4dGVudDJbMl0gJiZcbiAgICBleHRlbnQxWzFdID09IGV4dGVudDJbMV0gJiZcbiAgICBleHRlbnQxWzNdID09IGV4dGVudDJbM11cbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGFwcHJveGltYXRlbHkgZXF1aXZhbGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZSBpbiBleHRlbnQgY29vcmRpbmF0ZSB1bml0cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBkaWZmZXIgYnkgbGVzcyB0aGFuIHRoZSB0b2xlcmFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHByb3hpbWF0ZWx5RXF1YWxzKGV4dGVudDEsIGV4dGVudDIsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gKFxuICAgIE1hdGguYWJzKGV4dGVudDFbMF0gLSBleHRlbnQyWzBdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbMl0gLSBleHRlbnQyWzJdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbMV0gLSBleHRlbnQyWzFdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbM10gLSBleHRlbnQyWzNdKSA8IHRvbGVyYW5jZVxuICApO1xufVxuXG4vKipcbiAqIE1vZGlmeSBhbiBleHRlbnQgdG8gaW5jbHVkZSBhbm90aGVyIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIFRoZSBleHRlbnQgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBUaGUgZXh0ZW50IHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgZmlyc3QuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCAoZXh0ZW5kZWQpIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChleHRlbnQxLCBleHRlbnQyKSB7XG4gIGlmIChleHRlbnQyWzBdIDwgZXh0ZW50MVswXSkge1xuICAgIGV4dGVudDFbMF0gPSBleHRlbnQyWzBdO1xuICB9XG4gIGlmIChleHRlbnQyWzJdID4gZXh0ZW50MVsyXSkge1xuICAgIGV4dGVudDFbMl0gPSBleHRlbnQyWzJdO1xuICB9XG4gIGlmIChleHRlbnQyWzFdIDwgZXh0ZW50MVsxXSkge1xuICAgIGV4dGVudDFbMV0gPSBleHRlbnQyWzFdO1xuICB9XG4gIGlmIChleHRlbnQyWzNdID4gZXh0ZW50MVszXSkge1xuICAgIGV4dGVudDFbM10gPSBleHRlbnQyWzNdO1xuICB9XG4gIHJldHVybiBleHRlbnQxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgaWYgKGNvb3JkaW5hdGVbMF0gPCBleHRlbnRbMF0pIHtcbiAgICBleHRlbnRbMF0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzBdID4gZXh0ZW50WzJdKSB7XG4gICAgZXh0ZW50WzJdID0gY29vcmRpbmF0ZVswXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA8IGV4dGVudFsxXSkge1xuICAgIGV4dGVudFsxXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMV0gPiBleHRlbnRbM10pIHtcbiAgICBleHRlbnRbM10gPSBjb29yZGluYXRlWzFdO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEZsYXRDb29yZGluYXRlcyhcbiAgZXh0ZW50LFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4pIHtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGV4dGVuZFhZKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFJpbmdzKGV4dGVudCwgcmluZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gcmluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgcmluZ3NbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFhZKGV4dGVudCwgeCwgeSkge1xuICBleHRlbnRbMF0gPSBNYXRoLm1pbihleHRlbnRbMF0sIHgpO1xuICBleHRlbnRbMV0gPSBNYXRoLm1pbihleHRlbnRbMV0sIHkpO1xuICBleHRlbnRbMl0gPSBNYXRoLm1heChleHRlbnRbMl0sIHgpO1xuICBleHRlbnRbM10gPSBNYXRoLm1heChleHRlbnRbM10sIHkpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYGNhbGxiYWNrYCBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gSWYgdGhlXG4gKiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXQgdmFsdWVcbiAqIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IFN9IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHJldHVybiB7U3xib29sZWFufSBWYWx1ZS5cbiAqIEB0ZW1wbGF0ZSBTXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoQ29ybmVyKGV4dGVudCwgY2FsbGJhY2spIHtcbiAgbGV0IHZhbDtcbiAgdmFsID0gY2FsbGJhY2soZ2V0Qm90dG9tTGVmdChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2soZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrKGdldFRvcFJpZ2h0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjayhnZXRUb3BMZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJlYShleHRlbnQpIHtcbiAgbGV0IGFyZWEgPSAwO1xuICBpZiAoIWlzRW1wdHkoZXh0ZW50KSkge1xuICAgIGFyZWEgPSBnZXRXaWR0aChleHRlbnQpICogZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBib3R0b20gbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21MZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzFdXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEJvdHRvbSByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbMV1dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY2VudGVyIGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ2VudGVyLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VudGVyKGV4dGVudCkge1xuICByZXR1cm4gWyhleHRlbnRbMF0gKyBleHRlbnRbMl0pIC8gMiwgKGV4dGVudFsxXSArIGV4dGVudFszXSkgLyAyXTtcbn1cblxuLyoqXG4gKiBHZXQgYSBjb3JuZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgQ29ybmVyLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvcm5lciBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29ybmVyKGV4dGVudCwgY29ybmVyKSB7XG4gIGxldCBjb29yZGluYXRlO1xuICBpZiAoY29ybmVyID09PSAnYm90dG9tLWxlZnQnKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldEJvdHRvbUxlZnQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09ICdib3R0b20tcmlnaHQnKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldEJvdHRvbVJpZ2h0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSAndG9wLWxlZnQnKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09ICd0b3AtcmlnaHQnKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvcm5lcicpO1xuICB9XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVubGFyZ2VkIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmxhcmdlZEFyZWEoZXh0ZW50MSwgZXh0ZW50Mikge1xuICBjb25zdCBtaW5YID0gTWF0aC5taW4oZXh0ZW50MVswXSwgZXh0ZW50MlswXSk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLm1pbihleHRlbnQxWzFdLCBleHRlbnQyWzFdKTtcbiAgY29uc3QgbWF4WCA9IE1hdGgubWF4KGV4dGVudDFbMl0sIGV4dGVudDJbMl0pO1xuICBjb25zdCBtYXhZID0gTWF0aC5tYXgoZXh0ZW50MVszXSwgZXh0ZW50MlszXSk7XG4gIHJldHVybiAobWF4WCAtIG1pblgpICogKG1heFkgLSBtaW5ZKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JWaWV3QW5kU2l6ZShjZW50ZXIsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBzaXplLCBkZXN0KSB7XG4gIGNvbnN0IFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTNdID0gZ2V0Um90YXRlZFZpZXdwb3J0KFxuICAgIGNlbnRlcixcbiAgICByZXNvbHV0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIHNpemUsXG4gICk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBNYXRoLm1pbih4MCwgeDEsIHgyLCB4MyksXG4gICAgTWF0aC5taW4oeTAsIHkxLCB5MiwgeTMpLFxuICAgIE1hdGgubWF4KHgwLCB4MSwgeDIsIHgzKSxcbiAgICBNYXRoLm1heCh5MCwgeTEsIHkyLCB5MyksXG4gICAgZGVzdCxcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IExpbmVhciByaW5nIHJlcHJlc2VudGluZyB0aGUgdmlld3BvcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGVkVmlld3BvcnQoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSkge1xuICBjb25zdCBkeCA9IChyZXNvbHV0aW9uICogc2l6ZVswXSkgLyAyO1xuICBjb25zdCBkeSA9IChyZXNvbHV0aW9uICogc2l6ZVsxXSkgLyAyO1xuICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gIGNvbnN0IHhDb3MgPSBkeCAqIGNvc1JvdGF0aW9uO1xuICBjb25zdCB4U2luID0gZHggKiBzaW5Sb3RhdGlvbjtcbiAgY29uc3QgeUNvcyA9IGR5ICogY29zUm90YXRpb247XG4gIGNvbnN0IHlTaW4gPSBkeSAqIHNpblJvdGF0aW9uO1xuICBjb25zdCB4ID0gY2VudGVyWzBdO1xuICBjb25zdCB5ID0gY2VudGVyWzFdO1xuICByZXR1cm4gW1xuICAgIHggLSB4Q29zICsgeVNpbixcbiAgICB5IC0geFNpbiAtIHlDb3MsXG4gICAgeCAtIHhDb3MgLSB5U2luLFxuICAgIHkgLSB4U2luICsgeUNvcyxcbiAgICB4ICsgeENvcyAtIHlTaW4sXG4gICAgeSArIHhTaW4gKyB5Q29zLFxuICAgIHggKyB4Q29zICsgeVNpbixcbiAgICB5ICsgeFNpbiAtIHlDb3MsXG4gICAgeCAtIHhDb3MgKyB5U2luLFxuICAgIHkgLSB4U2luIC0geUNvcyxcbiAgXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGhlaWdodCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzNdIC0gZXh0ZW50WzFdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVyc2VjdGlvbiBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IGdldEludGVyc2VjdGlvbihleHRlbnQxLCBleHRlbnQyKTtcbiAgcmV0dXJuIGdldEFyZWEoaW50ZXJzZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZXh0ZW50cy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIE9wdGlvbmFsIGV4dGVudCB0byBwb3B1bGF0ZSB3aXRoIGludGVyc2VjdGlvbi5cbiAqIEByZXR1cm4ge0V4dGVudH0gSW50ZXJzZWN0aW5nIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihleHRlbnQxLCBleHRlbnQyLCBkZXN0KSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IGRlc3QgPyBkZXN0IDogY3JlYXRlRW1wdHkoKTtcbiAgaWYgKGludGVyc2VjdHMoZXh0ZW50MSwgZXh0ZW50MikpIHtcbiAgICBpZiAoZXh0ZW50MVswXSA+IGV4dGVudDJbMF0pIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDFbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDJbMF07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzFdID4gZXh0ZW50MlsxXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MlsxXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMl0gPCBleHRlbnQyWzJdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQxWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQyWzJdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVszXSA8IGV4dGVudDJbM10pIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDFbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoaW50ZXJzZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBNYXJnaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJnaW4oZXh0ZW50KSB7XG4gIHJldHVybiBnZXRXaWR0aChleHRlbnQpICsgZ2V0SGVpZ2h0KGV4dGVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplICh3aWR0aCwgaGVpZ2h0KSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gVGhlIGV4dGVudCBzaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZShleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0gLSBleHRlbnRbMF0sIGV4dGVudFszXSAtIGV4dGVudFsxXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BMZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzNdXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbM11dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2lkdGgoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gLSBleHRlbnRbMF07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG9uZSBleHRlbnQgaW50ZXJzZWN0cyBhbm90aGVyLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgaW50ZXJzZWN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiAoXG4gICAgZXh0ZW50MVswXSA8PSBleHRlbnQyWzJdICYmXG4gICAgZXh0ZW50MVsyXSA+PSBleHRlbnQyWzBdICYmXG4gICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzNdICYmXG4gICAgZXh0ZW50MVszXSA+PSBleHRlbnQyWzFdXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGV4dGVudCBpcyBlbXB0eS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzJdIDwgZXh0ZW50WzBdIHx8IGV4dGVudFszXSA8IGV4dGVudFsxXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5PclVwZGF0ZShleHRlbnQsIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gZXh0ZW50WzBdO1xuICAgIGRlc3RbMV0gPSBleHRlbnRbMV07XG4gICAgZGVzdFsyXSA9IGV4dGVudFsyXTtcbiAgICBkZXN0WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUZyb21DZW50ZXIoZXh0ZW50LCB2YWx1ZSkge1xuICBjb25zdCBkZWx0YVggPSAoKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBjb25zdCBkZWx0YVkgPSAoKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBleHRlbnRbMF0gLT0gZGVsdGFYO1xuICBleHRlbnRbMl0gKz0gZGVsdGFYO1xuICBleHRlbnRbMV0gLT0gZGVsdGFZO1xuICBleHRlbnRbM10gKz0gZGVsdGFZO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgc2VnbWVudCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyBpbnRlcnNlY3RzIChjcm9zc2VzLFxuICogdG91Y2hlcywgb3IgaXMgY29udGFpbmVkIGJ5KSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gc3RhcnQgU2VnbWVudCBzdGFydCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZW5kIFNlZ21lbnQgZW5kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzU2VnbWVudChleHRlbnQsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGludGVyc2VjdHMgPSBmYWxzZTtcbiAgY29uc3Qgc3RhcnRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgc3RhcnQpO1xuICBjb25zdCBlbmRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgZW5kKTtcbiAgaWYgKFxuICAgIHN0YXJ0UmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HIHx8XG4gICAgZW5kUmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HXG4gICkge1xuICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gICAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICAgIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gICAgY29uc3Qgc3RhcnRYID0gc3RhcnRbMF07XG4gICAgY29uc3Qgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgY29uc3QgZW5kWCA9IGVuZFswXTtcbiAgICBjb25zdCBlbmRZID0gZW5kWzFdO1xuICAgIGNvbnN0IHNsb3BlID0gKGVuZFkgLSBzdGFydFkpIC8gKGVuZFggLSBzdGFydFgpO1xuICAgIGxldCB4LCB5O1xuICAgIGlmICghIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpICYmICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHRvcFxuICAgICAgeCA9IGVuZFggLSAoZW5kWSAtIG1heFkpIC8gc2xvcGU7XG4gICAgICBpbnRlcnNlY3RzID0geCA+PSBtaW5YICYmIHggPD0gbWF4WDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWludGVyc2VjdHMgJiZcbiAgICAgICEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5SSUdIVCkgJiZcbiAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpXG4gICAgKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHJpZ2h0XG4gICAgICB5ID0gZW5kWSAtIChlbmRYIC0gbWF4WCkgKiBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSAmJlxuICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5CRUxPVylcbiAgICApIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgYm90dG9tXG4gICAgICB4ID0gZW5kWCAtIChlbmRZIC0gbWluWSkgLyBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkxFRlQpICYmXG4gICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkxFRlQpXG4gICAgKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGxlZnRcbiAgICAgIHkgPSBlbmRZIC0gKGVuZFggLSBtaW5YKSAqIHNsb3BlO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcnNlY3RzO1xufVxuXG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBDYWxsZWQgd2l0aCBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBleHRlbnQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcHNdIE51bWJlciBvZiBzdG9wcyBwZXIgc2lkZSB1c2VkIGZvciB0aGUgdHJhbnNmb3JtLlxuICogQnkgZGVmYXVsdCBvbmx5IHRoZSBjb3JuZXJzIGFyZSB1c2VkLlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZuLCBkZXN0LCBzdG9wcykge1xuICBpZiAoaXNFbXB0eShleHRlbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIH1cbiAgbGV0IGNvb3JkaW5hdGVzID0gW107XG4gIGlmIChzdG9wcyA+IDEpIHtcbiAgICBjb25zdCB3aWR0aCA9IGV4dGVudFsyXSAtIGV4dGVudFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSBleHRlbnRbM10gLSBleHRlbnRbMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wczsgKytpKSB7XG4gICAgICBjb29yZGluYXRlcy5wdXNoKFxuICAgICAgICBleHRlbnRbMF0gKyAod2lkdGggKiBpKSAvIHN0b3BzLFxuICAgICAgICBleHRlbnRbMV0sXG4gICAgICAgIGV4dGVudFsyXSxcbiAgICAgICAgZXh0ZW50WzFdICsgKGhlaWdodCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFsyXSAtICh3aWR0aCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFszXSxcbiAgICAgICAgZXh0ZW50WzBdLFxuICAgICAgICBleHRlbnRbM10gLSAoaGVpZ2h0ICogaSkgLyBzdG9wcyxcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvb3JkaW5hdGVzID0gW1xuICAgICAgZXh0ZW50WzBdLFxuICAgICAgZXh0ZW50WzFdLFxuICAgICAgZXh0ZW50WzJdLFxuICAgICAgZXh0ZW50WzFdLFxuICAgICAgZXh0ZW50WzJdLFxuICAgICAgZXh0ZW50WzNdLFxuICAgICAgZXh0ZW50WzBdLFxuICAgICAgZXh0ZW50WzNdLFxuICAgIF07XG4gIH1cbiAgdHJhbnNmb3JtRm4oY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzLCAyKTtcbiAgY29uc3QgeHMgPSBbXTtcbiAgY29uc3QgeXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB4cy5wdXNoKGNvb3JkaW5hdGVzW2ldKTtcbiAgICB5cy5wdXNoKGNvb3JkaW5hdGVzW2kgKyAxXSk7XG4gIH1cbiAgcmV0dXJuIF9ib3VuZGluZ0V4dGVudFhZcyh4cywgeXMsIGRlc3QpO1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwcm92aWRlZCBleHRlbnQgaW4tcGxhY2UgdG8gYmUgd2l0aGluIHRoZSByZWFsIHdvcmxkXG4gKiBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvblxuICogQHJldHVybiB7RXh0ZW50fSBUaGUgZXh0ZW50IHdpdGhpbiB0aGUgcmVhbCB3b3JsZCBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWChleHRlbnQsIHByb2plY3Rpb24pIHtcbiAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGNvbnN0IGNlbnRlciA9IGdldENlbnRlcihleHRlbnQpO1xuICBpZiAoXG4gICAgcHJvamVjdGlvbi5jYW5XcmFwWCgpICYmXG4gICAgKGNlbnRlclswXSA8IHByb2plY3Rpb25FeHRlbnRbMF0gfHwgY2VudGVyWzBdID49IHByb2plY3Rpb25FeHRlbnRbMl0pXG4gICkge1xuICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICBjb25zdCB3b3JsZHNBd2F5ID0gTWF0aC5mbG9vcihcbiAgICAgIChjZW50ZXJbMF0gLSBwcm9qZWN0aW9uRXh0ZW50WzBdKSAvIHdvcmxkV2lkdGgsXG4gICAgKTtcbiAgICBjb25zdCBvZmZzZXQgPSB3b3JsZHNBd2F5ICogd29ybGRXaWR0aDtcbiAgICBleHRlbnRbMF0gLT0gb2Zmc2V0O1xuICAgIGV4dGVudFsyXSAtPSBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBGaXRzIHRoZSBleHRlbnQgdG8gdGhlIHJlYWwgd29ybGRcbiAqXG4gKiBJZiB0aGUgZXh0ZW50IGRvZXMgbm90IGNyb3NzIHRoZSBhbnRpIG1lcmlkaWFuLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBleHRlbnQgaW4gYW4gYXJyYXlcbiAqIElmIHRoZSBleHRlbnQgY3Jvc3NlcyB0aGUgYW50aSBtZXJpZGlhbiwgdGhlIGV4dGVudCB3aWxsIGJlIHNsaWNlZCwgc28gZWFjaCBwYXJ0IGZpdHMgd2l0aGluIHRoZVxuICogcmVhbCB3b3JsZFxuICpcbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aVdvcmxkXSBSZXR1cm4gYWxsIHdvcmxkc1xuICogQHJldHVybiB7QXJyYXk8RXh0ZW50Pn0gVGhlIGV4dGVudCB3aXRoaW4gdGhlIHJlYWwgd29ybGQgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcEFuZFNsaWNlWChleHRlbnQsIHByb2plY3Rpb24sIG11bHRpV29ybGQpIHtcbiAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSkge1xuICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuXG4gICAgaWYgKCFpc0Zpbml0ZShleHRlbnRbMF0pIHx8ICFpc0Zpbml0ZShleHRlbnRbMl0pKSB7XG4gICAgICByZXR1cm4gW1twcm9qZWN0aW9uRXh0ZW50WzBdLCBleHRlbnRbMV0sIHByb2plY3Rpb25FeHRlbnRbMl0sIGV4dGVudFszXV1dO1xuICAgIH1cblxuICAgIHdyYXBYKGV4dGVudCwgcHJvamVjdGlvbik7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuXG4gICAgaWYgKGdldFdpZHRoKGV4dGVudCkgPiB3b3JsZFdpZHRoICYmICFtdWx0aVdvcmxkKSB7XG4gICAgICAvLyB0aGUgZXh0ZW50IHdyYXBzIGFyb3VuZCBvbiBpdHNlbGZcbiAgICAgIHJldHVybiBbW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXV07XG4gICAgfVxuICAgIGlmIChleHRlbnRbMF0gPCBwcm9qZWN0aW9uRXh0ZW50WzBdKSB7XG4gICAgICAvLyB0aGUgZXh0ZW50IGNyb3NzZXMgdGhlIGFudGkgbWVyaWRpYW4sIHNvIGl0IG5lZWRzIHRvIGJlIHNsaWNlZFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW2V4dGVudFswXSArIHdvcmxkV2lkdGgsIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXSxcbiAgICAgICAgW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgZXh0ZW50WzJdLCBleHRlbnRbM11dLFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudFsyXSA+IHByb2plY3Rpb25FeHRlbnRbMl0pIHtcbiAgICAgIC8vIHRoZSBleHRlbnQgY3Jvc3NlcyB0aGUgYW50aSBtZXJpZGlhbiwgc28gaXQgbmVlZHMgdG8gYmUgc2xpY2VkXG4gICAgICByZXR1cm4gW1xuICAgICAgICBbZXh0ZW50WzBdLCBleHRlbnRbMV0sIHByb2plY3Rpb25FeHRlbnRbMl0sIGV4dGVudFszXV0sXG4gICAgICAgIFtwcm9qZWN0aW9uRXh0ZW50WzBdLCBleHRlbnRbMV0sIGV4dGVudFsyXSAtIHdvcmxkV2lkdGgsIGV4dGVudFszXV0sXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbZXh0ZW50XTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvY29vcmRpbmF0ZVxuICovXG5pbXBvcnQge2dldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsbywgdG9GaXhlZH0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7cGFkTnVtYmVyfSBmcm9tICcuL3N0cmluZy5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4gYHh5YCwgYHh5emAgb3IgYHh5em1gIGNvb3JkaW5hdGUuXG4gKiBFeGFtcGxlOiBgWzE2LCA0OF1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IENvb3JkaW5hdGVcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmRcbiAqIHRyYW5zZm9ybXMgaXQgaW50byBhIGB7c3RyaW5nfWAuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChDb29yZGluYXRlfHVuZGVmaW5lZCkpOiBzdHJpbmd9IENvb3JkaW5hdGVGb3JtYXRcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEFkZCBgZGVsdGFgIHRvIGBjb29yZGluYXRlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7YWRkfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBhZGQoY29vcmQsIFstMiwgNF0pO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbNS44NSwgNTEuOTgzMzMzXVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBpbnB1dCBjb29yZGluYXRlIGFkanVzdGVkIGJ5XG4gKiB0aGUgZ2l2ZW4gZGVsdGEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29vcmRpbmF0ZSwgZGVsdGEpIHtcbiAgY29vcmRpbmF0ZVswXSArPSArZGVsdGFbMF07XG4gIGNvb3JkaW5hdGVbMV0gKz0gK2RlbHRhWzFdO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gY2lyY2xlIFRoZSBjaXJjbGUuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDbG9zZXN0IHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uQ2lyY2xlKGNvb3JkaW5hdGUsIGNpcmNsZSkge1xuICBjb25zdCByID0gY2lyY2xlLmdldFJhZGl1cygpO1xuICBjb25zdCBjZW50ZXIgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XG4gIGNvbnN0IHgwID0gY2VudGVyWzBdO1xuICBjb25zdCB5MCA9IGNlbnRlclsxXTtcbiAgY29uc3QgeDEgPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5MSA9IGNvb3JkaW5hdGVbMV07XG5cbiAgbGV0IGR4ID0geDEgLSB4MDtcbiAgY29uc3QgZHkgPSB5MSAtIHkwO1xuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICBkeCA9IDE7XG4gIH1cbiAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgY29uc3QgeCA9IHgwICsgKHIgKiBkeCkgLyBkO1xuICBjb25zdCB5ID0geTAgKyAociAqIGR5KSAvIGQ7XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIHNlZ21lbnQuXG4gKiBUaGlzIGlzIHRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50IHdoZW5cbiAqIHRoZSBmb290IGlzIG9uIHRoZSBzZWdtZW50LCBvciB0aGUgY2xvc2VzdCBzZWdtZW50IGNvb3JkaW5hdGUgd2hlbiB0aGUgZm9vdFxuICogaXMgb3V0c2lkZSB0aGUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBzZWdtZW50IFRoZSB0d28gY29vcmRpbmF0ZXNcbiAqIG9mIHRoZSBzZWdtZW50LlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGZvb3Qgb2YgdGhlIHBlcnBlbmRpY3VsYXIgb2ZcbiAqIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSB7XG4gIGNvbnN0IHgwID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeTAgPSBjb29yZGluYXRlWzFdO1xuICBjb25zdCBzdGFydCA9IHNlZ21lbnRbMF07XG4gIGNvbnN0IGVuZCA9IHNlZ21lbnRbMV07XG4gIGNvbnN0IHgxID0gc3RhcnRbMF07XG4gIGNvbnN0IHkxID0gc3RhcnRbMV07XG4gIGNvbnN0IHgyID0gZW5kWzBdO1xuICBjb25zdCB5MiA9IGVuZFsxXTtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIGNvbnN0IGFsb25nID1cbiAgICBkeCA9PT0gMCAmJiBkeSA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IChkeCAqICh4MCAtIHgxKSArIGR5ICogKHkwIC0geTEpKSAvIChkeCAqIGR4ICsgZHkgKiBkeSB8fCAwKTtcbiAgbGV0IHgsIHk7XG4gIGlmIChhbG9uZyA8PSAwKSB7XG4gICAgeCA9IHgxO1xuICAgIHkgPSB5MTtcbiAgfSBlbHNlIGlmIChhbG9uZyA+PSAxKSB7XG4gICAgeCA9IHgyO1xuICAgIHkgPSB5MjtcbiAgfSBlbHNlIHtcbiAgICB4ID0geDEgKyBhbG9uZyAqIGR4O1xuICAgIHkgPSB5MSArIGFsb25nICogZHk7XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGVGb3JtYXR9IGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiB1c2VkIHRvIGZvcm1hdFxuICogYSB7Q29vcmRpbmF0ZX0gdG8gYSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2NyZWF0ZVN0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBzdHJpbmdpZnlGdW5jID0gY3JlYXRlU3RyaW5nWFkoKTtcbiAqICAgICBjb25zdCBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIHdpdGggZXhwbGljaXRseSBzcGVjaWZ5aW5nIDIgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Y3JlYXRlU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHN0cmluZ2lmeUZ1bmMgPSBjcmVhdGVTdHJpbmdYWSgyKTtcbiAqICAgICBjb25zdCBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc3Ljg1LCA0Ny45OCdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlRm9ybWF0fSBDb29yZGluYXRlIGZvcm1hdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1hZKGZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgWFkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIGZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhlbWlzcGhlcmVzIEhlbWlzcGhlcmVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlc1RvU3RyaW5nSERNUyhoZW1pc3BoZXJlcywgZGVncmVlcywgZnJhY3Rpb25EaWdpdHMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZERlZ3JlZXMgPSBtb2R1bG8oZGVncmVlcyArIDE4MCwgMzYwKSAtIDE4MDtcbiAgY29uc3QgeCA9IE1hdGguYWJzKDM2MDAgKiBub3JtYWxpemVkRGVncmVlcyk7XG4gIGNvbnN0IGRlY2ltYWxzID0gZnJhY3Rpb25EaWdpdHMgfHwgMDtcblxuICBsZXQgZGVnID0gTWF0aC5mbG9vcih4IC8gMzYwMCk7XG4gIGxldCBtaW4gPSBNYXRoLmZsb29yKCh4IC0gZGVnICogMzYwMCkgLyA2MCk7XG4gIGxldCBzZWMgPSB0b0ZpeGVkKHggLSBkZWcgKiAzNjAwIC0gbWluICogNjAsIGRlY2ltYWxzKTtcblxuICBpZiAoc2VjID49IDYwKSB7XG4gICAgc2VjID0gMDtcbiAgICBtaW4gKz0gMTtcbiAgfVxuXG4gIGlmIChtaW4gPj0gNjApIHtcbiAgICBtaW4gPSAwO1xuICAgIGRlZyArPSAxO1xuICB9XG5cbiAgbGV0IGhkbXMgPSBkZWcgKyAnXFx1MDBiMCc7XG4gIGlmIChtaW4gIT09IDAgfHwgc2VjICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBwYWROdW1iZXIobWluLCAyKSArICdcXHUyMDMyJztcbiAgfVxuICBpZiAoc2VjICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBwYWROdW1iZXIoc2VjLCAyLCBkZWNpbWFscykgKyAnXFx1MjAzMyc7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWREZWdyZWVzICE9PSAwKSB7XG4gICAgaGRtcyArPSAnICcgKyBoZW1pc3BoZXJlcy5jaGFyQXQobm9ybWFsaXplZERlZ3JlZXMgPCAwID8gMSA6IDApO1xuICB9XG5cbiAgcmV0dXJuIGhkbXM7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHRvIGEgc3RyaW5nXG4gKiB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIHRlbXBsYXRlLiBUaGUgc3RyaW5ncyBge3h9YCBhbmQgYHt5fWAgaW4gdGhlIHRlbXBsYXRlXG4gKiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgY29vcmRpbmF0ZSB2YWx1ZXMgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgY29uc3Qgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoOHw0OCkuJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgY29uc3Qgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSwgMik7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoNy44NXw0Ny45OCkuJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIEEgdGVtcGxhdGUgc3RyaW5nIHdpdGggYHt4fWAgYW5kIGB7eX1gIHBsYWNlaG9sZGVyc1xuICogICAgIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSBmaXJzdCBhbmQgc2Vjb25kIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChjb29yZGluYXRlLCB0ZW1wbGF0ZSwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgaWYgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVcbiAgICAgIC5yZXBsYWNlKCd7eH0nLCBjb29yZGluYXRlWzBdLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKVxuICAgICAgLnJlcGxhY2UoJ3t5fScsIGNvb3JkaW5hdGVbMV0udG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBjb29yZGluYXRlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoY29vcmRpbmF0ZTEsIGNvb3JkaW5hdGUyKSB7XG4gIGxldCBlcXVhbHMgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gY29vcmRpbmF0ZTEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAoY29vcmRpbmF0ZTFbaV0gIT0gY29vcmRpbmF0ZTJbaV0pIHtcbiAgICAgIGVxdWFscyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcXVhbHM7XG59XG5cbi8qKlxuICogUm90YXRlIGBjb29yZGluYXRlYCBieSBgYW5nbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kXG4gKiByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtyb3RhdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHJvdGF0ZVJhZGlhbnMgPSBNYXRoLlBJIC8gMjsgLy8gOTAgZGVncmVlc1xuICogICAgIHJvdGF0ZShjb29yZCwgcm90YXRlUmFkaWFucyk7XG4gKiAgICAgLy8gY29vcmQgaXMgbm93IFstNDcuOTgzMzMzLCA3Ljg1XVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIHJhZGlhbi5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoY29vcmRpbmF0ZSwgYW5nbGUpIHtcbiAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXSAqIGNvc0FuZ2xlIC0gY29vcmRpbmF0ZVsxXSAqIHNpbkFuZ2xlO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXSAqIGNvc0FuZ2xlICsgY29vcmRpbmF0ZVswXSAqIHNpbkFuZ2xlO1xuICBjb29yZGluYXRlWzBdID0geDtcbiAgY29vcmRpbmF0ZVsxXSA9IHk7XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIFNjYWxlIGBjb29yZGluYXRlYCBieSBgc2NhbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkXG4gKiBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtzY2FsZSBhcyBzY2FsZUNvb3JkaW5hdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHNjYWxlID0gMS4yO1xuICogICAgIHNjYWxlQ29vcmRpbmF0ZShjb29yZCwgc2NhbGUpO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbOS40MiwgNTcuNTc5OTk5Nl1cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZSBmYWN0b3IuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoY29vcmRpbmF0ZSwgc2NhbGUpIHtcbiAgY29vcmRpbmF0ZVswXSAqPSBzY2FsZTtcbiAgY29vcmRpbmF0ZVsxXSAqPSBzY2FsZTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gY29vcmQxIGFuZCBjb29yZDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgY29uc3QgZHggPSBjb29yZDFbMF0gLSBjb29yZDJbMF07XG4gIGNvbnN0IGR5ID0gY29vcmQxWzFdIC0gY29vcmQyWzFdO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIGNvb3JkMSBhbmQgY29vcmQyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSBhIGNvb3JkaW5hdGUgdG8gYSBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gc2VnbWVudCBMaW5lIHNlZ21lbnQgKDJcbiAqIGNvb3JkaW5hdGVzKS5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZShjb29yZGluYXRlLCBjbG9zZXN0T25TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBnZW9ncmFwaGljIGNvb3JkaW5hdGUgd2l0aCB0aGUgaGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcywgYW5kXG4gKiBzZWNvbmRzLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nSERNU30gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdIRE1TKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc0N1x1MDBCMCA1OFx1MjAzMiA2MFx1MjAzMyBOIDdcdTAwQjAgNTBcdTIwMzIgNjBcdTIwMzMgRSdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdIRE1TfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ0hETVMoY29vcmQsIDEpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzQ3XHUwMEIwIDU4XHUyMDMyIDYwLjBcdTIwMzMgTiA3XHUwMEIwIDUwXHUyMDMyIDYwLjBcdTIwMzMgRSdcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcyBhbmQgc2Vjb25kcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nSERNUyhjb29yZGluYXRlLCBmcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBkZWdyZWVzVG9TdHJpbmdIRE1TKCdOUycsIGNvb3JkaW5hdGVbMV0sIGZyYWN0aW9uRGlnaXRzKSArXG4gICAgICAnICcgK1xuICAgICAgZGVncmVlc1RvU3RyaW5nSERNUygnRVcnLCBjb29yZGluYXRlWzBdLCBmcmFjdGlvbkRpZ2l0cylcbiAgICApO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBjb29yZGluYXRlIGFzIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ1hZKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdYWShjb29yZCwgMSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNy44LCA0OC4wJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBYWS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nWFkoY29vcmRpbmF0ZSwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgcmV0dXJuIGZvcm1hdChjb29yZGluYXRlLCAne3h9LCB7eX0nLCBmcmFjdGlvbkRpZ2l0cyk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGUgaW4tcGxhY2UgdG8gYmUgd2l0aGluIHRoZSByZWFsIHdvcmxkXG4gKiBleHRlbnQuIFRoZSBsb3dlciBwcm9qZWN0aW9uIGV4dGVudCBib3VuZGFyeSBpcyBpbmNsdXNpdmUsIHRoZSB1cHBlciBvbmVcbiAqIGV4Y2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgd2l0aGluIHRoZSByZWFsIHdvcmxkIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKGNvb3JkaW5hdGUsIHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSkge1xuICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uLmdldEV4dGVudCgpKTtcbiAgICBjb25zdCB3b3JsZHNBd2F5ID0gZ2V0V29ybGRzQXdheShjb29yZGluYXRlLCBwcm9qZWN0aW9uLCB3b3JsZFdpZHRoKTtcbiAgICBpZiAod29ybGRzQXdheSkge1xuICAgICAgY29vcmRpbmF0ZVswXSAtPSB3b3JsZHNBd2F5ICogd29ybGRXaWR0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW3NvdXJjZUV4dGVudFdpZHRoXSBXaWR0aCBvZiB0aGUgc291cmNlIGV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gT2Zmc2V0IGluIHdvcmxkIHdpZHRocy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmxkc0F3YXkoY29vcmRpbmF0ZSwgcHJvamVjdGlvbiwgc291cmNlRXh0ZW50V2lkdGgpIHtcbiAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGxldCB3b3JsZHNBd2F5ID0gMDtcbiAgaWYgKFxuICAgIHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgIChjb29yZGluYXRlWzBdIDwgcHJvamVjdGlvbkV4dGVudFswXSB8fCBjb29yZGluYXRlWzBdID4gcHJvamVjdGlvbkV4dGVudFsyXSlcbiAgKSB7XG4gICAgc291cmNlRXh0ZW50V2lkdGggPSBzb3VyY2VFeHRlbnRXaWR0aCB8fCBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICB3b3JsZHNBd2F5ID0gTWF0aC5mbG9vcihcbiAgICAgIChjb29yZGluYXRlWzBdIC0gcHJvamVjdGlvbkV4dGVudFswXSkgLyBzb3VyY2VFeHRlbnRXaWR0aCxcbiAgICApO1xuICB9XG4gIHJldHVybiB3b3JsZHNBd2F5O1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zcGhlcmVcbiAqL1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFuc30gZnJvbSAnLi9tYXRoLmpzJztcblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIG9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgZ2V0TGVuZ3RofSBvciB7QGxpbmsgZ2V0QXJlYX1cbiAqIGZ1bmN0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNwaGVyZU1ldHJpY09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J11cbiAqIFByb2plY3Rpb24gb2YgdGhlICBnZW9tZXRyeS4gIEJ5IGRlZmF1bHQsIHRoZSBnZW9tZXRyeSBpcyBhc3N1bWVkIHRvIGJlIGluXG4gKiBXZWIgTWVyY2F0b3IuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1cz02MzcxMDA4LjhdIFNwaGVyZSByYWRpdXMuICBCeSBkZWZhdWx0LCB0aGVcbiAqIFttZWFuIEVhcnRoIHJhZGl1c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWFydGhfcmFkaXVzI01lYW5fcmFkaXVzKVxuICogZm9yIHRoZSBXR1M4NCBlbGxpcHNvaWQgaXMgdXNlZC5cbiAqL1xuXG4vKipcbiAqIFRoZSBtZWFuIEVhcnRoIHJhZGl1cyAoMS8zICogKDJhICsgYikpIGZvciB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWFydGhfcmFkaXVzI01lYW5fcmFkaXVzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9SQURJVVMgPSA2MzcxMDA4Ljg7XG5cbi8qKlxuICogR2V0IHRoZSBncmVhdCBjaXJjbGUgZGlzdGFuY2UgKGluIG1ldGVycykgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpYyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IGMxIFN0YXJ0aW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5fSBjMiBFbmRpbmcgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzXSBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBncmVhdCBjaXJjbGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2UoYzEsIGMyLCByYWRpdXMpIHtcbiAgcmFkaXVzID0gcmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgY29uc3QgbGF0MiA9IHRvUmFkaWFucyhjMlsxXSk7XG4gIGNvbnN0IGRlbHRhTGF0QnkyID0gKGxhdDIgLSBsYXQxKSAvIDI7XG4gIGNvbnN0IGRlbHRhTG9uQnkyID0gdG9SYWRpYW5zKGMyWzBdIC0gYzFbMF0pIC8gMjtcbiAgY29uc3QgYSA9XG4gICAgTWF0aC5zaW4oZGVsdGFMYXRCeTIpICogTWF0aC5zaW4oZGVsdGFMYXRCeTIpICtcbiAgICBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKlxuICAgICAgTWF0aC5zaW4oZGVsdGFMb25CeTIpICpcbiAgICAgIE1hdGguY29zKGxhdDEpICpcbiAgICAgIE1hdGguY29zKGxhdDIpO1xuICByZXR1cm4gMiAqIHJhZGl1cyAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1bXVsYXRpdmUgZ3JlYXQgY2lyY2xlIGxlbmd0aCBvZiBsaW5lc3RyaW5nIGNvb3JkaW5hdGVzIChnZW9ncmFwaGljKS5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIExpbmVzdHJpbmcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCAoaW4gbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cykge1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWkgLSAxOyArK2kpIHtcbiAgICBsZW5ndGggKz0gZ2V0RGlzdGFuY2UoY29vcmRpbmF0ZXNbaV0sIGNvb3JkaW5hdGVzW2kgKyAxXSwgcmFkaXVzKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3BoZXJpY2FsIGxlbmd0aCBvZiBhIGdlb21ldHJ5LiAgVGhpcyBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGVcbiAqIGdyZWF0IGNpcmNsZSBkaXN0YW5jZXMgYmV0d2VlbiBjb29yZGluYXRlcy4gIEZvciBwb2x5Z29ucywgdGhlIGxlbmd0aCBpc1xuICogdGhlIHN1bSBvZiBhbGwgcmluZ3MuICBGb3IgcG9pbnRzLCB0aGUgbGVuZ3RoIGlzIHplcm8uICBGb3IgbXVsdGktcGFydFxuICogZ2VvbWV0cmllcywgdGhlIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBsZW5ndGggb2YgZWFjaCBwYXJ0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7U3BoZXJlTWV0cmljT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZVxuICogbGVuZ3RoIGNhbGN1bGF0aW9uLiAgQnkgZGVmYXVsdCwgZ2VvbWV0cmllcyBhcmUgYXNzdW1lZCB0byBiZSBpbiAnRVBTRzozODU3Jy5cbiAqIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBsZW5ndGggKGluIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZW5ndGgoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICBsZXQgbGVuZ3RoID0gMDtcbiAgbGV0IGNvb3JkaW5hdGVzLCBjb29yZHMsIGksIGlpLCBqLCBqajtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgIGNhc2UgJ011bHRpUG9pbnQnOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTGluZWFyUmluZyc6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgbGVuZ3RoID0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdQb2x5Z29uJzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ011bHRpUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IHtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPVxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICkuZ2V0R2VvbWV0cmllcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aChnZW9tZXRyaWVzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcGhlcmljYWwgYXJlYSBmb3IgYSBsaXN0IG9mIGNvb3JkaW5hdGVzLlxuICpcbiAqIFtSZWZlcmVuY2VdKGh0dHBzOi8vdHJzLmpwbC5uYXNhLmdvdi9oYW5kbGUvMjAxNC80MDQwOSlcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDdcbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgTGlzdCBvZiBjb29yZGluYXRlcyBvZiBhIGxpbmVhclxuICogcmluZy4gSWYgdGhlIHJpbmcgaXMgb3JpZW50ZWQgY2xvY2t3aXNlLCB0aGUgYXJlYSB3aWxsIGJlIHBvc2l0aXZlLFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgbGV0IGFyZWEgPSAwO1xuICBjb25zdCBsZW4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIGxldCB4MSA9IGNvb3JkaW5hdGVzW2xlbiAtIDFdWzBdO1xuICBsZXQgeTEgPSBjb29yZGluYXRlc1tsZW4gLSAxXVsxXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHgyID0gY29vcmRpbmF0ZXNbaV1bMF07XG4gICAgY29uc3QgeTIgPSBjb29yZGluYXRlc1tpXVsxXTtcbiAgICBhcmVhICs9XG4gICAgICB0b1JhZGlhbnMoeDIgLSB4MSkgKlxuICAgICAgKDIgKyBNYXRoLnNpbih0b1JhZGlhbnMoeTEpKSArIE1hdGguc2luKHRvUmFkaWFucyh5MikpKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIChhcmVhICogcmFkaXVzICogcmFkaXVzKSAvIDIuMDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwaGVyaWNhbCBhcmVhIG9mIGEgZ2VvbWV0cnkuICBUaGlzIGlzIHRoZSBhcmVhIChpbiBtZXRlcnMpIGFzc3VtaW5nXG4gKiB0aGF0IHBvbHlnb24gZWRnZXMgYXJlIHNlZ21lbnRzIG9mIGdyZWF0IGNpcmNsZXMgb24gYSBzcGhlcmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBBIGdlb21ldHJ5LlxuICogQHBhcmFtIHtTcGhlcmVNZXRyaWNPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGFyZWFcbiAqICAgICBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiAgICAgWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBwcm92aWRpbmcgYSBgcHJvamVjdGlvbmAgb3B0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3BoZXJpY2FsIGFyZWEgKGluIHNxdWFyZSBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJlYShnZW9tZXRyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIGNvbnN0IHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gfHwgJ0VQU0c6Mzg1Nyc7XG4gIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gIGlmICh0eXBlICE9PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKS50cmFuc2Zvcm0ocHJvamVjdGlvbiwgJ0VQU0c6NDMyNicpO1xuICB9XG4gIGxldCBhcmVhID0gMDtcbiAgbGV0IGNvb3JkaW5hdGVzLCBjb29yZHMsIGksIGlpLCBqLCBqajtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTGluZWFyUmluZyc6IHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdQb2x5Z29uJzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGFyZWEgPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXNbMF0sIHJhZGl1cykpO1xuICAgICAgZm9yIChpID0gMSwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRzWzBdLCByYWRpdXMpKTtcbiAgICAgICAgZm9yIChqID0gMSwgamogPSBjb29yZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID1cbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICApLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgKz0gZ2V0QXJlYShnZW9tZXRyaWVzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCB0aGUgZ2l2ZW4gZGlzdGFuY2UgYW5kIGJlYXJpbmcgZnJvbSBgYzFgLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMxIFRoZSBvcmlnaW4gcG9pbnQgKGBbbG9uLCBsYXRdYCBpbiBkZWdyZWVzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBUaGUgZ3JlYXQtY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG9yaWdpblxuICogICAgIHBvaW50IGFuZCB0aGUgdGFyZ2V0IHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgVGhlIGJlYXJpbmcgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNdIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS4gIERlZmF1bHRzIHRvIHRoZSBFYXJ0aCdzXG4gKiAgICAgbWVhbiByYWRpdXMgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaGUgdGFyZ2V0IHBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0KGMxLCBkaXN0YW5jZSwgYmVhcmluZywgcmFkaXVzKSB7XG4gIHJhZGl1cyA9IHJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIGNvbnN0IGxvbjEgPSB0b1JhZGlhbnMoYzFbMF0pO1xuICBjb25zdCBkQnlSID0gZGlzdGFuY2UgLyByYWRpdXM7XG4gIGNvbnN0IGxhdCA9IE1hdGguYXNpbihcbiAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGRCeVIpICtcbiAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhiZWFyaW5nKSxcbiAgKTtcbiAgY29uc3QgbG9uID1cbiAgICBsb24xICtcbiAgICBNYXRoLmF0YW4yKFxuICAgICAgTWF0aC5zaW4oYmVhcmluZykgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGxhdDEpLFxuICAgICAgTWF0aC5jb3MoZEJ5UikgLSBNYXRoLnNpbihsYXQxKSAqIE1hdGguc2luKGxhdCksXG4gICAgKTtcbiAgcmV0dXJuIFt0b0RlZ3JlZXMobG9uKSwgdG9EZWdyZWVzKGxhdCldO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb25zb2xlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2luZm8nfCd3YXJuJ3wnZXJyb3InfCdub25lJ30gTGV2ZWxcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8TGV2ZWwsIG51bWJlcj59XG4gKi9cbmNvbnN0IGxldmVscyA9IHtcbiAgaW5mbzogMSxcbiAgd2FybjogMixcbiAgZXJyb3I6IDMsXG4gIG5vbmU6IDQsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBsZXZlbCA9IGxldmVscy5pbmZvO1xuXG4vKipcbiAqIFNldCB0aGUgbG9nZ2luZyBsZXZlbC4gIEJ5IGRlZmF1bHQsIHRoZSBsZXZlbCBpcyBzZXQgdG8gJ2luZm8nIGFuZCBhbGxcbiAqIG1lc3NhZ2VzIHdpbGwgYmUgbG9nZ2VkLiAgU2V0IHRvICd3YXJuJyB0byBvbmx5IGRpc3BsYXkgd2FybmluZ3MgYW5kIGVycm9ycy5cbiAqIFNldCB0byAnZXJyb3InIHRvIG9ubHkgZGlzcGxheSBlcnJvcnMuICBTZXQgdG8gJ25vbmUnIHRvIHNpbGVuY2UgYWxsIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7TGV2ZWx9IGwgVGhlIG5ldyBsZXZlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExldmVsKGwpIHtcbiAgbGV2ZWwgPSBsZXZlbHNbbF07XG59XG5cbi8qKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFyZ3VtZW50cyB0byBsb2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gIGlmIChsZXZlbCA+IGxldmVscy5pbmZvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKC4uLmFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgQXJndW1lbnRzIHRvIGxvZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2FybiguLi5hcmdzKSB7XG4gIGlmIChsZXZlbCA+IGxldmVscy53YXJuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybiguLi5hcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5cbi8qKlxuICogQHBhcmFtICB7Li4uYW55fSBhcmdzIEFyZ3VtZW50cyB0byBsb2dcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKC4uLmFyZ3MpIHtcbiAgaWYgKGxldmVsID4gbGV2ZWxzLmVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qXG4gKi9cblxuLyoqXG4gKiBUaGUgb2wvcHJvaiBtb2R1bGUgc3RvcmVzOlxuICogKiBhIGxpc3Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn1cbiAqIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBwcm9qZWN0aW9uIHN1cHBvcnRlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqICogYSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgbmVlZGVkIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gb25lIHByb2plY3Rpb25cbiAqIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgc3RhdGljIGZ1bmN0aW9ucyBhcmUgdGhlIG1ldGhvZHMgdXNlZCB0byBtYWludGFpbiB0aGVzZS5cbiAqIEVhY2ggdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiBoYW5kbGUgbm90IG9ubHkgc2ltcGxlIGNvb3JkaW5hdGUgcGFpcnMsIGJ1dCBhbHNvXG4gKiBsYXJnZSBhcnJheXMgb2YgY29vcmRpbmF0ZXMgc3VjaCBhcyB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBXaGVuIGxvYWRlZCwgdGhlIGxpYnJhcnkgYWRkcyBwcm9qZWN0aW9uIG9iamVjdHMgZm9yIEVQU0c6NDMyNiAoV0dTODRcbiAqIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMpIGFuZCBFUFNHOjM4NTcgKFdlYiBvciBTcGhlcmljYWwgTWVyY2F0b3IsIGFzIHVzZWRcbiAqIGZvciBleGFtcGxlIGJ5IEJpbmcgTWFwcyBvciBPcGVuU3RyZWV0TWFwKSwgdG9nZXRoZXIgd2l0aCB0aGUgcmVsZXZhbnRcbiAqIHRyYW5zZm9ybSBmdW5jdGlvbnMuXG4gKlxuICogQWRkaXRpb25hbCB0cmFuc2Zvcm1zIG1heSBiZSBhZGRlZCBieSB1c2luZyB0aGUgaHR0cDovL3Byb2o0anMub3JnL1xuICogbGlicmFyeSAodmVyc2lvbiAyLjIgb3IgbGF0ZXIpLiBZb3UgY2FuIHVzZSB0aGUgZnVsbCBidWlsZCBzdXBwbGllZCBieVxuICogUHJvajRqcywgb3IgY3JlYXRlIGEgY3VzdG9tIGJ1aWxkIHRvIHN1cHBvcnQgdGhvc2UgcHJvamVjdGlvbnMgeW91IG5lZWQ7IHNlZVxuICogdGhlIFByb2o0anMgd2Vic2l0ZSBmb3IgaG93IHRvIGRvIHRoaXMuIFlvdSBhbHNvIG5lZWQgdGhlIFByb2o0anMgZGVmaW5pdGlvbnNcbiAqIGZvciB0aGUgcmVxdWlyZWQgcHJvamVjdGlvbnMuIFRoZXNlIGRlZmluaXRpb25zIGNhbiBiZSBvYnRhaW5lZCBmcm9tXG4gKiBodHRwczovL2Vwc2cuaW8vLCBhbmQgYXJlIGEgSlMgZnVuY3Rpb24sIHNvIGNhbiBiZSBsb2FkZWQgaW4gYSBzY3JpcHRcbiAqIHRhZyAoYXMgaW4gdGhlIGV4YW1wbGVzKSBvciBwYXN0ZWQgaW50byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZSBhZGRlZCB0byBwcm9qNCdzIHJlZ2lzdHJ5IChieVxuICogdXNpbmcgYHByb2o0LmRlZnMoKWApLCBzaW1wbHkgY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBmcm9tIHRoZSBgb2wvcHJvai9wcm9qNGBcbiAqIHBhY2thZ2UuIEV4aXN0aW5nIHRyYW5zZm9ybXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IHRoaXMgZnVuY3Rpb24uIFNlZVxuICogZXhhbXBsZXMvd21zLWltYWdlLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogQWRkaXRpb25hbCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGNhbiBiZSByZWdpc3RlcmVkIHdpdGggYHByb2o0LmRlZnMoKWAgYW55XG4gKiB0aW1lLiBKdXN0IG1ha2Ugc3VyZSB0byBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGFnYWluOyBmb3IgZXhhbXBsZSwgd2l0aCB1c2VyLXN1cHBsaWVkIGRhdGEgd2hlcmUgeW91IGRvbid0XG4gKiBrbm93IGluIGFkdmFuY2Ugd2hhdCBwcm9qZWN0aW9ucyBhcmUgbmVlZGVkLCB5b3UgY2FuIGluaXRpYWxseSBsb2FkIG1pbmltYWxcbiAqIHN1cHBvcnQgYW5kIHRoZW4gbG9hZCB3aGljaGV2ZXIgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBOb3RlIHRoYXQgUHJvajRqcyBkb2VzIG5vdCBzdXBwb3J0IHByb2plY3Rpb24gZXh0ZW50cy4gSWYgeW91IHdhbnQgdG8gYWRkXG4gKiBvbmUgZm9yIGNyZWF0aW5nIGRlZmF1bHQgdGlsZSBncmlkcywgeW91IGNhbiBhZGQgaXQgYWZ0ZXIgdGhlIFByb2plY3Rpb25cbiAqIG9iamVjdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYHNldEV4dGVudGAsIGZvciBleGFtcGxlLFxuICogYGdldCgnRVBTRzoxMjM0Jykuc2V0RXh0ZW50KGV4dGVudClgLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIFByb2o0anMgc3VwcG9ydCwgYW55IHRyYW5zZm9ybSBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFRvIHVzZSB0aGlzLCB5b3UgbXVzdCBmaXJzdCBjcmVhdGVcbiAqIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0IGZvciB0aGUgbmV3IHByb2plY3Rpb24gYW5kIGFkZCBpdCB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouYWRkUHJvamVjdGlvbn0uIFlvdSBjYW4gdGhlbiBhZGQgdGhlIGZvcndhcmQgYW5kIGludmVyc2VcbiAqIGZ1bmN0aW9ucyB3aXRoIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFNlZVxuICogZXhhbXBsZXMvd21zLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogTm90ZSB0aGF0IGlmIG5vIHRyYW5zZm9ybXMgYXJlIG5lZWRlZCBhbmQgeW91IG9ubHkgbmVlZCB0byBkZWZpbmUgdGhlXG4gKiBwcm9qZWN0aW9uLCBqdXN0IGFkZCBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRQcm9qZWN0aW9ufS4gU2VlIGV4YW1wbGVzL3dtcy1uby1wcm9qIGZvciBhbiBleGFtcGxlIG9mXG4gKiB0aGlzLlxuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL3Byb2ovUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQge1xuICBQUk9KRUNUSU9OUyBhcyBFUFNHMzg1N19QUk9KRUNUSU9OUyxcbiAgZnJvbUVQU0c0MzI2LFxuICB0b0VQU0c0MzI2LFxufSBmcm9tICcuL3Byb2ovZXBzZzM4NTcuanMnO1xuaW1wb3J0IHtQUk9KRUNUSU9OUyBhcyBFUFNHNDMyNl9QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2c0MzI2LmpzJztcbmltcG9ydCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IHtcbiAgYWRkIGFzIGFkZFByb2osXG4gIGNsZWFyIGFzIGNsZWFyUHJvaixcbiAgZ2V0IGFzIGdldFByb2osXG59IGZyb20gJy4vcHJvai9wcm9qZWN0aW9ucy5qcyc7XG5pbXBvcnQge1xuICBhZGQgYXMgYWRkVHJhbnNmb3JtRnVuYyxcbiAgY2xlYXIgYXMgY2xlYXJUcmFuc2Zvcm1GdW5jcyxcbiAgZ2V0IGFzIGdldFRyYW5zZm9ybUZ1bmMsXG59IGZyb20gJy4vcHJvai90cmFuc2Zvcm1zLmpzJztcbmltcG9ydCB7YXBwbHlUcmFuc2Zvcm0sIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wLCBtb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2VxdWFscywgZ2V0V29ybGRzQXdheX0gZnJvbSAnLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCB7Z2V0RGlzdGFuY2V9IGZyb20gJy4vc3BoZXJlLmpzJztcbmltcG9ydCB7d2Fybn0gZnJvbSAnLi9jb25zb2xlLmpzJztcblxuLyoqXG4gKiBBIHByb2plY3Rpb24gYXMge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0sIFNSUyBpZGVudGlmaWVyXG4gKiBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICogQHR5cGVkZWYge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gUHJvamVjdGlvbkxpa2VcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIGFjY2VwdHMgYW4gYXJyYXkgb2YgaW5wdXQgY29vcmRpbmF0ZSB2YWx1ZXMsIGFuIG9wdGlvbmFsXG4gKiBvdXRwdXQgYXJyYXksIGFuZCBhbiBvcHRpb25hbCBkaW1lbnNpb24gKGRlZmF1bHQgc2hvdWxkIGJlIDIpLiAgVGhlIGZ1bmN0aW9uXG4gKiB0cmFuc2Zvcm1zIHRoZSBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgcG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXksIGFuZFxuICogcmV0dXJucyB0aGUgb3V0cHV0IGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBUcmFuc2Zvcm1GdW5jdGlvblxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XVxuICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb25dXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0cmlkZV1cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59XG4gKlxuICogQGFwaVxuICovXG5cbmV4cG9ydCB7TUVURVJTX1BFUl9VTklUfTtcblxuZXhwb3J0IHtQcm9qZWN0aW9ufTtcblxubGV0IHNob3dDb29yZGluYXRlV2FybmluZyA9IHRydWU7XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBbZGlzYWJsZSA9IHRydWVdIERpc2FibGUgY29uc29sZSBpbmZvIGFib3V0IGB1c2VHZW9ncmFwaGljKClgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ29vcmRpbmF0ZVdhcm5pbmcoZGlzYWJsZSkge1xuICBjb25zdCBoaWRlID0gZGlzYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGRpc2FibGU7XG4gIHNob3dDb29yZGluYXRlV2FybmluZyA9ICFoaWRlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGNvb3JkaW5hdGUgYXJyYXkgKG5ldyBhcnJheSwgc2FtZSBjb29yZGluYXRlXG4gKiAgICAgdmFsdWVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVHJhbnNmb3JtKGlucHV0LCBvdXRwdXQpIHtcbiAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIG91dHB1dCA9IG91dHB1dDtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBjb29yZGluYXRlIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBJbnB1dCBjb29yZGluYXRlIGFycmF5IChzYW1lIGFycmF5IGFzIGlucHV0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5VHJhbnNmb3JtKGlucHV0LCBvdXRwdXQpIHtcbiAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkICYmIGlucHV0ICE9PSBvdXRwdXQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvdXRwdXRbaV0gPSBpbnB1dFtpXTtcbiAgICB9XG4gICAgaW5wdXQgPSBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuXG4vKipcbiAqIEFkZCBhIFByb2plY3Rpb24gb2JqZWN0IHRvIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBwcm9qZWN0aW9ucyB0aGF0IGNhbiBiZVxuICogbG9va2VkIHVwIGJ5IHRoZWlyIGNvZGUuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24gaW5zdGFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgYWRkUHJvaihwcm9qZWN0aW9uLmdldENvZGUoKSwgcHJvamVjdGlvbik7XG4gIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbiwgcHJvamVjdGlvbiwgY2xvbmVUcmFuc2Zvcm0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zIFByb2plY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUHJvamVjdGlvbnMocHJvamVjdGlvbnMpIHtcbiAgcHJvamVjdGlvbnMuZm9yRWFjaChhZGRQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBGZXRjaGVzIGEgUHJvamVjdGlvbiBvYmplY3QgZm9yIHRoZSBjb2RlIHNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uTGlrZSBFaXRoZXIgYSBjb2RlIHN0cmluZyB3aGljaCBpc1xuICogICAgIGEgY29tYmluYXRpb24gb2YgYXV0aG9yaXR5IGFuZCBpZGVudGlmaWVyIHN1Y2ggYXMgXCJFUFNHOjQzMjZcIiwgb3IgYW5cbiAqICAgICBleGlzdGluZyBwcm9qZWN0aW9uIG9iamVjdCwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybiB7UHJvamVjdGlvbnxudWxsfSBQcm9qZWN0aW9uIG9iamVjdCwgb3IgbnVsbCBpZiBub3QgaW4gbGlzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChwcm9qZWN0aW9uTGlrZSkge1xuICByZXR1cm4gdHlwZW9mIHByb2plY3Rpb25MaWtlID09PSAnc3RyaW5nJ1xuICAgID8gZ2V0UHJvaigvKiogQHR5cGUge3N0cmluZ30gKi8gKHByb2plY3Rpb25MaWtlKSlcbiAgICA6IC8qKiBAdHlwZSB7UHJvamVjdGlvbn0gKi8gKHByb2plY3Rpb25MaWtlKSB8fCBudWxsO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcG9pbnQgaW4gZGVncmVlcyBvciBkaXN0YW5jZSB1bml0cy5cbiAqIEZvciBwcm9qZWN0aW9ucyB3aXRoIGRlZ3JlZXMgYXMgdGhlIHVuaXQgdGhpcyB3aWxsIHNpbXBseSByZXR1cm4gdGhlXG4gKiBwcm92aWRlZCByZXNvbHV0aW9uLiBGb3Igb3RoZXIgcHJvamVjdGlvbnMgdGhlIHBvaW50IHJlc29sdXRpb24gaXNcbiAqIGJ5IGRlZmF1bHQgZXN0aW1hdGVkIGJ5IHRyYW5zZm9ybWluZyB0aGUgYHBvaW50YCBwaXhlbCB0byBFUFNHOjQzMjYsXG4gKiBtZWFzdXJpbmcgaXRzIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG5vcm1hbCBzcGhlcmUsXG4gKiBhbmQgdGFraW5nIHRoZSBhdmVyYWdlIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICogQSBjdXN0b20gZnVuY3Rpb24gY2FuIGJlIHByb3ZpZGVkIGZvciBhIHNwZWNpZmljIHByb2plY3Rpb24sIGVpdGhlclxuICogYnkgc2V0dGluZyB0aGUgYGdldFBvaW50UmVzb2x1dGlvbmAgb3B0aW9uIGluIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gY29uc3RydWN0b3Igb3IgYnkgdXNpbmdcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb24jc2V0R2V0UG9pbnRSZXNvbHV0aW9ufSB0byBjaGFuZ2UgYW4gZXhpc3RpbmdcbiAqIHByb2plY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIE5vbWluYWwgcmVzb2x1dGlvbiBpbiBwcm9qZWN0aW9uIHVuaXRzLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQgdG8gZmluZCBhZGp1c3RlZCByZXNvbHV0aW9uIGF0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovVW5pdHMuanNcIikuVW5pdHN9IFt1bml0c10gVW5pdHMgdG8gZ2V0IHRoZSBwb2ludCByZXNvbHV0aW9uIGluLlxuICogRGVmYXVsdCBpcyB0aGUgcHJvamVjdGlvbidzIHVuaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBQb2ludCByZXNvbHV0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9pbnRSZXNvbHV0aW9uKHByb2plY3Rpb24sIHJlc29sdXRpb24sIHBvaW50LCB1bml0cykge1xuICBwcm9qZWN0aW9uID0gZ2V0KHByb2plY3Rpb24pO1xuICBsZXQgcG9pbnRSZXNvbHV0aW9uO1xuICBjb25zdCBnZXR0ZXIgPSBwcm9qZWN0aW9uLmdldFBvaW50UmVzb2x1dGlvbkZ1bmMoKTtcbiAgaWYgKGdldHRlcikge1xuICAgIHBvaW50UmVzb2x1dGlvbiA9IGdldHRlcihyZXNvbHV0aW9uLCBwb2ludCk7XG4gICAgaWYgKHVuaXRzICYmIHVuaXRzICE9PSBwcm9qZWN0aW9uLmdldFVuaXRzKCkpIHtcbiAgICAgIGNvbnN0IG1ldGVyc1BlclVuaXQgPSBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICAgIGlmIChtZXRlcnNQZXJVbml0KSB7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiA9XG4gICAgICAgICAgKHBvaW50UmVzb2x1dGlvbiAqIG1ldGVyc1BlclVuaXQpIC8gTUVURVJTX1BFUl9VTklUW3VuaXRzXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJvalVuaXRzID0gcHJvamVjdGlvbi5nZXRVbml0cygpO1xuICAgIGlmICgocHJvalVuaXRzID09ICdkZWdyZWVzJyAmJiAhdW5pdHMpIHx8IHVuaXRzID09ICdkZWdyZWVzJykge1xuICAgICAgcG9pbnRSZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXN0aW1hdGUgcG9pbnQgcmVzb2x1dGlvbiBieSB0cmFuc2Zvcm1pbmcgdGhlIGNlbnRlciBwaXhlbCB0byBFUFNHOjQzMjYsXG4gICAgICAvLyBtZWFzdXJpbmcgaXRzIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG5vcm1hbCBzcGhlcmUsIGFuZCB0YWtpbmcgdGhlXG4gICAgICAvLyBhdmVyYWdlIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgY29uc3QgdG9FUFNHNDMyNiA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgICAgICAgcHJvamVjdGlvbixcbiAgICAgICAgZ2V0KCdFUFNHOjQzMjYnKSxcbiAgICAgICk7XG4gICAgICBpZiAodG9FUFNHNDMyNiA9PT0gaWRlbnRpdHlUcmFuc2Zvcm0gJiYgcHJvalVuaXRzICE9PSAnZGVncmVlcycpIHtcbiAgICAgICAgLy8gbm8gdHJhbnNmb3JtIGlzIGF2YWlsYWJsZVxuICAgICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uICogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmVydGljZXMgPSBbXG4gICAgICAgICAgcG9pbnRbMF0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgICBwb2ludFsxXSxcbiAgICAgICAgICBwb2ludFswXSArIHJlc29sdXRpb24gLyAyLFxuICAgICAgICAgIHBvaW50WzFdLFxuICAgICAgICAgIHBvaW50WzBdLFxuICAgICAgICAgIHBvaW50WzFdIC0gcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgICAgcG9pbnRbMF0sXG4gICAgICAgICAgcG9pbnRbMV0gKyByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgXTtcbiAgICAgICAgdmVydGljZXMgPSB0b0VQU0c0MzI2KHZlcnRpY2VzLCB2ZXJ0aWNlcywgMik7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoMCwgMiksIHZlcnRpY2VzLnNsaWNlKDIsIDQpKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoNCwgNiksIHZlcnRpY2VzLnNsaWNlKDYsIDgpKTtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gdW5pdHNcbiAgICAgICAgPyBNRVRFUlNfUEVSX1VOSVRbdW5pdHNdXG4gICAgICAgIDogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiAvPSBtZXRlcnNQZXJVbml0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcy4gVGhvc2UgYWxsb3dcbiAqIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucyk7XG4gIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAoc291cmNlICE9PSBkZXN0aW5hdGlvbikge1xuICAgICAgICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZSwgZGVzdGluYXRpb24sIGNsb25lVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGluIGFueSBwcm9qZWN0aW9uXG4gKiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczEgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczIgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkVHJhbnNmb3JtIFRyYW5zZm9ybWF0aW9uIGZyb20gYW55XG4gKiAgIHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBpbnZlcnNlVHJhbnNmb3JtIFRyYW5zZm9ybSBmcm9tIGFueSBwcm9qZWN0aW9uXG4gKiAgIGluIHByb2plY3Rpb24yIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKFxuICBwcm9qZWN0aW9uczEsXG4gIHByb2plY3Rpb25zMixcbiAgZm9yd2FyZFRyYW5zZm9ybSxcbiAgaW52ZXJzZVRyYW5zZm9ybSxcbikge1xuICBwcm9qZWN0aW9uczEuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdGlvbjEpIHtcbiAgICBwcm9qZWN0aW9uczIuZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdGlvbjIpIHtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yLCBmb3J3YXJkVHJhbnNmb3JtKTtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjIsIHByb2plY3Rpb24xLCBpbnZlcnNlVHJhbnNmb3JtKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2xlYXIgYWxsIGNhY2hlZCBwcm9qZWN0aW9ucyBhbmQgdHJhbnNmb3Jtcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQWxsUHJvamVjdGlvbnMoKSB7XG4gIGNsZWFyUHJvaigpO1xuICBjbGVhclRyYW5zZm9ybUZ1bmNzKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufHN0cmluZ3x1bmRlZmluZWR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0Q29kZSBEZWZhdWx0IGNvZGUuXG4gKiBAcmV0dXJuIHtQcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uLCBkZWZhdWx0Q29kZSkge1xuICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZ2V0KGRlZmF1bHRDb2RlKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb2plY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGdldChwcm9qZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtQcm9qZWN0aW9ufSAqLyAocHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBtb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gZnJvbSBhIHNpbXBsZSAyRCBjb29yZGluYXRlIHRyYW5zZm9ybVxuICogZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkVHJhbnNmb3JtIENvb3JkaW5hdGVcbiAqICAgICB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oY29vcmRUcmFuc2Zvcm0pIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb25zIHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaWRlXSBTdHJpZGUuXG4gICAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0LCBkaW1lbnNpb24sIHN0cmlkZSkge1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgZGltZW5zaW9uID0gZGltZW5zaW9uICE9PSB1bmRlZmluZWQgPyBkaW1lbnNpb24gOiAyO1xuICAgICAgc3RyaWRlID0gc3RyaWRlID8/IGRpbWVuc2lvbjtcbiAgICAgIG91dHB1dCA9IG91dHB1dCAhPT0gdW5kZWZpbmVkID8gb3V0cHV0IDogbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBjb29yZFRyYW5zZm9ybShpbnB1dC5zbGljZShpLCBpICsgZGltZW5zaW9uKSk7XG4gICAgICAgIGNvbnN0IHBvaW50TGVuZ3RoID0gcG9pbnQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgamogPSBzdHJpZGU7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgb3V0cHV0W2kgKyBqXSA9IGogPj0gcG9pbnRMZW5ndGggPyBpbnB1dFtpICsgal0gOiBwb2ludFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGNvb3JkaW5hdGUgdHJhbnNmb3JtIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGJldHdlZW4gdGhlXG4gKiBzb3VyY2UgcHJvamVjdGlvbiBhbmQgdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBUaGUgZm9yd2FyZCBhbmQgaW52ZXJzZSBmdW5jdGlvbnMgY29udmVydCBjb29yZGluYXRlIHBhaXJzOyB0aGlzIGZ1bmN0aW9uXG4gKiBjb252ZXJ0cyB0aGVzZSBpbnRvIHRoZSBmdW5jdGlvbnMgdXNlZCBpbnRlcm5hbGx5IHdoaWNoIGFsc28gaGFuZGxlXG4gKiBleHRlbnRzIGFuZCBjb29yZGluYXRlIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBmb3J3YXJkIFRoZSBmb3J3YXJkIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb25cbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gaW52ZXJzZSBUaGUgaW52ZXJzZSB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbiB0byB0aGUgc291cmNlXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIG9ubHlcbiAqICAgICB0cmFuc2Zvcm0gbGVzcyBkaW1lbnNpb25zIHRoYW4gdGhlIGlucHV0IGNvb3JkaW5hdGUsIGl0IGlzIHN1cHBvc2VlZCB0byByZXR1cm4gYSBjb29yZGluYXRlXG4gKiAgICAgd2l0aCBvbmx5IHRoZSBsZW5ndGggaXQgY2FuIHRyYW5zZm9ybS4gVGhlIG90aGVyIGRpbWVuc2lvbnMgd2lsbCBiZSB0YWtlbiB1bmNoYW5nZWQgZnJvbSB0aGVcbiAqICAgICBzb3VyY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb29yZGluYXRlVHJhbnNmb3Jtcyhzb3VyY2UsIGRlc3RpbmF0aW9uLCBmb3J3YXJkLCBpbnZlcnNlKSB7XG4gIGNvbnN0IHNvdXJjZVByb2ogPSBnZXQoc291cmNlKTtcbiAgY29uc3QgZGVzdFByb2ogPSBnZXQoZGVzdGluYXRpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKFxuICAgIHNvdXJjZVByb2osXG4gICAgZGVzdFByb2osXG4gICAgY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oZm9yd2FyZCksXG4gICk7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoXG4gICAgZGVzdFByb2osXG4gICAgc291cmNlUHJvaixcbiAgICBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShpbnZlcnNlKSxcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSBmcm9tIGxvbmdpdHVkZS9sYXRpdHVkZSB0byBhIGRpZmZlcmVudCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS5cbiAqICAgICBhbiBhcnJheSB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFRhcmdldCBwcm9qZWN0aW9uLiBUaGVcbiAqICAgICBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIHByb2plY3RlZCB0byB0aGUgdGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTG9uTGF0KGNvb3JkaW5hdGUsIHByb2plY3Rpb24pIHtcbiAgZGlzYWJsZUNvb3JkaW5hdGVXYXJuaW5nKCk7XG4gIHJldHVybiB0cmFuc2Zvcm0oXG4gICAgY29vcmRpbmF0ZSxcbiAgICAnRVBTRzo0MzI2JyxcbiAgICBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycsXG4gICk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgdG8gbG9uZ2l0dWRlL2xhdGl0dWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBQcm9qZWN0ZWQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uIG9mIHRoZSBjb29yZGluYXRlLlxuICogICAgIFRoZSBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS4gYW4gYXJyYXlcbiAqICAgICB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Mb25MYXQoY29vcmRpbmF0ZSwgcHJvamVjdGlvbikge1xuICBjb25zdCBsb25MYXQgPSB0cmFuc2Zvcm0oXG4gICAgY29vcmRpbmF0ZSxcbiAgICBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycsXG4gICAgJ0VQU0c6NDMyNicsXG4gICk7XG4gIGNvbnN0IGxvbiA9IGxvbkxhdFswXTtcbiAgaWYgKGxvbiA8IC0xODAgfHwgbG9uID4gMTgwKSB7XG4gICAgbG9uTGF0WzBdID0gbW9kdWxvKGxvbiArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuICByZXR1cm4gbG9uTGF0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gcHJvamVjdGlvbnMgYXJlIHRoZSBzYW1lLCB0aGF0IGlzIGV2ZXJ5IGNvb3JkaW5hdGUgaW4gb25lXG4gKiBwcm9qZWN0aW9uIGRvZXMgcmVwcmVzZW50IHRoZSBzYW1lIGdlb2dyYXBoaWMgcG9pbnQgYXMgdGhlIHNhbWUgY29vcmRpbmF0ZSBpblxuICogdGhlIG90aGVyIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uMSBQcm9qZWN0aW9uIDEuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24yIFByb2plY3Rpb24gMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEVxdWl2YWxlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVpdmFsZW50KHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMikge1xuICBpZiAocHJvamVjdGlvbjEgPT09IHByb2plY3Rpb24yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZXF1YWxVbml0cyA9IHByb2plY3Rpb24xLmdldFVuaXRzKCkgPT09IHByb2plY3Rpb24yLmdldFVuaXRzKCk7XG4gIGlmIChwcm9qZWN0aW9uMS5nZXRDb2RlKCkgPT09IHByb2plY3Rpb24yLmdldENvZGUoKSkge1xuICAgIHJldHVybiBlcXVhbFVuaXRzO1xuICB9XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMgPT09IGNsb25lVHJhbnNmb3JtICYmIGVxdWFsVW5pdHM7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgaW4gdGhlIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBmb3IgdGhlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHNvdXJjZVByb2plY3Rpb24gU291cmNlIFByb2plY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gUHJvamVjdGlvblxuICogICAgIG9iamVjdC5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gIHNvdXJjZVByb2plY3Rpb24sXG4gIGRlc3RpbmF0aW9uUHJvamVjdGlvbixcbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGxldCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnVuYyhzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpO1xuICBpZiAoIXRyYW5zZm9ybUZ1bmMpIHtcbiAgICB0cmFuc2Zvcm1GdW5jID0gaWRlbnRpdHlUcmFuc2Zvcm07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmM7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIHByb2plY3Rpb24tbGlrZSBvYmplY3RzLCBzZWFyY2hlcyBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICogZnVuY3Rpb24gdG8gY29udmVydCBhIGNvb3JkaW5hdGVzIGFycmF5IGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZVxuICogZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0aW5hdGlvblByb2plY3Rpb24gPSBnZXQoZGVzdGluYXRpb24pO1xuICByZXR1cm4gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgZnJvbSBzb3VyY2UgcHJvamVjdGlvbiB0byBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogVGhpcyByZXR1cm5zIGEgbmV3IGNvb3JkaW5hdGUgKGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsKS5cbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9wcm9qLnRyYW5zZm9ybUV4dGVudH0gZm9yIGV4dGVudCB0cmFuc2Zvcm1hdGlvbi5cbiAqIFNlZSB0aGUgdHJhbnNmb3JtIG1ldGhvZCBvZiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnl+R2VvbWV0cnl9IGFuZCBpdHNcbiAqIHN1YmNsYXNzZXMgZm9yIGdlb21ldHJ5IHRyYW5zZm9ybXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShjb29yZGluYXRlLCBzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKGNvb3JkaW5hdGUsIHVuZGVmaW5lZCwgY29vcmRpbmF0ZS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZXh0ZW50IGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXNcbiAqIHJldHVybnMgYSBuZXcgZXh0ZW50IChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wc10gTnVtYmVyIG9mIHN0b3BzIHBlciBzaWRlIHVzZWQgZm9yIHRoZSB0cmFuc2Zvcm0uXG4gKiBCeSBkZWZhdWx0IG9ubHkgdGhlIGNvcm5lcnMgYXJlIHVzZWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSB0cmFuc2Zvcm1lZCBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBzb3VyY2UsIGRlc3RpbmF0aW9uLCBzdG9wcykge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1GdW5jLCB1bmRlZmluZWQsIHN0b3BzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvamVjdGlvbiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gUG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1XaXRoUHJvamVjdGlvbnMoXG4gIHBvaW50LFxuICBzb3VyY2VQcm9qZWN0aW9uLFxuICBkZXN0aW5hdGlvblByb2plY3Rpb24sXG4pIHtcbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhcbiAgICBzb3VyY2VQcm9qZWN0aW9uLFxuICAgIGRlc3RpbmF0aW9uUHJvamVjdGlvbixcbiAgKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMocG9pbnQpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtQcm9qZWN0aW9ufG51bGx9XG4gKi9cbmxldCB1c2VyUHJvamVjdGlvbiA9IG51bGw7XG5cbi8qKlxuICogU2V0IHRoZSBwcm9qZWN0aW9uIGZvciBjb29yZGluYXRlcyBzdXBwbGllZCBmcm9tIGFuZCByZXR1cm5lZCBieSBBUEkgbWV0aG9kcy5cbiAqIFRoaXMgaW5jbHVkZXMgYWxsIEFQSSBtZXRob2RzIGV4Y2VwdCBmb3IgdGhvc2UgaW50ZXJhY3Rpbmcgd2l0aCB0aWxlIGdyaWRzLFxuICogcGx1cyB7QGxpbmsgaW1wb3J0KFwiLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gYW5kIHtAbGluayBpbXBvcnQoXCIuL1ZpZXcuanNcIikuU3RhdGV9LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgdXNlciBwcm9qZWN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VXNlclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICB1c2VyUHJvamVjdGlvbiA9IGdldChwcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlciBwcm9qZWN0aW9uIGlmIHNldC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyVXNlclByb2plY3Rpb24oKSB7XG4gIHVzZXJQcm9qZWN0aW9uID0gbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb2plY3Rpb24gZm9yIGNvb3JkaW5hdGVzIHN1cHBsaWVkIGZyb20gYW5kIHJldHVybmVkIGJ5IEFQSSBtZXRob2RzLlxuICogQHJldHVybiB7UHJvamVjdGlvbnxudWxsfSBUaGUgdXNlciBwcm9qZWN0aW9uIChvciBudWxsIGlmIG5vdCBzZXQpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlclByb2plY3Rpb24oKSB7XG4gIHJldHVybiB1c2VyUHJvamVjdGlvbjtcbn1cblxuLyoqXG4gKiBVc2UgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyAoV0dTLTg0IGRhdHVtKSBpbiBBUEkgbWV0aG9kcy5cbiAqIFRoaXMgaW5jbHVkZXMgYWxsIEFQSSBtZXRob2RzIGV4Y2VwdCBmb3IgdGhvc2UgaW50ZXJhY3Rpbmcgd2l0aCB0aWxlIGdyaWRzLFxuICogcGx1cyB7QGxpbmsgaW1wb3J0KFwiLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gYW5kIHtAbGluayBpbXBvcnQoXCIuL1ZpZXcuanNcIikuU3RhdGV9LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlR2VvZ3JhcGhpYygpIHtcbiAgc2V0VXNlclByb2plY3Rpb24oJ0VQU0c6NDMyNicpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGNvb3JkaW5hdGUgdHJhbnNmb3JtZWQgaW50byB0aGUgdXNlciBwcm9qZWN0aW9uLiAgSWYgbm8gdXNlciBwcm9qZWN0aW9uXG4gKiBpcyBzZXQsIHRoZSBvcmlnaW5hbCBjb29yZGluYXRlIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlIElucHV0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2VQcm9qZWN0aW9uIFRoZSBpbnB1dCBjb29yZGluYXRlIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgaW5wdXQgY29vcmRpbmF0ZSBpbiB0aGUgdXNlciBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Vc2VyQ29vcmRpbmF0ZShjb29yZGluYXRlLCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHNvdXJjZVByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb29yZGluYXRlIHRyYW5zZm9ybWVkIGZyb20gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgY29vcmRpbmF0ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZSBJbnB1dCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdFByb2plY3Rpb24gVGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgaW5wdXQgY29vcmRpbmF0ZSB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyQ29vcmRpbmF0ZShjb29yZGluYXRlLCBkZXN0UHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgaWYgKFxuICAgICAgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nICYmXG4gICAgICAhZXF1YWxzKGNvb3JkaW5hdGUsIFswLCAwXSkgJiZcbiAgICAgIGNvb3JkaW5hdGVbMF0gPj0gLTE4MCAmJlxuICAgICAgY29vcmRpbmF0ZVswXSA8PSAxODAgJiZcbiAgICAgIGNvb3JkaW5hdGVbMV0gPj0gLTkwICYmXG4gICAgICBjb29yZGluYXRlWzFdIDw9IDkwXG4gICAgKSB7XG4gICAgICBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSBmYWxzZTtcbiAgICAgIHdhcm4oXG4gICAgICAgICdDYWxsIHVzZUdlb2dyYXBoaWMoKSBmcm9tIG9sL3Byb2ogb25jZSB0byB3b3JrIHdpdGggW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIGNvb3JkaW5hdGVzLicsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGV4dGVudCB0cmFuc2Zvcm1lZCBpbnRvIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGV4dGVudCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgSW5wdXQgZXh0ZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgZXh0ZW50IHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBpbnB1dCBleHRlbnQgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gZXh0ZW50IHRyYW5zZm9ybWVkIGZyb20gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgZXh0ZW50IGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBJbnB1dCBleHRlbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIGlucHV0IGV4dGVudCB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyRXh0ZW50KGV4dGVudCwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIGlucHV0IHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfVxuICBjb25zdCBzb3VyY2VNZXRlcnNQZXJVbml0ID0gZ2V0KHNvdXJjZVByb2plY3Rpb24pLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgY29uc3QgdXNlck1ldGVyc1BlclVuaXQgPSB1c2VyUHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIHJldHVybiBzb3VyY2VNZXRlcnNQZXJVbml0ICYmIHVzZXJNZXRlcnNQZXJVbml0XG4gICAgPyAocmVzb2x1dGlvbiAqIHNvdXJjZU1ldGVyc1BlclVuaXQpIC8gdXNlck1ldGVyc1BlclVuaXRcbiAgICA6IHJlc29sdXRpb247XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZXN0UHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc29sdXRpb247XG4gIH1cbiAgY29uc3QgZGVzdE1ldGVyc1BlclVuaXQgPSBnZXQoZGVzdFByb2plY3Rpb24pLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgY29uc3QgdXNlck1ldGVyc1BlclVuaXQgPSB1c2VyUHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIHJldHVybiBkZXN0TWV0ZXJzUGVyVW5pdCAmJiB1c2VyTWV0ZXJzUGVyVW5pdFxuICAgID8gKHJlc29sdXRpb24gKiB1c2VyTWV0ZXJzUGVyVW5pdCkgLyBkZXN0TWV0ZXJzUGVyVW5pdFxuICAgIDogcmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2FmZSBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbiBmcm9tIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBcIlNhZmVcIiBtZWFucyB0aGF0IGl0IGNhbiBoYW5kbGUgd3JhcHBpbmcgb2YgeC1jb29yZGluYXRlcyBmb3IgZ2xvYmFsIHByb2plY3Rpb25zLFxuICogYW5kIHRoYXQgY29vcmRpbmF0ZXMgZXhjZWVkaW5nIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB2YWxpZGl0eSBleHRlbnQncyByYW5nZSB3aWxsIGJlXG4gKiBjbGFtcGVkIHRvIHRoZSB2YWxpZGl0eSByYW5nZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdFByb2ogRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdHJhbnNmb3JtIFRyYW5zZm9ybSBmdW5jdGlvbiAoc291cmNlIHRvIGRlc3RpbmF0aW9uKS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFNhZmUgdHJhbnNmb3JtIGZ1bmN0aW9uIChzb3VyY2UgdG8gZGVzdGluYXRpb24pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2FmZUNvb3JkaW5hdGVUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdFByb2osIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgbGV0IHRyYW5zZm9ybWVkLCB3b3JsZHNBd2F5O1xuICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICBjb25zdCBzb3VyY2VFeHRlbnRXaWR0aCA9IGdldFdpZHRoKHNvdXJjZUV4dGVudCk7XG4gICAgICBjb29yZCA9IGNvb3JkLnNsaWNlKDApO1xuICAgICAgd29ybGRzQXdheSA9IGdldFdvcmxkc0F3YXkoY29vcmQsIHNvdXJjZVByb2osIHNvdXJjZUV4dGVudFdpZHRoKTtcbiAgICAgIGlmICh3b3JsZHNBd2F5KSB7XG4gICAgICAgIC8vIE1vdmUgeCB0byB0aGUgcmVhbCB3b3JsZFxuICAgICAgICBjb29yZFswXSA9IGNvb3JkWzBdIC0gd29ybGRzQXdheSAqIHNvdXJjZUV4dGVudFdpZHRoO1xuICAgICAgfVxuICAgICAgY29vcmRbMF0gPSBjbGFtcChjb29yZFswXSwgc291cmNlRXh0ZW50WzBdLCBzb3VyY2VFeHRlbnRbMl0pO1xuICAgICAgY29vcmRbMV0gPSBjbGFtcChjb29yZFsxXSwgc291cmNlRXh0ZW50WzFdLCBzb3VyY2VFeHRlbnRbM10pO1xuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0oY29vcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShjb29yZCk7XG4gICAgfVxuICAgIGlmICh3b3JsZHNBd2F5ICYmIGRlc3RQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIC8vIE1vdmUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZSBiYWNrIHRvIHRoZSBvZmZzZXQgd29ybGRcbiAgICAgIHRyYW5zZm9ybWVkWzBdICs9IHdvcmxkc0F3YXkgKiBnZXRXaWR0aChkZXN0UHJvai5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBZGQgdHJhbnNmb3JtcyB0byBhbmQgZnJvbSBFUFNHOjQzMjYgYW5kIEVQU0c6Mzg1Ny4gIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBieSB3aGVuIHRoaXMgbW9kdWxlIGlzIGV4ZWN1dGVkIGFuZCBzaG91bGQgb25seSBuZWVkIHRvIGJlIGNhbGxlZCBhZ2FpbiBhZnRlclxuICogYGNsZWFyQWxsUHJvamVjdGlvbnMoKWAgaXMgY2FsbGVkIChlLmcuIGluIHRlc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbW1vbigpIHtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzIHRvIGNvbnZlcnQgd2l0aGluIHNldCBvZlxuICAvLyBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHMzg1N19QUk9KRUNUSU9OUyk7XG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHNDMyNl9QUk9KRUNUSU9OUyk7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdG8gY29udmVydCBFUFNHOjQzMjYgbGlrZSBjb29yZGluYXRlcyB0byBFUFNHOjM4NTcgbGlrZVxuICAvLyBjb29yZGluYXRlcyBhbmQgYmFjay5cbiAgYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMoXG4gICAgRVBTRzQzMjZfUFJPSkVDVElPTlMsXG4gICAgRVBTRzM4NTdfUFJPSkVDVElPTlMsXG4gICAgZnJvbUVQU0c0MzI2LFxuICAgIHRvRVBTRzQzMjYsXG4gICk7XG59XG5cbmFkZENvbW1vbigpO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jZW50ZXJjb25zdHJhaW50XG4gKi9cbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWQpLCBudW1iZXIsIGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplLCBib29sZWFuPSwgQXJyYXk8bnVtYmVyPj0pOiAoaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9ubHlDZW50ZXIgSWYgdHJ1ZSwgdGhlIGNvbnN0cmFpbnQgd2lsbCBvbmx5IGFwcGx5IHRvIHRoZSB2aWV3IGNlbnRlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc21vb3RoIElmIHRydWUsIHRoZSB2aWV3IHdpbGwgYmUgYWJsZSB0byBnbyBzbGlnaHRseSBvdXQgb2YgdGhlIGdpdmVuIGV4dGVudFxuICogKG9ubHkgZHVyaW5nIGludGVyYWN0aW9uIGFuZCBhbmltYXRpb24pLlxuICogQHJldHVybiB7VHlwZX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnQoZXh0ZW50LCBvbmx5Q2VudGVyLCBzbW9vdGgpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gY2VudGVyIENlbnRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFZpZXdwb3J0IHNpemU7IHVudXNlZCBpZiBgb25seUNlbnRlcmAgd2FzIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gVHJ1ZSBpZiBhbiBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbY2VudGVyU2hpZnRdIFNoaWZ0IGJldHdlZW4gbWFwIGNlbnRlciBhbmQgdmlld3BvcnQgY2VudGVyLlxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjZW50ZXIsIHJlc29sdXRpb24sIHNpemUsIGlzTW92aW5nLCBjZW50ZXJTaGlmdCkge1xuICAgICAgaWYgKCFjZW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzb2x1dGlvbiAmJiAhb25seUNlbnRlcikge1xuICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgfVxuICAgICAgY29uc3Qgdmlld1dpZHRoID0gb25seUNlbnRlciA/IDAgOiBzaXplWzBdICogcmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHZpZXdIZWlnaHQgPSBvbmx5Q2VudGVyID8gMCA6IHNpemVbMV0gKiByZXNvbHV0aW9uO1xuICAgICAgY29uc3Qgc2hpZnRYID0gY2VudGVyU2hpZnQgPyBjZW50ZXJTaGlmdFswXSA6IDA7XG4gICAgICBjb25zdCBzaGlmdFkgPSBjZW50ZXJTaGlmdCA/IGNlbnRlclNoaWZ0WzFdIDogMDtcbiAgICAgIGxldCBtaW5YID0gZXh0ZW50WzBdICsgdmlld1dpZHRoIC8gMiArIHNoaWZ0WDtcbiAgICAgIGxldCBtYXhYID0gZXh0ZW50WzJdIC0gdmlld1dpZHRoIC8gMiArIHNoaWZ0WDtcbiAgICAgIGxldCBtaW5ZID0gZXh0ZW50WzFdICsgdmlld0hlaWdodCAvIDIgKyBzaGlmdFk7XG4gICAgICBsZXQgbWF4WSA9IGV4dGVudFszXSAtIHZpZXdIZWlnaHQgLyAyICsgc2hpZnRZO1xuXG4gICAgICAvLyBub3RlOiB3aGVuIHpvb21pbmcgb3V0IG9mIGJvdW5kcywgbWluIGFuZCBtYXggdmFsdWVzIGZvciB4IGFuZCB5IG1heVxuICAgICAgLy8gZW5kIHVwIGludmVydGVkIChtaW4gPiBtYXgpOyB0aGlzIGhhcyB0byBiZSBhY2NvdW50ZWQgZm9yXG4gICAgICBpZiAobWluWCA+IG1heFgpIHtcbiAgICAgICAgbWluWCA9IChtYXhYICsgbWluWCkgLyAyO1xuICAgICAgICBtYXhYID0gbWluWDtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5ZID4gbWF4WSkge1xuICAgICAgICBtaW5ZID0gKG1heFkgKyBtaW5ZKSAvIDI7XG4gICAgICAgIG1heFkgPSBtaW5ZO1xuICAgICAgfVxuXG4gICAgICBsZXQgeCA9IGNsYW1wKGNlbnRlclswXSwgbWluWCwgbWF4WCk7XG4gICAgICBsZXQgeSA9IGNsYW1wKGNlbnRlclsxXSwgbWluWSwgbWF4WSk7XG5cbiAgICAgIC8vIGR1cmluZyBhbiBpbnRlcmFjdGlvbiwgYWxsb3cgc29tZSBvdmVyc2Nyb2xsXG4gICAgICBpZiAoaXNNb3ZpbmcgJiYgc21vb3RoICYmIHJlc29sdXRpb24pIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSAzMCAqIHJlc29sdXRpb247XG4gICAgICAgIHggKz1cbiAgICAgICAgICAtcmF0aW8gKiBNYXRoLmxvZygxICsgTWF0aC5tYXgoMCwgbWluWCAtIGNlbnRlclswXSkgLyByYXRpbykgK1xuICAgICAgICAgIHJhdGlvICogTWF0aC5sb2coMSArIE1hdGgubWF4KDAsIGNlbnRlclswXSAtIG1heFgpIC8gcmF0aW8pO1xuICAgICAgICB5ICs9XG4gICAgICAgICAgLXJhdGlvICogTWF0aC5sb2coMSArIE1hdGgubWF4KDAsIG1pblkgLSBjZW50ZXJbMV0pIC8gcmF0aW8pICtcbiAgICAgICAgICByYXRpbyAqIE1hdGgubG9nKDEgKyBNYXRoLm1heCgwLCBjZW50ZXJbMV0gLSBtYXhZKSAvIHJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gQ2VudGVyLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25lKGNlbnRlcikge1xuICByZXR1cm4gY2VudGVyO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZXNvbHV0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtnZXRIZWlnaHQsIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBudW1iZXIsIGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplLCBib29sZWFuPSk6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG1vZGlmaWVkIHJlc29sdXRpb24gdGFraW5nIGludG8gYWNjb3VudCB0aGUgdmlld3BvcnQgc2l6ZSBhbmQgbWF4aW11bVxuICogYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSB2aWV3cG9ydFNpemUgVmlld3BvcnQgc2l6ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd0Z1bGxFeHRlbnQgV2hldGhlciB0byBzaG93IHRoZSBmdWxsIGV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gQ2FwcGVkIHJlc29sdXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFZpZXdwb3J0Q2xhbXBlZFJlc29sdXRpb24oXG4gIHJlc29sdXRpb24sXG4gIG1heEV4dGVudCxcbiAgdmlld3BvcnRTaXplLFxuICBzaG93RnVsbEV4dGVudCxcbikge1xuICBjb25zdCB4UmVzb2x1dGlvbiA9IGdldFdpZHRoKG1heEV4dGVudCkgLyB2aWV3cG9ydFNpemVbMF07XG4gIGNvbnN0IHlSZXNvbHV0aW9uID0gZ2V0SGVpZ2h0KG1heEV4dGVudCkgLyB2aWV3cG9ydFNpemVbMV07XG5cbiAgaWYgKHNob3dGdWxsRXh0ZW50KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHJlc29sdXRpb24sIE1hdGgubWF4KHhSZXNvbHV0aW9uLCB5UmVzb2x1dGlvbikpO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihyZXNvbHV0aW9uLCBNYXRoLm1pbih4UmVzb2x1dGlvbiwgeVJlc29sdXRpb24pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgcmVzb2x1dGlvbiB0byBiZSBiZXR3ZWVuIG1heFJlc29sdXRpb24gYW5kIG1pblJlc29sdXRpb24gd2hpbGVcbiAqIHN0aWxsIGFsbG93aW5nIHRoZSB2YWx1ZSB0byBiZSBzbGlnaHRseSBvdXQgb2YgYm91bmRzLlxuICogTm90ZTogdGhlIGNvbXB1dGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBsb2dhcml0aG0gZnVuY3Rpb24gKGxuKTpcbiAqICAtIGF0IDEsIGxuKHgpIGlzIDBcbiAqICAtIGFib3ZlIDEsIGxuKHgpIGtlZXBzIGluY3JlYXNpbmcgYnV0IGF0IGEgbXVjaCBzbG93ZXIgcGFjZSB0aGFuIHhcbiAqIFRoZSBmaW5hbCByZXN1bHQgaXMgY2xhbXBlZCB0byBwcmV2ZW50IGdldHRpbmcgdG9vIGZhciBhd2F5IGZyb20gYm91bmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIE1heCByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblJlc29sdXRpb24gTWluIHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNtb290aGVkIHJlc29sdXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFNtb290aENsYW1wZWRSZXNvbHV0aW9uKHJlc29sdXRpb24sIG1heFJlc29sdXRpb24sIG1pblJlc29sdXRpb24pIHtcbiAgbGV0IHJlc3VsdCA9IE1hdGgubWluKHJlc29sdXRpb24sIG1heFJlc29sdXRpb24pO1xuICBjb25zdCByYXRpbyA9IDUwO1xuXG4gIHJlc3VsdCAqPVxuICAgIE1hdGgubG9nKDEgKyByYXRpbyAqIE1hdGgubWF4KDAsIHJlc29sdXRpb24gLyBtYXhSZXNvbHV0aW9uIC0gMSkpIC8gcmF0aW8gK1xuICAgIDE7XG4gIGlmIChtaW5SZXNvbHV0aW9uKSB7XG4gICAgcmVzdWx0ID0gTWF0aC5tYXgocmVzdWx0LCBtaW5SZXNvbHV0aW9uKTtcbiAgICByZXN1bHQgLz1cbiAgICAgIE1hdGgubG9nKDEgKyByYXRpbyAqIE1hdGgubWF4KDAsIG1pblJlc29sdXRpb24gLyByZXNvbHV0aW9uIC0gMSkpIC9cbiAgICAgICAgcmF0aW8gK1xuICAgICAgMTtcbiAgfVxuICByZXR1cm4gY2xhbXAocmVzdWx0LCBtaW5SZXNvbHV0aW9uIC8gMiwgbWF4UmVzb2x1dGlvbiAqIDIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcmVzb2x1dGlvbnMgUmVzb2x1dGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzbW9vdGhdIElmIHRydWUsIHRoZSB2aWV3IHdpbGwgYmUgYWJsZSB0byBzbGlnaHRseSBleGNlZWQgcmVzb2x1dGlvbiBsaW1pdHMuIERlZmF1bHQ6IHRydWUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW21heEV4dGVudF0gTWF4aW11bSBhbGxvd2VkIGV4dGVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3dGdWxsRXh0ZW50XSBJZiB0cnVlLCBhbGxvd3MgdXMgdG8gc2hvdyB0aGUgZnVsbCBleHRlbnQuIERlZmF1bHQ6IGZhbHNlLlxuICogQHJldHVybiB7VHlwZX0gWm9vbSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zKFxuICByZXNvbHV0aW9ucyxcbiAgc21vb3RoLFxuICBtYXhFeHRlbnQsXG4gIHNob3dGdWxsRXh0ZW50LFxuKSB7XG4gIHNtb290aCA9IHNtb290aCAhPT0gdW5kZWZpbmVkID8gc21vb3RoIDogdHJ1ZTtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIERpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFZpZXdwb3J0IHNpemUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb3ZpbmddIFRydWUgaWYgYW4gaW50ZXJhY3Rpb24gb3IgYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlc29sdXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlc29sdXRpb24sIGRpcmVjdGlvbiwgc2l6ZSwgaXNNb3ZpbmcpIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbWF4UmVzb2x1dGlvbiA9IHJlc29sdXRpb25zWzBdO1xuICAgICAgICBjb25zdCBtaW5SZXNvbHV0aW9uID0gcmVzb2x1dGlvbnNbcmVzb2x1dGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGNhcHBlZE1heFJlcyA9IG1heEV4dGVudFxuICAgICAgICAgID8gZ2V0Vmlld3BvcnRDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgbWF4RXh0ZW50LFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICBzaG93RnVsbEV4dGVudCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG1heFJlc29sdXRpb247XG5cbiAgICAgICAgLy8gZHVyaW5nIGludGVyYWN0aW5nIG9yIGFuaW1hdGluZywgYWxsb3cgaW50ZXJtZWRpYXJ5IHZhbHVlc1xuICAgICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wKHJlc29sdXRpb24sIG1pblJlc29sdXRpb24sIGNhcHBlZE1heFJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRTbW9vdGhDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgICBjYXBwZWRNYXhSZXMsXG4gICAgICAgICAgICBtaW5SZXNvbHV0aW9uLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYXBwZWQgPSBNYXRoLm1pbihjYXBwZWRNYXhSZXMsIHJlc29sdXRpb24pO1xuICAgICAgICBjb25zdCB6ID0gTWF0aC5mbG9vcihsaW5lYXJGaW5kTmVhcmVzdChyZXNvbHV0aW9ucywgY2FwcGVkLCBkaXJlY3Rpb24pKTtcbiAgICAgICAgaWYgKHJlc29sdXRpb25zW3pdID4gY2FwcGVkTWF4UmVzICYmIHogPCByZXNvbHV0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb25zW3ogKyAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnNbel07XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcG93ZXIgUG93ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBNYXhpbXVtIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW21pblJlc29sdXRpb25dIE1pbmltdW0gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Ntb290aF0gSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIHNsaWdodGx5IGV4Y2VlZCByZXNvbHV0aW9uIGxpbWl0cy4gRGVmYXVsdDogdHJ1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbWF4RXh0ZW50XSBNYXhpbXVtIGFsbG93ZWQgZXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd0Z1bGxFeHRlbnRdIElmIHRydWUsIGFsbG93cyB1cyB0byBzaG93IHRoZSBmdWxsIGV4dGVudC4gRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvUG93ZXIoXG4gIHBvd2VyLFxuICBtYXhSZXNvbHV0aW9uLFxuICBtaW5SZXNvbHV0aW9uLFxuICBzbW9vdGgsXG4gIG1heEV4dGVudCxcbiAgc2hvd0Z1bGxFeHRlbnQsXG4pIHtcbiAgc21vb3RoID0gc21vb3RoICE9PSB1bmRlZmluZWQgPyBzbW9vdGggOiB0cnVlO1xuICBtaW5SZXNvbHV0aW9uID0gbWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gbWluUmVzb2x1dGlvbiA6IDA7XG5cbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIERpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFZpZXdwb3J0IHNpemUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb3ZpbmddIFRydWUgaWYgYW4gaW50ZXJhY3Rpb24gb3IgYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlc29sdXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJlc29sdXRpb24sIGRpcmVjdGlvbiwgc2l6ZSwgaXNNb3ZpbmcpIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY2FwcGVkTWF4UmVzID0gbWF4RXh0ZW50XG4gICAgICAgICAgPyBnZXRWaWV3cG9ydENsYW1wZWRSZXNvbHV0aW9uKFxuICAgICAgICAgICAgICBtYXhSZXNvbHV0aW9uLFxuICAgICAgICAgICAgICBtYXhFeHRlbnQsXG4gICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgIHNob3dGdWxsRXh0ZW50LFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbWF4UmVzb2x1dGlvbjtcblxuICAgICAgICAvLyBkdXJpbmcgaW50ZXJhY3Rpbmcgb3IgYW5pbWF0aW5nLCBhbGxvdyBpbnRlcm1lZGlhcnkgdmFsdWVzXG4gICAgICAgIGlmIChpc01vdmluZykge1xuICAgICAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXAocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiwgY2FwcGVkTWF4UmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldFNtb290aENsYW1wZWRSZXNvbHV0aW9uKFxuICAgICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICAgIGNhcHBlZE1heFJlcyxcbiAgICAgICAgICAgIG1pblJlc29sdXRpb24sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IDFlLTk7XG4gICAgICAgIGNvbnN0IG1pblpvb21MZXZlbCA9IE1hdGguY2VpbChcbiAgICAgICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gY2FwcGVkTWF4UmVzKSAvIE1hdGgubG9nKHBvd2VyKSAtIHRvbGVyYW5jZSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gLWRpcmVjdGlvbiAqICgwLjUgLSB0b2xlcmFuY2UpICsgMC41O1xuICAgICAgICBjb25zdCBjYXBwZWQgPSBNYXRoLm1pbihjYXBwZWRNYXhSZXMsIHJlc29sdXRpb24pO1xuICAgICAgICBjb25zdCBjYXBwZWRab29tTGV2ZWwgPSBNYXRoLmZsb29yKFxuICAgICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBjYXBwZWQpIC8gTWF0aC5sb2cocG93ZXIpICsgb2Zmc2V0LFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBNYXRoLm1heChtaW5ab29tTGV2ZWwsIGNhcHBlZFpvb21MZXZlbCk7XG4gICAgICAgIGNvbnN0IG5ld1Jlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3cocG93ZXIsIHpvb21MZXZlbCk7XG4gICAgICAgIHJldHVybiBjbGFtcChuZXdSZXNvbHV0aW9uLCBtaW5SZXNvbHV0aW9uLCBjYXBwZWRNYXhSZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBNaW4gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Ntb290aF0gSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIHNsaWdodGx5IGV4Y2VlZCByZXNvbHV0aW9uIGxpbWl0cy4gRGVmYXVsdDogdHJ1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbWF4RXh0ZW50XSBNYXhpbXVtIGFsbG93ZWQgZXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd0Z1bGxFeHRlbnRdIElmIHRydWUsIGFsbG93cyB1cyB0byBzaG93IHRoZSBmdWxsIGV4dGVudC4gRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWluTWF4UmVzb2x1dGlvbihcbiAgbWF4UmVzb2x1dGlvbixcbiAgbWluUmVzb2x1dGlvbixcbiAgc21vb3RoLFxuICBtYXhFeHRlbnQsXG4gIHNob3dGdWxsRXh0ZW50LFxuKSB7XG4gIHNtb290aCA9IHNtb290aCAhPT0gdW5kZWZpbmVkID8gc21vb3RoIDogdHJ1ZTtcblxuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgVmlld3BvcnQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gVHJ1ZSBpZiBhbiBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocmVzb2x1dGlvbiwgZGlyZWN0aW9uLCBzaXplLCBpc01vdmluZykge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjYXBwZWRNYXhSZXMgPSBtYXhFeHRlbnRcbiAgICAgICAgICA/IGdldFZpZXdwb3J0Q2xhbXBlZFJlc29sdXRpb24oXG4gICAgICAgICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgICAgICAgIG1heEV4dGVudCxcbiAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgc2hvd0Z1bGxFeHRlbnQsXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBtYXhSZXNvbHV0aW9uO1xuXG4gICAgICAgIGlmICghc21vb3RoIHx8ICFpc01vdmluZykge1xuICAgICAgICAgIHJldHVybiBjbGFtcChyZXNvbHV0aW9uLCBtaW5SZXNvbHV0aW9uLCBjYXBwZWRNYXhSZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTbW9vdGhDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgIGNhcHBlZE1heFJlcyxcbiAgICAgICAgICBtaW5SZXNvbHV0aW9uLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JvdGF0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBib29sZWFuPSk6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZShyb3RhdGlvbikge1xuICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uZShyb3RhdGlvbikge1xuICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIE4uXG4gKiBAcmV0dXJuIHtUeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvTihuKSB7XG4gIGNvbnN0IHRoZXRhID0gKDIgKiBNYXRoLlBJKSAvIG47XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01vdmluZ10gVHJ1ZSBpZiBhbiBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJvdGF0aW9uLCBpc01vdmluZykge1xuICAgICAgaWYgKGlzTW92aW5nKSB7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm90YXRpb24gPSBNYXRoLmZsb29yKHJvdGF0aW9uIC8gdGhldGEgKyAwLjUpICogdGhldGE7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdG9sZXJhbmNlXSBUb2xlcmFuY2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvWmVybyh0b2xlcmFuY2UpIHtcbiAgY29uc3QgdCA9IHRvbGVyYW5jZSA9PT0gdW5kZWZpbmVkID8gdG9SYWRpYW5zKDUpIDogdG9sZXJhbmNlO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb3ZpbmddIFRydWUgaWYgYW4gaW50ZXJhY3Rpb24gb3IgYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb3RhdGlvbiwgaXNNb3ZpbmcpIHtcbiAgICAgIGlmIChpc01vdmluZyB8fCByb3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uKSA8PSB0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgIH1cbiAgKTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZWFzaW5nXG4gKi9cblxuLyoqXG4gKiBTdGFydCBzbG93IGFuZCBzcGVlZCB1cC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhc2VJbih0KSB7XG4gIHJldHVybiBNYXRoLnBvdyh0LCAzKTtcbn1cblxuLyoqXG4gKiBTdGFydCBmYXN0IGFuZCBzbG93IGRvd24uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYXNlT3V0KHQpIHtcbiAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHQpO1xufVxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgdGhlbiBzbG93IGRvd24gYWdhaW4uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbkFuZE91dCh0KSB7XG4gIHJldHVybiAzICogdCAqIHQgLSAyICogdCAqIHQgKiB0O1xufVxuXG4vKipcbiAqIE1haW50YWluIGEgY29uc3RhbnQgc3BlZWQgb3ZlciB0aW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuIHQ7XG59XG5cbi8qKlxuICogU3RhcnQgc2xvdywgc3BlZWQgdXAsIGFuZCBhdCB0aGUgdmVyeSBlbmQgc2xvdyBkb3duIGFnYWluLiAgVGhpcyBoYXMgdGhlXG4gKiBzYW1lIGdlbmVyYWwgYmVoYXZpb3IgYXMge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmcuaW5BbmRPdXR9LCBidXQgdGhlIGZpbmFsXG4gKiBzbG93ZG93biBpcyBkZWxheWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBBbmREb3duKHQpIHtcbiAgaWYgKHQgPCAwLjUpIHtcbiAgICByZXR1cm4gaW5BbmRPdXQoMiAqIHQpO1xuICB9XG4gIHJldHVybiAxIC0gaW5BbmRPdXQoMiAqICh0IC0gMC41KSk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3RyYW5zZm9ybVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBBbiBhcnJheSByZXByZXNlbnRpbmcgYW4gYWZmaW5lIDJkIHRyYW5zZm9ybWF0aW9uIGZvciB1c2Ugd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC90cmFuc2Zvcm19IGZ1bmN0aW9ucy4gVGhlIGFycmF5IGhhcyA2IGVsZW1lbnRzLlxuICogQHR5cGVkZWYgeyFBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgYWZmaW5lIDJkIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucy4gVGhlIGZ1bmN0aW9ucyB3b3JrIG9uIGFuXG4gKiBhcnJheSBvZiA2IGVsZW1lbnRzLiBUaGUgZWxlbWVudCBvcmRlciBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFtTVkdNYXRyaXhcbiAqIGludGVyZmFjZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR01hdHJpeCkgYW5kIGlzXG4gKiBhIHN1YnNldCAoZWxlbWVudHMgYSB0byBmKSBvZiBhIDNcdTAwRDczIG1hdHJpeDpcbiAqIGBgYFxuICogWyBhIGMgZSBdXG4gKiBbIGIgZCBmIF1cbiAqIFsgMCAwIDEgXVxuICogYGBgXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge1RyYW5zZm9ybX1cbiAqL1xuY29uc3QgdG1wXyA9IG5ldyBBcnJheSg2KTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaWRlbnRpdHkgdHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gSWRlbnRpdHkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIHRvIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHRyYW5zZm9ybSkge1xuICByZXR1cm4gc2V0KHRyYW5zZm9ybSwgMSwgMCwgMCwgMSwgMCwgMCk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIHVuZGVybHlpbmcgbWF0cmljZXMgb2YgdHdvIHRyYW5zZm9ybXMgYW5kIHJldHVybiB0aGUgcmVzdWx0IGluXG4gKiB0aGUgZmlyc3QgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIFRyYW5zZm9ybSBwYXJhbWV0ZXJzIG9mIG1hdHJpeCAxLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0yIFRyYW5zZm9ybSBwYXJhbWV0ZXJzIG9mIG1hdHJpeCAyLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBtdWx0aXBsaWVkIHdpdGggdHJhbnNmb3JtMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgY29uc3QgYTEgPSB0cmFuc2Zvcm0xWzBdO1xuICBjb25zdCBiMSA9IHRyYW5zZm9ybTFbMV07XG4gIGNvbnN0IGMxID0gdHJhbnNmb3JtMVsyXTtcbiAgY29uc3QgZDEgPSB0cmFuc2Zvcm0xWzNdO1xuICBjb25zdCBlMSA9IHRyYW5zZm9ybTFbNF07XG4gIGNvbnN0IGYxID0gdHJhbnNmb3JtMVs1XTtcbiAgY29uc3QgYTIgPSB0cmFuc2Zvcm0yWzBdO1xuICBjb25zdCBiMiA9IHRyYW5zZm9ybTJbMV07XG4gIGNvbnN0IGMyID0gdHJhbnNmb3JtMlsyXTtcbiAgY29uc3QgZDIgPSB0cmFuc2Zvcm0yWzNdO1xuICBjb25zdCBlMiA9IHRyYW5zZm9ybTJbNF07XG4gIGNvbnN0IGYyID0gdHJhbnNmb3JtMls1XTtcblxuICB0cmFuc2Zvcm0xWzBdID0gYTEgKiBhMiArIGMxICogYjI7XG4gIHRyYW5zZm9ybTFbMV0gPSBiMSAqIGEyICsgZDEgKiBiMjtcbiAgdHJhbnNmb3JtMVsyXSA9IGExICogYzIgKyBjMSAqIGQyO1xuICB0cmFuc2Zvcm0xWzNdID0gYjEgKiBjMiArIGQxICogZDI7XG4gIHRyYW5zZm9ybTFbNF0gPSBhMSAqIGUyICsgYzEgKiBmMiArIGUxO1xuICB0cmFuc2Zvcm0xWzVdID0gYjEgKiBlMiArIGQxICogZjIgKyBmMTtcblxuICByZXR1cm4gdHJhbnNmb3JtMTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHRyYW5zZm9ybSBjb21wb25lbnRzIGEtZiBvbiBhIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBhIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIGIgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYyBUaGUgYyBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkIFRoZSBkIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGUgVGhlIGUgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZiBUaGUgZiBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IE1hdHJpeCB3aXRoIHRyYW5zZm9ybSBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRyYW5zZm9ybSwgYSwgYiwgYywgZCwgZSwgZikge1xuICB0cmFuc2Zvcm1bMF0gPSBhO1xuICB0cmFuc2Zvcm1bMV0gPSBiO1xuICB0cmFuc2Zvcm1bMl0gPSBjO1xuICB0cmFuc2Zvcm1bM10gPSBkO1xuICB0cmFuc2Zvcm1bNF0gPSBlO1xuICB0cmFuc2Zvcm1bNV0gPSBmO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIFNldCB0cmFuc2Zvcm0gb24gb25lIG1hdHJpeCBmcm9tIGFub3RoZXIgbWF0cml4LlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIHRvLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0yIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIGZyb20uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIHdpdGggdHJhbnNmb3JtIGZyb20gdHJhbnNmb3JtMiBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RnJvbUFycmF5KHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgdHJhbnNmb3JtMVswXSA9IHRyYW5zZm9ybTJbMF07XG4gIHRyYW5zZm9ybTFbMV0gPSB0cmFuc2Zvcm0yWzFdO1xuICB0cmFuc2Zvcm0xWzJdID0gdHJhbnNmb3JtMlsyXTtcbiAgdHJhbnNmb3JtMVszXSA9IHRyYW5zZm9ybTJbM107XG4gIHRyYW5zZm9ybTFbNF0gPSB0cmFuc2Zvcm0yWzRdO1xuICB0cmFuc2Zvcm0xWzVdID0gdHJhbnNmb3JtMls1XTtcbiAgcmV0dXJuIHRyYW5zZm9ybTE7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm0gcmV0dXJuaW5nIHRoZVxuICogcmVzdWx0aW5nLCB0cmFuc2Zvcm1lZCBjb29yZGluYXRlLiBUaGUgY29vcmRpbmF0ZSB3aWxsIGJlIG1vZGlmaWVkIGluLXBsYWNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfGltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHJldHVybiBjb29yZGluYXRlIHNvIHRoYXQgb3BlcmF0aW9ucyBjYW4gYmVcbiAqICAgICBjaGFpbmVkIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkodHJhbnNmb3JtLCBjb29yZGluYXRlKSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgY29vcmRpbmF0ZVswXSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdO1xuICBjb29yZGluYXRlWzFdID0gdHJhbnNmb3JtWzFdICogeCArIHRyYW5zZm9ybVszXSAqIHkgKyB0cmFuc2Zvcm1bNV07XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgcm90YXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHJvdGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKHRyYW5zZm9ybSwgYW5nbGUpIHtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCBjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwKSk7XG59XG5cbi8qKlxuICogQXBwbGllcyBzY2FsZSB0byBhIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjYWxlIGZhY3RvciB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgc2NhbGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgeCwgeSkge1xuICByZXR1cm4gbXVsdGlwbHkodHJhbnNmb3JtLCBzZXQodG1wXywgeCwgMCwgMCwgeSwgMCwgMCkpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzY2FsZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRhcmdldCBUcmFuc2Zvcm0gdG8gb3ZlcndyaXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBTY2FsZSBmYWN0b3IgeS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBzY2FsZSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2NhbGUodGFyZ2V0LCB4LCB5KSB7XG4gIHJldHVybiBzZXQodGFyZ2V0LCB4LCAwLCAwLCB5LCAwLCAwKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRyYW5zbGF0aW9uIHRvIHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZHggVHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeSBUcmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHRyYW5zbGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgZHgsIGR5KSB7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCAxLCAwLCAwLCAxLCBkeCwgZHkpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcG9zaXRlIHRyYW5zZm9ybSBnaXZlbiBhbiBpbml0aWFsIHRyYW5zbGF0aW9uLCBzY2FsZSwgcm90YXRpb24sIGFuZFxuICogZmluYWwgdHJhbnNsYXRpb24gKGluIHRoYXQgb3JkZXIgb25seSwgbm90IGNvbW11dGF0aXZlKS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRoZSB0cmFuc2Zvcm0gKHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MSBJbml0aWFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkxIEluaXRpYWwgdHJhbnNsYXRpb24geS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiAoaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgyIEZpbmFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkyIEZpbmFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgY29tcG9zaXRlIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2UodHJhbnNmb3JtLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHRyYW5zZm9ybVswXSA9IHN4ICogY29zO1xuICB0cmFuc2Zvcm1bMV0gPSBzeSAqIHNpbjtcbiAgdHJhbnNmb3JtWzJdID0gLXN4ICogc2luO1xuICB0cmFuc2Zvcm1bM10gPSBzeSAqIGNvcztcbiAgdHJhbnNmb3JtWzRdID0gZHgyICogc3ggKiBjb3MgLSBkeTIgKiBzeCAqIHNpbiArIGR4MTtcbiAgdHJhbnNmb3JtWzVdID0gZHgyICogc3kgKiBzaW4gKyBkeTIgKiBzeSAqIGNvcyArIGR5MTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcG9zaXRlIHRyYW5zZm9ybSBnaXZlbiBhbiBpbml0aWFsIHRyYW5zbGF0aW9uLCBzY2FsZSwgcm90YXRpb24sIGFuZFxuICogZmluYWwgdHJhbnNsYXRpb24gKGluIHRoYXQgb3JkZXIgb25seSwgbm90IGNvbW11dGF0aXZlKS4gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1cbiAqIHN0cmluZyBjYW4gYmUgYXBwbGllZCBhcyBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBvZiBhbiBIVE1MRWxlbWVudCdzIHN0eWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MSBJbml0aWFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkxIEluaXRpYWwgdHJhbnNsYXRpb24geS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiAoaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgyIEZpbmFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkyIEZpbmFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wb3NpdGUgY3NzIHRyYW5zZm9ybS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VDc3NUcmFuc2Zvcm0oZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKSB7XG4gIHJldHVybiB0b1N0cmluZyhjb21wb3NlKGNyZWF0ZSgpLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpKTtcbn1cblxuLyoqXG4gKiBJbnZlcnQgdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gc291cmNlIFRoZSBzb3VyY2UgdHJhbnNmb3JtIHRvIGludmVydC5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBpbnZlcnRlZCAoc291cmNlKSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQoc291cmNlKSB7XG4gIHJldHVybiBtYWtlSW52ZXJzZShzb3VyY2UsIHNvdXJjZSk7XG59XG5cbi8qKlxuICogSW52ZXJ0IHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRhcmdldCBUcmFuc2Zvcm0gdG8gYmUgc2V0IGFzIHRoZSBpbnZlcnNlIG9mXG4gKiAgICAgdGhlIHNvdXJjZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHNvdXJjZSBUaGUgc291cmNlIHRyYW5zZm9ybSB0byBpbnZlcnQuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgaW52ZXJ0ZWQgKHRhcmdldCkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUludmVyc2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgY29uc3QgZGV0ID0gZGV0ZXJtaW5hbnQoc291cmNlKTtcbiAgYXNzZXJ0KGRldCAhPT0gMCwgJ1RyYW5zZm9ybWF0aW9uIG1hdHJpeCBjYW5ub3QgYmUgaW52ZXJ0ZWQnKTtcblxuICBjb25zdCBhID0gc291cmNlWzBdO1xuICBjb25zdCBiID0gc291cmNlWzFdO1xuICBjb25zdCBjID0gc291cmNlWzJdO1xuICBjb25zdCBkID0gc291cmNlWzNdO1xuICBjb25zdCBlID0gc291cmNlWzRdO1xuICBjb25zdCBmID0gc291cmNlWzVdO1xuXG4gIHRhcmdldFswXSA9IGQgLyBkZXQ7XG4gIHRhcmdldFsxXSA9IC1iIC8gZGV0O1xuICB0YXJnZXRbMl0gPSAtYyAvIGRldDtcbiAgdGFyZ2V0WzNdID0gYSAvIGRldDtcbiAgdGFyZ2V0WzRdID0gKGMgKiBmIC0gZCAqIGUpIC8gZGV0O1xuICB0YXJnZXRbNV0gPSAtKGEgKiBmIC0gYiAqIGUpIC8gZGV0O1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gbWF0IE1hdHJpeC5cbiAqIEByZXR1cm4ge251bWJlcn0gRGV0ZXJtaW5hbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtYXQpIHtcbiAgcmV0dXJuIG1hdFswXSAqIG1hdFszXSAtIG1hdFsxXSAqIG1hdFsyXTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbmNvbnN0IG1hdHJpeFByZWNpc2lvbiA9IFsxZTYsIDFlNiwgMWU2LCAxZTYsIDIsIDJdO1xuXG4vKipcbiAqIEEgcm91bmRlZCBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgdHJhbnNmb3JtLiAgVGhpcyBjYW4gYmUgdXNlZFxuICogZm9yIENTUyB0cmFuc2Zvcm1zLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSBtYXQgTWF0cml4LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtIGFzIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcobWF0KSB7XG4gIGNvbnN0IHRyYW5zZm9ybVN0cmluZyA9XG4gICAgJ21hdHJpeCgnICtcbiAgICBtYXRcbiAgICAgIC5tYXAoXG4gICAgICAgICh2YWx1ZSwgaSkgPT5cbiAgICAgICAgICBNYXRoLnJvdW5kKHZhbHVlICogbWF0cml4UHJlY2lzaW9uW2ldKSAvIG1hdHJpeFByZWNpc2lvbltpXSxcbiAgICAgIClcbiAgICAgIC5qb2luKCcsICcpICtcbiAgICAnKSc7XG4gIHJldHVybiB0cmFuc2Zvcm1TdHJpbmc7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC90cmFuc2Zvcm1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVzdGluYXRpb25TdHJpZGVdIFN0cmlkZSBvZiBkZXN0aW5hdGlvbiBjb29yZGluYXRlczsgaWYgdW5zcGVjaWZpZWQsIGFzc3VtZWQgdG8gYmUgMi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtMkQoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgdHJhbnNmb3JtLFxuICBkZXN0LFxuICBkZXN0aW5hdGlvblN0cmlkZSxcbikge1xuICBkZXN0ID0gZGVzdCA/IGRlc3QgOiBbXTtcbiAgZGVzdGluYXRpb25TdHJpZGUgPSBkZXN0aW5hdGlvblN0cmlkZSA/IGRlc3RpbmF0aW9uU3RyaWRlIDogMjtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHggPSBmbGF0Q29vcmRpbmF0ZXNbal07XG4gICAgY29uc3QgeSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV07XG4gICAgZGVzdFtpKytdID0gdHJhbnNmb3JtWzBdICogeCArIHRyYW5zZm9ybVsyXSAqIHkgKyB0cmFuc2Zvcm1bNF07XG4gICAgZGVzdFtpKytdID0gdHJhbnNmb3JtWzFdICogeCArIHRyYW5zZm9ybVszXSAqIHkgKyB0cmFuc2Zvcm1bNV07XG5cbiAgICBmb3IgKGxldCBrID0gMjsgayA8IGRlc3RpbmF0aW9uU3RyaWRlOyBrKyspIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1tqICsga107XG4gICAgfVxuICB9XG5cbiAgaWYgKGRlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgUm90YXRpb24gYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBhbmdsZSxcbiAgYW5jaG9yLFxuICBkZXN0LFxuKSB7XG4gIGRlc3QgPSBkZXN0ID8gZGVzdCA6IFtdO1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgY29uc3QgYW5jaG9yWCA9IGFuY2hvclswXTtcbiAgY29uc3QgYW5jaG9yWSA9IGFuY2hvclsxXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IGRlbHRhWCA9IGZsYXRDb29yZGluYXRlc1tqXSAtIGFuY2hvclg7XG4gICAgY29uc3QgZGVsdGFZID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSAtIGFuY2hvclk7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWCArIGRlbHRhWCAqIGNvcyAtIGRlbHRhWSAqIHNpbjtcbiAgICBkZXN0W2krK10gPSBhbmNob3JZICsgZGVsdGFYICogc2luICsgZGVsdGFZICogY29zO1xuICAgIGZvciAobGV0IGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIFNjYWxlIHRoZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggU2NhbGUgZmFjdG9yIGluIHRoZSB4LWRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgaW4gdGhlIHktZGlyZWN0aW9uLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgU2NhbGUgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHN4LFxuICBzeSxcbiAgYW5jaG9yLFxuICBkZXN0LFxuKSB7XG4gIGRlc3QgPSBkZXN0ID8gZGVzdCA6IFtdO1xuICBjb25zdCBhbmNob3JYID0gYW5jaG9yWzBdO1xuICBjb25zdCBhbmNob3JZID0gYW5jaG9yWzFdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgZGVsdGFYID0gZmxhdENvb3JkaW5hdGVzW2pdIC0gYW5jaG9yWDtcbiAgICBjb25zdCBkZWx0YVkgPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdIC0gYW5jaG9yWTtcbiAgICBkZXN0W2krK10gPSBhbmNob3JYICsgc3ggKiBkZWx0YVg7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIHN5ICogZGVsdGFZO1xuICAgIGZvciAobGV0IGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIERlbHRhIFguXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGRlbHRhWCxcbiAgZGVsdGFZLFxuICBkZXN0LFxuKSB7XG4gIGRlc3QgPSBkZXN0ID8gZGVzdCA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2pdICsgZGVsdGFYO1xuICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gKyBkZWx0YVk7XG4gICAgZm9yIChsZXQgayA9IGogKyAyOyBrIDwgaiArIHN0cmlkZTsgKytrKSB7XG4gICAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNba107XG4gICAgfVxuICB9XG4gIGlmIChkZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vR2VvbWV0cnlcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxufSBmcm9tICcuLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlRW1wdHksXG4gIGNyZWF0ZU9yVXBkYXRlRW1wdHksXG4gIGdldEhlaWdodCxcbiAgcmV0dXJuT3JVcGRhdGUsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9uLCBnZXRUcmFuc2Zvcm19IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHttZW1vaXplT25lfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydYWScgfCAnWFlaJyB8ICdYWU0nIHwgJ1hZWk0nfSBHZW9tZXRyeUxheW91dFxuICogVGhlIGNvb3JkaW5hdGUgbGF5b3V0IGZvciBnZW9tZXRyaWVzLCBpbmRpY2F0aW5nIHdoZXRoZXIgYSAzcmQgb3IgNHRoIHogKCdaJylcbiAqIG9yIG1lYXN1cmUgKCdNJykgY29vcmRpbmF0ZSBpcyBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J1BvaW50JyB8ICdMaW5lU3RyaW5nJyB8ICdMaW5lYXJSaW5nJyB8ICdQb2x5Z29uJyB8ICdNdWx0aVBvaW50JyB8ICdNdWx0aUxpbmVTdHJpbmcnIHwgJ011bHRpUG9seWdvbicgfCAnR2VvbWV0cnlDb2xsZWN0aW9uJyB8ICdDaXJjbGUnfSBUeXBlXG4gKiBUaGUgZ2VvbWV0cnkgdHlwZS4gIE9uZSBvZiBgJ1BvaW50J2AsIGAnTGluZVN0cmluZydgLCBgJ0xpbmVhclJpbmcnYCxcbiAqIGAnUG9seWdvbidgLCBgJ011bHRpUG9pbnQnYCwgYCdNdWx0aUxpbmVTdHJpbmcnYCwgYCdNdWx0aVBvbHlnb24nYCxcbiAqIGAnR2VvbWV0cnlDb2xsZWN0aW9uJ2AsIG9yIGAnQ2lyY2xlJ2AuXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAqL1xuY29uc3QgdG1wVHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIGdlb21ldHJpZXMuXG4gKlxuICogVG8gZ2V0IG5vdGlmaWVkIG9mIGNoYW5nZXMgdG8gdGhlIGdlb21ldHJ5LCByZWdpc3RlciBhIGxpc3RlbmVyIGZvciB0aGVcbiAqIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgb24geW91ciBnZW9tZXRyeSBpbnN0YW5jZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgR2VvbWV0cnkgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgdHJhbnNmb3JtZWQgYW5kIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGUgZ2VvbWV0cnkuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJldmlzaW9uIFRoZSBnZW9tZXRyeSByZXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IFt0cmFuc2Zvcm1dIE9wdGlvbmFsIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtHZW9tZXRyeX0gU2ltcGxpZmllZCBnZW9tZXRyeS5cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZ5VHJhbnNmb3JtZWRJbnRlcm5hbCA9IG1lbW9pemVPbmUoXG4gICAgICAocmV2aXNpb24sIHNxdWFyZWRUb2xlcmFuY2UsIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY2xvbmUuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgcmV0dXJuIGNsb25lLmdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2Zvcm1lZCBhbmQgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IFt0cmFuc2Zvcm1dIE9wdGlvbmFsIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBzaW1wbGlmeVRyYW5zZm9ybWVkKHNxdWFyZWRUb2xlcmFuY2UsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0aGlzLnNpbXBsaWZ5VHJhbnNmb3JtZWRJbnRlcm5hbChcbiAgICAgIHRoaXMuZ2V0UmV2aXNpb24oKSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHshR2VvbWV0cnl9IENsb25lLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAqL1xuICBjb250YWluc1hZKHgsIHkpIHtcbiAgICBjb25zdCBjb29yZCA9IHRoaXMuZ2V0Q2xvc2VzdFBvaW50KFt4LCB5XSk7XG4gICAgcmV0dXJuIGNvb3JkWzBdID09PSB4ICYmIGNvb3JkWzFdID09PSB5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY2xvc2VzdCBwb2ludCBvZiB0aGUgZ2VvbWV0cnkgdG8gdGhlIHBhc3NlZCBwb2ludCBhc1xuICAgKiB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSBjb29yZGluYXRlfS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2Nsb3Nlc3RQb2ludF0gQ2xvc2VzdCBwb2ludC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDbG9zZXN0IHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDbG9zZXN0UG9pbnQocG9pbnQsIGNsb3Nlc3RQb2ludCkge1xuICAgIGNsb3Nlc3RQb2ludCA9IGNsb3Nlc3RQb2ludCA/IGNsb3Nlc3RQb2ludCA6IFtOYU4sIE5hTl07XG4gICAgdGhpcy5jbG9zZXN0UG9pbnRYWShwb2ludFswXSwgcG9pbnRbMV0sIGNsb3Nlc3RQb2ludCwgSW5maW5pdHkpO1xuICAgIHJldHVybiBjbG9zZXN0UG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZ2VvbWV0cnkgaW5jbHVkZXMgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlLiBJZiB0aGVcbiAgICogY29vcmRpbmF0ZSBpcyBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGdlb21ldHJ5LCByZXR1cm5zIGZhbHNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBpbnRlcnNlY3RzQ29vcmRpbmF0ZShjb29yZGluYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNYWShjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV4dGVudChleHRlbnQpIHtcbiAgICBpZiAodGhpcy5leHRlbnRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICBjb25zdCBleHRlbnQgPSB0aGlzLmNvbXB1dGVFeHRlbnQodGhpcy5leHRlbnRfKTtcbiAgICAgIGlmIChpc05hTihleHRlbnRbMF0pIHx8IGlzTmFOKGV4dGVudFsxXSkpIHtcbiAgICAgICAgY3JlYXRlT3JVcGRhdGVFbXB0eShleHRlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5leHRlbnRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5PclVwZGF0ZSh0aGlzLmV4dGVudF8sIGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlIHRoZSBnZW9tZXRyeSBhcm91bmQgYSBnaXZlbiBjb29yZGluYXRlLiBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIHJvdGF0ZShhbmdsZSwgYW5jaG9yKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgZ2VvbWV0cnkgKHdpdGggYW4gb3B0aW9uYWwgb3JpZ2luKS4gIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5XG4gICAqIGNvb3JkaW5hdGVzIGluIHBsYWNlLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3ldIFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeS1kaXJlY3Rpb24gKGRlZmF1bHRzIHRvIHN4KS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBzY2FsZSBvcmlnaW4gKGRlZmF1bHRzIHRvIHRoZSBjZW50ZXJcbiAgICogICAgIG9mIHRoZSBnZW9tZXRyeSBleHRlbnQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBzY2FsZShzeCwgc3ksIGFuY2hvcikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoaXMgZ2VvbWV0cnkuICBGb3IgbGluZXN0cmluZ3MsIHRoaXMgdXNlc1xuICAgKiB0aGUgW0RvdWdsYXMgUGV1Y2tlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSlcbiAgICogYWxnb3JpdGhtLiAgRm9yIHBvbHlnb25zLCBhIHF1YW50aXphdGlvbi1iYXNlZFxuICAgKiBzaW1wbGlmaWNhdGlvbiBpcyB1c2VkIHRvIHByZXNlcnZlIHRvcG9sb2d5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRoZSB0b2xlcmFuY2UgZGlzdGFuY2UgZm9yIHNpbXBsaWZpY2F0aW9uLlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeX0gQSBuZXcsIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNpbXBsaWZ5KHRvbGVyYW5jZSkge1xuICAgIHJldHVybiB0aGlzLmdldFNpbXBsaWZpZWRHZW9tZXRyeSh0b2xlcmFuY2UgKiB0b2xlcmFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGlzIGdlb21ldHJ5IHVzaW5nIHRoZSBEb3VnbGFzIFBldWNrZXJcbiAgICogYWxnb3JpdGhtLlxuICAgKiBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeX0gU2ltcGxpZmllZCBnZW9tZXRyeS5cbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0eXBlIG9mIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtUeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICogQ2FsbGVkIHdpdGggYSBmbGF0IGFycmF5IG9mIGdlb21ldHJ5IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIGdlb21ldHJ5LiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgaW4gcGxhY2UuICBJZlxuICAgKiBpbnN0ZWFkIHlvdSB3YW50IGEgbmV3IGdlb21ldHJ5LCBmaXJzdCBgY2xvbmUoKWAgdGhpcyBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggRGVsdGEgWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2xhdGUoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5IGZyb20gb25lIGNvb3JkaW5hdGUgcmVmZXJlbmNlXG4gICAqIHN5c3RlbSB0byBhbm90aGVyLiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIEZvciBleGFtcGxlLCBhIGxpbmUgd2lsbCBiZSB0cmFuc2Zvcm1lZCB0byBhIGxpbmUgYW5kIGEgY2lyY2xlIHRvIGEgY2lyY2xlLlxuICAgKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBgY2xvbmUoKWAgaXQgYW5kXG4gICAqIHRoZW4gdXNlIHRoaXMgZnVuY3Rpb24gb24gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHNvdXJjZSBUaGUgY3VycmVudCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAgICogICAgIHN0cmluZyBpZGVudGlmaWVyIG9yIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIFRoZSBkZXNpcmVkIHByb2plY3Rpb24uICBDYW4gYmUgYVxuICAgKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gICAqIEByZXR1cm4ge3RoaXN9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovXG4gICAgY29uc3Qgc291cmNlUHJvaiA9IGdldFByb2plY3Rpb24oc291cmNlKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9XG4gICAgICBzb3VyY2VQcm9qLmdldFVuaXRzKCkgPT0gJ3RpbGUtcGl4ZWxzJ1xuICAgICAgICA/IGZ1bmN0aW9uIChpbkNvb3JkaW5hdGVzLCBvdXRDb29yZGluYXRlcywgc3RyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbEV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ZWRFeHRlbnQgPSBzb3VyY2VQcm9qLmdldFdvcmxkRXh0ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IGdldEhlaWdodChwcm9qZWN0ZWRFeHRlbnQpIC8gZ2V0SGVpZ2h0KHBpeGVsRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgIHRtcFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgcHJvamVjdGVkRXh0ZW50WzBdLFxuICAgICAgICAgICAgICBwcm9qZWN0ZWRFeHRlbnRbM10sXG4gICAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgICAtc2NhbGUsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJhbnNmb3JtMkQoXG4gICAgICAgICAgICAgIGluQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIGluQ29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgIHRtcFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgb3V0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGdldFRyYW5zZm9ybShzb3VyY2VQcm9qLCBkZXN0aW5hdGlvbikoXG4gICAgICAgICAgICAgIGluQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgIG91dENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBnZXRUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb21ldHJ5O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1NpbXBsZUdlb21ldHJ5XG4gKi9cbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuL0dlb21ldHJ5LmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMsIGdldENlbnRlcn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7cm90YXRlLCBzY2FsZSwgdHJhbnNmb3JtMkQsIHRyYW5zbGF0ZX0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzOyBkbyBub3QgaW5zdGFudGlhdGVcbiAqIGluIGFwcHMsIGFzIGNhbm5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU2ltcGxlR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9XG4gICAgICovXG4gICAgdGhpcy5sYXlvdXQgPSAnWFknO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdHJpZGUgPSAyO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbXB1dGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgZXh0ZW50LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PCo+IHwgbnVsbH0gQ29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpcnN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRGbGF0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBMYXN0IHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggLSB0aGlzLnN0cmlkZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIGltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXQgbGF5b3V0fSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeSB1c2luZyB0aGUgRG91Z2xhcyBQZXVja2VyIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1NpbXBsZUdlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgaWYgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gIT09IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gMDtcbiAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIC8vIElmIHNxdWFyZWRUb2xlcmFuY2UgaXMgbmVnYXRpdmUgb3IgaWYgd2Uga25vdyB0aGF0IHNpbXBsaWZpY2F0aW9uIHdpbGwgbm90XG4gICAgLy8gaGF2ZSBhbnkgZWZmZWN0IHRoZW4ganVzdCByZXR1cm4gdGhpcy5cbiAgICBpZiAoXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlIDwgMCB8fFxuICAgICAgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSAhPT0gMCAmJlxuICAgICAgICBzcXVhcmVkVG9sZXJhbmNlIDw9IHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHNpbXBsaWZpZWRHZW9tZXRyeSA9XG4gICAgICB0aGlzLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGlmaWVkR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIDwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2ltcGxpZmllZEdlb21ldHJ5O1xuICAgIH1cbiAgICAvLyBTaW1wbGlmaWNhdGlvbiBkaWQgbm90IGFjdHVhbGx5IHJlbW92ZSBhbnkgY29vcmRpbmF0ZXMuICBXZSBub3cga25vd1xuICAgIC8vIHRoYXQgYW55IGNhbGxzIHRvIGdldFNpbXBsaWZpZWRHZW9tZXRyeSB3aXRoIGEgc3F1YXJlZFRvbGVyYW5jZSBsZXNzXG4gICAgLy8gdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBzcXVhcmVkVG9sZXJhbmNlIHdpbGwgYWxzbyBub3QgaGF2ZSBhbnlcbiAgICAvLyBlZmZlY3QuICBUaGlzIGFsbG93cyB1cyB0byBzaG9ydCBjaXJjdWl0IHNpbXBsaWZpY2F0aW9uIChzYXZpbmcgQ1BVXG4gICAgLy8gY3ljbGVzKSBhbmQgcHJldmVudHMgdGhlIGNhY2hlIG9mIHNpbXBsaWZpZWQgZ2VvbWV0cmllcyBmcm9tIGZpbGxpbmdcbiAgICAvLyB1cCB3aXRoIHVzZWxlc3MgaWRlbnRpY2FsIGNvcGllcyBvZiB0aGlzIGdlb21ldHJ5IChzYXZpbmcgbWVtb3J5KS5cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSBzcXVhcmVkVG9sZXJhbmNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtTaW1wbGVHZW9tZXRyeX0gU2ltcGxpZmllZCBnZW9tZXRyeS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gU3RyaWRlLlxuICAgKi9cbiAgZ2V0U3RyaWRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmlkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBzZXRGbGF0Q29vcmRpbmF0ZXMobGF5b3V0LCBmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICB0aGlzLnN0cmlkZSA9IGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpO1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fHVuZGVmaW5lZH0gbGF5b3V0IExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXN0aW5nIE5lc3RpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCBuZXN0aW5nKSB7XG4gICAgbGV0IHN0cmlkZTtcbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBzdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQobGF5b3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXN0aW5nOyArK2kpIHtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubGF5b3V0ID0gJ1hZJztcbiAgICAgICAgICB0aGlzLnN0cmlkZSA9IDI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtBcnJheTx1bmtub3duPn0gKi8gKGNvb3JkaW5hdGVzWzBdKTtcbiAgICAgIH1cbiAgICAgIHN0cmlkZSA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGxheW91dCA9IGdldExheW91dEZvclN0cmlkZShzdHJpZGUpO1xuICAgIH1cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgKiBDYWxsZWQgd2l0aCBhIGZsYXQgYXJyYXkgb2YgZ2VvbWV0cnkgY29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIGlmICh0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdHJhbnNmb3JtRm4oXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgdGhpcy5sYXlvdXQuc3RhcnRzV2l0aCgnWFlaJykgPyAzIDogMixcbiAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiBhbmdsZSBpbiBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByb3RhdGUoYW5nbGUsIGFuY2hvcikge1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcykge1xuICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHJvdGF0ZShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAwLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGFuZ2xlLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhlIGdlb21ldHJ5ICh3aXRoIGFuIG9wdGlvbmFsIG9yaWdpbikuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3ldIFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeS1kaXJlY3Rpb24gKGRlZmF1bHRzIHRvIHN4KS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBzY2FsZSBvcmlnaW4gKGRlZmF1bHRzIHRvIHRoZSBjZW50ZXJcbiAgICogICAgIG9mIHRoZSBnZW9tZXRyeSBleHRlbnQpLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2NhbGUoc3gsIHN5LCBhbmNob3IpIHtcbiAgICBpZiAoc3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3kgPSBzeDtcbiAgICB9XG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIGFuY2hvciA9IGdldENlbnRlcih0aGlzLmdldEV4dGVudCgpKTtcbiAgICB9XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgc2NhbGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBzeCxcbiAgICAgICAgc3ksXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIGdlb21ldHJ5LiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgaW4gcGxhY2UuICBJZlxuICAgKiBpbnN0ZWFkIHlvdSB3YW50IGEgbmV3IGdlb21ldHJ5LCBmaXJzdCBgY2xvbmUoKWAgdGhpcyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0cmFuc2xhdGUoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICB0cmFuc2xhdGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWSxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExheW91dEZvclN0cmlkZShzdHJpZGUpIHtcbiAgbGV0IGxheW91dDtcbiAgaWYgKHN0cmlkZSA9PSAyKSB7XG4gICAgbGF5b3V0ID0gJ1hZJztcbiAgfSBlbHNlIGlmIChzdHJpZGUgPT0gMykge1xuICAgIGxheW91dCA9ICdYWVonO1xuICB9IGVsc2UgaWYgKHN0cmlkZSA9PSA0KSB7XG4gICAgbGF5b3V0ID0gJ1hZWk0nO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9ICovIChsYXlvdXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqIEByZXR1cm4ge251bWJlcn0gU3RyaWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaWRlRm9yTGF5b3V0KGxheW91dCkge1xuICBsZXQgc3RyaWRlO1xuICBpZiAobGF5b3V0ID09ICdYWScpIHtcbiAgICBzdHJpZGUgPSAyO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PSAnWFlaJyB8fCBsYXlvdXQgPT0gJ1hZTScpIHtcbiAgICBzdHJpZGUgPSAzO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PSAnWFlaTScpIHtcbiAgICBzdHJpZGUgPSA0O1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHN0cmlkZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaW1wbGVHZW9tZXRyeX0gc2ltcGxlR2VvbWV0cnkgU2ltcGxlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBmbGF0IGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtR2VvbTJEKHNpbXBsZUdlb21ldHJ5LCB0cmFuc2Zvcm0sIGRlc3QpIHtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gc2ltcGxlR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gIGlmICghZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3RyaWRlID0gc2ltcGxlR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gIHJldHVybiB0cmFuc2Zvcm0yRChcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgMCxcbiAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgIHN0cmlkZSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgZGVzdCxcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2ltcGxlR2VvbWV0cnk7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jbG9zZXN0XG4gKi9cbmltcG9ydCB7bGVycCwgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIDJEIGxpbmUgc2VnbWVudCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MV0gdG9cbiAqIGZsYXRDb29yZGluYXRlc1tvZmZzZXQyXSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHBvaW50ICh4LCB5KS4gIEV4dHJhXG4gKiBkaW1lbnNpb25zIGFyZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldDEgT2Zmc2V0IDEuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0MiBPZmZzZXQgMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICovXG5mdW5jdGlvbiBhc3NpZ25DbG9zZXN0KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldDEsXG4gIG9mZnNldDIsXG4gIHN0cmlkZSxcbiAgeCxcbiAgeSxcbiAgY2xvc2VzdFBvaW50LFxuKSB7XG4gIGNvbnN0IHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDFdO1xuICBjb25zdCB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxICsgMV07XG4gIGNvbnN0IGR4ID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIC0geDE7XG4gIGNvbnN0IGR5ID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDIgKyAxXSAtIHkxO1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQxO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldDI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBsZXJwKFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQxICsgaV0sXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldDIgKyBpXSxcbiAgICAgICAgICB0LFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0MTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgfVxuICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3F1YXJlZCBvZiB0aGUgbGFyZ2VzdCBkaXN0YW5jZSBiZXR3ZWVuIGFueSBwYWlyIG9mIGNvbnNlY3V0aXZlXG4gKiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG1heCkge1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBmb3IgKG9mZnNldCArPSBzdHJpZGU7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgY29uc3Qgc3F1YXJlZERlbHRhID0gc3F1YXJlZER4KHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoc3F1YXJlZERlbHRhID4gbWF4KSB7XG4gICAgICBtYXggPSBzcXVhcmVkRGVsdGE7XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBtYXgsXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBtYXggPSBtYXhTcXVhcmVkRGVsdGEoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBtYXgpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpQXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICBtYXgsXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBtYXggPSBhcnJheU1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBtYXgpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbdG1wUG9pbnRdIFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBtYXhEZWx0YSxcbiAgaXNSaW5nLFxuICB4LFxuICB5LFxuICBjbG9zZXN0UG9pbnQsXG4gIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgdG1wUG9pbnQsXG4pIHtcbiAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG4gIGxldCBpLCBzcXVhcmVkRGlzdGFuY2U7XG4gIGlmIChtYXhEZWx0YSA9PT0gMCkge1xuICAgIC8vIEFsbCBwb2ludHMgYXJlIGlkZW50aWNhbCwgc28ganVzdCB0ZXN0IHRoZSBmaXJzdCBwb2ludC5cbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLFxuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLFxuICAgICk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG4gIHRtcFBvaW50ID0gdG1wUG9pbnQgPyB0bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGxldCBpbmRleCA9IG9mZnNldCArIHN0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgYXNzaWduQ2xvc2VzdChcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIGluZGV4IC0gc3RyaWRlLFxuICAgICAgaW5kZXgsXG4gICAgICBzdHJpZGUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHRtcFBvaW50LFxuICAgICk7XG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KHgsIHksIHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IHRtcFBvaW50W2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIGluZGV4ICs9IHN0cmlkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2tpcCBhaGVhZCBtdWx0aXBsZSBwb2ludHMsIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFsbCB0aGUgc2tpcHBlZFxuICAgICAgLy8gcG9pbnRzIGNhbm5vdCBiZSBhbnkgY2xvc2VyIHRoYW4gdGhlIGNsb3Nlc3QgcG9pbnQgd2UgaGF2ZSBmb3VuZCBzb1xuICAgICAgLy8gZmFyLiAgV2Uga25vdyB0aGlzIGJlY2F1c2Ugd2Uga25vdyBob3cgY2xvc2UgdGhlIGN1cnJlbnQgcG9pbnQgaXMsIGhvd1xuICAgICAgLy8gY2xvc2UgdGhlIGNsb3Nlc3QgcG9pbnQgd2UgaGF2ZSBmb3VuZCBzbyBmYXIgaXMsIGFuZCB0aGUgbWF4aW11bVxuICAgICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBwb2ludHMuICBGb3IgZXhhbXBsZSwgaWYgd2UncmUgY3VycmVudGx5XG4gICAgICAvLyBhdCBkaXN0YW5jZSAxMCwgdGhlIGJlc3Qgd2UndmUgZm91bmQgc28gZmFyIGlzIDMsIGFuZCB0aGF0IHRoZSBtYXhpbXVtXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIHBvaW50cyBpcyAyLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2tpcCBhdFxuICAgICAgLy8gbGVhc3QgKDEwIC0gMykgLyAyID09IDMgKHJvdW5kZWQgZG93bikgcG9pbnRzIHRvIGhhdmUgYW55IGNoYW5jZSBvZlxuICAgICAgLy8gZmluZGluZyBhIGNsb3NlciBwb2ludC4gIFdlIHVzZSBNYXRoLm1heCguLi4sIDEpIHRvIGVuc3VyZSB0aGF0IHdlXG4gICAgICAvLyBhbHdheXMgYWR2YW5jZSBhdCBsZWFzdCBvbmUgcG9pbnQsIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICBpbmRleCArPVxuICAgICAgICBzdHJpZGUgKlxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAoKE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UpIC0gTWF0aC5zcXJ0KG1pblNxdWFyZWREaXN0YW5jZSkpIC9cbiAgICAgICAgICAgIG1heERlbHRhKSB8XG4gICAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChpc1JpbmcpIHtcbiAgICAvLyBDaGVjayB0aGUgY2xvc2luZyBzZWdtZW50LlxuICAgIGFzc2lnbkNsb3Nlc3QoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBlbmQgLSBzdHJpZGUsXG4gICAgICBvZmZzZXQsXG4gICAgICBzdHJpZGUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHRtcFBvaW50LFxuICAgICk7XG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KHgsIHksIHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IHRtcFBvaW50W2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3RtcFBvaW50XSBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgbWF4RGVsdGEsXG4gIGlzUmluZyxcbiAgeCxcbiAgeSxcbiAgY2xvc2VzdFBvaW50LFxuICBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gIHRtcFBvaW50LFxuKSB7XG4gIHRtcFBvaW50ID0gdG1wUG9pbnQgPyB0bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgbWluU3F1YXJlZERpc3RhbmNlID0gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgbWF4RGVsdGEsXG4gICAgICBpc1JpbmcsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgICAgIHRtcFBvaW50LFxuICAgICk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEZWx0YSBNYXggZGVsdGEuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmluZyBJcyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFt0bXBQb2ludF0gVGVtcG9yYXJ5IHBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduQ2xvc2VzdE11bHRpQXJyYXlQb2ludChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIG1heERlbHRhLFxuICBpc1JpbmcsXG4gIHgsXG4gIHksXG4gIGNsb3Nlc3RQb2ludCxcbiAgbWluU3F1YXJlZERpc3RhbmNlLFxuICB0bXBQb2ludCxcbikge1xuICB0bXBQb2ludCA9IHRtcFBvaW50ID8gdG1wUG9pbnQgOiBbTmFOLCBOYU5dO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kcyxcbiAgICAgIHN0cmlkZSxcbiAgICAgIG1heERlbHRhLFxuICAgICAgaXNSaW5nLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gICAgICB0bXBQb2ludCxcbiAgICApO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvZGVmbGF0ZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZUNvb3JkaW5hdGUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGNvb3JkaW5hdGUsIHN0cmlkZSkge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0KytdID0gY29vcmRpbmF0ZVtpXTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlcyhcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGNvb3JkaW5hdGVzLFxuICBzdHJpZGUsXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cmlkZTsgKytqKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0KytdID0gY29vcmRpbmF0ZVtqXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlc3MgQ29vcmRpbmF0ZXNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtlbmRzXSBFbmRzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgY29vcmRpbmF0ZXNzLFxuICBzdHJpZGUsXG4gIGVuZHMsXG4pIHtcbiAgZW5kcyA9IGVuZHMgPyBlbmRzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IDAsIGpqID0gY29vcmRpbmF0ZXNzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmQgPSBkZWZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBjb29yZGluYXRlc3Nbal0sXG4gICAgICBzdHJpZGUsXG4gICAgKTtcbiAgICBlbmRzW2krK10gPSBlbmQ7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIGVuZHMubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGVuZHM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IGNvb3JkaW5hdGVzc3MgQ29vcmRpbmF0ZXNzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gW2VuZHNzXSBFbmRzcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBFbmRzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBjb29yZGluYXRlc3NzLFxuICBzdHJpZGUsXG4gIGVuZHNzLFxuKSB7XG4gIGVuZHNzID0gZW5kc3MgPyBlbmRzcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIGNvbnN0IGVuZHMgPSBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNvb3JkaW5hdGVzc3Nbal0sXG4gICAgICBzdHJpZGUsXG4gICAgICBlbmRzc1tpXSxcbiAgICApO1xuICAgIGlmIChlbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZW5kc1swXSA9IG9mZnNldDtcbiAgICB9XG4gICAgZW5kc3NbaSsrXSA9IGVuZHM7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVuZHNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzcztcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5XG4gKi9cbi8vIEJhc2VkIG9uIHNpbXBsaWZ5LWpzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3NpbXBsaWZ5LWpzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTIsIFZsYWRpbWlyIEFnYWZvbmtpblxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy9cbi8vICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbi8vICAgICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vL1xuLy8gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbi8vIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbi8vIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4vLyBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4vLyBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuLy8gU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4vLyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuLy8gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbi8vIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4vLyBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtzcXVhcmVkRGlzdGFuY2UsIHNxdWFyZWRTZWdtZW50RGlzdGFuY2V9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlnaFF1YWxpdHkgSGlnaGVzdCBxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc10gU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBTaW1wbGlmaWVkIGxpbmUgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlMaW5lU3RyaW5nKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIGhpZ2hRdWFsaXR5LFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuKSB7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPVxuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgIT09IHVuZGVmaW5lZCA/IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgOiBbXTtcbiAgaWYgKCFoaWdoUXVhbGl0eSkge1xuICAgIGVuZCA9IHJhZGlhbERpc3RhbmNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICk7XG4gICAgZmxhdENvb3JkaW5hdGVzID0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcztcbiAgICBvZmZzZXQgPSAwO1xuICAgIHN0cmlkZSA9IDI7XG4gIH1cbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlcihcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgb2Zmc2V0LFxuICAgIGVuZCxcbiAgICBzdHJpZGUsXG4gICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgIDAsXG4gICk7XG4gIHJldHVybiBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXQsXG4pIHtcbiAgY29uc3QgbiA9IChlbmQgLSBvZmZzZXQpIC8gc3RyaWRlO1xuICBpZiAobiA8IDMpIHtcbiAgICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gIH1cbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBtYXJrZXJzID0gbmV3IEFycmF5KG4pO1xuICBtYXJrZXJzWzBdID0gMTtcbiAgbWFya2Vyc1tuIC0gMV0gPSAxO1xuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IHN0YWNrID0gW29mZnNldCwgZW5kIC0gc3RyaWRlXTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgZmlyc3QgPSBzdGFjay5wb3AoKTtcbiAgICBsZXQgbWF4U3F1YXJlZERpc3RhbmNlID0gMDtcbiAgICBjb25zdCB4MSA9IGZsYXRDb29yZGluYXRlc1tmaXJzdF07XG4gICAgY29uc3QgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZmlyc3QgKyAxXTtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tsYXN0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tsYXN0ICsgMV07XG4gICAgZm9yIChsZXQgaSA9IGZpcnN0ICsgc3RyaWRlOyBpIDwgbGFzdDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIGNvbnN0IHggPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICBjb25zdCB5ID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGNvbnN0IHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWRTZWdtZW50RGlzdGFuY2UoeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA+IG1heFNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIG1heFNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1heFNxdWFyZWREaXN0YW5jZSA+IHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICAgIG1hcmtlcnNbKGluZGV4IC0gb2Zmc2V0KSAvIHN0cmlkZV0gPSAxO1xuICAgICAgaWYgKGZpcnN0ICsgc3RyaWRlIDwgaW5kZXgpIHtcbiAgICAgICAgc3RhY2sucHVzaChmaXJzdCwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ICsgc3RyaWRlIDwgbGFzdCkge1xuICAgICAgICBzdGFjay5wdXNoKGluZGV4LCBsYXN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAobWFya2Vyc1tpXSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGkgKiBzdHJpZGVdO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGkgKiBzdHJpZGUgKyAxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRFbmRzIFNpbXBsaWZpZWQgZW5kcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBzcXVhcmVkVG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kcyxcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBkb3VnbGFzUGV1Y2tlcihcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgc2ltcGxpZmllZE9mZnNldCxcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXJNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbiAgc2ltcGxpZmllZEVuZHNzLFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IGRvdWdsYXNQZXVja2VyQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzLFxuICAgICAgc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBzaW1wbGlmaWVkT2Zmc2V0LFxuICAgICAgc2ltcGxpZmllZEVuZHMsXG4gICAgKTtcbiAgICBzaW1wbGlmaWVkRW5kc3MucHVzaChzaW1wbGlmaWVkRW5kcyk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbERpc3RhbmNlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXQsXG4pIHtcbiAgaWYgKGVuZCA8PSBvZmZzZXQgKyBzdHJpZGUpIHtcbiAgICAvLyB6ZXJvIG9yIG9uZSBwb2ludCwgbm8gc2ltcGxpZmljYXRpb24gcG9zc2libGUsIHNvIGNvcHkgYW5kIHJldHVyblxuICAgIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAvLyBjb3B5IGZpcnN0IHBvaW50XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgxO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MTtcbiAgbGV0IHgyID0geDE7XG4gIGxldCB5MiA9IHkxO1xuICBmb3IgKG9mZnNldCArPSBzdHJpZGU7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5MikgPiBzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgICAvLyBjb3B5IHBvaW50IGF0IG9mZnNldFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgfVxuICBpZiAoeDIgIT0geDEgfHwgeTIgIT0geTEpIHtcbiAgICAvLyBjb3B5IGxhc3QgcG9pbnRcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEByZXR1cm4ge251bWJlcn0gUm91bmRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXAodmFsdWUsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gdG9sZXJhbmNlICogTWF0aC5yb3VuZCh2YWx1ZSAvIHRvbGVyYW5jZSk7XG59XG5cbi8qKlxuICogU2ltcGxpZmllcyBhIGxpbmUgc3RyaW5nIHVzaW5nIGFuIGFsZ29yaXRobSBkZXNpZ25lZCBieSBUaW0gU2NoYXViLlxuICogQ29vcmRpbmF0ZXMgYXJlIHNuYXBwZWQgdG8gdGhlIG5lYXJlc3QgdmFsdWUgaW4gYSB2aXJ0dWFsIGdyaWQgYW5kXG4gKiBjb25zZWN1dGl2ZSBkdXBsaWNhdGUgY29vcmRpbmF0ZXMgYXJlIGRpc2NhcmRlZC4gIFRoaXMgZWZmZWN0aXZlbHkgcHJlc2VydmVzXG4gKiB0b3BvbG9neSBhcyB0aGUgc2ltcGxpZmljYXRpb24gb2YgYW55IHN1YnNlY3Rpb24gb2YgYSBsaW5lIHN0cmluZyBpc1xuICogaW5kZXBlbmRlbnQgb2YgdGhlIHJlc3Qgb2YgdGhlIGxpbmUgc3RyaW5nLiAgVGhpcyBtZWFucyB0aGF0LCBmb3IgZXhhbXBsZXMsXG4gKiB0aGUgY29tbW9uIGVkZ2UgYmV0d2VlbiB0d28gcG9seWdvbnMgd2lsbCBiZSBzaW1wbGlmaWVkIHRvIHRoZSBzYW1lIGxpbmVcbiAqIHN0cmluZyBpbmRlcGVuZGVudGx5IGluIGJvdGggcG9seWdvbnMuICBUaGlzIGltcGxlbWVudGF0aW9uIHVzZXMgYSBzaW5nbGVcbiAqIHBhc3Mgb3ZlciB0aGUgY29vcmRpbmF0ZXMgYW5kIGVsaW1pbmF0ZXMgaW50ZXJtZWRpYXRlIGNvbGxpbmVhciBwb2ludHMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICB0b2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXQsXG4pIHtcbiAgLy8gZG8gbm90aGluZyBpZiB0aGUgbGluZSBpcyBlbXB0eVxuICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIC8vIHNuYXAgdGhlIGZpcnN0IGNvb3JkaW5hdGUgKFAxKVxuICBsZXQgeDEgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCB0b2xlcmFuY2UpO1xuICBsZXQgeTEgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgLy8gYWRkIHRoZSBmaXJzdCBjb29yZGluYXRlIHRvIHRoZSBvdXRwdXRcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDE7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkxO1xuICAvLyBmaW5kIHRoZSBuZXh0IGNvb3JkaW5hdGUgdGhhdCBkb2VzIG5vdCBzbmFwIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBmaXJzdFxuICAvLyBjb29yZGluYXRlIChQMilcbiAgbGV0IHgyLCB5MjtcbiAgZG8ge1xuICAgIHgyID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgICB5MiA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICAgIC8vIGFsbCBjb29yZGluYXRlcyBzbmFwIHRvIHRoZSBzYW1lIHZhbHVlLCB0aGUgbGluZSBjb2xsYXBzZXMgdG8gYSBwb2ludFxuICAgICAgLy8gcHVzaCB0aGUgbGFzdCBzbmFwcGVkIHZhbHVlIGFueXdheSB0byBlbnN1cmUgdGhhdCB0aGUgb3V0cHV0IGNvbnRhaW5zXG4gICAgICAvLyBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgICAvLyBGSVhNRSBzaG91bGQgd2UgcmVhbGx5IHJldHVybiBhdCBsZWFzdCB0d28gcG9pbnRzIGFueXdheT9cbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gICAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgICB9XG4gIH0gd2hpbGUgKHgyID09IHgxICYmIHkyID09IHkxKTtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCkge1xuICAgIC8vIHNuYXAgdGhlIG5leHQgY29vcmRpbmF0ZSAoUDMpXG4gICAgY29uc3QgeDMgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCB0b2xlcmFuY2UpO1xuICAgIGNvbnN0IHkzID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICAvLyBza2lwIFAzIGlmIGl0IGlzIGVxdWFsIHRvIFAyXG4gICAgaWYgKHgzID09IHgyICYmIHkzID09IHkyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIFAxIGFuZCBQMlxuICAgIGNvbnN0IGR4MSA9IHgyIC0geDE7XG4gICAgY29uc3QgZHkxID0geTIgLSB5MTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRlbHRhIGJldHdlZW4gUDMgYW5kIFAxXG4gICAgY29uc3QgZHgyID0geDMgLSB4MTtcbiAgICBjb25zdCBkeTIgPSB5MyAtIHkxO1xuICAgIC8vIGlmIFAxLCBQMiwgYW5kIFAzIGFyZSBjb2xpbmVhciBhbmQgUDMgaXMgZnVydGhlciBmcm9tIFAxIHRoYW4gUDIgaXMgZnJvbVxuICAgIC8vIFAxIGluIHRoZSBzYW1lIGRpcmVjdGlvbiB0aGVuIFAyIGlzIG9uIHRoZSBzdHJhaWdodCBsaW5lIGJldHdlZW4gUDEgYW5kXG4gICAgLy8gUDNcbiAgICBpZiAoXG4gICAgICBkeDEgKiBkeTIgPT0gZHkxICogZHgyICYmXG4gICAgICAoKGR4MSA8IDAgJiYgZHgyIDwgZHgxKSB8fCBkeDEgPT0gZHgyIHx8IChkeDEgPiAwICYmIGR4MiA+IGR4MSkpICYmXG4gICAgICAoKGR5MSA8IDAgJiYgZHkyIDwgZHkxKSB8fCBkeTEgPT0gZHkyIHx8IChkeTEgPiAwICYmIGR5MiA+IGR5MSkpXG4gICAgKSB7XG4gICAgICAvLyBkaXNjYXJkIFAyIGFuZCBzZXQgUDIgPSBQM1xuICAgICAgeDIgPSB4MztcbiAgICAgIHkyID0geTM7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gZWl0aGVyIFAxLCBQMiwgYW5kIFAzIGFyZSBub3QgY29saW5lYXIsIG9yIHRoZXkgYXJlIGNvbGluZWFyIGJ1dCBQMyBpc1xuICAgIC8vIGJldHdlZW4gUDMgYW5kIFAxIG9yIG9uIHRoZSBvcHBvc2l0ZSBoYWxmIG9mIHRoZSBsaW5lIHRvIFAyLiAgYWRkIFAyLFxuICAgIC8vIGFuZCBjb250aW51ZSB3aXRoIFAxID0gUDIgYW5kIFAyID0gUDNcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgeDIgPSB4MztcbiAgICB5MiA9IHkzO1xuICB9XG4gIC8vIGFkZCB0aGUgbGFzdCBwb2ludCAoUDIpXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRFbmRzIFNpbXBsaWZpZWQgZW5kcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICB0b2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXQsXG4gIHNpbXBsaWZpZWRFbmRzLFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IHF1YW50aXplKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgdG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNpbXBsaWZpZWRPZmZzZXQsXG4gICAgKTtcbiAgICBzaW1wbGlmaWVkRW5kcy5wdXNoKHNpbXBsaWZpZWRPZmZzZXQpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHNpbXBsaWZpZWRFbmRzcyBTaW1wbGlmaWVkIGVuZHNzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplTXVsdGlBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIHRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbiAgc2ltcGxpZmllZEVuZHNzLFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IHF1YW50aXplQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzLFxuICAgICAgc3RyaWRlLFxuICAgICAgdG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNpbXBsaWZpZWRPZmZzZXQsXG4gICAgICBzaW1wbGlmaWVkRW5kcyxcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzcy5wdXNoKHNpbXBsaWZpZWRFbmRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbmZsYXRlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBbY29vcmRpbmF0ZXNdIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgY29vcmRpbmF0ZXMsXG4pIHtcbiAgY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXMgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvb3JkaW5hdGVzW2krK10gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoaiwgaiArIHN0cmlkZSk7XG4gIH1cbiAgY29vcmRpbmF0ZXMubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBbY29vcmRpbmF0ZXNzXSBDb29yZGluYXRlc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gQ29vcmRpbmF0ZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIGNvb3JkaW5hdGVzcyxcbikge1xuICBjb29yZGluYXRlc3MgPSBjb29yZGluYXRlc3MgIT09IHVuZGVmaW5lZCA/IGNvb3JkaW5hdGVzcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSAwLCBqaiA9IGVuZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbal07XG4gICAgY29vcmRpbmF0ZXNzW2krK10gPSBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBjb29yZGluYXRlc3NbaV0sXG4gICAgKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgY29vcmRpbmF0ZXNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBbY29vcmRpbmF0ZXNzc11cbiAqICAgICBDb29yZGluYXRlc3NzLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBDb29yZGluYXRlc3NzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIGNvb3JkaW5hdGVzc3MsXG4pIHtcbiAgY29vcmRpbmF0ZXNzcyA9IGNvb3JkaW5hdGVzc3MgIT09IHVuZGVmaW5lZCA/IGNvb3JkaW5hdGVzc3MgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gMCwgamogPSBlbmRzcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2pdO1xuICAgIGNvb3JkaW5hdGVzc3NbaSsrXSA9XG4gICAgICBlbmRzLmxlbmd0aCA9PT0gMSAmJiBlbmRzWzBdID09PSBvZmZzZXRcbiAgICAgICAgPyBbXVxuICAgICAgICA6IGluZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgZW5kcyxcbiAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzc3NbaV0sXG4gICAgICAgICAgKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgY29vcmRpbmF0ZXNzcy5sZW5ndGggPSBpO1xuICByZXR1cm4gY29vcmRpbmF0ZXNzcztcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2FyZWFcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBsZXQgdHdpY2VBcmVhID0gMDtcbiAgY29uc3QgeDAgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgY29uc3QgeTAgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGxldCBkeDEgPSAwO1xuICBsZXQgZHkxID0gMDtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IGR4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdIC0geDA7XG4gICAgY29uc3QgZHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdIC0geTA7XG4gICAgdHdpY2VBcmVhICs9IGR5MSAqIGR4MiAtIGR4MSAqIGR5MjtcbiAgICBkeDEgPSBkeDI7XG4gICAgZHkxID0gZHkyO1xuICB9XG4gIHJldHVybiB0d2ljZUFyZWEgLyAyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBhcmVhICs9IGxpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSkge1xuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgYXJlYSArPSBsaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTGluZWFyUmluZ1xuICovXG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2Fzc2lnbkNsb3Nlc3RQb2ludCwgbWF4U3F1YXJlZERlbHRhfSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2RvdWdsYXNQZXVja2VyfSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9pbmZsYXRlLmpzJztcbmltcG9ydCB7bGluZWFyUmluZyBhcyBsaW5lYXJSaW5nQXJlYX0gZnJvbSAnLi9mbGF0L2FyZWEuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExpbmVhciByaW5nIGdlb21ldHJ5LiBPbmx5IHVzZWQgYXMgcGFydCBvZiBwb2x5Z29uOyBjYW5ub3QgYmUgcmVuZGVyZWRcbiAqIG9uIGl0cyBvd24uXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBMaW5lYXJSaW5nIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fEFycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiAgICAgRm9yIGludGVybmFsIHVzZSwgZmxhdCBjb29yZGluYXRlcyBpbiBjb21iaW5hdGlvbiB3aXRoIGBsYXlvdXRgIGFyZSBhbHNvIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgaWYgKGxheW91dCAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqLyAoXG4gICAgICAgICAgY29vcmRpbmF0ZXNcbiAgICAgICAgKSxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTGluZWFyUmluZ30gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhclJpbmcodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSwgdGhpcy5sYXlvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChcbiAgICAgICAgbWF4U3F1YXJlZERlbHRhKFxuICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgICAgIDAsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sXG4gICAgICB0cnVlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIGxpbmVhciByaW5nIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBcmVhKCkge1xuICAgIHJldHVybiBsaW5lYXJSaW5nQXJlYShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZWFyIHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge0xpbmVhclJpbmd9IFNpbXBsaWZpZWQgTGluZWFyUmluZy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICApO1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAnWFknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ0xpbmVhclJpbmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHBhcmFtIHshQXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCwgY29vcmRpbmF0ZXMsIDEpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJSaW5nO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1BvaW50XG4gKi9cbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7Y29udGFpbnNYWSwgY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7c3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9pbnQgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBQb2ludCBleHRlbmRzIFNpbXBsZUdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IVBvaW50fSBDbG9uZS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICBwb2ludC5hcHBseVByb3BlcnRpZXModGhpcyk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3Qgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMF0sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMV0sXG4gICAgKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybiBzcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlcy5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbXB1dGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0eXBlIG9mIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuVHlwZX0gR2VvbWV0cnkgdHlwZS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdQb2ludCc7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCB0aGlzLmZsYXRDb29yZGluYXRlc1swXSwgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0LCBjb29yZGluYXRlcywgMCk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGUoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBjb29yZGluYXRlcyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jb250YWluc1xuICovXG5pbXBvcnQge2ZvckVhY2hDb3JuZXJ9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdDb250YWluc0V4dGVudChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBleHRlbnQsXG4pIHtcbiAgY29uc3Qgb3V0c2lkZSA9IGZvckVhY2hDb3JuZXIoXG4gICAgZXh0ZW50LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjb29yZGluYXRlKSB7XG4gICAgICByZXR1cm4gIWxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGNvb3JkaW5hdGVbMF0sXG4gICAgICAgIGNvb3JkaW5hdGVbMV0sXG4gICAgICApO1xuICAgIH0sXG4gICk7XG4gIHJldHVybiAhb3V0c2lkZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nQ29udGFpbnNYWShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICB4LFxuICB5LFxuKSB7XG4gIC8vIGh0dHBzOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwMy1faW5jbHVzaW9uLmh0bWxcbiAgLy8gQ29weXJpZ2h0IDIwMDAgc29mdFN1cmZlciwgMjAxMiBEYW4gU3VuZGF5XG4gIC8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IHVzZWQgYW5kIG1vZGlmaWVkIGZvciBhbnkgcHVycG9zZVxuICAvLyBwcm92aWRpbmcgdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgaW5jbHVkZWQgd2l0aCBpdC5cbiAgLy8gU29mdFN1cmZlciBtYWtlcyBubyB3YXJyYW50eSBmb3IgdGhpcyBjb2RlLCBhbmQgY2Fubm90IGJlIGhlbGRcbiAgLy8gbGlhYmxlIGZvciBhbnkgcmVhbCBvciBpbWFnaW5lZCBkYW1hZ2UgcmVzdWx0aW5nIGZyb20gaXRzIHVzZS5cbiAgLy8gVXNlcnMgb2YgdGhpcyBjb2RlIG11c3QgdmVyaWZ5IGNvcnJlY3RuZXNzIGZvciB0aGVpciBhcHBsaWNhdGlvbi5cbiAgbGV0IHduID0gMDtcbiAgbGV0IHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIGxldCB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgaWYgKHkxIDw9IHkpIHtcbiAgICAgIGlmICh5MiA+IHkgJiYgKHgyIC0geDEpICogKHkgLSB5MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSA+IDApIHtcbiAgICAgICAgd24rKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHkyIDw9IHkgJiYgKHgyIC0geDEpICogKHkgLSB5MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSA8IDApIHtcbiAgICAgIHduLS07XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gd24gIT09IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NDb250YWluc1hZKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICB4LFxuICB5LFxuKSB7XG4gIGlmIChlbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzWzBdLCBzdHJpZGUsIHgsIHkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAxLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChcbiAgICAgIGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgZW5kc1tpIC0gMV0sIGVuZHNbaV0sIHN0cmlkZSwgeCwgeSlcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NzQ29udGFpbnNYWShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIHgsXG4gIHksXG4pIHtcbiAgaWYgKGVuZHNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludFxuICovXG5pbXBvcnQge2FzY2VuZGluZ30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc0NvbnRhaW5zWFl9IGZyb20gJy4vY29udGFpbnMuanMnO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBwb2ludCB0aGF0IGlzIGxpa2VseSB0byBsaWUgaW4gdGhlIGludGVyaW9yIG9mIHRoZSBsaW5lYXIgcmluZ3MuXG4gKiBJbnNwaXJlZCBieSBKVFMncyBjb20udml2aWRzb2x1dGlvbnMuanRzLmdlb20uR2VvbWV0cnkjZ2V0SW50ZXJpb3JQb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDZW50ZXJzIEZsYXQgY2VudGVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGF0Q2VudGVyc09mZnNldCBGbGF0IGNlbnRlciBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IERlc3RpbmF0aW9uIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIGZsYXRDZW50ZXJzLFxuICBmbGF0Q2VudGVyc09mZnNldCxcbiAgZGVzdCxcbikge1xuICBsZXQgaSwgaWksIHgsIHgxLCB4MiwgeTEsIHkyO1xuICBjb25zdCB5ID0gZmxhdENlbnRlcnNbZmxhdENlbnRlcnNPZmZzZXQgKyAxXTtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIGhvcml6b250YWwgbGluZVxuICBmb3IgKGxldCByID0gMCwgcnIgPSBlbmRzLmxlbmd0aDsgciA8IHJyOyArK3IpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW3JdO1xuICAgIHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gICAgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBpZiAoKHkgPD0geTEgJiYgeTIgPD0geSkgfHwgKHkxIDw9IHkgJiYgeSA8PSB5MikpIHtcbiAgICAgICAgeCA9ICgoeSAtIHkxKSAvICh5MiAtIHkxKSkgKiAoeDIgLSB4MSkgKyB4MTtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKHgpO1xuICAgICAgfVxuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfVxuICB9XG4gIC8vIEZpbmQgdGhlIGxvbmdlc3Qgc2VnbWVudCBvZiB0aGUgaG9yaXpvbnRhbCBsaW5lIHRoYXQgaGFzIGl0cyBjZW50ZXIgcG9pbnRcbiAgLy8gaW5zaWRlIHRoZSBsaW5lYXIgcmluZy5cbiAgbGV0IHBvaW50WCA9IE5hTjtcbiAgbGV0IG1heFNlZ21lbnRMZW5ndGggPSAtSW5maW5pdHk7XG4gIGludGVyc2VjdGlvbnMuc29ydChhc2NlbmRpbmcpO1xuICB4MSA9IGludGVyc2VjdGlvbnNbMF07XG4gIGZvciAoaSA9IDEsIGlpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgeDIgPSBpbnRlcnNlY3Rpb25zW2ldO1xuICAgIGNvbnN0IHNlZ21lbnRMZW5ndGggPSBNYXRoLmFicyh4MiAtIHgxKTtcbiAgICBpZiAoc2VnbWVudExlbmd0aCA+IG1heFNlZ21lbnRMZW5ndGgpIHtcbiAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgaWYgKGxpbmVhclJpbmdzQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCB4LCB5KSkge1xuICAgICAgICBwb2ludFggPSB4O1xuICAgICAgICBtYXhTZWdtZW50TGVuZ3RoID0gc2VnbWVudExlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgfVxuICBpZiAoaXNOYU4ocG9pbnRYKSkge1xuICAgIC8vIFRoZXJlIGlzIG5vIGhvcml6b250YWwgbGluZSB0aGF0IGhhcyBpdHMgY2VudGVyIHBvaW50IGluc2lkZSB0aGUgbGluZWFyXG4gICAgLy8gcmluZy4gIFVzZSB0aGUgY2VudGVyIG9mIHRoZSB0aGUgbGluZWFyIHJpbmcncyBleHRlbnQuXG4gICAgcG9pbnRYID0gZmxhdENlbnRlcnNbZmxhdENlbnRlcnNPZmZzZXRdO1xuICB9XG4gIGlmIChkZXN0KSB7XG4gICAgZGVzdC5wdXNoKHBvaW50WCwgeSwgbWF4U2VnbWVudExlbmd0aCk7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgcmV0dXJuIFtwb2ludFgsIHksIG1heFNlZ21lbnRMZW5ndGhdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDZW50ZXJzIEZsYXQgY2VudGVycy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEludGVyaW9yIHBvaW50cyBhcyBYWU0gY29vcmRpbmF0ZXMsIHdoZXJlIE0gaXMgdGhlXG4gKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmlvclBvaW50c09mTXVsdGlBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIGZsYXRDZW50ZXJzLFxuKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgbGV0IGludGVyaW9yUG9pbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgaW50ZXJpb3JQb2ludHMgPSBnZXRJbnRlcmlvclBvaW50T2ZBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZHMsXG4gICAgICBzdHJpZGUsXG4gICAgICBmbGF0Q2VudGVycyxcbiAgICAgIDIgKiBpLFxuICAgICAgaW50ZXJpb3JQb2ludHMsXG4gICAgKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGludGVyaW9yUG9pbnRzO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc2VnbWVudHNcbiAqL1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYGNhbGxiYWNrYCBmb3IgZWFjaCBzZWdtZW50IG9mIHRoZSBmbGF0IGNvb3JkaW5hdGVzXG4gKiBhcnJheS4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdFxuICogdmFsdWUgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlLCBpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBUfSBjYWxsYmFjayBGdW5jdGlvblxuICogICAgIGNhbGxlZCBmb3IgZWFjaCBzZWdtZW50LlxuICogQHJldHVybiB7VHxib29sZWFufSBWYWx1ZS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY2FsbGJhY2spIHtcbiAgbGV0IHJldDtcbiAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHJldCA9IGNhbGxiYWNrKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCAtIHN0cmlkZSwgb2Zmc2V0KSxcbiAgICAgIGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHN0cmlkZSksXG4gICAgKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50XG4gKi9cbmltcG9ydCB7XG4gIGNvbnRhaW5zRXh0ZW50LFxuICBjcmVhdGVFbXB0eSxcbiAgZXh0ZW5kRmxhdENvb3JkaW5hdGVzLFxuICBpbnRlcnNlY3RzLFxuICBpbnRlcnNlY3RzU2VnbWVudCxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Zm9yRWFjaCBhcyBmb3JFYWNoU2VnbWVudH0gZnJvbSAnLi9zZWdtZW50cy5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdDb250YWluc0V4dGVudCwgbGluZWFyUmluZ0NvbnRhaW5zWFl9IGZyb20gJy4vY29udGFpbnMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBleHRlbnQsXG4pIHtcbiAgY29uc3QgY29vcmRpbmF0ZXNFeHRlbnQgPSBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgY3JlYXRlRW1wdHkoKSxcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgb2Zmc2V0LFxuICAgIGVuZCxcbiAgICBzdHJpZGUsXG4gICk7XG4gIGlmICghaW50ZXJzZWN0cyhleHRlbnQsIGNvb3JkaW5hdGVzRXh0ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY29udGFpbnNFeHRlbnQoZXh0ZW50LCBjb29yZGluYXRlc0V4dGVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZXNFeHRlbnRbMF0gPj0gZXh0ZW50WzBdICYmIGNvb3JkaW5hdGVzRXh0ZW50WzJdIDw9IGV4dGVudFsyXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFsxXSA+PSBleHRlbnRbMV0gJiYgY29vcmRpbmF0ZXNFeHRlbnRbM10gPD0gZXh0ZW50WzNdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZvckVhY2hTZWdtZW50KFxuICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICBvZmZzZXQsXG4gICAgZW5kLFxuICAgIHN0cmlkZSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQxIFN0YXJ0IHBvaW50LlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludDIgRW5kIHBvaW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc2VnbWVudCBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QsXG4gICAgICogICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Mikge1xuICAgICAgcmV0dXJuIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgcG9pbnQxLCBwb2ludDIpO1xuICAgIH0sXG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIGV4dGVudCxcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAoXG4gICAgICBpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1tpXSwgc3RyaWRlLCBleHRlbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kc1tpXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGV4dGVudCxcbikge1xuICBpZiAoaW50ZXJzZWN0c0xpbmVTdHJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgZXh0ZW50WzBdLFxuICAgICAgZXh0ZW50WzFdLFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgZXh0ZW50WzBdLFxuICAgICAgZXh0ZW50WzNdLFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgZXh0ZW50WzJdLFxuICAgICAgZXh0ZW50WzFdLFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgZXh0ZW50WzJdLFxuICAgICAgZXh0ZW50WzNdLFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBleHRlbnQsXG4pIHtcbiAgaWYgKCFpbnRlcnNlY3RzTGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlLCBleHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAxLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChcbiAgICAgIGxpbmVhclJpbmdDb250YWluc0V4dGVudChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICBlbmRzW2kgLSAxXSxcbiAgICAgICAgZW5kc1tpXSxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBleHRlbnQsXG4gICAgICApXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgZW5kc1tpIC0gMV0sXG4gICAgICAgICAgZW5kc1tpXSxcbiAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgZXh0ZW50LFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVhclJpbmdNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgZXh0ZW50LFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgaWYgKFxuICAgICAgaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBleHRlbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3JldmVyc2VcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCAtIHN0cmlkZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgIGNvbnN0IHRtcCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXSA9IHRtcDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICBlbmQgLT0gc3RyaWRlO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9vcmllbnRcbiAqL1xuaW1wb3J0IHtjb29yZGluYXRlcyBhcyByZXZlcnNlQ29vcmRpbmF0ZXN9IGZyb20gJy4vcmV2ZXJzZS5qcyc7XG5cbi8qKlxuICogSXMgdGhlIGxpbmVhciByaW5nIG9yaWVudGVkIGNsb2Nrd2lzZSBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggYSBib3R0b20tbGVmdFxuICogY29vcmRpbmF0ZSBvcmlnaW4/IEZvciBhIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggYSB0b3AtbGVmdCBjb29yZGluYXRlIG9yaWdpbixcbiAqIHRoZSByaW5nJ3Mgb3JpZW50YXRpb24gaXMgY2xvY2t3aXNlIHdoZW4gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBJcyBjbG9ja3dpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nSXNDbG9ja3dpc2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xMTY1NjQ3L2Nsb2Nrd2lzZS1tZXRob2QjMTE2NTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vT1NHZW8vZ2RhbC9ibG9iL21hc3Rlci9nZGFsL29nci9vZ3JsaW5lYXJyaW5nLmNwcFxuICBsZXQgZWRnZSA9IDA7XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIGVkZ2UgKz0gKHgyIC0geDEpICogKHkyICsgeTEpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gZWRnZSA9PT0gMCA/IHVuZGVmaW5lZCA6IGVkZ2UgPiAwO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbGluZWFyIHJpbmdzIGFyZSBvcmllbnRlZC4gIEJ5IGRlZmF1bHQsIGxlZnQtaGFuZCBvcmllbnRhdGlvblxuICogaXMgdGVzdGVkIChmaXJzdCByaW5nIG11c3QgYmUgY2xvY2t3aXNlLCByZW1haW5pbmcgcmluZ3MgY291bnRlci1jbG9ja3dpc2UpLlxuICogVG8gdGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvbiwgdXNlIHRoZSBgcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBBcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc0FyZU9yaWVudGVkKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICByaWdodCxcbikge1xuICByaWdodCA9IHJpZ2h0ICE9PSB1bmRlZmluZWQgPyByaWdodCA6IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIGNvbnN0IGlzQ2xvY2t3aXNlID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICk7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGlmICgocmlnaHQgJiYgaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGxpbmVhciByaW5ncyBhcmUgb3JpZW50ZWQuICBCeSBkZWZhdWx0LCBsZWZ0LWhhbmQgb3JpZW50YXRpb25cbiAqIGlzIHRlc3RlZCAoZmlyc3QgcmluZyBtdXN0IGJlIGNsb2Nrd2lzZSwgcmVtYWluaW5nIHJpbmdzIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqIFRvIHRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb24sIHVzZSB0aGUgYHJpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBBcnJheSBvZiBhcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3NBcmVPcmllbnRlZChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIHJpZ2h0LFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgaWYgKCFsaW5lYXJSaW5nc0FyZU9yaWVudGVkKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHJpZ2h0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZW5kcy5sZW5ndGgpIHtcbiAgICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogT3JpZW50IGNvb3JkaW5hdGVzIGluIGEgZmxhdCBhcnJheSBvZiBsaW5lYXIgcmluZ3MuICBCeSBkZWZhdWx0LCByaW5nc1xuICogYXJlIG9yaWVudGVkIGZvbGxvd2luZyB0aGUgbGVmdC1oYW5kIHJ1bGUgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kXG4gKiBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLiAgVG8gb3JpZW50IGFjY29yZGluZyB0byB0aGVcbiAqIHJpZ2h0LWhhbmQgcnVsZSwgdXNlIHRoZSBgcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyaWdodF0gRm9sbG93IHRoZSByaWdodC1oYW5kIHJ1bGUgZm9yIG9yaWVudGF0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmllbnRMaW5lYXJSaW5ncyhcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgcmlnaHQsXG4pIHtcbiAgcmlnaHQgPSByaWdodCAhPT0gdW5kZWZpbmVkID8gcmlnaHQgOiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBjb25zdCBpc0Nsb2Nrd2lzZSA9IGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICApO1xuICAgIGNvbnN0IHJldmVyc2UgPVxuICAgICAgaSA9PT0gMFxuICAgICAgICA/IChyaWdodCAmJiBpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiAhaXNDbG9ja3dpc2UpXG4gICAgICAgIDogKHJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiBpc0Nsb2Nrd2lzZSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldmVyc2VDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBPcmllbnQgY29vcmRpbmF0ZXMgaW4gYSBmbGF0IGFycmF5IG9mIGxpbmVhciByaW5ncy4gIEJ5IGRlZmF1bHQsIHJpbmdzXG4gKiBhcmUgb3JpZW50ZWQgZm9sbG93aW5nIHRoZSBsZWZ0LWhhbmQgcnVsZSAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmRcbiAqIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuICBUbyBvcmllbnQgYWNjb3JkaW5nIHRvIHRoZVxuICogcmlnaHQtaGFuZCBydWxlLCB1c2UgdGhlIGByaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgQXJyYXkgb2YgYXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0XSBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICByaWdodCxcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgb2Zmc2V0ID0gb3JpZW50TGluZWFyUmluZ3MoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzc1tpXSxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHJpZ2h0LFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSB0d28tZGltZW5zaW9uYWwgZW5kc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBMaW5lYXIgcmluZyBlbmQgaW5kZXhlc1xuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFR3byBkaW1lbnNpb25hbCBlbmRzcyBhcnJheSB0aGF0IGNhblxuICogYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBNdWx0aVBvbHlnb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVFbmRzKGZsYXRDb29yZGluYXRlcywgZW5kcykge1xuICBjb25zdCBlbmRzcyA9IFtdO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgbGV0IHByZXZFbmRJbmRleCA9IDA7XG4gIGxldCBzdGFydE9yaWVudGF0aW9uO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIC8vIGNsYXNzaWZpZXMgYW4gYXJyYXkgb2YgcmluZ3MgaW50byBwb2x5Z29ucyB3aXRoIG91dGVyIHJpbmdzIGFuZCBob2xlc1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIDIpO1xuICAgIGlmIChzdGFydE9yaWVudGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXJ0T3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB9XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSBzdGFydE9yaWVudGF0aW9uKSB7XG4gICAgICBlbmRzcy5wdXNoKGVuZHMuc2xpY2UocHJldkVuZEluZGV4LCBpICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZW5kc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZW5kc3NbZW5kc3MubGVuZ3RoIC0gMV0ucHVzaChlbmRzW3ByZXZFbmRJbmRleF0pO1xuICAgIH1cbiAgICBwcmV2RW5kSW5kZXggPSBpICsgMTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIGVuZHNzO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1BvbHlnb25cbiAqL1xuaW1wb3J0IExpbmVhclJpbmcgZnJvbSAnLi9MaW5lYXJSaW5nLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuL1BvaW50LmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXJyYXlNYXhTcXVhcmVkRGVsdGEsIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50fSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSwgZ2V0Q2VudGVyLCBpc0VtcHR5fSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Z2V0SW50ZXJpb3JQb2ludE9mQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcmlvcnBvaW50LmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXl9IGZyb20gJy4vZmxhdC9pbmZsYXRlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc0FyZU9yaWVudGVkLCBvcmllbnRMaW5lYXJSaW5nc30gZnJvbSAnLi9mbGF0L29yaWVudC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzIGFzIGxpbmVhclJpbmdzQXJlYX0gZnJvbSAnLi9mbGF0L2FyZWEuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc0NvbnRhaW5zWFl9IGZyb20gJy4vZmxhdC9jb250YWlucy5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge3F1YW50aXplQXJyYXl9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5pbXBvcnQge29mZnNldCBhcyBzcGhlcmVPZmZzZXR9IGZyb20gJy4uL3NwaGVyZS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9seWdvbiBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+PnwhQXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXNcbiAgICogICAgIEFycmF5IG9mIGxpbmVhciByaW5ncyB0aGF0IGRlZmluZSB0aGUgcG9seWdvbi4gVGhlIGZpcnN0IGxpbmVhciByaW5nIG9mIHRoZVxuICAgKiAgICAgYXJyYXkgZGVmaW5lcyB0aGUgb3V0ZXItYm91bmRhcnkgb3Igc3VyZmFjZSBvZiB0aGUgcG9seWdvbi4gRWFjaCBzdWJzZXF1ZW50XG4gICAqICAgICBsaW5lYXIgcmluZyBkZWZpbmVzIGEgaG9sZSBpbiB0aGUgc3VyZmFjZSBvZiB0aGUgcG9seWdvbi4gQSBsaW5lYXIgcmluZyBpc1xuICAgKiAgICAgYW4gYXJyYXkgb2YgdmVydGljZXMnIGNvb3JkaW5hdGVzIHdoZXJlIHRoZSBmaXJzdCBjb29yZGluYXRlIGFuZCB0aGUgbGFzdCBhcmVcbiAgICogICAgIGVxdWl2YWxlbnQuIChGb3IgaW50ZXJuYWwgdXNlLCBmbGF0IGNvb3JkaW5hdGVzIGluIGNvbWJpbmF0aW9uIHdpdGhcbiAgICogICAgIGBsYXlvdXRgIGFuZCBgZW5kc2AgYXJlIGFsc28gYWNjZXB0ZWQuKVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW5kc10gRW5kcyAoZm9yIGludGVybmFsIHVzZSB3aXRoIGZsYXQgY29vcmRpbmF0ZXMpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIGxheW91dCwgZW5kcykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gbnVsbDtcblxuICAgIGlmIChsYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBlbmRzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcyksXG4gICAgICApO1xuICAgICAgdGhpcy5lbmRzXyA9IGVuZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59ICovIChcbiAgICAgICAgICBjb29yZGluYXRlc1xuICAgICAgICApLFxuICAgICAgICBsYXlvdXQsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBsaW5lYXIgcmluZyB0byB0aGlzIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7TGluZWFyUmluZ30gbGluZWFyUmluZyBMaW5lYXIgcmluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgYXBwZW5kTGluZWFyUmluZyhsaW5lYXJSaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBsaW5lYXJSaW5nLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgbGluZWFyUmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kc18ucHVzaCh0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IVBvbHlnb259IENsb25lLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSxcbiAgICAgIHRoaXMubGF5b3V0LFxuICAgICAgdGhpcy5lbmRzXy5zbGljZSgpLFxuICAgICk7XG4gICAgcG9seWdvbi5hcHBseVByb3BlcnRpZXModGhpcyk7XG4gICAgcmV0dXJuIHBvbHlnb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhEZWx0YVJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMubWF4RGVsdGFfID0gTWF0aC5zcXJ0KFxuICAgICAgICBhcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuZW5kc18sXG4gICAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICAgICAgMCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXyxcbiAgICAgIHRydWUsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjb250YWluc1hZKHgsIHkpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NDb250YWluc1hZKFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhcmVhIG9mIHRoZSBwb2x5Z29uIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBcmVhKCkge1xuICAgIHJldHVybiBsaW5lYXJSaW5nc0FyZWEoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb29yZGluYXRlIGFycmF5IGZvciB0aGlzIGdlb21ldHJ5LiAgVGhpcyBhcnJheSBoYXMgdGhlIHN0cnVjdHVyZVxuICAgKiBvZiBhIEdlb0pTT04gY29vcmRpbmF0ZSBhcnJheSBmb3IgcG9seWdvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0XSBPcmllbnQgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvIHRoZSByaWdodC1oYW5kXG4gICAqICAgICBydWxlIChjb3VudGVyLWNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kIGNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgSWYgYGZhbHNlYCwgY29vcmRpbmF0ZXMgd2lsbCBiZSBvcmllbnRlZCBhY2NvcmRpbmcgdG8gdGhlIGxlZnQtaGFuZCBydWxlXG4gICAqICAgICAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS5cbiAgICogICAgIEJ5IGRlZmF1bHQsIGNvb3JkaW5hdGUgb3JpZW50YXRpb24gd2lsbCBkZXBlbmQgb24gaG93IHRoZSBnZW9tZXRyeSB3YXNcbiAgICogICAgIGNvbnN0cnVjdGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRDb29yZGluYXRlcyhyaWdodCkge1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgICAgb3JpZW50TGluZWFyUmluZ3MoZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAgICovXG4gIGdldEVuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW50ZXJpb3IgcG9pbnQuXG4gICAqL1xuICBnZXRGbGF0SW50ZXJpb3JQb2ludCgpIHtcbiAgICBpZiAodGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNvbnN0IGZsYXRDZW50ZXIgPSBnZXRDZW50ZXIodGhpcy5nZXRFeHRlbnQoKSk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50XyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KFxuICAgICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMuZW5kc18sXG4gICAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgICBmbGF0Q2VudGVyLFxuICAgICAgICAwLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludF9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbnRlcmlvciBwb2ludCBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7UG9pbnR9IEludGVyaW9yIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICAgKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEludGVyaW9yUG9pbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50KCksICdYWU0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiByaW5ncyBvZiB0aGUgcG9seWdvbiwgIHRoaXMgaW5jbHVkZXMgdGhlIGV4dGVyaW9yXG4gICAqIHJpbmcgYW5kIGFueSBpbnRlcmlvciByaW5ncy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgcmluZ3MuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVhclJpbmdDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBOdGggbGluZWFyIHJpbmcgb2YgdGhlIHBvbHlnb24gZ2VvbWV0cnkuIFJldHVybiBgbnVsbGAgaWYgdGhlXG4gICAqIGdpdmVuIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICogVGhlIGV4dGVyaW9yIGxpbmVhciByaW5nIGlzIGF2YWlsYWJsZSBhdCBpbmRleCBgMGAgYW5kIHRoZSBpbnRlcmlvciByaW5nc1xuICAgKiBhdCBpbmRleCBgMWAgYW5kIGJleW9uZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtMaW5lYXJSaW5nfG51bGx9IExpbmVhciByaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lYXJSaW5nKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmVuZHNfLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgICBpbmRleCA9PT0gMCA/IDAgOiB0aGlzLmVuZHNfW2luZGV4IC0gMV0sXG4gICAgICAgIHRoaXMuZW5kc19baW5kZXhdLFxuICAgICAgKSxcbiAgICAgIHRoaXMubGF5b3V0LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaW5lYXIgcmluZ3Mgb2YgdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm4ge0FycmF5PExpbmVhclJpbmc+fSBMaW5lYXIgcmluZ3MuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVhclJpbmdzKCkge1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IGVuZHMgPSB0aGlzLmVuZHNfO1xuICAgIGNvbnN0IGxpbmVhclJpbmdzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgICAgY29uc3QgbGluZWFyUmluZyA9IG5ldyBMaW5lYXJSaW5nKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBlbmQpLFxuICAgICAgICBsYXlvdXQsXG4gICAgICApO1xuICAgICAgbGluZWFyUmluZ3MucHVzaChsaW5lYXJSaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWVudGVkIGZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpIHtcbiAgICBpZiAodGhpcy5vcmllbnRlZFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgICAgaWYgKGxpbmVhclJpbmdzQXJlT3JpZW50ZWQoZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSkpIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXy5sZW5ndGggPSBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuZW5kc18sXG4gICAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAodGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtQb2x5Z29ufSBTaW1wbGlmaWVkIFBvbHlnb24uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3Qgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IHF1YW50aXplQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBNYXRoLnNxcnQoc3F1YXJlZFRvbGVyYW5jZSksXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHNpbXBsaWZpZWRFbmRzLFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsICdYWScsIHNpbXBsaWZpZWRFbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ1BvbHlnb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIGV4dGVudCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0LCBjb29yZGluYXRlcywgMik7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgZW5kcyA9IGRlZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgKTtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBlbmRzLmxlbmd0aCA9PT0gMCA/IDAgOiBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9seWdvbjtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXBwcm94aW1hdGlvbiBvZiBhIGNpcmNsZSBvbiB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyIChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBncmVhdC1jaXJjbGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvXG4gKiAgICAgdGhlIHBvbHlnb24gdmVydGljZXMgaW4gbWV0ZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtuXSBPcHRpb25hbCBudW1iZXIgb2YgdmVydGljZXMgZm9yIHRoZSByZXN1bHRpbmdcbiAqICAgICBwb2x5Z29uLiBEZWZhdWx0IGlzIGAzMmAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NwaGVyZVJhZGl1c10gT3B0aW9uYWwgcmFkaXVzIGZvciB0aGUgc3BoZXJlIChkZWZhdWx0cyB0b1xuICogICAgIHRoZSBFYXJ0aCdzIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQpLlxuICogQHJldHVybiB7UG9seWdvbn0gVGhlIFwiY2lyY3VsYXJcIiBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2lyY3VsYXIoY2VudGVyLCByYWRpdXMsIG4sIHNwaGVyZVJhZGl1cykge1xuICBuID0gbiA/IG4gOiAzMjtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBleHRlbmQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBzcGhlcmVPZmZzZXQoY2VudGVyLCByYWRpdXMsICgyICogTWF0aC5QSSAqIGkpIC8gbiwgc3BoZXJlUmFkaXVzKSxcbiAgICApO1xuICB9XG4gIGZsYXRDb29yZGluYXRlcy5wdXNoKGZsYXRDb29yZGluYXRlc1swXSwgZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgJ1hZJywgW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwb2x5Z29uIGZyb20gYW4gZXh0ZW50LiBUaGUgbGF5b3V0IHVzZWQgaXMgYFhZYC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBUaGUgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FeHRlbnQoZXh0ZW50KSB7XG4gIGlmIChpc0VtcHR5KGV4dGVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcG9seWdvbiBmcm9tIGVtcHR5IGV4dGVudCcpO1xuICB9XG4gIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gIGNvbnN0IG1pblkgPSBleHRlbnRbMV07XG4gIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IFtcbiAgICBtaW5YLFxuICAgIG1pblksXG4gICAgbWluWCxcbiAgICBtYXhZLFxuICAgIG1heFgsXG4gICAgbWF4WSxcbiAgICBtYXhYLFxuICAgIG1pblksXG4gICAgbWluWCxcbiAgICBtaW5ZLFxuICBdO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCAnWFknLCBbZmxhdENvb3JkaW5hdGVzLmxlbmd0aF0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgcG9seWdvbiBmcm9tIGEgY2lyY2xlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBjaXJjbGUgQ2lyY2xlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWRlc10gTnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBEZWZhdWx0IGlzIDMyLlxuICogQHBhcmFtIHtudW1iZXJ9IFthbmdsZV0gU3RhcnQgYW5nbGUgZm9yIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gaW5cbiAqICAgICBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zLiAwIG1lYW5zIEVhc3QuIERlZmF1bHQgaXMgMC5cbiAqIEByZXR1cm4ge1BvbHlnb259IFBvbHlnb24gZ2VvbWV0cnkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ2lyY2xlKGNpcmNsZSwgc2lkZXMsIGFuZ2xlKSB7XG4gIHNpZGVzID0gc2lkZXMgPyBzaWRlcyA6IDMyO1xuICBjb25zdCBzdHJpZGUgPSBjaXJjbGUuZ2V0U3RyaWRlKCk7XG4gIGNvbnN0IGxheW91dCA9IGNpcmNsZS5nZXRMYXlvdXQoKTtcbiAgY29uc3QgY2VudGVyID0gY2lyY2xlLmdldENlbnRlcigpO1xuICBjb25zdCBhcnJheUxlbmd0aCA9IHN0cmlkZSAqIChzaWRlcyArIDEpO1xuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoYXJyYXlMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyBpICs9IHN0cmlkZSkge1xuICAgIGZsYXRDb29yZGluYXRlc1tpXSA9IDA7XG4gICAgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDI7IGogPCBzdHJpZGU7IGorKykge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2kgKyBqXSA9IGNlbnRlcltqXTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgbGF5b3V0LCBlbmRzKTtcbiAgbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCBjaXJjbGUuZ2V0UmFkaXVzKCksIGFuZ2xlKTtcbiAgcmV0dXJuIHBvbHlnb247XG59XG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb29yZGluYXRlcyBvZiBhIHBvbHlnb24gdG8gbWFrZSBpdCBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvbiBQb2x5Z29uIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FuZ2xlXSBTdGFydCBhbmdsZSBmb3IgdGhlIGZpcnN0IHZlcnRleCBvZiB0aGUgcG9seWdvbiBpblxuICogICAgIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMuIDAgbWVhbnMgRWFzdC4gRGVmYXVsdCBpcyAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCByYWRpdXMsIGFuZ2xlKSB7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gIGNvbnN0IHN0cmlkZSA9IHBvbHlnb24uZ2V0U3RyaWRlKCk7XG4gIGNvbnN0IHNpZGVzID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHN0cmlkZSAtIDE7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBhbmdsZSA/IGFuZ2xlIDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2lkZXM7ICsraSkge1xuICAgIGNvbnN0IG9mZnNldCA9IGkgKiBzdHJpZGU7XG4gICAgY29uc3QgYW5nbGUgPSBzdGFydEFuZ2xlICsgKG1vZHVsbyhpLCBzaWRlcykgKiAyICogTWF0aC5QSSkgLyBzaWRlcztcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSA9IGNlbnRlclswXSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gPSBjZW50ZXJbMV0gKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gIH1cbiAgcG9seWdvbi5jaGFuZ2VkKCk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IFZpZXdQcm9wZXJ0eSBmcm9tICcuL1ZpZXdQcm9wZXJ0eS5qcyc7XG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL3RpbGVncmlkL2NvbW1vbi5qcyc7XG5pbXBvcnQge1xuICBNRVRFUlNfUEVSX1VOSVQsXG4gIGNyZWF0ZVByb2plY3Rpb24sXG4gIGRpc2FibGVDb29yZGluYXRlV2FybmluZyxcbiAgZnJvbVVzZXJDb29yZGluYXRlLFxuICBmcm9tVXNlckV4dGVudCxcbiAgZ2V0VXNlclByb2plY3Rpb24sXG4gIHRvVXNlckNvb3JkaW5hdGUsXG4gIHRvVXNlckV4dGVudCxcbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYWRkIGFzIGFkZENvb3JkaW5hdGUsXG4gIGVxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsLFxuICBlcXVhbHMsXG4gIHJvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlLFxufSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge25vbmUgYXMgY2VudGVyTm9uZSwgY3JlYXRlRXh0ZW50fSBmcm9tICcuL2NlbnRlcmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IHtjbGFtcCwgbW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTWluTWF4UmVzb2x1dGlvbixcbiAgY3JlYXRlU25hcFRvUG93ZXIsXG4gIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zLFxufSBmcm9tICcuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVNuYXBUb04sXG4gIGNyZWF0ZVNuYXBUb1plcm8sXG4gIGRpc2FibGUsXG4gIG5vbmUgYXMgcm90YXRpb25Ob25lLFxufSBmcm9tICcuL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQge2Vhc2VPdXQsIGluQW5kT3V0fSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQge1xuICBnZXRDZW50ZXIsXG4gIGdldEZvclZpZXdBbmRTaXplLFxuICBnZXRIZWlnaHQsXG4gIGdldFdpZHRoLFxuICBpc0VtcHR5LFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7ZnJvbUV4dGVudCBhcyBwb2x5Z29uRnJvbUV4dGVudH0gZnJvbSAnLi9nZW9tL1BvbHlnb24uanMnO1xuXG4vKipcbiAqIEFuIGFuaW1hdGlvbiBjb25maWd1cmF0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbc291cmNlQ2VudGVyXSBTb3VyY2UgY2VudGVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW3RhcmdldENlbnRlcl0gVGFyZ2V0IGNlbnRlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUmVzb2x1dGlvbl0gU291cmNlIHJlc29sdXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldFJlc29sdXRpb25dIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSb3RhdGlvbl0gU291cmNlIHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRSb3RhdGlvbl0gVGFyZ2V0IHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gQW5jaG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IFN0YXJ0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb21wbGV0ZSBDb21wbGV0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IGVhc2luZyBFYXNpbmcuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IGNhbGxiYWNrIENhbGxiYWNrLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RyYWludHNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jZW50ZXJjb25zdHJhaW50LmpzXCIpLlR5cGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3JvdGF0aW9uY29uc3RyYWludC5qc1wiKS5UeXBlfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpdE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGJveCB0b1xuICogZml0IHRoZSBleHRlbnQgaW50by4gRGVmYXVsdHMgdG8gdGhlIHNpemUgb2YgdGhlIG1hcCB0aGUgdmlldyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiBJZiBubyBtYXAgb3IgbXVsdGlwbGUgbWFwcyBhcmUgY29ubmVjdGVkIHRvIHRoZSB2aWV3LCBwcm92aWRlIHRoZSBkZXNpcmVkIGJveCBzaXplXG4gKiAoZS5nLiBgbWFwLmdldFNpemUoKWApLlxuICogQHByb3BlcnR5IHshQXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIChpbiBwaXhlbHMpIHRvIGJlXG4gKiBjbGVhcmVkIGluc2lkZSB0aGUgdmlldy4gVmFsdWVzIGluIHRoZSBhcnJheSBhcmUgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0XG4gKiBwYWRkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbmVhcmVzdD1mYWxzZV0gSWYgdGhlIHZpZXcgYGNvbnN0cmFpblJlc29sdXRpb25gIG9wdGlvbiBpcyBgdHJ1ZWAsXG4gKiBnZXQgdGhlIG5lYXJlc3QgZXh0ZW50IGluc3RlYWQgb2YgdGhlIGNsb3Nlc3QgdGhhdCBhY3R1YWxseSBmaXRzIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uPTBdIE1pbmltdW0gcmVzb2x1dGlvbiB0aGF0IHdlIHpvb20gdG8uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCB0aGF0IHdlIHpvb20gdG8uIElmXG4gKiBgbWluUmVzb2x1dGlvbmAgaXMgZ2l2ZW4sIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiB0byB0aGUgdGFyZ2V0IGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZCBkdXJpbmdcbiAqIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IFtjYWxsYmFja10gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgaW5cbiAqIGl0cyBmaW5hbCBwb3NpdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYHRydWVgIGlmIHRoZSBhbmltYXRpb25cbiAqIHNlcmllcyBjb21wbGV0ZWQgb24gaXRzIG93biBvciBgZmFsc2VgIGlmIGl0IHdhcyBjYW5jZWxsZWQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGluaXRpYWwgY2VudGVyIGZvclxuICogdGhlIHZpZXcuIElmIGEgdXNlciBwcm9qZWN0aW9uIGlzIG5vdCBzZXQsIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdGhlIGNlbnRlciBpc1xuICogc3BlY2lmaWVkIHdpdGggdGhlIGBwcm9qZWN0aW9uYCBvcHRpb24uIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmUgZmV0Y2hlZCBpZiB0aGlzXG4gKiBpcyBub3Qgc2V0LCBidXQgdGhlIGNlbnRlciBjYW4gYmUgc2V0IGxhdGVyIHdpdGgge0BsaW5rICNzZXRDZW50ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufG51bWJlcn0gW2NvbnN0cmFpblJvdGF0aW9uPXRydWVdIFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKiBgZmFsc2VgIG1lYW5zIG5vIGNvbnN0cmFpbnQuIGB0cnVlYCBtZWFucyBubyBjb25zdHJhaW50LCBidXQgc25hcCB0byB6ZXJvXG4gKiBuZWFyIHplcm8uIEEgbnVtYmVyIGNvbnN0cmFpbnMgdGhlIHJvdGF0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHZhbHVlcy4gRm9yXG4gKiBleGFtcGxlLCBgNGAgd2lsbCBjb25zdHJhaW4gdGhlIHJvdGF0aW9uIHRvIDAsIDkwLCAxODAsIGFuZCAyNzAgZGVncmVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZVJvdGF0aW9uPXRydWVdIEVuYWJsZSByb3RhdGlvbi5cbiAqIElmIGBmYWxzZWAsIGEgcm90YXRpb24gY29uc3RyYWludCB0aGF0IGFsd2F5cyBzZXRzIHRoZSByb3RhdGlvbiB0byB6ZXJvIGlzXG4gKiB1c2VkLiBUaGUgYGNvbnN0cmFpblJvdGF0aW9uYCBvcHRpb24gaGFzIG5vIGVmZmVjdCBpZiBgZW5hYmxlUm90YXRpb25gIGlzXG4gKiBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBleHRlbnQgdGhhdCBjb25zdHJhaW5zIHRoZVxuICogdmlldywgaW4gb3RoZXIgd29yZHMsIG5vdGhpbmcgb3V0c2lkZSBvZiB0aGlzIGV4dGVudCBjYW4gYmUgdmlzaWJsZSBvbiB0aGUgbWFwLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluT25seUNlbnRlcj1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIG9ubHkgYXBwbHkgdG8gdGhlIHZpZXcgY2VudGVyIGFuZCBub3QgdGhlIHdob2xlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Ntb290aEV4dGVudENvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIGJlIGFwcGxpZWQgc21vb3RobHksIGkuZS4gYWxsb3cgdGhlIHZpZXcgdG8gZ28gc2xpZ2h0bHkgb3V0c2lkZVxuICogb2YgdGhlIGdpdmVuIGBleHRlbnRgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1pblJlc29sdXRpb25gIChvclxuICogYG1heFpvb21gKSBhbmQgYHpvb21GYWN0b3JgLiBJZiB1bnNwZWNpZmllZCBpdCBpcyBjYWxjdWxhdGVkIGluIHN1Y2ggYSB3YXlcbiAqIHRoYXQgdGhlIHByb2plY3Rpb24ncyB2YWxpZGl0eSBleHRlbnQgZml0cyBpbiBhIDI1NngyNTYgcHggdGlsZS4gSWYgdGhlXG4gKiBwcm9qZWN0aW9uIGlzIFNwaGVyaWNhbCBNZXJjYXRvciAodGhlIGRlZmF1bHQpIHRoZW4gYG1heFJlc29sdXRpb25gIGRlZmF1bHRzXG4gKiB0byBgNDAwNzUwMTYuNjg1NTc4NDkgLyAyNTYgPSAxNTY1NDMuMDMzOTI4MDQwOTdgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiAgSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtYXhSZXNvbHV0aW9uYCAob3JcbiAqIGBtaW5ab29tYCkgYW5kIGB6b29tRmFjdG9yYC4gIElmIHVuc3BlY2lmaWVkIGl0IGlzIGNhbGN1bGF0ZWQgYXNzdW1pbmcgMjlcbiAqIHpvb20gbGV2ZWxzICh3aXRoIGEgZmFjdG9yIG9mIDIpLiBJZiB0aGUgcHJvamVjdGlvbiBpcyBTcGhlcmljYWwgTWVyY2F0b3JcbiAqICh0aGUgZGVmYXVsdCkgdGhlbiBgbWluUmVzb2x1dGlvbmAgZGVmYXVsdHMgdG9cbiAqIGA0MDA3NTAxNi42ODU1Nzg0OSAvIDI1NiAvIE1hdGgucG93KDIsIDI4KSA9IDAuMDAwNTgzMTY4MjQ1NTgzOTI1M2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MjhdIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWluWm9vbWAgKG9yXG4gKiBgbWF4UmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1pblJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1heFpvb21gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWF4Wm9vbWAgKG9yXG4gKiBgbWluUmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1heFJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1pblpvb21gLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlXb3JsZD1mYWxzZV0gSWYgYGZhbHNlYCB0aGUgdmlldyBpcyBjb25zdHJhaW5lZCBzb1xuICogb25seSBvbmUgd29ybGQgaXMgdmlzaWJsZSwgYW5kIHlvdSBjYW5ub3QgcGFuIG9mZiB0aGUgZWRnZS4gIElmIGB0cnVlYCB0aGUgbWFwXG4gKiBtYXkgc2hvdyBtdWx0aXBsZSB3b3JsZHMgYXQgbG93IHpvb20gbGV2ZWxzLiAgT25seSB1c2VkIGlmIHRoZSBgcHJvamVjdGlvbmAgaXNcbiAqIGdsb2JhbC4gIE5vdGUgdGhhdCBpZiBgZXh0ZW50YCBpcyBhbHNvIHByb3ZpZGVkIGl0IGlzIGdpdmVuIHByZWNlZGVuY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGFsd2F5c1xuICogYW5pbWF0ZSB0byB0aGUgY2xvc2VzdCB6b29tIGxldmVsIGFmdGVyIGFuIGludGVyYWN0aW9uOyBmYWxzZSBtZWFuc1xuICogaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbGxvd2VkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIHJlc29sdXRpb25cbiAqIG1pbi9tYXggdmFsdWVzIHdpbGwgYmUgYXBwbGllZCBzbW9vdGhseSwgaS4gZS4gYWxsb3cgdGhlIHZpZXcgdG8gZXhjZWVkIHNsaWdodGx5XG4gKiB0aGUgZ2l2ZW4gcmVzb2x1dGlvbiBvciB6b29tIGJvdW5kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dGdWxsRXh0ZW50PWZhbHNlXSBBbGxvdyB0aGUgdmlldyB0byBiZSB6b29tZWQgb3V0IHRvXG4gKiBzaG93IHRoZSBmdWxsIGNvbmZpZ3VyZWQgZXh0ZW50LiBCeSBkZWZhdWx0LCB3aGVuIGEgdmlldyBpcyBjb25maWd1cmVkIHdpdGggYW5cbiAqIGV4dGVudCwgdXNlcnMgd2lsbCBub3QgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGUgdmlld3BvcnQgZXhjZWVkcyB0aGUgZXh0ZW50IGluXG4gKiBlaXRoZXIgZGltZW5zaW9uLiBUaGlzIG1lYW5zIHRoZSBmdWxsIGV4dGVudCBtYXkgbm90IGJlIHZpc2libGUgaWYgdGhlIHZpZXdwb3J0XG4gKiBpcyB0YWxsZXIgb3Igd2lkZXIgdGhhbiB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudC4gSWZcbiAqIHNob3dGdWxsRXh0ZW50IGlzIHRydWUsIHRoZSB1c2VyIHdpbGwgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGF0IHRoZSB2aWV3cG9ydFxuICogZXhjZWVkcyB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudCwgYnV0IG5vdCBib3RoLCBhbGxvd2luZyB0aGVcbiAqIGZ1bGwgZXh0ZW50IHRvIGJlIHNob3duLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXSBUaGVcbiAqIHByb2plY3Rpb24uIFRoZSBkZWZhdWx0IGlzIFNwaGVyaWNhbCBNZXJjYXRvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzb2x1dGlvbl0gVGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuIFRoZVxuICogdW5pdHMgYXJlIGBwcm9qZWN0aW9uYCB1bml0cyBwZXIgcGl4ZWwgKGUuZy4gbWV0ZXJzIHBlciBwaXhlbCkuIEFuXG4gKiBhbHRlcm5hdGl2ZSB0byBzZXR0aW5nIHRoaXMgaXMgdG8gc2V0IGB6b29tYC4gTGF5ZXIgc291cmNlcyB3aWxsIG5vdCBiZVxuICogZmV0Y2hlZCBpZiBuZWl0aGVyIHRoaXMgbm9yIGB6b29tYCBhcmUgZGVmaW5lZCwgYnV0IHRoZXkgY2FuIGJlIHNldCBsYXRlclxuICogd2l0aCB7QGxpbmsgI3NldFpvb219IG9yIHtAbGluayAjc2V0UmVzb2x1dGlvbn0uXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9uc10gUmVzb2x1dGlvbnMgdGhhdCBkZXRlcm1pbmUgdGhlXG4gKiB6b29tIGxldmVscyBpZiBzcGVjaWZpZWQuIFRoZSBpbmRleCBpbiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gdGhlIHpvb20gbGV2ZWwsXG4gKiB0aGVyZWZvcmUgdGhlIHJlc29sdXRpb24gdmFsdWVzIGhhdmUgdG8gYmUgaW4gZGVzY2VuZGluZyBvcmRlci4gSXQgYWxzbyBjb25zdHJhaW5zXG4gKiB0aGUgcmVzb2x1dGlvbiBieSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgc2V0IHRoZSBgbWF4UmVzb2x1dGlvbmAsXG4gKiBgbWluUmVzb2x1dGlvbmAsIGBtaW5ab29tYCwgYG1heFpvb21gLCBhbmQgYHpvb21GYWN0b3JgIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSBpbml0aWFsIHJvdGF0aW9uIGZvciB0aGUgdmlldyBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCAwIG1lYW5zIE5vcnRoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gT25seSB1c2VkIGlmIGByZXNvbHV0aW9uYCBpcyBub3QgZGVmaW5lZC4gWm9vbVxuICogbGV2ZWwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21GYWN0b3I9Ml0gVGhlIHpvb20gZmFjdG9yIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5PG51bWJlcj59IFtwYWRkaW5nPVswLCAwLCAwLCAwXV0gUGFkZGluZyAoaW4gY3NzIHBpeGVscykuXG4gKiBJZiB0aGUgbWFwIHZpZXdwb3J0IGlzIHBhcnRpYWxseSBjb3ZlcmVkIHdpdGggb3RoZXIgY29udGVudCAob3ZlcmxheXMpIGFsb25nXG4gKiBpdHMgZWRnZXMsIHRoaXMgc2V0dGluZyBhbGxvd3MgdG8gc2hpZnQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgYXdheSBmcm9tXG4gKiB0aGF0IGNvbnRlbnQuIFRoZSBvcmRlciBvZiB0aGUgdmFsdWVzIGlzIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjZW50ZXJdIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZlxuICogdGhlIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGFuaW1hdGlvbi4gVGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHJlc29sdXRpb25gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kXG4gKiBvZiB0aGUgYW5pbWF0aW9uLiAgSWYgYHpvb21gIGlzIGFsc28gcHJvdmlkZWQsIHRoaXMgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb25dIFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mXG4gKiB0aGUgYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gT3B0aW9uYWwgYW5jaG9yIHRvIHJlbWFpbiBmaXhlZFxuICogZHVyaW5nIGEgcm90YXRpb24gb3IgcmVzb2x1dGlvbiBhbmltYXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMDBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZFxuICogZHVyaW5nIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoaW4gdmlldyBwcm9qZWN0aW9uIGNvb3JkaW5hdGVzKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtuZXh0Q2VudGVyXSBUaGUgbmV4dCBjZW50ZXIgZHVyaW5nIGFuIGFuaW1hdGlvbiBzZXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW25leHRSZXNvbHV0aW9uXSBUaGUgbmV4dCByZXNvbHV0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtuZXh0Um90YXRpb25dIFRoZSBuZXh0IHJvdGF0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb20gWm9vbS5cbiAqL1xuXG4vKipcbiAqIExpa2Uge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LCBidXQganVzdCBgdmlld1N0YXRlYCBhbmQgYGV4dGVudGAuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50XG4gKiBAcHJvcGVydHkge1N0YXRlfSB2aWV3U3RhdGUgVmlldyBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50IChpbiB1c2VyIHByb2plY3Rpb24gY29vcmRpbmF0ZXMpLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlPn0gW2xheWVyU3RhdGVzQXJyYXldIExheWVyIHN0YXRlcy5cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWluIHpvb20gbGV2ZWwgZm9yIHRoZSBtYXAgdmlldy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IERFRkFVTFRfTUlOX1pPT00gPSAwO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmNlbnRlcid8J2NoYW5nZTpyZXNvbHV0aW9uJ3wnY2hhbmdlOnJvdGF0aW9uJ30gVmlld09iamVjdEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPFZpZXdPYmplY3RFdmVudFR5cGVzLCBpbXBvcnQoXCIuL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfFZpZXdPYmplY3RFdmVudFR5cGVzLCBSZXR1cm4+fSBWaWV3T25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgVmlldyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbXBsZSAyRCB2aWV3IG9mIHRoZSBtYXAuXG4gKlxuICogVGhpcyBpcyB0aGUgb2JqZWN0IHRvIGFjdCB1cG9uIHRvIGNoYW5nZSB0aGUgY2VudGVyLCByZXNvbHV0aW9uLFxuICogYW5kIHJvdGF0aW9uIG9mIHRoZSBtYXAuXG4gKlxuICogQSBWaWV3IGhhcyBhIGBwcm9qZWN0aW9uYC4gVGhlIHByb2plY3Rpb24gZGV0ZXJtaW5lcyB0aGVcbiAqIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjZW50ZXIsIGFuZCBpdHMgdW5pdHMgZGV0ZXJtaW5lIHRoZSB1bml0cyBvZiB0aGVcbiAqIHJlc29sdXRpb24gKHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsKS4gVGhlIGRlZmF1bHQgcHJvamVjdGlvbiBpc1xuICogV2ViIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICpcbiAqICMjIyBUaGUgdmlldyBzdGF0ZXNcbiAqXG4gKiBBIFZpZXcgaXMgZGV0ZXJtaW5lZCBieSB0aHJlZSBzdGF0ZXM6IGBjZW50ZXJgLCBgcmVzb2x1dGlvbmAsXG4gKiBhbmQgYHJvdGF0aW9uYC4gRWFjaCBzdGF0ZSBoYXMgYSBjb3JyZXNwb25kaW5nIGdldHRlciBhbmQgc2V0dGVyLCBlLmcuXG4gKiBgZ2V0Q2VudGVyYCBhbmQgYHNldENlbnRlcmAgZm9yIHRoZSBgY2VudGVyYCBzdGF0ZS5cbiAqXG4gKiBUaGUgYHpvb21gIHN0YXRlIGlzIGFjdHVhbGx5IG5vdCBzYXZlZCBvbiB0aGUgdmlldzogYWxsIGNvbXB1dGF0aW9uc1xuICogaW50ZXJuYWxseSB1c2UgdGhlIGByZXNvbHV0aW9uYCBzdGF0ZS4gU3RpbGwsIHRoZSBgc2V0Wm9vbWAgYW5kIGBnZXRab29tYFxuICogbWV0aG9kcyBhcmUgYXZhaWxhYmxlLCBhcyB3ZWxsIGFzIGBnZXRSZXNvbHV0aW9uRm9yWm9vbWAgYW5kXG4gKiBgZ2V0Wm9vbUZvclJlc29sdXRpb25gIHRvIHN3aXRjaCBmcm9tIG9uZSBzeXN0ZW0gdG8gdGhlIG90aGVyLlxuICpcbiAqICMjIyBUaGUgY29uc3RyYWludHNcbiAqXG4gKiBgc2V0Q2VudGVyYCwgYHNldFJlc29sdXRpb25gIGFuZCBgc2V0Um90YXRpb25gIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGVcbiAqIHN0YXRlcyBvZiB0aGUgdmlldywgYnV0IGFueSBjb25zdHJhaW50IGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdpbGxcbiAqIGJlIGFwcGxpZWQgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBBIFZpZXcgb2JqZWN0IGNhbiBoYXZlIGEgKnJlc29sdXRpb24gY29uc3RyYWludCosIGEgKnJvdGF0aW9uIGNvbnN0cmFpbnQqXG4gKiBhbmQgYSAqY2VudGVyIGNvbnN0cmFpbnQqLlxuICpcbiAqIFRoZSAqcmVzb2x1dGlvbiBjb25zdHJhaW50KiB0eXBpY2FsbHkgcmVzdHJpY3RzIG1pbi9tYXggdmFsdWVzIGFuZFxuICogc25hcHMgdG8gc3BlY2lmaWMgcmVzb2x1dGlvbnMuIEl0IGlzIGRldGVybWluZWQgYnkgdGhlIGZvbGxvd2luZ1xuICogb3B0aW9uczogYHJlc29sdXRpb25zYCwgYG1heFJlc29sdXRpb25gLCBgbWF4Wm9vbWAgYW5kIGB6b29tRmFjdG9yYC5cbiAqIElmIGByZXNvbHV0aW9uc2AgaXMgc2V0LCB0aGUgb3RoZXIgdGhyZWUgb3B0aW9ucyBhcmUgaWdub3JlZC4gU2VlXG4gKiBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG9wdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIHZpZXdcbiAqIG9ubHkgaGFzIGEgbWluL21heCByZXN0cmljdGlvbiBhbmQgYWxsb3cgaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIHdoZW5cbiAqIHBpbmNoLXpvb21pbmcgZm9yIGV4YW1wbGUuXG4gKlxuICogVGhlICpyb3RhdGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyBhbmdsZXMuIEl0IGlzIGRldGVybWluZWRcbiAqIGJ5IHRoZSBmb2xsb3dpbmcgb3B0aW9uczogYGVuYWJsZVJvdGF0aW9uYCBhbmQgYGNvbnN0cmFpblJvdGF0aW9uYC5cbiAqIEJ5IGRlZmF1bHQgcm90YXRpb24gaXMgYWxsb3dlZCBhbmQgaXRzIHZhbHVlIGlzIHNuYXBwZWQgdG8gemVybyB3aGVuIGFwcHJvYWNoaW5nIHRoZVxuICogaG9yaXpvbnRhbC5cbiAqXG4gKiBUaGUgKmNlbnRlciBjb25zdHJhaW50KiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgZXh0ZW50YCBvcHRpb24uIEJ5XG4gKiBkZWZhdWx0IHRoZSB2aWV3IGNlbnRlciBpcyBub3QgY29uc3RyYWluZWQgYXQgYWxsLlxuICpcbiAqICMjIyBDaGFuZ2luZyB0aGUgdmlldyBzdGF0ZVxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgYHNldFpvb21gLCBgc2V0UmVzb2x1dGlvbmAsIGBzZXRDZW50ZXJgIGFuZFxuICogYHNldFJvdGF0aW9uYCBhcmUgc3ViamVjdCB0byB0aGUgYWJvdmUgbWVudGlvbmVkIGNvbnN0cmFpbnRzLiBBcyBzdWNoLCBpdFxuICogbWF5IHNvbWV0aW1lcyBub3QgYmUgcG9zc2libGUgdG8ga25vdyBpbiBhZHZhbmNlIHRoZSByZXN1bHRpbmcgc3RhdGUgb2YgdGhlXG4gKiBWaWV3LiBGb3IgZXhhbXBsZSwgY2FsbGluZyBgc2V0UmVzb2x1dGlvbigxMClgIGRvZXMgbm90IGd1YXJhbnRlZSB0aGF0XG4gKiBgZ2V0UmVzb2x1dGlvbigpYCB3aWxsIHJldHVybiBgMTBgLlxuICpcbiAqIEEgY29uc2VxdWVuY2Ugb2YgdGhpcyBpcyB0aGF0LCB3aGVuIGFwcGx5aW5nIGEgZGVsdGEgb24gdGhlIHZpZXcgc3RhdGUsIG9uZVxuICogc2hvdWxkIHVzZSBgYWRqdXN0Q2VudGVyYCwgYGFkanVzdFJvdGF0aW9uYCwgYGFkanVzdFpvb21gIGFuZCBgYWRqdXN0UmVzb2x1dGlvbmBcbiAqIHJhdGhlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIHNldHRlcnMuIFRoaXMgd2lsbCBsZXQgdmlldyBkbyBpdHMgaW50ZXJuYWxcbiAqIGNvbXB1dGF0aW9ucy4gQmVzaWRlcywgdGhlIGBhZGp1c3QqYCBtZXRob2RzIGFsc28gdGFrZSBhbiBgYW5jaG9yYFxuICogYXJndW1lbnQgd2hpY2ggYWxsb3dzIHNwZWNpZnlpbmcgYW4gb3JpZ2luIGZvciB0aGUgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogIyMjIEludGVyYWN0aW5nIHdpdGggdGhlIHZpZXdcbiAqXG4gKiBWaWV3IGNvbnN0cmFpbnRzIGFyZSB1c3VhbGx5IG9ubHkgYXBwbGllZCB3aGVuIHRoZSB2aWV3IGlzICphdCByZXN0KiwgbWVhbmluZyB0aGF0XG4gKiBubyBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgb25nb2luZy4gQXMgc3VjaCwgaWYgdGhlIHVzZXIgcHV0cyB0aGUgdmlldyBpbiBhXG4gKiBzdGF0ZSB0aGF0IGlzIG5vdCBlcXVpdmFsZW50IHRvIGEgY29uc3RyYWluZWQgb25lIChlLmcuIHJvdGF0aW5nIHRoZSB2aWV3IHdoZW5cbiAqIHRoZSBzbmFwIGFuZ2xlIGlzIDApLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgYXQgdGhlIGludGVyYWN0aW9uIGVuZCB0b1xuICogcHV0IGJhY2sgdGhlIHZpZXcgdG8gYSBzdGFibGUgc3RhdGU7XG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBWaWV3IGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBbb3B0aW9uc10gVmlldyBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Vmlld09uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuaGludHNfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8QW5pbWF0aW9uPj59XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy52aWV3cG9ydFNpemVfID0gWzEwMCwgMTAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMubmV4dENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0aW9ucy5wcm9qZWN0aW9uKSB7XG4gICAgICBkaXNhYmxlQ29vcmRpbmF0ZVdhcm5pbmcoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICBvcHRpb25zLmNlbnRlciA9IGZyb21Vc2VyQ29vcmRpbmF0ZShvcHRpb25zLmNlbnRlciwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4dGVudCkge1xuICAgICAgb3B0aW9ucy5leHRlbnQgPSBmcm9tVXNlckV4dGVudChvcHRpb25zLmV4dGVudCwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAgICovXG4gIGFwcGx5T3B0aW9uc18ob3B0aW9ucykge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBWaWV3UHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2tleV07XG4gICAgfVxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0cnVlKTtcblxuICAgIGNvbnN0IHJlc29sdXRpb25Db25zdHJhaW50SW5mbyA9IGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWF4UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblJlc29sdXRpb25fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby56b29tRmFjdG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wYWRkaW5nXyA9IG9wdGlvbnMucGFkZGluZztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblpvb21fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblpvb207XG5cbiAgICBjb25zdCBjZW50ZXJDb25zdHJhaW50ID0gY3JlYXRlQ2VudGVyQ29uc3RyYWludChvcHRpb25zKTtcbiAgICBjb25zdCByZXNvbHV0aW9uQ29uc3RyYWludCA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5jb25zdHJhaW50O1xuICAgIGNvbnN0IHJvdGF0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVJvdGF0aW9uQ29uc3RyYWludChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NvbnN0cmFpbnRzfVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHNfID0ge1xuICAgICAgY2VudGVyOiBjZW50ZXJDb25zdHJhaW50LFxuICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbkNvbnN0cmFpbnQsXG4gICAgICByb3RhdGlvbjogcm90YXRpb25Db25zdHJhaW50LFxuICAgIH07XG5cbiAgICB0aGlzLnNldFJvdGF0aW9uKG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwKTtcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFxuICAgICAgb3B0aW9ucy5jZW50ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2VudGVyIDogbnVsbCxcbiAgICApO1xuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKG9wdGlvbnMucmVzb2x1dGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRab29tKG9wdGlvbnMuem9vbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhZGRpbmcgKGluIGNzcyBwaXhlbHMpLlxuICAgKiBJZiB0aGUgbWFwIHZpZXdwb3J0IGlzIHBhcnRpYWxseSBjb3ZlcmVkIHdpdGggb3RoZXIgY29udGVudCAob3ZlcmxheXMpIGFsb25nXG4gICAqIGl0cyBlZGdlcywgdGhpcyBzZXR0aW5nIGFsbG93cyB0byBzaGlmdCB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhd2F5IGZyb20gdGhhdFxuICAgKiBjb250ZW50LiBUaGUgb3JkZXIgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgaXMgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LlxuICAgKiBUaGUgZGVmYXVsdCBpcyBubyBwYWRkaW5nLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIGBbMCwgMCwgMCwgMF1gLlxuICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAqIEBhcGlcbiAgICovXG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBhZGRpbmdfO1xuICB9XG4gIHNldCBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBsZXQgb2xkUGFkZGluZyA9IHRoaXMucGFkZGluZ187XG4gICAgdGhpcy5wYWRkaW5nXyA9IHBhZGRpbmc7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgIGNvbnN0IG5ld1BhZGRpbmcgPSBwYWRkaW5nIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIG9sZFBhZGRpbmcgPSBvbGRQYWRkaW5nIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICAgIGNvbnN0IG9mZnNldFggPVxuICAgICAgICAocmVzb2x1dGlvbiAvIDIpICpcbiAgICAgICAgKG5ld1BhZGRpbmdbM10gLSBvbGRQYWRkaW5nWzNdICsgb2xkUGFkZGluZ1sxXSAtIG5ld1BhZGRpbmdbMV0pO1xuICAgICAgY29uc3Qgb2Zmc2V0WSA9XG4gICAgICAgIChyZXNvbHV0aW9uIC8gMikgKlxuICAgICAgICAobmV3UGFkZGluZ1swXSAtIG9sZFBhZGRpbmdbMF0gKyBvbGRQYWRkaW5nWzJdIC0gbmV3UGFkZGluZ1syXSk7XG4gICAgICB0aGlzLnNldENlbnRlckludGVybmFsKFtjZW50ZXJbMF0gKyBvZmZzZXRYLCBjZW50ZXJbMV0gLSBvZmZzZXRZXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIHZpZXcgb3B0aW9ucyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdmlldy4gIFRoZVxuICAgKiBjdXJyZW50IHJlc29sdXRpb24gKG9yIHpvb20pLCBjZW50ZXIsIGFuZCByb3RhdGlvbiBhcmUgYXBwbGllZCB0byBhbnkgc3RvcmVkXG4gICAqIG9wdGlvbnMuICBUaGUgcHJvdmlkZWQgb3B0aW9ucyBjYW4gYmUgdXNlZCB0byBhcHBseSBuZXcgbWluL21heCB6b29tIG9yXG4gICAqIHJlc29sdXRpb24gbGltaXRzLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBuZXdPcHRpb25zIE5ldyBvcHRpb25zIHRvIGJlIGFwcGxpZWQuXG4gICAqIEByZXR1cm4ge1ZpZXdPcHRpb25zfSBOZXcgb3B0aW9ucyB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgdmlldyBzdGF0ZS5cbiAgICovXG4gIGdldFVwZGF0ZWRPcHRpb25zXyhuZXdPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuXG4gICAgLy8gcHJlc2VydmUgcmVzb2x1dGlvbiAob3Igem9vbSlcbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnpvb20gPSB0aGlzLmdldFpvb20oKTtcbiAgICB9XG5cbiAgICAvLyBwcmVzZXJ2ZSBjZW50ZXJcbiAgICBvcHRpb25zLmNlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcblxuICAgIC8vIHByZXNlcnZlIHJvdGF0aW9uXG4gICAgb3B0aW9ucy5yb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRlIHRoZSB2aWV3LiAgVGhlIHZpZXcncyBjZW50ZXIsIHpvb20gKG9yIHJlc29sdXRpb24pLCBhbmQgcm90YXRpb25cbiAgICogY2FuIGJlIGFuaW1hdGVkIGZvciBzbW9vdGggdHJhbnNpdGlvbnMgYmV0d2VlbiB2aWV3IHN0YXRlcy4gIEZvciBleGFtcGxlLFxuICAgKiB0byBhbmltYXRlIHRoZSB2aWV3IHRvIGEgbmV3IHpvb20gbGV2ZWw6XG4gICAqXG4gICAqICAgICB2aWV3LmFuaW1hdGUoe3pvb206IHZpZXcuZ2V0Wm9vbSgpICsgMX0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgYW5pbWF0aW9uIGxhc3RzIG9uZSBzZWNvbmQgYW5kIHVzZXMgaW4tYW5kLW91dCBlYXNpbmcuICBZb3VcbiAgICogY2FuIGN1c3RvbWl6ZSB0aGlzIGJlaGF2aW9yIGJ5IGluY2x1ZGluZyBgZHVyYXRpb25gIChpbiBtaWxsaXNlY29uZHMpIGFuZFxuICAgKiBgZWFzaW5nYCBvcHRpb25zIChzZWUge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmd9KS5cbiAgICpcbiAgICogVG8gY2hhaW4gdG9nZXRoZXIgbXVsdGlwbGUgYW5pbWF0aW9ucywgY2FsbCB0aGUgbWV0aG9kIHdpdGggbXVsdGlwbGVcbiAgICogYW5pbWF0aW9uIG9iamVjdHMuICBGb3IgZXhhbXBsZSwgdG8gZmlyc3Qgem9vbSBhbmQgdGhlbiBwYW46XG4gICAqXG4gICAqICAgICB2aWV3LmFuaW1hdGUoe3pvb206IDEwfSwge2NlbnRlcjogWzAsIDBdfSk7XG4gICAqXG4gICAqIElmIHlvdSBwcm92aWRlIGEgZnVuY3Rpb24gYXMgdGhlIGxhc3QgYXJndW1lbnQgdG8gdGhlIGFuaW1hdGUgbWV0aG9kLCBpdFxuICAgKiB3aWxsIGdldCBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24gc2VyaWVzLiAgVGhlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICogY2FsbGVkIHdpdGggYHRydWVgIGlmIHRoZSBhbmltYXRpb24gc2VyaWVzIGNvbXBsZXRlZCBvbiBpdHMgb3duIG9yIGBmYWxzZWBcbiAgICogaWYgaXQgd2FzIGNhbmNlbGxlZC5cbiAgICpcbiAgICogQW5pbWF0aW9ucyBhcmUgY2FuY2VsbGVkIGJ5IHVzZXIgaW50ZXJhY3Rpb25zIChlLmcuIGRyYWdnaW5nIHRoZSBtYXApIG9yIGJ5XG4gICAqIGNhbGxpbmcgYHZpZXcuc2V0Q2VudGVyKClgLCBgdmlldy5zZXRSZXNvbHV0aW9uKClgLCBvciBgdmlldy5zZXRSb3RhdGlvbigpYFxuICAgKiAob3IgYW5vdGhlciBtZXRob2QgdGhhdCBjYWxscyBvbmUgb2YgdGhlc2UpLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihBbmltYXRpb25PcHRpb25zfGZ1bmN0aW9uKGJvb2xlYW4pOiB2b2lkKX0gdmFyX2FyZ3MgQW5pbWF0aW9uXG4gICAqICAgICBvcHRpb25zLiAgTXVsdGlwbGUgYW5pbWF0aW9ucyBjYW4gYmUgcnVuIGluIHNlcmllcyBieSBwYXNzaW5nIG11bHRpcGxlXG4gICAqICAgICBvcHRpb25zIG9iamVjdHMuICBUbyBydW4gbXVsdGlwbGUgYW5pbWF0aW9ucyBpbiBwYXJhbGxlbCwgY2FsbCB0aGUgbWV0aG9kXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcy4gIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCBhcyBhIGZpbmFsXG4gICAqICAgICBhcmd1bWVudC4gIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICogICAgIHRoZSBhbmltYXRpb24gY29tcGxldGVkIHdpdGhvdXQgYmVpbmcgY2FuY2VsbGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBhbmltYXRlKHZhcl9hcmdzKSB7XG4gICAgaWYgKHRoaXMuaXNEZWYoKSAmJiAhdGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoMCk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChvcHRpb25zLmNlbnRlcikge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuY2VudGVyID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgICAgIG9wdGlvbnMuY2VudGVyLFxuICAgICAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYW5jaG9yKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5hbmNob3IgPSBmcm9tVXNlckNvb3JkaW5hdGUoXG4gICAgICAgICAgb3B0aW9ucy5hbmNob3IsXG4gICAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gb3B0aW9ucztcbiAgICB9XG4gICAgdGhpcy5hbmltYXRlSW50ZXJuYWwuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oQW5pbWF0aW9uT3B0aW9uc3xmdW5jdGlvbihib29sZWFuKTogdm9pZCl9IHZhcl9hcmdzIEFuaW1hdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYW5pbWF0ZUludGVybmFsKHZhcl9hcmdzKSB7XG4gICAgbGV0IGFuaW1hdGlvbkNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgaWYgKFxuICAgICAgYW5pbWF0aW9uQ291bnQgPiAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV0gPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV07XG4gICAgICAtLWFuaW1hdGlvbkNvdW50O1xuICAgIH1cblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGFuaW1hdGlvbkNvdW50ICYmICF0aGlzLmlzRGVmKCk7ICsraSkge1xuICAgICAgLy8gaWYgdmlldyBwcm9wZXJ0aWVzIGFyZSBub3QgeWV0IHNldCwgc2hvcnRjdXQgdG8gdGhlIGZpbmFsIHN0YXRlXG4gICAgICBjb25zdCBzdGF0ZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChzdGF0ZS5jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChzdGF0ZS5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFpvb20oc3RhdGUuem9vbSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnJlc29sdXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKHN0YXRlLnJlc29sdXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihzdGF0ZS5yb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBhbmltYXRpb25Db3VudCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLnRhcmdldENlbnRlcl8uc2xpY2UoKTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0UmVzb2x1dGlvbl87XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy50YXJnZXRSb3RhdGlvbl87XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgZm9yICg7IGkgPCBhbmltYXRpb25Db3VudDsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtBbmltYXRpb25PcHRpb25zfSAqLyAoYXJndW1lbnRzW2ldKTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgYW5jaG9yOiBvcHRpb25zLmFuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nIHx8IGluQW5kT3V0LFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZUNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldENlbnRlciA9IG9wdGlvbnMuY2VudGVyLnNsaWNlKCk7XG4gICAgICAgIGNlbnRlciA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbShvcHRpb25zLnpvb20pO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIGNvbnN0IGRlbHRhID1cbiAgICAgICAgICBtb2R1bG8ob3B0aW9ucy5yb3RhdGlvbiAtIHJvdGF0aW9uICsgTWF0aC5QSSwgMiAqIE1hdGguUEkpIC0gTWF0aC5QSTtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uID0gcm90YXRpb24gKyBkZWx0YTtcbiAgICAgICAgcm90YXRpb24gPSBhbmltYXRpb24udGFyZ2V0Um90YXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBhIG5vLW9wXG4gICAgICBpZiAoaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgYW5pbWF0aW9uLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gd2Ugc3RpbGwgcHVzaCBpdCBvbnRvIHRoZSBzZXJpZXMgZm9yIGNhbGxiYWNrIGhhbmRsaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCArPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICB9XG4gICAgICBzZXJpZXMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnNfLnB1c2goc2VyaWVzKTtcbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAxKTtcbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB2aWV3IGlzIGJlaW5nIGFuaW1hdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlldyBpcyBiZWluZyBhbmltYXRlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1tWaWV3SGludC5BTklNQVRJTkddID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlldywgc3VjaCBhcyBwYW5uaW5nIG9yIHpvb21pbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aWV3IGlzIGJlaW5nIGludGVyYWN0ZWQgd2l0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJhY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW1ZpZXdIaW50LklOVEVSQUNUSU5HXSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBvbmdvaW5nIGFuaW1hdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNhbmNlbEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LkFOSU1BVElORywgLXRoaXMuaGludHNfW1ZpZXdIaW50LkFOSU1BVElOR10pO1xuICAgIGxldCBhbmNob3I7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLmFuaW1hdGlvbnNfW2ldO1xuICAgICAgaWYgKHNlcmllc1swXS5jYWxsYmFjaykge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFjayhzZXJpZXNbMF0uY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHNlcmllcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gc2VyaWVzW2pdO1xuICAgICAgICAgIGlmICghYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBhbmltYXRpb24uYW5jaG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSBhbmNob3I7XG4gICAgdGhpcy5uZXh0Q2VudGVyXyA9IG51bGw7XG4gICAgdGhpcy5uZXh0UmVzb2x1dGlvbl8gPSBOYU47XG4gICAgdGhpcy5uZXh0Um90YXRpb25fID0gTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbGwgYW5pbWF0aW9ucy5cbiAgICovXG4gIHVwZGF0ZUFuaW1hdGlvbnNfKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVBbmltYXRpb25LZXlfKTtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IG1vcmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5hbmltYXRpb25zX1tpXTtcbiAgICAgIGxldCBzZXJpZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBzZXJpZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBzZXJpZXNbal07XG4gICAgICAgIGlmIChhbmltYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGFwc2VkID0gbm93IC0gYW5pbWF0aW9uLnN0YXJ0O1xuICAgICAgICBsZXQgZnJhY3Rpb24gPVxuICAgICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA+IDAgPyBlbGFwc2VkIC8gYW5pbWF0aW9uLmR1cmF0aW9uIDogMTtcbiAgICAgICAgaWYgKGZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICBhbmltYXRpb24uY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGZyYWN0aW9uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gYW5pbWF0aW9uLmVhc2luZyhmcmFjdGlvbik7XG4gICAgICAgIGlmIChhbmltYXRpb24uc291cmNlQ2VudGVyKSB7XG4gICAgICAgICAgY29uc3QgeDAgPSBhbmltYXRpb24uc291cmNlQ2VudGVyWzBdO1xuICAgICAgICAgIGNvbnN0IHkwID0gYW5pbWF0aW9uLnNvdXJjZUNlbnRlclsxXTtcbiAgICAgICAgICBjb25zdCB4MSA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXJbMF07XG4gICAgICAgICAgY29uc3QgeTEgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyWzFdO1xuICAgICAgICAgIHRoaXMubmV4dENlbnRlcl8gPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyO1xuICAgICAgICAgIGNvbnN0IHggPSB4MCArIHByb2dyZXNzICogKHgxIC0geDApO1xuICAgICAgICAgIGNvbnN0IHkgPSB5MCArIHByb2dyZXNzICogKHkxIC0geTApO1xuICAgICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IFt4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gJiYgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICAgICAgICBjb25zdCByZXNvbHV0aW9uID1cbiAgICAgICAgICAgIHByb2dyZXNzID09PSAxXG4gICAgICAgICAgICAgID8gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb25cbiAgICAgICAgICAgICAgOiBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiArXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgKlxuICAgICAgICAgICAgICAgICAgKGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uIC0gYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKFxuICAgICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IHRoaXMuY2FsY3VsYXRlQ2VudGVyWm9vbShcbiAgICAgICAgICAgICAgY29uc3RyYWluZWRSZXNvbHV0aW9uLFxuICAgICAgICAgICAgICBhbmltYXRpb24uYW5jaG9yLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvbl8gPSBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcbiAgICAgICAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID1cbiAgICAgICAgICAgIHByb2dyZXNzID09PSAxXG4gICAgICAgICAgICAgID8gbW9kdWxvKGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiArIE1hdGguUEksIDIgKiBNYXRoLlBJKSAtXG4gICAgICAgICAgICAgICAgTWF0aC5QSVxuICAgICAgICAgICAgICA6IGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiArXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgKlxuICAgICAgICAgICAgICAgICAgKGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiAtIGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbik7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbi5hbmNob3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbmVkUm90YXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yb3RhdGlvbihcbiAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJSb3RhdGUoXG4gICAgICAgICAgICAgIGNvbnN0cmFpbmVkUm90YXRpb24sXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmNob3IsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHRSb3RhdGlvbl8gPSBhbmltYXRpb24udGFyZ2V0Um90YXRpb247XG4gICAgICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKHRydWUpO1xuICAgICAgICBtb3JlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcmllc0NvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc19baV0gPSBudWxsO1xuICAgICAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAtMSk7XG4gICAgICAgIHRoaXMubmV4dENlbnRlcl8gPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRSZXNvbHV0aW9uXyA9IE5hTjtcbiAgICAgICAgdGhpcy5uZXh0Um90YXRpb25fID0gTmFOO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHNlcmllc1swXS5jYWxsYmFjaztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBydW5lIGNvbXBsZXRlZCBzZXJpZXNcbiAgICB0aGlzLmFuaW1hdGlvbnNfID0gdGhpcy5hbmltYXRpb25zXy5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKG1vcmUgJiYgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25zXy5iaW5kKHRoaXMpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFRhcmdldCByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFJvdGF0aW9uIGFuY2hvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIgZm9yIHJvdGF0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBjYWxjdWxhdGVDZW50ZXJSb3RhdGUocm90YXRpb24sIGFuY2hvcikge1xuICAgIGxldCBjZW50ZXI7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICBpZiAoY3VycmVudENlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjZW50ZXIgPSBbY3VycmVudENlbnRlclswXSAtIGFuY2hvclswXSwgY3VycmVudENlbnRlclsxXSAtIGFuY2hvclsxXV07XG4gICAgICByb3RhdGVDb29yZGluYXRlKGNlbnRlciwgcm90YXRpb24gLSB0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgICAgYWRkQ29vcmRpbmF0ZShjZW50ZXIsIGFuY2hvcik7XG4gICAgfVxuICAgIHJldHVybiBjZW50ZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBab29tIGFuY2hvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIgZm9yIHJlc29sdXRpb24gYW5kIGFuY2hvci5cbiAgICovXG4gIGNhbGN1bGF0ZUNlbnRlclpvb20ocmVzb2x1dGlvbiwgYW5jaG9yKSB7XG4gICAgbGV0IGNlbnRlcjtcbiAgICBjb25zdCBjdXJyZW50Q2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICAgIGNvbnN0IGN1cnJlbnRSZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB4ID1cbiAgICAgICAgYW5jaG9yWzBdIC1cbiAgICAgICAgKHJlc29sdXRpb24gKiAoYW5jaG9yWzBdIC0gY3VycmVudENlbnRlclswXSkpIC8gY3VycmVudFJlc29sdXRpb247XG4gICAgICBjb25zdCB5ID1cbiAgICAgICAgYW5jaG9yWzFdIC1cbiAgICAgICAgKHJlc29sdXRpb24gKiAoYW5jaG9yWzFdIC0gY3VycmVudENlbnRlclsxXSkpIC8gY3VycmVudFJlc29sdXRpb247XG4gICAgICBjZW50ZXIgPSBbeCwgeV07XG4gICAgfVxuICAgIHJldHVybiBjZW50ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2aWV3cG9ydCBzaXplLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uXSBUYWtlIGludG8gYWNjb3VudCB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0IHdoZW4gZ2l2aW5nIHRoZSBzaXplXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBWaWV3cG9ydCBzaXplIG9yIGBbMTAwLCAxMDBdYCB3aGVuIG5vIHZpZXdwb3J0IGlzIGZvdW5kLlxuICAgKi9cbiAgZ2V0Vmlld3BvcnRTaXplXyhyb3RhdGlvbikge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnZpZXdwb3J0U2l6ZV87XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICBjb25zdCB3ID0gc2l6ZVswXTtcbiAgICAgIGNvbnN0IGggPSBzaXplWzFdO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5hYnModyAqIE1hdGguY29zKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoICogTWF0aC5zaW4ocm90YXRpb24pKSxcbiAgICAgICAgTWF0aC5hYnModyAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoICogTWF0aC5jb3Mocm90YXRpb24pKSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgdmlld3BvcnQgc2l6ZSBvbiB0aGUgdmlldy4gVGhlIHZpZXdwb3J0IHNpemUgaXMgbm90IHJlYWQgZXZlcnkgdGltZSBmcm9tIHRoZSBET01cbiAgICogdG8gYXZvaWQgcGVyZm9ybWFuY2UgaGl0IGFuZCBsYXlvdXQgcmVmbG93LlxuICAgKiBUaGlzIHNob3VsZCBiZSBkb25lIG9uIG1hcCBzaXplIGNoYW5nZS5cbiAgICogTm90ZTogdGhlIGNvbnN0cmFpbnRzIGFyZSBub3QgcmVzb2x2ZWQgZHVyaW5nIGFuIGFuaW1hdGlvbiB0byBhdm9pZCBzdG9wcGluZyBpdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gVmlld3BvcnQgc2l6ZTsgaWYgdW5kZWZpbmVkLCBbMTAwLCAxMDBdIGlzIGFzc3VtZWRcbiAgICovXG4gIHNldFZpZXdwb3J0U2l6ZShzaXplKSB7XG4gICAgdGhpcy52aWV3cG9ydFNpemVfID0gQXJyYXkuaXNBcnJheShzaXplKSA/IHNpemUuc2xpY2UoKSA6IFsxMDAsIDEwMF07XG4gICAgaWYgKCF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGNlbnRlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDZW50ZXIoKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICAgIGlmICghY2VudGVyKSB7XG4gICAgICByZXR1cm4gY2VudGVyO1xuICAgIH1cbiAgICByZXR1cm4gdG9Vc2VyQ29vcmRpbmF0ZShjZW50ZXIsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgY2VudGVyIHdpdGhvdXQgdHJhbnNmb3JtaW5nIHRvIHVzZXIgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKi9cbiAgZ2V0Q2VudGVySW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29uc3RyYWludHN9IENvbnN0cmFpbnRzLlxuICAgKi9cbiAgZ2V0Q29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJlc29sdXRpb24gY29uc3RyYWludCBpcyBzZXRcbiAgICovXG4gIGdldENvbnN0cmFpblJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdjb25zdHJhaW5SZXNvbHV0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbaGludHNdIERlc3RpbmF0aW9uIGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBIaW50LlxuICAgKi9cbiAgZ2V0SGludHMoaGludHMpIHtcbiAgICBpZiAoaGludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGludHNbMF0gPSB0aGlzLmhpbnRzX1swXTtcbiAgICAgIGhpbnRzWzFdID0gdGhpcy5oaW50c19bMV07XG4gICAgICByZXR1cm4gaGludHM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhpbnRzXy5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXh0ZW50IGZvciB0aGUgY3VycmVudCB2aWV3IHN0YXRlIGFuZCB0aGUgcGFzc2VkIGJveCBzaXplLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gVGhlIHBpeGVsIGRpbWVuc2lvbnMgb2YgdGhlIGJveFxuICAgKiBpbnRvIHdoaWNoIHRoZSBjYWxjdWxhdGVkIGV4dGVudCBzaG91bGQgZml0LiBEZWZhdWx0cyB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICogbWFwIHRoZSB2aWV3IGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICogSWYgbm8gbWFwIG9yIG11bHRpcGxlIG1hcHMgYXJlIGNvbm5lY3RlZCB0byB0aGUgdmlldywgcHJvdmlkZSB0aGUgZGVzaXJlZFxuICAgKiBib3ggc2l6ZSAoZS5nLiBgbWFwLmdldFNpemUoKWApLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgY2FsY3VsYXRlRXh0ZW50KHNpemUpIHtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLmNhbGN1bGF0ZUV4dGVudEludGVybmFsKHNpemUpO1xuICAgIHJldHVybiB0b1VzZXJFeHRlbnQoZXh0ZW50LCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIEJveCBwaXhlbCBzaXplLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqIHRoZSBtYXAncyBsYXN0IGtub3duIHZpZXdwb3J0IHNpemUgd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICovXG4gIGNhbGN1bGF0ZUV4dGVudEludGVybmFsKHNpemUpIHtcbiAgICBzaXplID0gc2l6ZSB8fCB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICBjb25zdCBjZW50ZXIgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpXG4gICAgKTtcbiAgICBhc3NlcnQoY2VudGVyLCAnVGhlIHZpZXcgY2VudGVyIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IC8qKiBAdHlwZSB7IW51bWJlcn0gKi8gKHRoaXMuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICBhc3NlcnQocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkLCAnVGhlIHZpZXcgcmVzb2x1dGlvbiBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLyoqIEB0eXBlIHshbnVtYmVyfSAqLyAodGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICBhc3NlcnQocm90YXRpb24gIT09IHVuZGVmaW5lZCwgJ1RoZSB2aWV3IHJvdGF0aW9uIGlzIG5vdCBkZWZpbmVkJyk7XG5cbiAgICByZXR1cm4gZ2V0Rm9yVmlld0FuZFNpemUoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWF4UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNaW5SZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1pblJlc29sdXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhab29tKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKFxuICAgICAgdGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbih0aGlzLm1pblJlc29sdXRpb25fKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbmV3IG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1heFpvb20oem9vbSkge1xuICAgIHRoaXMuYXBwbHlPcHRpb25zXyh0aGlzLmdldFVwZGF0ZWRPcHRpb25zXyh7bWF4Wm9vbTogem9vbX0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluWm9vbSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChcbiAgICAgIHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24odGhpcy5tYXhSZXNvbHV0aW9uXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBUaGUgbWluaW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaW5ab29tKHpvb20pIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe21pblpvb206IHpvb219KSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIHZpZXcgc2hvdWxkIGFsbG93IGludGVybWVkaWFyeSB6b29tIGxldmVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFdoZXRoZXIgdGhlIHJlc29sdXRpb24gaXMgY29uc3RyYWluZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvbnN0cmFpblJlc29sdXRpb24oZW5hYmxlZCkge1xuICAgIHRoaXMuYXBwbHlPcHRpb25zXyh0aGlzLmdldFVwZGF0ZWRPcHRpb25zXyh7Y29uc3RyYWluUmVzb2x1dGlvbjogZW5hYmxlZH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gVGhlIHByb2plY3Rpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByb2plY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovICh0aGlzLmdldChWaWV3UHJvcGVydHkuUkVTT0xVVElPTikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbnMgZm9yIHRoZSB2aWV3LiBUaGlzIHJldHVybnMgdGhlIGFycmF5IG9mIHJlc29sdXRpb25zXG4gICAqIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIFZpZXcsIG9yIHVuZGVmaW5lZCBpZiBub25lIHdlcmUgZ2l2ZW4uXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBUaGUgcmVzb2x1dGlvbnMgb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIGEgcHJvdmlkZWQgZXh0ZW50IChpbiBtYXAgdW5pdHMpIGFuZCBzaXplIChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIEJveCBwaXhlbCBzaXplLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBwcm92aWRlZCBleHRlbnQgd2lsbCByZW5kZXIgYXRcbiAgICogICAgIHRoZSBnaXZlbiBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50KGV4dGVudCwgc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFJlc29sdXRpb25Gb3JFeHRlbnRJbnRlcm5hbChcbiAgICAgIGZyb21Vc2VyRXh0ZW50KGV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpLFxuICAgICAgc2l6ZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgYSBwcm92aWRlZCBleHRlbnQgKGluIG1hcCB1bml0cykgYW5kIHNpemUgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gQm94IHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIHByb3ZpZGVkIGV4dGVudCB3aWxsIHJlbmRlciBhdFxuICAgKiAgICAgdGhlIGdpdmVuIHNpemUuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwoZXh0ZW50LCBzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKCk7XG4gICAgY29uc3QgeFJlc29sdXRpb24gPSBnZXRXaWR0aChleHRlbnQpIC8gc2l6ZVswXTtcbiAgICBjb25zdCB5UmVzb2x1dGlvbiA9IGdldEhlaWdodChleHRlbnQpIC8gc2l6ZVsxXTtcbiAgICByZXR1cm4gTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGFcbiAgICogcmVzb2x1dGlvbi4gRXhwb25lbnRpYWwgc2NhbGluZyBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvd2VyXSBQb3dlci5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSBSZXNvbHV0aW9uIGZvciB2YWx1ZSBmdW5jdGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uKHBvd2VyKSB7XG4gICAgcG93ZXIgPSBwb3dlciB8fCAyO1xuICAgIGNvbnN0IG1heFJlc29sdXRpb24gPSB0aGlzLmdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0aGlzLm1heFJlc29sdXRpb25fKTtcbiAgICBjb25zdCBtaW5SZXNvbHV0aW9uID0gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgICBjb25zdCBtYXggPSBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcik7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlLlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhwb3dlciwgdmFsdWUgKiBtYXgpO1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVzb2x1dGlvbiBmb3IgYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIDAgYW5kIDEuIEV4cG9uZW50aWFsIHNjYWxpbmcgaXMgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3dlcl0gUG93ZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlcik6IG51bWJlcn0gVmFsdWUgZm9yIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAqL1xuICBnZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbihwb3dlcikge1xuICAgIGNvbnN0IGxvZ1Bvd2VyID0gTWF0aC5sb2cocG93ZXIgfHwgMik7XG4gICAgY29uc3QgbWF4UmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pO1xuICAgIGNvbnN0IG1pblJlc29sdXRpb24gPSB0aGlzLm1pblJlc29sdXRpb25fO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZhbHVlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAocmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyIC8gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBtaW51cyBwYWRkaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uXSBUYWtlIGludG8gYWNjb3VudCB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0IHdoZW4gZ2l2aW5nIHRoZSBzaXplXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBWaWV3cG9ydCBzaXplIHJlZHVjZWQgYnkgdGhlIHBhZGRpbmcuXG4gICAqL1xuICBnZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKHJvdGF0aW9uKSB7XG4gICAgbGV0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8ocm90YXRpb24pO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmdfO1xuICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICBzaXplID0gW1xuICAgICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICAgIHNpemVbMV0gLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0YXRlfSBWaWV3IHN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgY2VudGVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpXG4gICAgKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICBpZiAocGFkZGluZykge1xuICAgICAgY29uc3QgcmVkdWNlZFNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICAgIGNlbnRlciA9IGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjZW50ZXIsXG4gICAgICAgIHRoaXMuZ2V0Vmlld3BvcnRTaXplXygpLFxuICAgICAgICBbcmVkdWNlZFNpemVbMF0gLyAyICsgcGFkZGluZ1szXSwgcmVkdWNlZFNpemVbMV0gLyAyICsgcGFkZGluZ1swXV0sXG4gICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlcjogY2VudGVyLnNsaWNlKDApLFxuICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gcHJvamVjdGlvbiA6IG51bGwsXG4gICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgbmV4dENlbnRlcjogdGhpcy5uZXh0Q2VudGVyXyxcbiAgICAgIG5leHRSZXNvbHV0aW9uOiB0aGlzLm5leHRSZXNvbHV0aW9uXyxcbiAgICAgIG5leHRSb3RhdGlvbjogdGhpcy5uZXh0Um90YXRpb25fLFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgem9vbTogdGhpcy5nZXRab29tKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtWaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBMaWtlIGBGcmFtZVN0YXRlYCwgYnV0IGp1c3QgYHZpZXdTdGF0ZWAgYW5kIGBleHRlbnRgLlxuICAgKi9cbiAgZ2V0Vmlld1N0YXRlQW5kRXh0ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2aWV3U3RhdGU6IHRoaXMuZ2V0U3RhdGUoKSxcbiAgICAgIGV4dGVudDogdGhpcy5jYWxjdWxhdGVFeHRlbnQoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB6b29tIGxldmVsLiBUaGlzIG1ldGhvZCBtYXkgcmV0dXJuIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzXG4gICAqIGlmIHRoZSB2aWV3IGRvZXMgbm90IGNvbnN0cmFpbiB0aGUgcmVzb2x1dGlvbiwgb3IgaWYgYW4gaW50ZXJhY3Rpb24gb3JcbiAgICogYW5pbWF0aW9uIGlzIHVuZGVyd2F5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBab29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRab29tKCkge1xuICAgIGxldCB6b29tO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB6b29tID0gdGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB6b29tIGxldmVsIGZvciBhIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgem9vbSBsZXZlbCBmb3IgdGhlIHByb3ZpZGVkIHJlc29sdXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5taW5ab29tXyB8fCAwO1xuICAgIGxldCBtYXgsIHpvb21GYWN0b3I7XG4gICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfKSB7XG4gICAgICBjb25zdCBuZWFyZXN0ID0gbGluZWFyRmluZE5lYXJlc3QodGhpcy5yZXNvbHV0aW9uc18sIHJlc29sdXRpb24sIDEpO1xuICAgICAgb2Zmc2V0ID0gbmVhcmVzdDtcbiAgICAgIG1heCA9IHRoaXMucmVzb2x1dGlvbnNfW25lYXJlc3RdO1xuICAgICAgaWYgKG5lYXJlc3QgPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMSkge1xuICAgICAgICB6b29tRmFjdG9yID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSBtYXggLyB0aGlzLnJlc29sdXRpb25zX1tuZWFyZXN0ICsgMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heCA9IHRoaXMubWF4UmVzb2x1dGlvbl87XG4gICAgICB6b29tRmFjdG9yID0gdGhpcy56b29tRmFjdG9yXztcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIE1hdGgubG9nKG1heCAvIHJlc29sdXRpb24pIC8gTWF0aC5sb2coem9vbUZhY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciBhIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZpZXcgcmVzb2x1dGlvbiBmb3IgdGhlIHByb3ZpZGVkIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3Jab29tKHpvb20pIHtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uc18/Lmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bMF07XG4gICAgICB9XG4gICAgICBjb25zdCBiYXNlTGV2ZWwgPSBjbGFtcChcbiAgICAgICAgTWF0aC5mbG9vcih6b29tKSxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMixcbiAgICAgICk7XG4gICAgICBjb25zdCB6b29tRmFjdG9yID1cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvIHRoaXMucmVzb2x1dGlvbnNfW2Jhc2VMZXZlbCArIDFdO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvXG4gICAgICAgIE1hdGgucG93KHpvb21GYWN0b3IsIGNsYW1wKHpvb20gLSBiYXNlTGV2ZWwsIDAsIDEpKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gLyBNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCB6b29tIC0gdGhpcy5taW5ab29tXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpdCB0aGUgZ2l2ZW4gZ2VvbWV0cnkgb3IgZXh0ZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBtYXAgc2l6ZSBhbmQgYm9yZGVyLlxuICAgKiBUaGUgc2l6ZSBpcyBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3ggdG8gZml0IHRoZSBleHRlbnQgaW50by5cbiAgICogSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCB3YW50IHRvIHVzZSB0aGUgbWFwIHNpemUsIHRoYXQgaXMgYG1hcC5nZXRTaXplKClgLlxuICAgKiBUYWtlcyBjYXJlIG9mIHRoZSBtYXAgYW5nbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBnZW9tZXRyeU9yRXh0ZW50IFRoZSBnZW9tZXRyeSBvclxuICAgKiAgICAgZXh0ZW50IHRvIGZpdCB0aGUgdmlldyB0by5cbiAgICogQHBhcmFtIHtGaXRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZml0KGdlb21ldHJ5T3JFeHRlbnQsIG9wdGlvbnMpIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIGxldCBnZW9tZXRyeTtcbiAgICBhc3NlcnQoXG4gICAgICBBcnJheS5pc0FycmF5KGdlb21ldHJ5T3JFeHRlbnQpIHx8XG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAoZ2VvbWV0cnlPckV4dGVudCkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KSA9PT1cbiAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgJ0ludmFsaWQgZXh0ZW50IG9yIGdlb21ldHJ5IHByb3ZpZGVkIGFzIGBnZW9tZXRyeWAnLFxuICAgICk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvbWV0cnlPckV4dGVudCkpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgIWlzRW1wdHkoZ2VvbWV0cnlPckV4dGVudCksXG4gICAgICAgICdDYW5ub3QgZml0IGVtcHR5IGV4dGVudCBwcm92aWRlZCBhcyBgZ2VvbWV0cnlgJyxcbiAgICAgICk7XG4gICAgICBjb25zdCBleHRlbnQgPSBmcm9tVXNlckV4dGVudChnZW9tZXRyeU9yRXh0ZW50LCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeU9yRXh0ZW50LmdldFR5cGUoKSA9PT0gJ0NpcmNsZScpIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IGZyb21Vc2VyRXh0ZW50KFxuICAgICAgICBnZW9tZXRyeU9yRXh0ZW50LmdldEV4dGVudCgpLFxuICAgICAgICB0aGlzLmdldFByb2plY3Rpb24oKSxcbiAgICAgICk7XG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCk7XG4gICAgICBnZW9tZXRyeS5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbigpLCBnZXRDZW50ZXIoZXh0ZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeU9yRXh0ZW50XG4gICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSh1c2VyUHJvamVjdGlvbiwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5T3JFeHRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maXRJbnRlcm5hbChnZW9tZXRyeSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJvdGF0ZWQgZXh0ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnRcIikuRXh0ZW50fSBUaGUgcm90YXRlZCBleHRlbnQgZm9yIHRoZSBnZW9tZXRyeS5cbiAgICovXG4gIHJvdGF0ZWRFeHRlbnRGb3JHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IGNvc0FuZ2xlID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICBjb25zdCBjb29yZHMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgbWluUm90WCA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWluUm90WSA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCByb3RYID0gY29vcmRzW2ldICogY29zQW5nbGUgLSBjb29yZHNbaSArIDFdICogc2luQW5nbGU7XG4gICAgICBjb25zdCByb3RZID0gY29vcmRzW2ldICogc2luQW5nbGUgKyBjb29yZHNbaSArIDFdICogY29zQW5nbGU7XG4gICAgICBtaW5Sb3RYID0gTWF0aC5taW4obWluUm90WCwgcm90WCk7XG4gICAgICBtaW5Sb3RZID0gTWF0aC5taW4obWluUm90WSwgcm90WSk7XG4gICAgICBtYXhSb3RYID0gTWF0aC5tYXgobWF4Um90WCwgcm90WCk7XG4gICAgICBtYXhSb3RZID0gTWF0aC5tYXgobWF4Um90WSwgcm90WSk7XG4gICAgfVxuICAgIHJldHVybiBbbWluUm90WCwgbWluUm90WSwgbWF4Um90WCwgbWF4Um90WV07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0ZpdE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgZml0SW50ZXJuYWwoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgIHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9XG4gICAgICBvcHRpb25zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGFkZGluZyA6IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBuZWFyZXN0ID0gb3B0aW9ucy5uZWFyZXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5lYXJlc3QgOiBmYWxzZTtcbiAgICBsZXQgbWluUmVzb2x1dGlvbjtcbiAgICBpZiAob3B0aW9ucy5taW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSBvcHRpb25zLm1pblJlc29sdXRpb247XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvclpvb20ob3B0aW9ucy5tYXhab29tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IDA7XG4gICAgfVxuXG4gICAgY29uc3Qgcm90YXRlZEV4dGVudCA9IHRoaXMucm90YXRlZEV4dGVudEZvckdlb21ldHJ5KGdlb21ldHJ5KTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXNvbHV0aW9uXG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb25Gb3JFeHRlbnRJbnRlcm5hbChyb3RhdGVkRXh0ZW50LCBbXG4gICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICBzaXplWzFdIC0gcGFkZGluZ1swXSAtIHBhZGRpbmdbMl0sXG4gICAgXSk7XG4gICAgcmVzb2x1dGlvbiA9IGlzTmFOKHJlc29sdXRpb24pXG4gICAgICA/IG1pblJlc29sdXRpb25cbiAgICAgIDogTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbik7XG4gICAgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHJlc29sdXRpb24sIG5lYXJlc3QgPyAwIDogMSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgY2VudGVyXG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgY29uc3QgY2VudGVyUm90ID0gZ2V0Q2VudGVyKHJvdGF0ZWRFeHRlbnQpO1xuICAgIGNlbnRlclJvdFswXSArPSAoKHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdKSAvIDIpICogcmVzb2x1dGlvbjtcbiAgICBjZW50ZXJSb3RbMV0gKz0gKChwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSkgLyAyKSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IGNlbnRlclJvdFswXSAqIGNvc0FuZ2xlIC0gY2VudGVyUm90WzFdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyWSA9IGNlbnRlclJvdFsxXSAqIGNvc0FuZ2xlICsgY2VudGVyUm90WzBdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDb25zdHJhaW5lZENlbnRlcihbY2VudGVyWCwgY2VudGVyWV0sIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayA/IG9wdGlvbnMuY2FsbGJhY2sgOiBWT0lEO1xuXG4gICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRlSW50ZXJuYWwoXG4gICAgICAgIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSBjZW50ZXI7XG4gICAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKGZhbHNlLCB0cnVlKTtcbiAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2VudGVyIG9uIGNvb3JkaW5hdGUgYW5kIHZpZXcgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB0aGUgdmlldyB0byBjZW50ZXIgb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGNlbnRlck9uKGNvb3JkaW5hdGUsIHNpemUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5jZW50ZXJPbkludGVybmFsKFxuICAgICAgZnJvbVVzZXJDb29yZGluYXRlKGNvb3JkaW5hdGUsIHRoaXMuZ2V0UHJvamVjdGlvbigpKSxcbiAgICAgIHNpemUsXG4gICAgICBwb3NpdGlvbixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB0aGUgdmlldyB0byBjZW50ZXIgb24uXG4gICAqL1xuICBjZW50ZXJPbkludGVybmFsKGNvb3JkaW5hdGUsIHNpemUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChcbiAgICAgIGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjb29yZGluYXRlLFxuICAgICAgICBzaXplLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgdGhpcy5nZXRSZXNvbHV0aW9uKCksXG4gICAgICAgIHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzaGlmdCBiZXR3ZWVuIG1hcCBhbmQgdmlld3BvcnQgY2VudGVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IENlbnRlciBzaGlmdC5cbiAgICovXG4gIGNhbGN1bGF0ZUNlbnRlclNoaWZ0KGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUpIHtcbiAgICBsZXQgY2VudGVyU2hpZnQ7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMucGFkZGluZ187XG4gICAgaWYgKHBhZGRpbmcgJiYgY2VudGVyKSB7XG4gICAgICBjb25zdCByZWR1Y2VkU2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplTWludXNQYWRkaW5nXygtcm90YXRpb24pO1xuICAgICAgY29uc3Qgc2hpZnRlZENlbnRlciA9IGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjZW50ZXIsXG4gICAgICAgIHNpemUsXG4gICAgICAgIFtyZWR1Y2VkU2l6ZVswXSAvIDIgKyBwYWRkaW5nWzNdLCByZWR1Y2VkU2l6ZVsxXSAvIDIgKyBwYWRkaW5nWzBdXSxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICApO1xuICAgICAgY2VudGVyU2hpZnQgPSBbXG4gICAgICAgIGNlbnRlclswXSAtIHNoaWZ0ZWRDZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlclsxXSAtIHNoaWZ0ZWRDZW50ZXJbMV0sXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyU2hpZnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZGVmaW5lZC5cbiAgICovXG4gIGlzRGVmKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKSAmJiB0aGlzLmdldFJlc29sdXRpb24oKSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldy4gQW55IGV4dGVudCBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRlbHRhQ29vcmRpbmF0ZXMgUmVsYXRpdmUgdmFsdWUgdG8gYWRkLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGp1c3RDZW50ZXIoZGVsdGFDb29yZGluYXRlcykge1xuICAgIGNvbnN0IGNlbnRlciA9IHRvVXNlckNvb3JkaW5hdGUodGhpcy50YXJnZXRDZW50ZXJfLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgdGhpcy5zZXRDZW50ZXIoW1xuICAgICAgY2VudGVyWzBdICsgZGVsdGFDb29yZGluYXRlc1swXSxcbiAgICAgIGNlbnRlclsxXSArIGRlbHRhQ29vcmRpbmF0ZXNbMV0sXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyByZWxhdGl2ZSBjb29yZGluYXRlcyB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3LiBBbnkgZXh0ZW50IGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZGVsdGFDb29yZGluYXRlcyBSZWxhdGl2ZSB2YWx1ZSB0byBhZGQuXG4gICAqL1xuICBhZGp1c3RDZW50ZXJJbnRlcm5hbChkZWx0YUNvb3JkaW5hdGVzKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy50YXJnZXRDZW50ZXJfO1xuICAgIHRoaXMuc2V0Q2VudGVySW50ZXJuYWwoW1xuICAgICAgY2VudGVyWzBdICsgZGVsdGFDb29yZGluYXRlc1swXSxcbiAgICAgIGNlbnRlclsxXSArIGRlbHRhQ29vcmRpbmF0ZXNbMV0sXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgdGhlIHZpZXcgcmVzb2x1dGlvbiBieSBhIHJhdGlvLCBvcHRpb25hbGx5IHVzaW5nIGFuIGFuY2hvci4gQW55IHJlc29sdXRpb25cbiAgICogY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gVGhlIHJhdGlvIHRvIGFwcGx5IG9uIHRoZSB2aWV3IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGp1c3RSZXNvbHV0aW9uKHJhdGlvLCBhbmNob3IpIHtcbiAgICBhbmNob3IgPSBhbmNob3IgJiYgZnJvbVVzZXJDb29yZGluYXRlKGFuY2hvciwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgIHRoaXMuYWRqdXN0UmVzb2x1dGlvbkludGVybmFsKHJhdGlvLCBhbmNob3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoZSB2aWV3IHJlc29sdXRpb24gYnkgYSByYXRpbywgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFRoZSByYXRpbyB0byBhcHBseSBvbiB0aGUgdmlldyByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICovXG4gIGFkanVzdFJlc29sdXRpb25JbnRlcm5hbChyYXRpbywgYW5jaG9yKSB7XG4gICAgY29uc3QgaXNNb3ZpbmcgPSB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fICogcmF0aW8sXG4gICAgICAwLFxuICAgICAgc2l6ZSxcbiAgICAgIGlzTW92aW5nLFxuICAgICk7XG5cbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclpvb20obmV3UmVzb2x1dGlvbiwgYW5jaG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fICo9IHJhdGlvO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIHZpZXcgem9vbSBsZXZlbCwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFJlbGF0aXZlIHZhbHVlIHRvIGFkZCB0byB0aGUgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFpvb20oZGVsdGEsIGFuY2hvcikge1xuICAgIHRoaXMuYWRqdXN0UmVzb2x1dGlvbihNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCAtZGVsdGEpLCBhbmNob3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgdmlldyByb3RhdGlvbiwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByb3RhdGlvblxuICAgKiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBSZWxhdGl2ZSB2YWx1ZSB0byBhZGQgdG8gdGhlIHpvb20gcm90YXRpb24sIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFJvdGF0aW9uKGRlbHRhLCBhbmNob3IpIHtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBmcm9tVXNlckNvb3JkaW5hdGUoYW5jaG9yLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgUmVsYXRpdmUgdmFsdWUgdG8gYWRkIHRvIHRoZSB6b29tIHJvdGF0aW9uLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKi9cbiAgYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKSB7XG4gICAgY29uc3QgaXNNb3ZpbmcgPSB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKTtcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gKyBkZWx0YSxcbiAgICAgIGlzTW92aW5nLFxuICAgICk7XG4gICAgaWYgKGFuY2hvcikge1xuICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJSb3RhdGUobmV3Um90YXRpb24sIGFuY2hvcik7XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0Um90YXRpb25fICs9IGRlbHRhO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciBvZiB0aGUgY3VycmVudCB2aWV3LiBBbnkgZXh0ZW50IGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDZW50ZXIoY2VudGVyKSB7XG4gICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChcbiAgICAgIGNlbnRlciA/IGZyb21Vc2VyQ29vcmRpbmF0ZShjZW50ZXIsIHRoaXMuZ2V0UHJvamVjdGlvbigpKSA6IGNlbnRlcixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIHVzaW5nIHRoZSB2aWV3IHByb2plY3Rpb24gKG5vdCB0aGUgdXNlciBwcm9qZWN0aW9uKS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKi9cbiAgc2V0Q2VudGVySW50ZXJuYWwoY2VudGVyKSB7XG4gICAgdGhpcy50YXJnZXRDZW50ZXJfID0gY2VudGVyO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVmlld0hpbnQuanNcIikuZGVmYXVsdH0gaGludCBIaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IHZhbHVlLlxuICAgKi9cbiAgc2V0SGludChoaW50LCBkZWx0YSkge1xuICAgIHRoaXMuaGludHNfW2hpbnRdICs9IGRlbHRhO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1toaW50XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoaXMgdmlldy4gQW55IHJlc29sdXRpb24gY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uIGZvciB0aGlzIHZpZXcuIEFueSByb3RhdGlvbiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLnRhcmdldFJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tIHRvIGEgc3BlY2lmaWMgem9vbSBsZXZlbC4gQW55IHJlc29sdXRpb24gY29uc3RyYWluIHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFpvb20oem9vbSkge1xuICAgIHRoaXMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb25Gb3Jab29tKHpvb20pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbXB1dGUgcm90YXRpb24vcmVzb2x1dGlvbi9jZW50ZXIgYmFzZWQgb24gdGFyZ2V0IHZhbHVlcy5cbiAgICogTm90ZTogd2UgaGF2ZSB0byBjb21wdXRlIHJvdGF0aW9uIGZpcnN0LCB0aGVuIHJlc29sdXRpb24gYW5kIGNlbnRlciBjb25zaWRlcmluZyB0aGF0XG4gICAqIHBhcmFtZXRlcnMgY2FuIGluZmx1ZW5jZSBvbmUgYW5vdGhlciBpbiBjYXNlIGEgdmlldyBleHRlbnQgY29uc3RyYWludCBpcyBwcmVzZW50LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdENhbmNlbEFuaW1zXSBEbyBub3QgY2FuY2VsIGFuaW1hdGlvbnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlTW92aW5nXSBBcHBseSBjb25zdHJhaW50cyBhcyBpZiB0aGUgdmlldyBpcyBtb3ZpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhcHBseVRhcmdldFN0YXRlXyhkb05vdENhbmNlbEFuaW1zLCBmb3JjZU1vdmluZykge1xuICAgIGNvbnN0IGlzTW92aW5nID1cbiAgICAgIHRoaXMuZ2V0QW5pbWF0aW5nKCkgfHwgdGhpcy5nZXRJbnRlcmFjdGluZygpIHx8IGZvcmNlTW92aW5nO1xuXG4gICAgLy8gY29tcHV0ZSByb3RhdGlvblxuICAgIGNvbnN0IG5ld1JvdGF0aW9uID0gdGhpcy5jb25zdHJhaW50c18ucm90YXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJvdGF0aW9uXyxcbiAgICAgIGlzTW92aW5nLFxuICAgICk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgMCxcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZyxcbiAgICApO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHRoaXMuY29uc3RyYWludHNfLmNlbnRlcihcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICBzaXplLFxuICAgICAgaXNNb3ZpbmcsXG4gICAgICB0aGlzLmNhbGN1bGF0ZUNlbnRlclNoaWZ0KFxuICAgICAgICB0aGlzLnRhcmdldENlbnRlcl8sXG4gICAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICAgIG5ld1JvdGF0aW9uLFxuICAgICAgICBzaXplLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5ST1RBVElPTikgIT09IG5ld1JvdGF0aW9uKSB7XG4gICAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUk9UQVRJT04sIG5ld1JvdGF0aW9uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OKSAhPT0gbmV3UmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIG5ld1Jlc29sdXRpb24pO1xuICAgICAgdGhpcy5zZXQoJ3pvb20nLCB0aGlzLmdldFpvb20oKSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFuZXdDZW50ZXIgfHxcbiAgICAgICF0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSwgbmV3Q2VudGVyKVxuICAgICkge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUiwgbmV3Q2VudGVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSAmJiAhZG9Ob3RDYW5jZWxBbmltcykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIHRoaXMuY2FuY2VsQW5jaG9yXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhbnkgY29uc3RyYWludHMgbmVlZCB0byBiZSBhcHBsaWVkLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgb24gaW50ZXJhY3Rpb24gZW5kLlxuICAgKiBOb3RlOiBjYWxsaW5nIHRoaXMgd2l0aCBhIGR1cmF0aW9uIG9mIDAgd2lsbCBhcHBseSB0aGUgY29uc3RyYWluZWQgdmFsdWVzIHN0cmFpZ2h0IGF3YXksXG4gICAqIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25EaXJlY3Rpb25dIFdoaWNoIGRpcmVjdGlvbiB0byB6b29tLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICovXG4gIHJlc29sdmVDb25zdHJhaW50cyhkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiAyMDA7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gcmVzb2x1dGlvbkRpcmVjdGlvbiB8fCAwO1xuXG4gICAgY29uc3QgbmV3Um90YXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yb3RhdGlvbih0aGlzLnRhcmdldFJvdGF0aW9uXyk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgc2l6ZSxcbiAgICApO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHRoaXMuY29uc3RyYWludHNfLmNlbnRlcihcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICBzaXplLFxuICAgICAgZmFsc2UsXG4gICAgICB0aGlzLmNhbGN1bGF0ZUNlbnRlclNoaWZ0KFxuICAgICAgICB0aGlzLnRhcmdldENlbnRlcl8sXG4gICAgICAgIG5ld1Jlc29sdXRpb24sXG4gICAgICAgIG5ld1JvdGF0aW9uLFxuICAgICAgICBzaXplLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwICYmICF0aGlzLmNhbmNlbEFuY2hvcl8pIHtcbiAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbl8gPSBuZXdSZXNvbHV0aW9uO1xuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSBuZXdSb3RhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IG5ld0NlbnRlcjtcbiAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmNob3IgPSBhbmNob3IgfHwgKGR1cmF0aW9uID09PSAwID8gdGhpcy5jYW5jZWxBbmNob3JfIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmdldFJlc29sdXRpb24oKSAhPT0gbmV3UmVzb2x1dGlvbiB8fFxuICAgICAgdGhpcy5nZXRSb3RhdGlvbigpICE9PSBuZXdSb3RhdGlvbiB8fFxuICAgICAgIXRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldENlbnRlckludGVybmFsKCksIG5ld0NlbnRlcilcbiAgICApIHtcbiAgICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICAgIHJvdGF0aW9uOiBuZXdSb3RhdGlvbixcbiAgICAgICAgY2VudGVyOiBuZXdDZW50ZXIsXG4gICAgICAgIHJlc29sdXRpb246IG5ld1Jlc29sdXRpb24sXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIFZpZXcgdGhhdCBhbiBpbnRlcmFjdGlvbiBoYXMgc3RhcnRlZC5cbiAgICogVGhlIHZpZXcgc3RhdGUgd2lsbCBiZSByZXNvbHZlZCB0byBhIHN0YWJsZSBvbmUgaWYgbmVlZGVkXG4gICAqIChkZXBlbmRpbmcgb24gaXRzIGNvbnN0cmFpbnRzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgYmVnaW5JbnRlcmFjdGlvbigpIHtcbiAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcblxuICAgIHRoaXMuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBlbmRJbnRlcmFjdGlvbihkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgYW5jaG9yID0gYW5jaG9yICYmIGZyb21Vc2VyQ29vcmRpbmF0ZShhbmNob3IsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICB0aGlzLmVuZEludGVyYWN0aW9uSW50ZXJuYWwoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKi9cbiAgZW5kSW50ZXJhY3Rpb25JbnRlcm5hbChkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgaWYgKCF0aGlzLmdldEludGVyYWN0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdmFsaWQgcG9zaXRpb24gZm9yIHRoZSB2aWV3IGNlbnRlciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29uc3RyYWludHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlciBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0YXJnZXRSZXNvbHV0aW9uXSBUYXJnZXQgcmVzb2x1dGlvbi4gSWYgbm90IHN1cHBsaWVkLCB0aGUgY3VycmVudCBvbmUgd2lsbCBiZSB1c2VkLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBndWVzcyBhIHZhbGlkIGNlbnRlciBwb3NpdGlvbiBhdCBhIGRpZmZlcmVudCB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IFZhbGlkIGNlbnRlciBwb3NpdGlvbi5cbiAgICovXG4gIGdldENvbnN0cmFpbmVkQ2VudGVyKHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbikge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8odGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGFyZ2V0Q2VudGVyLFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvbiB8fCB0aGlzLmdldFJlc29sdXRpb24oKSxcbiAgICAgIHNpemUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCB6b29tIGxldmVsIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2aWV3IGNvbnN0cmFpbnRzLlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHRhcmdldFpvb20gVGFyZ2V0IHpvb20uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGlyZWN0aW9uPTBdIEluZGljYXRlIHdoaWNoIHJlc29sdXRpb24gc2hvdWxkIGJlIHVzZWRcbiAgICogYnkgYSByZW5kZXJlciBpZiB0aGUgdmlldyByZXNvbHV0aW9uIGRvZXMgbm90IG1hdGNoIGFueSByZXNvbHV0aW9uIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb25cbiAgICogd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3QgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBWYWxpZCB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0Q29uc3RyYWluZWRab29tKHRhcmdldFpvb20sIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldFJlcyA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvclpvb20odGFyZ2V0Wm9vbSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24oXG4gICAgICB0aGlzLmdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0YXJnZXRSZXMsIGRpcmVjdGlvbiksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCByZXNvbHV0aW9uIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2aWV3IGNvbnN0cmFpbnRzLlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGlyZWN0aW9uPTBdIEluZGljYXRlIHdoaWNoIHJlc29sdXRpb24gc2hvdWxkIGJlIHVzZWRcbiAgICogYnkgYSByZW5kZXJlciBpZiB0aGUgdmlldyByZXNvbHV0aW9uIGRvZXMgbm90IG1hdGNoIGFueSByZXNvbHV0aW9uIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb25cbiAgICogd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3QgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBWYWxpZCByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRhcmdldFJlc29sdXRpb24sIGRpcmVjdGlvbikge1xuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAwO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8odGhpcy5nZXRSb3RhdGlvbigpKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKHRhcmdldFJlc29sdXRpb24sIGRpcmVjdGlvbiwgc2l6ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gcmV0dXJuVmFsdWUgUmV0dXJuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhbmltYXRpb25DYWxsYmFjayhjYWxsYmFjaywgcmV0dXJuVmFsdWUpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2socmV0dXJuVmFsdWUpO1xuICB9LCAwKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY2VudGVyY29uc3RyYWludC5qc1wiKS5UeXBlfSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNlbnRlckNvbnN0cmFpbnQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHNtb290aCA9XG4gICAgICBvcHRpb25zLnNtb290aEV4dGVudENvbnN0cmFpbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuc21vb3RoRXh0ZW50Q29uc3RyYWludFxuICAgICAgICA6IHRydWU7XG4gICAgcmV0dXJuIGNyZWF0ZUV4dGVudChvcHRpb25zLmV4dGVudCwgb3B0aW9ucy5jb25zdHJhaW5Pbmx5Q2VudGVyLCBzbW9vdGgpO1xuICB9XG5cbiAgY29uc3QgcHJvamVjdGlvbiA9IGNyZWF0ZVByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uLCAnRVBTRzozODU3Jyk7XG4gIGlmIChvcHRpb25zLm11bHRpV29ybGQgIT09IHRydWUgJiYgcHJvamVjdGlvbi5pc0dsb2JhbCgpKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKS5zbGljZSgpO1xuICAgIGV4dGVudFswXSA9IC1JbmZpbml0eTtcbiAgICBleHRlbnRbMl0gPSBJbmZpbml0eTtcbiAgICByZXR1cm4gY3JlYXRlRXh0ZW50KGV4dGVudCwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBjZW50ZXJOb25lO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG9wdGlvbnMgVmlldyBvcHRpb25zLlxuICogQHJldHVybiB7e2NvbnN0cmFpbnQ6IGltcG9ydChcIi4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZSwgbWF4UmVzb2x1dGlvbjogbnVtYmVyLFxuICogICAgIG1pblJlc29sdXRpb246IG51bWJlciwgbWluWm9vbTogbnVtYmVyLCB6b29tRmFjdG9yOiBudW1iZXJ9fSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpIHtcbiAgbGV0IHJlc29sdXRpb25Db25zdHJhaW50O1xuICBsZXQgbWF4UmVzb2x1dGlvbjtcbiAgbGV0IG1pblJlc29sdXRpb247XG5cbiAgLy8gVE9ETzogbW92ZSB0aGVzZSB0byBiZSBvbCBjb25zdGFudHNcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVubGF5ZXJzL29wZW5sYXllcnMvaXNzdWVzLzIwNzZcbiAgY29uc3QgZGVmYXVsdE1heFpvb20gPSAyODtcbiAgY29uc3QgZGVmYXVsdFpvb21GYWN0b3IgPSAyO1xuXG4gIGxldCBtaW5ab29tID1cbiAgICBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IERFRkFVTFRfTUlOX1pPT007XG5cbiAgbGV0IG1heFpvb20gPVxuICAgIG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhab29tIDogZGVmYXVsdE1heFpvb207XG5cbiAgY29uc3Qgem9vbUZhY3RvciA9XG4gICAgb3B0aW9ucy56b29tRmFjdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21GYWN0b3IgOiBkZWZhdWx0Wm9vbUZhY3RvcjtcblxuICBjb25zdCBtdWx0aVdvcmxkID1cbiAgICBvcHRpb25zLm11bHRpV29ybGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXVsdGlXb3JsZCA6IGZhbHNlO1xuXG4gIGNvbnN0IHNtb290aCA9XG4gICAgb3B0aW9ucy5zbW9vdGhSZXNvbHV0aW9uQ29uc3RyYWludCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IG9wdGlvbnMuc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnRcbiAgICAgIDogdHJ1ZTtcblxuICBjb25zdCBzaG93RnVsbEV4dGVudCA9XG4gICAgb3B0aW9ucy5zaG93RnVsbEV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaG93RnVsbEV4dGVudCA6IGZhbHNlO1xuXG4gIGNvbnN0IHByb2plY3Rpb24gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuICBjb25zdCBwcm9qRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgbGV0IGNvbnN0cmFpbk9ubHlDZW50ZXIgPSBvcHRpb25zLmNvbnN0cmFpbk9ubHlDZW50ZXI7XG4gIGxldCBleHRlbnQgPSBvcHRpb25zLmV4dGVudDtcbiAgaWYgKCFtdWx0aVdvcmxkICYmICFleHRlbnQgJiYgcHJvamVjdGlvbi5pc0dsb2JhbCgpKSB7XG4gICAgY29uc3RyYWluT25seUNlbnRlciA9IGZhbHNlO1xuICAgIGV4dGVudCA9IHByb2pFeHRlbnQ7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbnMgPSBvcHRpb25zLnJlc29sdXRpb25zO1xuICAgIG1heFJlc29sdXRpb24gPSByZXNvbHV0aW9uc1ttaW5ab29tXTtcbiAgICBtaW5SZXNvbHV0aW9uID1cbiAgICAgIHJlc29sdXRpb25zW21heFpvb21dICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXNvbHV0aW9uc1ttYXhab29tXVxuICAgICAgICA6IHJlc29sdXRpb25zW3Jlc29sdXRpb25zLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbikge1xuICAgICAgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVTbmFwVG9SZXNvbHV0aW9ucyhcbiAgICAgICAgcmVzb2x1dGlvbnMsXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgIWNvbnN0cmFpbk9ubHlDZW50ZXIgJiYgZXh0ZW50LFxuICAgICAgICBzaG93RnVsbEV4dGVudCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdXRpb25Db25zdHJhaW50ID0gY3JlYXRlTWluTWF4UmVzb2x1dGlvbihcbiAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgbWluUmVzb2x1dGlvbixcbiAgICAgICAgc21vb3RoLFxuICAgICAgICAhY29uc3RyYWluT25seUNlbnRlciAmJiBleHRlbnQsXG4gICAgICAgIHNob3dGdWxsRXh0ZW50LFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWZhdWx0IG1pbiBhbmQgbWF4IHJlc29sdXRpb25cbiAgICBjb25zdCBzaXplID0gIXByb2pFeHRlbnRcbiAgICAgID8gLy8gdXNlIGFuIGV4dGVudCB0aGF0IGNhbiBmaXQgdGhlIHdob2xlIHdvcmxkIGlmIG5lZWQgYmVcbiAgICAgICAgKDM2MCAqIE1FVEVSU19QRVJfVU5JVC5kZWdyZWVzKSAvIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpXG4gICAgICA6IE1hdGgubWF4KGdldFdpZHRoKHByb2pFeHRlbnQpLCBnZXRIZWlnaHQocHJvakV4dGVudCkpO1xuXG4gICAgY29uc3QgZGVmYXVsdE1heFJlc29sdXRpb24gPVxuICAgICAgc2l6ZSAvIERFRkFVTFRfVElMRV9TSVpFIC8gTWF0aC5wb3coZGVmYXVsdFpvb21GYWN0b3IsIERFRkFVTFRfTUlOX1pPT00pO1xuXG4gICAgY29uc3QgZGVmYXVsdE1pblJlc29sdXRpb24gPVxuICAgICAgZGVmYXVsdE1heFJlc29sdXRpb24gL1xuICAgICAgTWF0aC5wb3coZGVmYXVsdFpvb21GYWN0b3IsIGRlZmF1bHRNYXhab29tIC0gREVGQVVMVF9NSU5fWk9PTSk7XG5cbiAgICAvLyB1c2VyIHByb3ZpZGVkIG1heFJlc29sdXRpb24gdGFrZXMgcHJlY2VkZW5jZVxuICAgIG1heFJlc29sdXRpb24gPSBvcHRpb25zLm1heFJlc29sdXRpb247XG4gICAgaWYgKG1heFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluWm9vbSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFJlc29sdXRpb24gPSBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1pblpvb20pO1xuICAgIH1cblxuICAgIC8vIHVzZXIgcHJvdmlkZWQgbWluUmVzb2x1dGlvbiB0YWtlcyBwcmVjZWRlbmNlXG4gICAgbWluUmVzb2x1dGlvbiA9IG9wdGlvbnMubWluUmVzb2x1dGlvbjtcbiAgICBpZiAobWluUmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWluUmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluUmVzb2x1dGlvbiA9IGRlZmF1bHRNaW5SZXNvbHV0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdpdmVuIGRpc2NyZXRlIHpvb20gbGV2ZWxzLCBtaW5SZXNvbHV0aW9uIG1heSBiZSBkaWZmZXJlbnQgdGhhbiBwcm92aWRlZFxuICAgIG1heFpvb20gPVxuICAgICAgbWluWm9vbSArXG4gICAgICBNYXRoLmZsb29yKFxuICAgICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKSxcbiAgICAgICk7XG4gICAgbWluUmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tIC0gbWluWm9vbSk7XG5cbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uKSB7XG4gICAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVNuYXBUb1Bvd2VyKFxuICAgICAgICB6b29tRmFjdG9yLFxuICAgICAgICBtYXhSZXNvbHV0aW9uLFxuICAgICAgICBtaW5SZXNvbHV0aW9uLFxuICAgICAgICBzbW9vdGgsXG4gICAgICAgICFjb25zdHJhaW5Pbmx5Q2VudGVyICYmIGV4dGVudCxcbiAgICAgICAgc2hvd0Z1bGxFeHRlbnQsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZU1pbk1heFJlc29sdXRpb24oXG4gICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgIG1pblJlc29sdXRpb24sXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgIWNvbnN0cmFpbk9ubHlDZW50ZXIgJiYgZXh0ZW50LFxuICAgICAgICBzaG93RnVsbEV4dGVudCxcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY29uc3RyYWludDogcmVzb2x1dGlvbkNvbnN0cmFpbnQsXG4gICAgbWF4UmVzb2x1dGlvbjogbWF4UmVzb2x1dGlvbixcbiAgICBtaW5SZXNvbHV0aW9uOiBtaW5SZXNvbHV0aW9uLFxuICAgIG1pblpvb206IG1pblpvb20sXG4gICAgem9vbUZhY3Rvcjogem9vbUZhY3RvcixcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vcm90YXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGV9IFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3RhdGlvbkNvbnN0cmFpbnQob3B0aW9ucykge1xuICBjb25zdCBlbmFibGVSb3RhdGlvbiA9XG4gICAgb3B0aW9ucy5lbmFibGVSb3RhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5lbmFibGVSb3RhdGlvbiA6IHRydWU7XG4gIGlmIChlbmFibGVSb3RhdGlvbikge1xuICAgIGNvbnN0IGNvbnN0cmFpblJvdGF0aW9uID0gb3B0aW9ucy5jb25zdHJhaW5Sb3RhdGlvbjtcbiAgICBpZiAoY29uc3RyYWluUm90YXRpb24gPT09IHVuZGVmaW5lZCB8fCBjb25zdHJhaW5Sb3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNuYXBUb1plcm8oKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpblJvdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJvdGF0aW9uTm9uZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW5Sb3RhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTbmFwVG9OKGNvbnN0cmFpblJvdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdGF0aW9uTm9uZTtcbiAgfVxuICByZXR1cm4gZGlzYWJsZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYW5pbWF0aW9uIGludm9sdmVzIG5vIHZpZXcgY2hhbmdlLlxuICogQHBhcmFtIHtBbmltYXRpb259IGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGFuaW1hdGlvbiBpbnZvbHZlcyBubyB2aWV3IGNoYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9vcEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIgJiYgYW5pbWF0aW9uLnRhcmdldENlbnRlcikge1xuICAgIGlmICghY29vcmRpbmF0ZXNFcXVhbChhbmltYXRpb24uc291cmNlQ2VudGVyLCBhbmltYXRpb24udGFyZ2V0Q2VudGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIEJveCBwaXhlbCBzaXplLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB0aGUgdmlldyB0byBjZW50ZXIgb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFNoaWZ0ZWQgY2VudGVyLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDZW50ZXJPbihjb29yZGluYXRlLCBzaXplLCBwb3NpdGlvbiwgcmVzb2x1dGlvbiwgcm90YXRpb24pIHtcbiAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgcG9zaXRpb25cbiAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcygtcm90YXRpb24pO1xuICBsZXQgc2luQW5nbGUgPSBNYXRoLnNpbigtcm90YXRpb24pO1xuICBsZXQgcm90WCA9IGNvb3JkaW5hdGVbMF0gKiBjb3NBbmdsZSAtIGNvb3JkaW5hdGVbMV0gKiBzaW5BbmdsZTtcbiAgbGV0IHJvdFkgPSBjb29yZGluYXRlWzFdICogY29zQW5nbGUgKyBjb29yZGluYXRlWzBdICogc2luQW5nbGU7XG4gIHJvdFggKz0gKHNpemVbMF0gLyAyIC0gcG9zaXRpb25bMF0pICogcmVzb2x1dGlvbjtcbiAgcm90WSArPSAocG9zaXRpb25bMV0gLSBzaXplWzFdIC8gMikgKiByZXNvbHV0aW9uO1xuXG4gIC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgYW5nbGVcbiAgc2luQW5nbGUgPSAtc2luQW5nbGU7IC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgcm90YXRpb25cbiAgY29uc3QgY2VudGVyWCA9IHJvdFggKiBjb3NBbmdsZSAtIHJvdFkgKiBzaW5BbmdsZTtcbiAgY29uc3QgY2VudGVyWSA9IHJvdFkgKiBjb3NBbmdsZSArIHJvdFggKiBzaW5BbmdsZTtcblxuICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9MYXllclxuICovXG5pbXBvcnQgQmFzZUxheWVyIGZyb20gJy4vQmFzZS5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IExheWVyUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi4vVmlldy5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGUpOkhUTUxFbGVtZW50fSBSZW5kZXJGdW5jdGlvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydzb3VyY2VyZWFkeSd8J2NoYW5nZTpzb3VyY2UnfSBMYXllckV2ZW50VHlwZVxuICovXG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfFxuICogICAgIExheWVyRXZlbnRUeXBlLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL3JlbmRlci9FdmVudFR5cGVcIikuTGF5ZXJSZW5kZXJFdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi9CYXNlXCIpLkJhc2VMYXllck9iamVjdEV2ZW50VHlwZXN8TGF5ZXJFdmVudFR5cGV8XG4gKiAgICAgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5MYXllclJlbmRlckV2ZW50VHlwZXMsIFJldHVybj59IExheWVyT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5kZWZhdWx0fSBbU291cmNlVHlwZT1pbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHRdXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbGF5ZXInXSBBIENTUyBjbGFzcyBuYW1lIHRvIHNldCB0byB0aGUgbGF5ZXIgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtTb3VyY2VUeXBlfSBbc291cmNlXSBTb3VyY2UgZm9yIHRoaXMgbGF5ZXIuICBJZiBub3QgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLFxuICogdGhlIHNvdXJjZSBjYW4gYmUgc2V0IGJ5IGNhbGxpbmcge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciNzZXRTb3VyY2UgbGF5ZXIuc2V0U291cmNlKHNvdXJjZSl9IGFmdGVyXG4gKiBjb25zdHJ1Y3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IFttYXBdIE1hcC5cbiAqIEBwcm9wZXJ0eSB7UmVuZGVyRnVuY3Rpb259IFtyZW5kZXJdIFJlbmRlciBmdW5jdGlvbi4gVGFrZXMgdGhlIGZyYW1lIHN0YXRlIGFzIGlucHV0IGFuZCBpcyBleHBlY3RlZCB0byByZXR1cm4gYW5cbiAqIEhUTUwgZWxlbWVudC4gV2lsbCBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIGZvciB0aGUgbGF5ZXIuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSBbcHJvcGVydGllc10gQXJiaXRyYXJ5IG9ic2VydmFibGUgcHJvcGVydGllcy4gQ2FuIGJlIGFjY2Vzc2VkIHdpdGggYCNnZXQoKWAgYW5kIGAjc2V0KClgLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHksIHRoZSB2YWx1ZSBpcyByb3VuZGVkIHRvIHR3byBkaWdpdHMgdG8gYXBwZWFyIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LlxuICogQHByb3BlcnR5IHtib29sZWFufSB2aXNpYmxlIFZpc2libGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG1hbmFnZWQgTWFuYWdlZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpJbmRleCBaSW5kZXguXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4UmVzb2x1dGlvbiBNYXhpbXVtIHJlc29sdXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluUmVzb2x1dGlvbiBNaW5pbXVtIHJlc29sdXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWm9vbSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4Wm9vbSBNYXhpbXVtIHpvb20uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZyb20gd2hpY2ggYWxsIGxheWVyIHR5cGVzIGFyZSBkZXJpdmVkLiBUaGlzIHNob3VsZCBvbmx5IGJlIGluc3RhbnRpYXRlZFxuICogaW4gdGhlIGNhc2Ugd2hlcmUgYSBjdXN0b20gbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCB3aXRoIGEgY3VzdG9tIGByZW5kZXJgIGZ1bmN0aW9uLlxuICogU3VjaCBhIGZ1bmN0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBvcHRpb25zYCBvYmplY3QsIGFuZCBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHJhc3RlciBvciB2ZWN0b3IgbWFwIGRhdGEuXG4gKiBMYXllcnMgZ3JvdXAgdG9nZXRoZXIgdGhvc2UgcHJvcGVydGllcyB0aGF0IHBlcnRhaW4gdG8gaG93IHRoZSBkYXRhIGlzIHRvIGJlXG4gKiBkaXNwbGF5ZWQsIGlycmVzcGVjdGl2ZSBvZiB0aGUgc291cmNlIG9mIHRoYXQgZGF0YS5cbiAqXG4gKiBMYXllcnMgYXJlIHVzdWFsbHkgYWRkZWQgdG8gYSBtYXAgd2l0aCBbbWFwLmFkZExheWVyKClde0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0I2FkZExheWVyfS5cbiAqIENvbXBvbmVudHMgbGlrZSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYXd+RHJhd30gdXNlIHVubWFuYWdlZCBsYXllcnNcbiAqIGludGVybmFsbHkuIFRoZXNlIHVubWFuYWdlZCBsYXllcnMgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwIHVzaW5nXG4gKiBbbGF5ZXIuc2V0TWFwKClde0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciNzZXRNYXB9IGluc3RlYWQuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UgY2hhbmdlcy5cbiAqIEEgYHNvdXJjZXJlYWR5YCBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBsYXllcidzIHNvdXJjZSBpcyByZWFkeS5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLlJlbmRlckV2ZW50I3ByZXJlbmRlclxuICogQGZpcmVzIGltcG9ydChcIi4uL3JlbmRlci9FdmVudC5qc1wiKS5SZW5kZXJFdmVudCNwb3N0cmVuZGVyXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLkJhc2VFdmVudCNzb3VyY2VyZWFkeVxuICpcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5kZWZhdWx0fSBbU291cmNlVHlwZT1pbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHRdXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3JlbmRlcmVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IFtSZW5kZXJlclR5cGU9aW1wb3J0KFwiLi4vcmVuZGVyZXIvTGF5ZXIuanNcIikuZGVmYXVsdF1cbiAqIEBhcGlcbiAqL1xuY2xhc3MgTGF5ZXIgZXh0ZW5kcyBCYXNlTGF5ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zPFNvdXJjZVR5cGU+fSBvcHRpb25zIExheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgYmFzZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMuc291cmNlO1xuXG4gICAgc3VwZXIoYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0xheWVyT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtMYXllck9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLm1hcFByZWNvbXBvc2VLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZUNoYW5nZUtleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyZXJUeXBlfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VSZWFkeV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cbiAgICAvLyBPdmVyd3JpdGUgZGVmYXVsdCByZW5kZXIgbWV0aG9kIHdpdGggYSBjdXN0b20gb25lXG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICB0aGlzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1hcCkge1xuICAgICAgdGhpcy5zZXRNYXAob3B0aW9ucy5tYXApO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoXG4gICAgICBMYXllclByb3BlcnR5LlNPVVJDRSxcbiAgICAgIHRoaXMuaGFuZGxlU291cmNlUHJvcGVydHlDaGFuZ2VfLFxuICAgICk7XG5cbiAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZVxuICAgICAgPyAvKiogQHR5cGUge1NvdXJjZVR5cGV9ICovIChvcHRpb25zLnNvdXJjZSlcbiAgICAgIDogbnVsbDtcbiAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gW2FycmF5XSBBcnJheSBvZiBsYXllcnMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gQXJyYXkgb2YgbGF5ZXJzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldExheWVyc0FycmF5KGFycmF5KSB7XG4gICAgYXJyYXkgPSBhcnJheSA/IGFycmF5IDogW107XG4gICAgYXJyYXkucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gW3N0YXRlc10gT3B0aW9uYWwgbGlzdCBvZiBsYXllciBzdGF0ZXMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IExpc3Qgb2YgbGF5ZXIgc3RhdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldExheWVyU3RhdGVzQXJyYXkoc3RhdGVzKSB7XG4gICAgc3RhdGVzID0gc3RhdGVzID8gc3RhdGVzIDogW107XG4gICAgc3RhdGVzLnB1c2godGhpcy5nZXRMYXllclN0YXRlKCkpO1xuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciBzb3VyY2UuXG4gICAqIEByZXR1cm4ge1NvdXJjZVR5cGV8bnVsbH0gVGhlIGxheWVyIHNvdXJjZSAob3IgYG51bGxgIGlmIG5vdCB5ZXQgc2V0KS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge1NvdXJjZVR5cGV9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5LlNPVVJDRSkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U291cmNlVHlwZXxudWxsfSBUaGUgc291cmNlIGJlaW5nIHJlbmRlcmVkLlxuICAgKi9cbiAgZ2V0UmVuZGVyU291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuU3RhdGV9IFNvdXJjZSBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRTb3VyY2VTdGF0ZSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIHJldHVybiAhc291cmNlID8gJ3VuZGVmaW5lZCcgOiBzb3VyY2UuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU291cmNlQ2hhbmdlXygpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSZWFkeV8gfHwgdGhpcy5nZXRTb3VyY2UoKS5nZXRTdGF0ZSgpICE9PSAncmVhZHknKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc291cmNlUmVhZHlfID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3NvdXJjZXJlYWR5Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVNvdXJjZVByb3BlcnR5Q2hhbmdlXygpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VDaGFuZ2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMuc291cmNlQ2hhbmdlS2V5Xyk7XG4gICAgICB0aGlzLnNvdXJjZUNoYW5nZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZVJlYWR5XyA9IGZhbHNlO1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbGlzdGVuKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlU291cmNlQ2hhbmdlXyxcbiAgICAgICAgdGhpcyxcbiAgICAgICk7XG4gICAgICBpZiAoc291cmNlLmdldFN0YXRlKCkgPT09ICdyZWFkeScpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VSZWFkeV8gPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3NvdXJjZXJlYWR5Jyk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlXCIpLkZlYXR1cmVMaWtlPj59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoXG4gICAqIGFuIGFycmF5IG9mIGZlYXR1cmVzLlxuICAgKi9cbiAgZ2V0RmVhdHVyZXMocGl4ZWwpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXJfKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmdldEZlYXR1cmVzKHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheXxGbG9hdDMyQXJyYXl8RGF0YVZpZXd8bnVsbH0gUGl4ZWwgZGF0YS5cbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXJfIHx8ICF0aGlzLnJlbmRlcmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmdldERhdGEocGl4ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYXllciBpcyB2aXNpYmxlIG9uIHRoZSBtYXAgdmlldywgaS5lLiB3aXRoaW4gaXRzIG1pbi9tYXggcmVzb2x1dGlvbiBvciB6b29tIGFuZFxuICAgKiBleHRlbnQsIG5vdCBzZXQgdG8gYHZpc2libGU6IGZhbHNlYCwgYW5kIG5vdCBpbnNpZGUgYSBsYXllciBncm91cCB0aGF0IGlzIHNldFxuICAgKiB0byBgdmlzaWJsZTogZmFsc2VgLlxuICAgKiBAcGFyYW0ge1ZpZXd8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBbdmlld10gVmlldyBvciB7QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LlxuICAgKiBPbmx5IHJlcXVpcmVkIHdoZW4gdGhlIGxheWVyIGlzIG5vdCBhZGRlZCB0byBhIG1hcC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGxheWVyIGlzIHZpc2libGUgaW4gdGhlIG1hcCB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBpc1Zpc2libGUodmlldykge1xuICAgIGxldCBmcmFtZVN0YXRlO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwSW50ZXJuYWwoKTtcbiAgICBpZiAoIXZpZXcgJiYgbWFwKSB7XG4gICAgICB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB9XG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBWaWV3KSB7XG4gICAgICBmcmFtZVN0YXRlID0ge1xuICAgICAgICB2aWV3U3RhdGU6IHZpZXcuZ2V0U3RhdGUoKSxcbiAgICAgICAgZXh0ZW50OiB2aWV3LmNhbGN1bGF0ZUV4dGVudCgpLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWVTdGF0ZSA9IHZpZXc7XG4gICAgfVxuICAgIGlmICghZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5ICYmIG1hcCkge1xuICAgICAgZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5ID0gbWFwLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgfVxuICAgIGxldCBsYXllclN0YXRlO1xuICAgIGlmIChmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkpIHtcbiAgICAgIGxheWVyU3RhdGUgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkuZmluZChcbiAgICAgICAgKGxheWVyU3RhdGUpID0+IGxheWVyU3RhdGUubGF5ZXIgPT09IHRoaXMsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllclN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXJFeHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIGluVmlldyhsYXllclN0YXRlLCBmcmFtZVN0YXRlLnZpZXdTdGF0ZSkgJiZcbiAgICAgICghbGF5ZXJFeHRlbnQgfHwgaW50ZXJzZWN0cyhsYXllckV4dGVudCwgZnJhbWVTdGF0ZS5leHRlbnQpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhdHRyaWJ1dGlvbnMgb2YgdGhlIHNvdXJjZSBvZiB0aGlzIGxheWVyIGZvciB0aGUgZ2l2ZW4gdmlldy5cbiAgICogQHBhcmFtIHtWaWV3fGltcG9ydChcIi4uL1ZpZXcuanNcIikuVmlld1N0YXRlTGF5ZXJTdGF0ZUV4dGVudH0gW3ZpZXddIFZpZXcgb3Ige0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfS5cbiAgICogT25seSByZXF1aXJlZCB3aGVuIHRoZSBsYXllciBpcyBub3QgYWRkZWQgdG8gYSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEF0dHJpYnV0aW9ucyBmb3IgdGhpcyBsYXllciBhdCB0aGUgZ2l2ZW4gdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXR0cmlidXRpb25zKHZpZXcpIHtcbiAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKHZpZXcpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGdldEF0dHJpYnV0aW9ucyA9IHRoaXMuZ2V0U291cmNlKCk/LmdldEF0dHJpYnV0aW9ucygpO1xuICAgIGlmICghZ2V0QXR0cmlidXRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lU3RhdGUgPVxuICAgICAgdmlldyBpbnN0YW5jZW9mIFZpZXcgPyB2aWV3LmdldFZpZXdTdGF0ZUFuZEV4dGVudCgpIDogdmlldztcbiAgICBsZXQgYXR0cmlidXRpb25zID0gZ2V0QXR0cmlidXRpb25zKGZyYW1lU3RhdGUpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRyaWJ1dGlvbnMpKSB7XG4gICAgICBhdHRyaWJ1dGlvbnMgPSBbYXR0cmlidXRpb25zXTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBjaGFyZ2UgdG8gbWFuYWdlIHRoZSByZW5kZXJpbmcgb2YgdGhlIGxheWVyLiBPbmUgbGF5ZXIgdHlwZSBpc1xuICAgKiBib3VuZGVkIHdpdGggb25lIGxheWVyIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IFRhcmdldCB3aGljaCB0aGUgcmVuZGVyZXIgbWF5IChidXQgbmVlZCBub3QpIHVzZVxuICAgKiBmb3IgcmVuZGVyaW5nIGl0cyBjb250ZW50LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSBUaGUgcmVuZGVyZWQgZWxlbWVudC5cbiAgICovXG4gIHJlbmRlcihmcmFtZVN0YXRlLCB0YXJnZXQpIHtcbiAgICBjb25zdCBsYXllclJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuXG4gICAgaWYgKGxheWVyUmVuZGVyZXIucHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUpKSB7XG4gICAgICB0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsYXllclJlbmRlcmVyLnJlbmRlckZyYW1lKGZyYW1lU3RhdGUsIHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgbGF5ZXIgaXMgbm90IHZpc2libGUgZHVyaW5nIGEgbWFwIHJlbmRlci5cbiAgICovXG4gIHVucmVuZGVyKCkge1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtzdHJpbmd9IERlY2x1dHRlciAqL1xuICBnZXREZWNsdXR0ZXIoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRGVjbHV0dGVyKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHt9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHJlbmRlcmVyIGZvbGxvd3MgYSBsYXlvdXQgLT4gcmVuZGVyIGFwcHJvYWNoLCBkbyB0aGUgZmluYWwgcmVuZGVyaW5nIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9NYXAuanMnKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlXG4gICAqL1xuICByZW5kZXJEZWZlcnJlZChmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgbGF5ZXJSZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICBpZiAoIWxheWVyUmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5ZXJSZW5kZXJlci5yZW5kZXJEZWZlcnJlZChmcmFtZVN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdXNlIGluc2lkZSB0aGUgbGlicmFyeSBvbmx5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IG1hcCBNYXAuXG4gICAqL1xuICBzZXRNYXBJbnRlcm5hbChtYXApIHtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgdGhpcy51bnJlbmRlcigpO1xuICAgIH1cbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1BUCwgbWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdXNlIGluc2lkZSB0aGUgbGlicmFyeSBvbmx5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBNYXAuXG4gICAqL1xuICBnZXRNYXBJbnRlcm5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxheWVyIHRvIGJlIHJlbmRlcmVkIG9uIHRvcCBvZiBvdGhlciBsYXllcnMgb24gYSBtYXAuIFRoZSBtYXAgd2lsbFxuICAgKiBub3QgbWFuYWdlIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLiBUaGlzXG4gICAqIGlzIHVzZWZ1bCBmb3IgdGVtcG9yYXJ5IGxheWVycy4gVG8gcmVtb3ZlIGFuIHVubWFuYWdlZCBsYXllciBmcm9tIHRoZSBtYXAsXG4gICAqIHVzZSBgI3NldE1hcChudWxsKWAuXG4gICAqXG4gICAqIFRvIGFkZCB0aGUgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwLCB1c2VcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwI2FkZExheWVyfSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IG1hcCBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBpZiAodGhpcy5tYXBQcmVjb21wb3NlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFByZWNvbXBvc2VLZXlfKTtcbiAgICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIW1hcCkge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcFJlbmRlcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5tYXBSZW5kZXJLZXlfKTtcbiAgICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBsaXN0ZW4oXG4gICAgICAgIG1hcCxcbiAgICAgICAgUmVuZGVyRXZlbnRUeXBlLlBSRUNPTVBPU0UsXG4gICAgICAgIHRoaXMuaGFuZGxlUHJlY29tcG9zZV8sXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuICAgICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbGlzdGVuKHRoaXMsIEV2ZW50VHlwZS5DSEFOR0UsIG1hcC5yZW5kZXIsIG1hcCk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gcmVuZGVyRXZlbnQgUmVuZGVyIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQcmVjb21wb3NlXyhyZW5kZXJFdmVudCkge1xuICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPVxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnQuanNcIikuZGVmYXVsdH0gKi8gKHJlbmRlckV2ZW50KVxuICAgICAgICAuZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIGNvbnN0IGxheWVyU3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoZmFsc2UpO1xuICAgIGFzc2VydChcbiAgICAgICFsYXllclN0YXRlc0FycmF5LnNvbWUoXG4gICAgICAgIChhcnJheUxheWVyU3RhdGUpID0+IGFycmF5TGF5ZXJTdGF0ZS5sYXllciA9PT0gbGF5ZXJTdGF0ZS5sYXllcixcbiAgICAgICksXG4gICAgICAnQSBsYXllciBjYW4gb25seSBiZSBhZGRlZCB0byB0aGUgbWFwIG9uY2UuIFVzZSBlaXRoZXIgYGxheWVyLnNldE1hcCgpYCBvciBgbWFwLmFkZExheWVyKClgLCBub3QgYm90aC4nLFxuICAgICk7XG4gICAgbGF5ZXJTdGF0ZXNBcnJheS5wdXNoKGxheWVyU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGF5ZXIgc291cmNlLlxuICAgKiBAcGFyYW0ge1NvdXJjZVR5cGV8bnVsbH0gc291cmNlIFRoZSBsYXllciBzb3VyY2UuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNvdXJjZShzb3VyY2UpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlNPVVJDRSwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlbmRlcmVyIGZvciB0aGlzIGxheWVyLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlclR5cGV8bnVsbH0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgdGhpcy5yZW5kZXJlcl8gPSB0aGlzLmNyZWF0ZVJlbmRlcmVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbGF5ZXIgaGFzIGEgcmVuZGVyZXIuXG4gICAqL1xuICBoYXNSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZW5kZXJlciBmb3IgdGhpcyBsYXllci5cbiAgICogQHJldHVybiB7UmVuZGVyZXJUeXBlfSBBIGxheWVyIHJlbmRlcmVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXJfKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyXy5kaXNwb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy5yZW5kZXJlcl87XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTb3VyY2UobnVsbCk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBsYXllciBpcyB2aXNpYmxlIGFuZCBpZiB0aGUgcHJvdmlkZWQgdmlldyBzdGF0ZVxuICogaGFzIHJlc29sdXRpb24gYW5kIHpvb20gbGV2ZWxzIHRoYXQgYXJlIGluIHJhbmdlIG9mIHRoZSBsYXllcidzIG1pbi9tYXguXG4gKiBAcGFyYW0ge1N0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlN0YXRlfSB2aWV3U3RhdGUgVmlldyBzdGF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBsYXllciBpcyB2aXNpYmxlIGF0IHRoZSBnaXZlbiB2aWV3IHN0YXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5WaWV3KGxheWVyU3RhdGUsIHZpZXdTdGF0ZSkge1xuICBpZiAoIWxheWVyU3RhdGUudmlzaWJsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG4gIGlmIChcbiAgICByZXNvbHV0aW9uIDwgbGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uIHx8XG4gICAgcmVzb2x1dGlvbiA+PSBsYXllclN0YXRlLm1heFJlc29sdXRpb25cbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHpvb20gPSB2aWV3U3RhdGUuem9vbTtcbiAgcmV0dXJuIHpvb20gPiBsYXllclN0YXRlLm1pblpvb20gJiYgem9vbSA8PSBsYXllclN0YXRlLm1heFpvb207XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyO1xuIiwgIlxuLyoqXG4gKiBSZWFycmFuZ2VzIGl0ZW1zIHNvIHRoYXQgYWxsIGl0ZW1zIGluIHRoZSBbbGVmdCwga10gYXJlIHRoZSBzbWFsbGVzdC5cbiAqIFRoZSBrLXRoIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSAoayAtIGxlZnQgKyAxKS10aCBzbWFsbGVzdCB2YWx1ZSBpbiBbbGVmdCwgcmlnaHRdLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1RbXX0gYXJyIHRoZSBhcnJheSB0byBwYXJ0aWFsbHkgc29ydCAoaW4gcGxhY2UpXG4gKiBAcGFyYW0ge251bWJlcn0gayBtaWRkbGUgaW5kZXggZm9yIHBhcnRpYWwgc29ydGluZyAoYXMgZGVmaW5lZCBhYm92ZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVmdD0wXSBsZWZ0IGluZGV4IG9mIHRoZSByYW5nZSB0byBzb3J0XG4gKiBAcGFyYW0ge251bWJlcn0gW3JpZ2h0PWFyci5sZW5ndGgtMV0gcmlnaHQgaW5kZXhcbiAqIEBwYXJhbSB7KGE6IFQsIGI6IFQpID0+IG51bWJlcn0gW2NvbXBhcmUgPSAoYSwgYikgPT4gYSAtIGJdIGNvbXBhcmUgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0ID0gMCwgcmlnaHQgPSBhcnIubGVuZ3RoIC0gMSwgY29tcGFyZSA9IGRlZmF1bHRDb21wYXJlKSB7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHQgPSBhcnJba107XG4gICAgICAgIGxldCBpID0gbGVmdDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIGxldCBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUW119IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSB7bnVtYmVyfSBqXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgY29uc3QgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuIiwgImltcG9ydCBxdWlja3NlbGVjdCBmcm9tICdxdWlja3NlbGVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJCdXNoIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhFbnRyaWVzID0gOSkge1xuICAgICAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgICAgICB0aGlzLl9tYXhFbnRyaWVzID0gTWF0aC5tYXgoNCwgbWF4RW50cmllcyk7XG4gICAgICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH1cblxuICAgIHNlYXJjaChiYm94KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5kYXRhO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY29uc3QgdG9CQm94ID0gdGhpcy50b0JCb3g7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9TZWFyY2ggPSBbXTtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29sbGlkZXMoYmJveCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZGF0YTtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdGhpcy50b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbG9hZChkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIGNvbnN0IHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGluc2VydChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlbW92ZShpdGVtLCBlcXVhbHNGbikge1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5kYXRhO1xuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy50b0JCb3goaXRlbSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgICAgICBsZXQgaSwgcGFyZW50LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBmaW5kSXRlbShpdGVtLCBub2RlLmNoaWxkcmVuLCBlcXVhbHNGbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0b0JCb3goaXRlbSkgeyByZXR1cm4gaXRlbTsgfVxuXG4gICAgY29tcGFyZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG4gICAgY29tcGFyZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbiAgICB0b0pTT04oKSB7IHJldHVybiB0aGlzLmRhdGE7IH1cblxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX2FsbChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goLi4ubm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBfYnVpbGQoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICBjb25zdCBOID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgbGV0IE0gPSB0aGlzLl9tYXhFbnRyaWVzO1xuICAgICAgICBsZXQgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZShpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpKTtcbiAgICAgICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRhcmdldCBoZWlnaHQgb2YgdGhlIGJ1bGstbG9hZGVkIHRyZWVcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmxvZyhOKSAvIE1hdGgubG9nKE0pKTtcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxuICAgICAgICAgICAgTSA9IE1hdGguY2VpbChOIC8gTWF0aC5wb3coTSwgaGVpZ2h0IC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICBub2RlLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cbiAgICAgICAgY29uc3QgTjIgPSBNYXRoLmNlaWwoTiAvIE0pO1xuICAgICAgICBjb25zdCBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSk7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkgKz0gTjEpIHtcblxuICAgICAgICAgICAgY29uc3QgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgX2Nob29zZVN1YnRyZWUoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBwYXRoLmxlbmd0aCAtIDEgPT09IGxldmVsKSBicmVhaztcblxuICAgICAgICAgICAgbGV0IG1pbkFyZWEgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IHRhcmdldE5vZGU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkKSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBfaW5zZXJ0KGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcbiAgICAgICAgY29uc3QgYmJveCA9IGlzTm9kZSA/IGl0ZW0gOiB0aGlzLnRvQkJveChpdGVtKTtcbiAgICAgICAgY29uc3QgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICBleHRlbmQobm9kZSwgYmJveCk7XG5cbiAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0UGF0aFtsZXZlbF0uY2hpbGRyZW4ubGVuZ3RoID4gdGhpcy5fbWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcbiAgICB9XG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdO1xuICAgICAgICBjb25zdCBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICBjb25zdCBzcGxpdEluZGV4ID0gdGhpcy5fY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKTtcblxuICAgICAgICBjb25zdCBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcbiAgICAgICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH1cblxuICAgIF9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyAxO1xuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9XG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKSB7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgbGV0IG1pbk92ZXJsYXAgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIGNvbnN0IGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgICAgICBjb25zdCBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxhcCA9PT0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4IHx8IE0gLSBtO1xuICAgIH1cblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pIHtcbiAgICAgICAgY29uc3QgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YO1xuICAgICAgICBjb25zdCBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblk7XG4gICAgICAgIGNvbnN0IHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKTtcbiAgICAgICAgY29uc3QgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xuXG4gICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxuICAgICAgICBpZiAoeE1hcmdpbiA8IHlNYXJnaW4pIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7XG4gICAgfVxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICBjb25zdCB0b0JCb3ggPSB0aGlzLnRvQkJveDtcbiAgICAgICAgY29uc3QgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpO1xuICAgICAgICBjb25zdCByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KTtcbiAgICAgICAgbGV0IG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9XG5cbiAgICBfYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKGxldCBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29uZGVuc2UocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRJdGVtKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbikge1xuICAgIGlmICghZXF1YWxzRm4pIHJldHVybiBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzRm4oaXRlbSwgaXRlbXNbaV0pKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCwgZGVzdE5vZGUpIHtcbiAgICBpZiAoIWRlc3ROb2RlKSBkZXN0Tm9kZSA9IGNyZWF0ZU5vZGUobnVsbCk7XG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1pblkgPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKGxldCBpID0gazsgaSA8IHA7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIGNvbnN0IG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCk7XG4gICAgY29uc3QgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKTtcbiAgICBjb25zdCBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpO1xuICAgIGNvbnN0IG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICpcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubWluWCA8PSBiLm1pblggJiZcbiAgICAgICAgICAgYS5taW5ZIDw9IGIubWluWSAmJlxuICAgICAgICAgICBiLm1heFggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWF4WSA8PSBhLm1heFk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuICAgIHJldHVybiBiLm1pblggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWluWSA8PSBhLm1heFkgJiZcbiAgICAgICAgICAgYi5tYXhYID49IGEubWluWCAmJlxuICAgICAgICAgICBiLm1heFkgPj0gYS5taW5ZO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgICAgbWluWDogSW5maW5pdHksXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxuICAgICAgICBtYXhYOiAtSW5maW5pdHksXG4gICAgICAgIG1heFk6IC1JbmZpbml0eVxuICAgIH07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcbiAgICBjb25zdCBzdGFjayA9IFtsZWZ0LCByaWdodF07XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIG1pZCwgbGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSURMRTogMCxcbiAgTE9BRElORzogMSxcbiAgTE9BREVEOiAyLFxuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zaXplXG4gKi9cblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhIHNpemU6IGBbd2lkdGgsIGhlaWdodF1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IFNpemVcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXJlZCBzaXplLlxuICogQHBhcmFtIHtTaXplfSBzaXplIFNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBhbW91bnQgYnkgd2hpY2ggdG8gYnVmZmVyLlxuICogQHBhcmFtIHtTaXplfSBbZGVzdF0gT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge1NpemV9IFRoZSBidWZmZXJlZCBzaXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyKHNpemUsIG51bSwgZGVzdCkge1xuICBpZiAoZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdCA9IFswLCAwXTtcbiAgfVxuICBkZXN0WzBdID0gc2l6ZVswXSArIDIgKiBudW07XG4gIGRlc3RbMV0gPSBzaXplWzFdICsgMiAqIG51bTtcbiAgcmV0dXJuIGRlc3Q7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHNpemUgaGFzIGEgcG9zaXRpdmUgYXJlYS5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBUaGUgc2l6ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNpemUgaGFzIGEgcG9zaXRpdmUgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0FyZWEoc2l6ZSkge1xuICByZXR1cm4gc2l6ZVswXSA+IDAgJiYgc2l6ZVsxXSA+IDA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHNpemUgc2NhbGVkIGJ5IGEgcmF0aW8uIFRoZSByZXN1bHQgd2lsbCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vycy5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFJhdGlvLlxuICogQHBhcmFtIHtTaXplfSBbZGVzdF0gT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge1NpemV9IFRoZSBzY2FsZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHNpemUsIHJhdGlvLCBkZXN0KSB7XG4gIGlmIChkZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0ID0gWzAsIDBdO1xuICB9XG4gIGRlc3RbMF0gPSAoc2l6ZVswXSAqIHJhdGlvICsgMC41KSB8IDA7XG4gIGRlc3RbMV0gPSAoc2l6ZVsxXSAqIHJhdGlvICsgMC41KSB8IDA7XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYFNpemVgIGFycmF5IGZvciB0aGUgcGFzc2VkIGluIG51bWJlciAobWVhbmluZzogc3F1YXJlKSBvclxuICogYFNpemVgIGFycmF5LlxuICogKG1lYW5pbmc6IG5vbi1zcXVhcmUpLFxuICogQHBhcmFtIHtudW1iZXJ8U2l6ZX0gc2l6ZSBXaWR0aCBhbmQgaGVpZ2h0LlxuICogQHBhcmFtIHtTaXplfSBbZGVzdF0gT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge1NpemV9IFNpemUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1NpemUoc2l6ZSwgZGVzdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGlmIChkZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0ID0gW3NpemUsIHNpemVdO1xuICB9IGVsc2Uge1xuICAgIGRlc3RbMF0gPSBzaXplO1xuICAgIGRlc3RbMV0gPSBzaXplO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JbWFnZVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQHByb3BlcnR5IHtib29sZWFufSByb3RhdGVXaXRoVmlldyBJZiB0aGUgaW1hZ2Ugc2hvdWxkIGdldCByb3RhdGVkIHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBkaXNwbGFjZW1lbnQgRGlzcGxhY2VtZW50LlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4uL3N0eWxlL1N0eWxlLmpzJykuRGVjbHV0dGVyTW9kZX0gZGVjbHV0dGVyTW9kZSBEZWNsdXR0ZXIgbW9kZTogYGRlY2x1dHRlcmAsIGBvYnN0YWNsZWAsIGBub25lYC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgYmFzZSBjbGFzcyB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3QgaW5zdGFudGlhdGVkIGluXG4gKiBhcHBzLiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0sIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvQ2lyY2xlfkNpcmNsZVN0eWxlfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvUmVndWxhclNoYXBlflJlZ3VsYXJTaGFwZX0uXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgSW1hZ2VTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IG9wdGlvbnMub3BhY2l0eTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gb3B0aW9ucy5yb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUob3B0aW9ucy5zY2FsZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZGlzcGxhY2VtZW50XyA9IG9wdGlvbnMuZGlzcGxhY2VtZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi9zdHlsZS9TdHlsZS5qcycpLkRlY2x1dHRlck1vZGV9XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJNb2RlXyA9IG9wdGlvbnMuZGVjbHV0dGVyTW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtJbWFnZVN0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICByZXR1cm4gbmV3IEltYWdlU3R5bGUoe1xuICAgICAgb3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KCksXG4gICAgICBzY2FsZTogQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGUsXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzeW1ib2xpemVyIG9wYWNpdHkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3BhY2l0eS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3ltYm9saXplciByb3RhdGVzIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUm90YXRlIHdpdGggbWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSb3RhdGVXaXRoVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGVXaXRoVmlld187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzeW1vYmxpemVyIHJvdGF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJvdGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzeW1ib2xpemVyIHNjYWxlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZSBhcnJheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTY2FsZSBhcnJheS5cbiAgICovXG4gIGdldFNjYWxlQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVBcnJheV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkaXNwbGFjZW1lbnQgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFNoYXBlJ3MgY2VudGVyIGRpc3BsYWNlbWVudFxuICAgKiBAYXBpXG4gICAqL1xuICBnZXREaXNwbGFjZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGxhY2VtZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlY2x1dHRlciBtb2RlIG9mIHRoZSBzaGFwZVxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0eWxlLmpzXCIpLkRlY2x1dHRlck1vZGV9IFNoYXBlJ3MgZGVjbHV0dGVyIG1vZGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RGVjbHV0dGVyTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsdXR0ZXJNb2RlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBpbiBwaXhlbHMuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAgICogc3ltYm9saXplci5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuY2hvci5cbiAgICovXG4gIGdldEFuY2hvcigpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGVsZW1lbnQgZm9yIHRoZSBzeW1ib2xpemVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IEltYWdlIGVsZW1lbnQuXG4gICAqL1xuICBnZXRJbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IEltYWdlIGVsZW1lbnQuXG4gICAqL1xuICBnZXRIaXREZXRlY3Rpb25JbWFnZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIHBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBQaXhlbCByYXRpby5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0SW1hZ2VTaXplKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIG9mIHRoZSBzeW1ib2xpemVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZ2luLlxuICAgKi9cbiAgZ2V0T3JpZ2luKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgc3ltYm9saXplciAoaW4gcGl4ZWxzKS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gU2l6ZS5cbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkaXNwbGFjZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGlzcGxhY2VtZW50IERpc3BsYWNlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RGlzcGxhY2VtZW50KGRpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50XyA9IGRpc3BsYWNlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG9wYWNpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9wYWNpdHkob3BhY2l0eSkge1xuICAgIHRoaXMub3BhY2l0eV8gPSBvcGFjaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRvIHJvdGF0ZSB0aGUgc3R5bGUgd2l0aCB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByb3RhdGVXaXRoVmlldyBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0ZVdpdGhWaWV3KHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIHRoaXMuc2NhbGVfID0gc2NhbGU7XG4gICAgdGhpcy5zY2FsZUFycmF5XyA9IHRvU2l6ZShzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIGxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBsb2FkKCkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIHVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IGBmYWxzZWAgb3IgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHN0eWxlIGlzIHJlYWR5IHRvIHVzZS5cbiAgICovXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVN0eWxlO1xuIiwgIi8qKlxuICogUkdCIHNwYWNlLlxuICpcbiAqIEBtb2R1bGUgIGNvbG9yLXNwYWNlL3JnYlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0bmFtZTogJ3JnYicsXG5cdG1pbjogWzAsMCwwXSxcblx0bWF4OiBbMjU1LDI1NSwyNTVdLFxuXHRjaGFubmVsOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdGFsaWFzOiBbJ1JHQiddXG59O1xuIiwgIi8qKlxuICogQ0lFIFhZWlxuICpcbiAqIEBtb2R1bGUgIGNvbG9yLXNwYWNlL3h5elxuICovXG5pbXBvcnQgcmdiIGZyb20gJy4vcmdiLmpzJztcblxudmFyIHh5eiA9IHtcblx0bmFtZTogJ3h5eicsXG5cdG1pbjogWzAsMCwwXSxcblx0Y2hhbm5lbDogWydYJywnWScsJ1onXSxcblx0YWxpYXM6IFsnWFlaJywgJ2NpZXh5eicsICdjaWUxOTMxJ11cbn07XG5cblxuLyoqXG4gKiBXaGl0ZXBvaW50IHJlZmVyZW5jZSB2YWx1ZXMgd2l0aCBvYnNlcnZlci9pbGx1bWluYW50XG4gKlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdGFuZGFyZF9pbGx1bWluYW50XG4gKi9cbnh5ei53aGl0ZXBvaW50ID0ge1xuXHQvLzE5MzEgMlx1MDBCMFxuXHQyOiB7XG5cdFx0Ly9pbmNhZGVzY2VudFxuXHRcdEE6WzEwOS44NSwgMTAwLCAzNS41ODVdLFxuXHRcdC8vIEI6W10sXG5cdFx0QzogWzk4LjA3NCwgMTAwLCAxMTguMjMyXSxcblx0XHRENTA6IFs5Ni40MjIsIDEwMCwgODIuNTIxXSxcblx0XHRENTU6IFs5NS42ODIsIDEwMCwgOTIuMTQ5XSxcblx0XHQvL2RheWxpZ2h0XG5cdFx0RDY1OiBbOTUuMDQ1NTkyNzA1MTY3LCAxMDAsIDEwOC45MDU3NzUwNzU5ODc4XSxcblx0XHRENzU6IFs5NC45NzIsIDEwMCwgMTIyLjYzOF0sXG5cdFx0Ly9mbG91cmVzY2VudFxuXHRcdC8vIEYxOiBbXSxcblx0XHRGMjogWzk5LjE4NywgMTAwLCA2Ny4zOTVdLFxuXHRcdC8vIEYzOiBbXSxcblx0XHQvLyBGNDogW10sXG5cdFx0Ly8gRjU6IFtdLFxuXHRcdC8vIEY2OltdLFxuXHRcdEY3OiBbOTUuMDQ0LCAxMDAsIDEwOC43NTVdLFxuXHRcdC8vIEY4OiBbXSxcblx0XHQvLyBGOTogW10sXG5cdFx0Ly8gRjEwOiBbXSxcblx0XHRGMTE6IFsxMDAuOTY2LCAxMDAsIDY0LjM3MF0sXG5cdFx0Ly8gRjEyOiBbXSxcblx0XHRFOiBbMTAwLDEwMCwxMDBdXG5cdH0sXG5cblx0Ly8xOTY0ICAxMFx1MDBCMFxuXHQxMDoge1xuXHRcdC8vaW5jYWRlc2NlbnRcblx0XHRBOlsxMTEuMTQ0LCAxMDAsIDM1LjIwMF0sXG5cdFx0QzogWzk3LjI4NSwgMTAwLCAxMTYuMTQ1XSxcblx0XHRENTA6IFs5Ni43MjAsIDEwMCwgODEuNDI3XSxcblx0XHRENTU6IFs5NS43OTksIDEwMCwgOTAuOTI2XSxcblx0XHQvL2RheWxpZ2h0XG5cdFx0RDY1OiBbOTQuODExLCAxMDAsIDEwNy4zMDRdLFxuXHRcdEQ3NTogWzk0LjQxNiwgMTAwLCAxMjAuNjQxXSxcblx0XHQvL2Zsb3VyZXNjZW50XG5cdFx0RjI6IFsxMDMuMjgwLCAxMDAsIDY5LjAyNl0sXG5cdFx0Rjc6IFs5NS43OTIsIDEwMCwgMTA3LjY4N10sXG5cdFx0RjExOiBbMTAzLjg2NiwgMTAwLCA2NS42MjddLFxuXHRcdEU6IFsxMDAsMTAwLDEwMF1cblx0fVxufTtcblxuXG4vKipcbiAqIFRvcCB2YWx1ZXMgYXJlIHRoZSB3aGl0ZXBvaW50XHUyMDE5cyB0b3AgdmFsdWVzLCBkZWZhdWx0IGFyZSBENjVcbiAqL1xueHl6Lm1heCA9IHh5ei53aGl0ZXBvaW50WzJdLkQ2NTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybSB4eXogdG8gcmdiXG4gKlxuICogQHBhcmFtIHtBcnJheX0geHl6IEFycmF5IG9mIHh5eiB2YWx1ZXNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gUkdCIHZhbHVlc1xuICovXG54eXoucmdiID0gZnVuY3Rpb24gKF94eXosIHdoaXRlKSB7XG5cdC8vRklYTUU6IG1ha2Ugc3VyZSB3ZSBoYXZlIHRvIGRpdmlkZSBsaWtlIHRoaXMuIFByb2JhYmx5IHdlIGhhdmUgdG8gcmVwbGFjZSBtYXRyaXggYXMgd2VsbCB0aGVuXG5cdHdoaXRlID0gd2hpdGUgfHwgeHl6LndoaXRlcG9pbnRbMl0uRTtcblxuXHR2YXIgeCA9IF94eXpbMF0gLyB3aGl0ZVswXSxcblx0XHR5ID0gX3h5elsxXSAvIHdoaXRlWzFdLFxuXHRcdHogPSBfeHl6WzJdIC8gd2hpdGVbMl0sXG5cdFx0ciwgZywgYjtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHQvLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9SR0JfWFlaX01hdHJpeC5odG1sXG5cdHIgPSAoeCAqIDMuMjQwOTY5OTQxOTA0NTIxKSArICh5ICogLTEuNTM3MzgzMTc3NTcwMDkzKSArICh6ICogLTAuNDk4NjEwNzYwMjkzKTtcblx0ZyA9ICh4ICogLTAuOTY5MjQzNjM2MjgwODcpICsgKHkgKiAxLjg3NTk2NzUwMTUwNzcyKSArICh6ICogMC4wNDE1NTUwNTc0MDcxNzUpO1xuXHRiID0gKHggKiAwLjA1NTYzMDA3OTY5Njk5MykgKyAoeSAqIC0wLjIwMzk3Njk1ODg4ODk3KSArICh6ICogMS4wNTY5NzE1MTQyNDI4NzgpO1xuXG5cdHIgPSByID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KHIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiByID0gKHIgKiAxMi45Mik7XG5cblx0ZyA9IGcgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coZywgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGcgPSAoZyAqIDEyLjkyKTtcblxuXHRiID0gYiA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogYiA9IChiICogMTIuOTIpO1xuXG5cdHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG5cdGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG5cdGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuXG5cbi8qKlxuICogUkdCIHRvIFhZWlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJnYiBSR0IgY2hhbm5lbHNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gWFlaIGNoYW5uZWxzXG4gKi9cbnJnYi54eXogPSBmdW5jdGlvbihyZ2IsIHdoaXRlKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1LFxuXHRcdFx0ZyA9IHJnYlsxXSAvIDI1NSxcblx0XHRcdGIgPSByZ2JbMl0gLyAyNTU7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChyICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKHIgLyAxMi45Mik7XG5cdGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KCgoZyArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChnIC8gMTIuOTIpO1xuXHRiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuXHR2YXIgeCA9IChyICogMC40MTIzOTA3OTkyNjU5NSkgKyAoZyAqIDAuMzU3NTg0MzM5MzgzODcpICsgKGIgKiAwLjE4MDQ4MDc4ODQwMTgzKTtcblx0dmFyIHkgPSAociAqIDAuMjEyNjM5MDA1ODcxNTEpICsgKGcgKiAwLjcxNTE2ODY3ODc2Nzc1KSArIChiICogMC4wNzIxOTIzMTUzNjA3MzMpO1xuXHR2YXIgeiA9IChyICogMC4wMTkzMzA4MTg3MTU1OTEpICsgKGcgKiAwLjExOTE5NDc3OTc5NDYyKSArIChiICogMC45NTA1MzIxNTIyNDk2Nik7XG5cblx0d2hpdGUgPSB3aGl0ZSB8fCB4eXoud2hpdGVwb2ludFsyXS5FO1xuXG5cdHJldHVybiBbeCAqIHdoaXRlWzBdLCB5ICogd2hpdGVbMV0sIHogKiB3aGl0ZVsyXV07XG59O1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgeHl6O1xuIiwgIi8qKlxuICogQ0lFIExVViAoQydlc3QgbGEgdmllKVxuICpcbiAqIEBtb2R1bGUgY29sb3Itc3BhY2UvbHV2XG4gKi9cbiBpbXBvcnQgeHl6IGZyb20gJy4veHl6LmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRuYW1lOiAnbHV2Jyxcblx0Ly9OT1RFOiBsdXYgaGFzIG5vIHJpZ2lkbHkgZGVmaW5lZCBsaW1pdHNcblx0Ly9lYXN5cmdiIGZhaWxzIHRvIGdldCBwcm9wZXIgY29vcmRzXG5cdC8vYm9yb25pbmUgc3RhdGVzIG5vIHJpZ2lkIGxpbWl0c1xuXHQvL2NvbG9yTWluZSByZWZlcnMgdGhpcyBvbmVzOlxuXHRtaW46IFswLC0xMzQsLTE0MF0sXG5cdG1heDogWzEwMCwyMjQsMTIyXSxcblx0Y2hhbm5lbDogWydsaWdodG5lc3MnLCAndScsICd2J10sXG5cdGFsaWFzOiBbJ0xVVicsICdjaWVsdXYnLCAnY2llMTk3NiddLFxuXG5cdHh5ejogZnVuY3Rpb24oYXJnLCBpLCBvKXtcblx0XHR2YXIgX3UsIF92LCBsLCB1LCB2LCB4LCB5LCB6LCB4biwgeW4sIHpuLCB1biwgdm47XG5cdFx0bCA9IGFyZ1swXSwgdSA9IGFyZ1sxXSwgdiA9IGFyZ1syXTtcblxuXHRcdGlmIChsID09PSAwKSByZXR1cm4gWzAsMCwwXTtcblxuXHRcdC8vZ2V0IGNvbnN0YW50c1xuXHRcdC8vdmFyIGUgPSAwLjAwODg1NjQ1MTY3OTAzNTYzMTsgLy8oNi8yOSleM1xuXHRcdHZhciBrID0gMC4wMDExMDcwNTY0NTk4Nzk0NTM5OyAvLygzLzI5KV4zXG5cblx0XHQvL2dldCBpbGx1bWluYW50L29ic2VydmVyXG5cdFx0aSA9IGkgfHwgJ0Q2NSc7XG5cdFx0byA9IG8gfHwgMjtcblxuXHRcdHhuID0geHl6LndoaXRlcG9pbnRbb11baV1bMF07XG5cdFx0eW4gPSB4eXoud2hpdGVwb2ludFtvXVtpXVsxXTtcblx0XHR6biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzJdO1xuXG5cdFx0dW4gPSAoNCAqIHhuKSAvICh4biArICgxNSAqIHluKSArICgzICogem4pKTtcblx0XHR2biA9ICg5ICogeW4pIC8gKHhuICsgKDE1ICogeW4pICsgKDMgKiB6bikpO1xuXHRcdC8vIHVuID0gMC4xOTc4MzAwMDY2NDI4Mztcblx0XHQvLyB2biA9IDAuNDY4MzE5OTk0OTM4Nzk7XG5cblxuXHRcdF91ID0gdSAvICgxMyAqIGwpICsgdW4gfHwgMDtcblx0XHRfdiA9IHYgLyAoMTMgKiBsKSArIHZuIHx8IDA7XG5cblx0XHR5ID0gbCA+IDggPyB5biAqIE1hdGgucG93KCAobCArIDE2KSAvIDExNiAsIDMpIDogeW4gKiBsICogaztcblxuXHRcdC8vd2lraXBlZGlhIG1ldGhvZFxuXHRcdHggPSB5ICogOSAqIF91IC8gKDQgKiBfdikgfHwgMDtcblx0XHR6ID0geSAqICgxMiAtIDMgKiBfdSAtIDIwICogX3YpIC8gKDQgKiBfdikgfHwgMDtcblxuXHRcdC8vYm9yb25pbmUgbWV0aG9kXG5cdFx0Ly9odHRwczovL2dpdGh1Yi5jb20vYm9yb25pbmUvaHVzbC9ibG9iL21hc3Rlci9odXNsLmNvZmZlZSNMMjAxXG5cdFx0Ly8geCA9IDAgLSAoOSAqIHkgKiBfdSkgLyAoKF91IC0gNCkgKiBfdiAtIF91ICogX3YpO1xuXHRcdC8vIHogPSAoOSAqIHkgLSAoMTUgKiBfdiAqIHkpIC0gKF92ICogeCkpIC8gKDMgKiBfdik7XG5cblx0XHRyZXR1cm4gW3gsIHksIHpdO1xuXHR9XG59O1xuXG4vLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0VxdWF0aW9ucy5odG1sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYm9yb25pbmUvaHVzbC9ibG9iL21hc3Rlci9odXNsLmNvZmZlZVxuLy9pIC0gaWxsdW1pbmFudFxuLy9vIC0gb2JzZXJ2ZXJcbnh5ei5sdXYgPSBmdW5jdGlvbihhcmcsIGksIG8pIHtcblx0dmFyIF91LCBfdiwgbCwgdSwgdiwgeCwgeSwgeiwgeG4sIHluLCB6biwgdW4sIHZuO1xuXG5cdC8vZ2V0IGNvbnN0YW50c1xuXHR2YXIgZSA9IDAuMDA4ODU2NDUxNjc5MDM1NjMxOyAvLyg2LzI5KV4zXG5cdHZhciBrID0gOTAzLjI5NjI5NjI5NjI5NjE7IC8vKDI5LzMpXjNcblxuXHQvL2dldCBpbGx1bWluYW50L29ic2VydmVyIGNvb3Jkc1xuXHRpID0gaSB8fCAnRDY1Jztcblx0byA9IG8gfHwgMjtcblxuXHR4biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzBdO1xuXHR5biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzFdO1xuXHR6biA9IHh5ei53aGl0ZXBvaW50W29dW2ldWzJdO1xuXG5cdHVuID0gKDQgKiB4bikgLyAoeG4gKyAoMTUgKiB5bikgKyAoMyAqIHpuKSk7XG5cdHZuID0gKDkgKiB5bikgLyAoeG4gKyAoMTUgKiB5bikgKyAoMyAqIHpuKSk7XG5cblxuXHR4ID0gYXJnWzBdLCB5ID0gYXJnWzFdLCB6ID0gYXJnWzJdO1xuXG5cblx0X3UgPSAoNCAqIHgpIC8gKHggKyAoMTUgKiB5KSArICgzICogeikpIHx8IDA7XG5cdF92ID0gKDkgKiB5KSAvICh4ICsgKDE1ICogeSkgKyAoMyAqIHopKSB8fCAwO1xuXG5cdHZhciB5ciA9IHkveW47XG5cblx0bCA9IHlyIDw9IGUgPyBrICogeXIgOiAxMTYgKiBNYXRoLnBvdyh5ciwgMS8zKSAtIDE2O1xuXG5cdHUgPSAxMyAqIGwgKiAoX3UgLSB1bik7XG5cdHYgPSAxMyAqIGwgKiAoX3YgLSB2bik7XG5cblx0cmV0dXJuIFtsLCB1LCB2XTtcbn07XG4iLCAiLyoqXG4gKiBDeWxpbmRyaWNhbCBDSUUgTFVWXG4gKlxuICogQG1vZHVsZSBjb2xvci1zcGFjZS9sY2h1dlxuICovXG5pbXBvcnQgbHV2IGZyb20gJy4vbHV2LmpzJztcbmltcG9ydCB4eXogZnJvbSAnLi94eXouanMnO1xuXG4vL2N5bGluZHJpY2FsIGx1dlxudmFyIGxjaHV2ID0ge1xuXHRuYW1lOiAnbGNodXYnLFxuXHRjaGFubmVsOiBbJ2xpZ2h0bmVzcycsICdjaHJvbWEnLCAnaHVlJ10sXG5cdGFsaWFzOiBbJ0xDSHV2JywgJ2NpZWxjaHV2J10sXG5cdG1pbjogWzAsMCwwXSxcblx0bWF4OiBbMTAwLDEwMCwzNjBdLFxuXG5cdGx1djogZnVuY3Rpb24obHV2KXtcblx0XHR2YXIgbCA9IGx1dlswXSxcblx0XHRjID0gbHV2WzFdLFxuXHRcdGggPSBsdXZbMl0sXG5cdFx0dSwgdiwgaHI7XG5cblx0XHRociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcblx0XHR1ID0gYyAqIE1hdGguY29zKGhyKTtcblx0XHR2ID0gYyAqIE1hdGguc2luKGhyKTtcblx0XHRyZXR1cm4gW2wsIHUsIHZdO1xuXHR9LFxuXG5cdHh5ejogZnVuY3Rpb24oYXJnKSB7XG5cdFx0cmV0dXJuIGx1di54eXoobGNodXYubHV2KGFyZykpO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsY2h1djtcblxubHV2LmxjaHV2ID0gZnVuY3Rpb24obHV2KXtcblx0dmFyIGwgPSBsdXZbMF0sIHUgPSBsdXZbMV0sIHYgPSBsdXZbMl07XG5cblx0dmFyIGMgPSBNYXRoLnNxcnQodSp1ICsgdip2KTtcblx0dmFyIGhyID0gTWF0aC5hdGFuMih2LHUpO1xuXHR2YXIgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0cmV0dXJuIFtsLGMsaF1cbn07XG5cbnh5ei5sY2h1diA9IGZ1bmN0aW9uKGFyZyl7XG4gIHJldHVybiBsdXYubGNodXYoeHl6Lmx1dihhcmcpKTtcbn07XG4iLCAiZXhwb3J0IGRlZmF1bHQge1xuXHRhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcblx0YW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG5cdGFxdWE6IFswLCAyNTUsIDI1NV0sXG5cdGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcblx0YXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcblx0YmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcblx0YmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG5cdGJsYWNrOiBbMCwgMCwgMF0sXG5cdGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG5cdGJsdWU6IFswLCAwLCAyNTVdLFxuXHRibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcblx0YnJvd246IFsxNjUsIDQyLCA0Ml0sXG5cdGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuXHRjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuXHRjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuXHRjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuXHRjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG5cdGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG5cdGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG5cdGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG5cdGN5YW46IFswLCAyNTUsIDI1NV0sXG5cdGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcblx0ZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG5cdGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuXHRkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuXHRkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuXHRkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuXHRkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcblx0ZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG5cdGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuXHRkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuXHRkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcblx0ZGFya3JlZDogWzEzOSwgMCwgMF0sXG5cdGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcblx0ZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG5cdGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG5cdGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcblx0ZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuXHRkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuXHRkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuXHRkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG5cdGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuXHRkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG5cdGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcblx0ZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG5cdGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcblx0ZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcblx0Zm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG5cdGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG5cdGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuXHRnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG5cdGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG5cdGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG5cdGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcblx0Z3JlZW46IFswLCAxMjgsIDBdLFxuXHRncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG5cdGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcblx0aG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcblx0aG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuXHRpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG5cdGluZGlnbzogWzc1LCAwLCAxMzBdLFxuXHRpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuXHRraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuXHRsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuXHRsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG5cdGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcblx0bGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG5cdGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuXHRsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG5cdGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuXHRsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuXHRsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcblx0bGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuXHRsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcblx0bGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG5cdGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG5cdGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuXHRsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcblx0bGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcblx0bGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcblx0bGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcblx0bGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcblx0bGltZTogWzAsIDI1NSwgMF0sXG5cdGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcblx0bGluZW46IFsyNTAsIDI0MCwgMjMwXSxcblx0bWFnZW50YTogWzI1NSwgMCwgMjU1XSxcblx0bWFyb29uOiBbMTI4LCAwLCAwXSxcblx0bWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuXHRtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcblx0bWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcblx0bWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG5cdG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcblx0bWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG5cdG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuXHRtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuXHRtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuXHRtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG5cdG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuXHRtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcblx0bW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcblx0bmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcblx0bmF2eTogWzAsIDAsIDEyOF0sXG5cdG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcblx0b2xpdmU6IFsxMjgsIDEyOCwgMF0sXG5cdG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG5cdG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcblx0b3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG5cdG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuXHRwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG5cdHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuXHRwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG5cdHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcblx0cGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuXHRwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcblx0cGVydTogWzIwNSwgMTMzLCA2M10sXG5cdHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcblx0cGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuXHRwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG5cdHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcblx0cmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG5cdHJlZDogWzI1NSwgMCwgMF0sXG5cdHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuXHRyb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuXHRzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcblx0c2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG5cdHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuXHRzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcblx0c2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcblx0c2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuXHRzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcblx0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuXHRzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuXHRzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcblx0c2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG5cdHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcblx0c3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG5cdHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG5cdHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuXHR0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuXHR0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG5cdHRvbWF0bzogWzI1NSwgOTksIDcxXSxcblx0dHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcblx0dmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG5cdHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG5cdHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG5cdHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcblx0eWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuXHR5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgY29sb3ItcGFyc2VcbiAqL1xuaW1wb3J0IG5hbWVzIGZyb20gJ2NvbG9yLW5hbWUnXG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlXG5cbi8qKlxuICogQmFzZSBodWVzXG4gKiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI3R5cGVkZWYtbmFtZWQtaHVlXG4gKi9cbi8vRklYTUU6IHVzZSBleHRlcm5hbCBodWUgZGV0ZWN0b3JcbnZhciBiYXNlSHVlcyA9IHtcblx0cmVkOiAwLFxuXHRvcmFuZ2U6IDYwLFxuXHR5ZWxsb3c6IDEyMCxcblx0Z3JlZW46IDE4MCxcblx0Ymx1ZTogMjQwLFxuXHRwdXJwbGU6IDMwMFxufVxuXG4vKipcbiAqIFBhcnNlIGNvbG9yIGZyb20gdGhlIHN0cmluZyBwYXNzZWRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgc3BhY2UgaW5kaWNhdG9yIGBzcGFjZWAsIGFuIGFycmF5IGB2YWx1ZXNgIGFuZCBgYWxwaGFgXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGNzdHIpIHtcblx0dmFyIG0sIHBhcnRzID0gW10sIGFscGhhID0gMSwgc3BhY2VcblxuXHQvL251bWVyaWMgY2FzZVxuXHRpZiAodHlwZW9mIGNzdHIgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIHsgc3BhY2U6ICdyZ2InLCB2YWx1ZXM6IFtjc3RyID4+PiAxNiwgKGNzdHIgJiAweDAwZmYwMCkgPj4+IDgsIGNzdHIgJiAweDAwMDBmZl0sIGFscGhhOiAxIH1cblx0fVxuXHRpZiAodHlwZW9mIGNzdHIgPT09ICdudW1iZXInKSByZXR1cm4geyBzcGFjZTogJ3JnYicsIHZhbHVlczogW2NzdHIgPj4+IDE2LCAoY3N0ciAmIDB4MDBmZjAwKSA+Pj4gOCwgY3N0ciAmIDB4MDAwMGZmXSwgYWxwaGE6IDEgfVxuXG5cdGNzdHIgPSBTdHJpbmcoY3N0cikudG9Mb3dlckNhc2UoKTtcblxuXHQvL2tleXdvcmRcblx0aWYgKG5hbWVzW2NzdHJdKSB7XG5cdFx0cGFydHMgPSBuYW1lc1tjc3RyXS5zbGljZSgpXG5cdFx0c3BhY2UgPSAncmdiJ1xuXHR9XG5cblx0Ly9yZXNlcnZlZCB3b3Jkc1xuXHRlbHNlIGlmIChjc3RyID09PSAndHJhbnNwYXJlbnQnKSB7XG5cdFx0YWxwaGEgPSAwXG5cdFx0c3BhY2UgPSAncmdiJ1xuXHRcdHBhcnRzID0gWzAsIDAsIDBdXG5cdH1cblxuXHQvL2hleFxuXHRlbHNlIGlmIChjc3RyWzBdID09PSAnIycpIHtcblx0XHR2YXIgYmFzZSA9IGNzdHIuc2xpY2UoMSlcblx0XHR2YXIgc2l6ZSA9IGJhc2UubGVuZ3RoXG5cdFx0dmFyIGlzU2hvcnQgPSBzaXplIDw9IDRcblx0XHRhbHBoYSA9IDFcblxuXHRcdGlmIChpc1Nob3J0KSB7XG5cdFx0XHRwYXJ0cyA9IFtcblx0XHRcdFx0cGFyc2VJbnQoYmFzZVswXSArIGJhc2VbMF0sIDE2KSxcblx0XHRcdFx0cGFyc2VJbnQoYmFzZVsxXSArIGJhc2VbMV0sIDE2KSxcblx0XHRcdFx0cGFyc2VJbnQoYmFzZVsyXSArIGJhc2VbMl0sIDE2KVxuXHRcdFx0XVxuXHRcdFx0aWYgKHNpemUgPT09IDQpIHtcblx0XHRcdFx0YWxwaGEgPSBwYXJzZUludChiYXNlWzNdICsgYmFzZVszXSwgMTYpIC8gMjU1XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cGFydHMgPSBbXG5cdFx0XHRcdHBhcnNlSW50KGJhc2VbMF0gKyBiYXNlWzFdLCAxNiksXG5cdFx0XHRcdHBhcnNlSW50KGJhc2VbMl0gKyBiYXNlWzNdLCAxNiksXG5cdFx0XHRcdHBhcnNlSW50KGJhc2VbNF0gKyBiYXNlWzVdLCAxNilcblx0XHRcdF1cblx0XHRcdGlmIChzaXplID09PSA4KSB7XG5cdFx0XHRcdGFscGhhID0gcGFyc2VJbnQoYmFzZVs2XSArIGJhc2VbN10sIDE2KSAvIDI1NVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghcGFydHNbMF0pIHBhcnRzWzBdID0gMFxuXHRcdGlmICghcGFydHNbMV0pIHBhcnRzWzFdID0gMFxuXHRcdGlmICghcGFydHNbMl0pIHBhcnRzWzJdID0gMFxuXG5cdFx0c3BhY2UgPSAncmdiJ1xuXHR9XG5cblx0Ly8gY29sb3Igc3BhY2Vcblx0ZWxzZSBpZiAobSA9IC9eKCg/OnJnYmE/fGhzW2x2Yl1hP3xod2JhP3xjbXlrP3x4eVt6eV18Z3JheXxsYWJ8bGNodT92P3xbbHlddXZ8bG1zfG9rbGNofG9rbGFifGNvbG9yKSlcXHMqXFwoKFteXFwpXSopXFwpLy5leGVjKGNzdHIpKSB7XG5cdFx0dmFyIG5hbWUgPSBtWzFdXG5cdFx0c3BhY2UgPSBuYW1lLnJlcGxhY2UoL2EkLywgJycpXG5cdFx0dmFyIGRpbXMgPSBzcGFjZSA9PT0gJ2NteWsnID8gNCA6IHNwYWNlID09PSAnZ3JheScgPyAxIDogM1xuXHRcdHBhcnRzID0gbVsyXS50cmltKCkuc3BsaXQoL1xccypbLFxcL11cXHMqfFxccysvKVxuXG5cdFx0Ly8gY29sb3Ioc3JnYi1saW5lYXIgeCB4IHgpIC0+IHNyZ2ItbGluZWFyKHggeCB4KVxuXHRcdGlmIChzcGFjZSA9PT0gJ2NvbG9yJykgc3BhY2UgPSBwYXJ0cy5zaGlmdCgpXG5cblx0XHRwYXJ0cyA9IHBhcnRzLm1hcChmdW5jdGlvbiAoeCwgaSkge1xuXHRcdFx0Ly88cGVyY2VudGFnZT5cblx0XHRcdGlmICh4W3gubGVuZ3RoIC0gMV0gPT09ICclJykge1xuXHRcdFx0XHR4ID0gcGFyc2VGbG9hdCh4KSAvIDEwMFxuXHRcdFx0XHQvLyBhbHBoYSAtPiAwLi4xXG5cdFx0XHRcdGlmIChpID09PSAzKSByZXR1cm4geFxuXHRcdFx0XHQvLyByZ2IgLT4gMC4uMjU1XG5cdFx0XHRcdGlmIChzcGFjZSA9PT0gJ3JnYicpIHJldHVybiB4ICogMjU1XG5cdFx0XHRcdC8vIGhzbCwgaHdiIEggLT4gMC4uMTAwXG5cdFx0XHRcdGlmIChzcGFjZVswXSA9PT0gJ2gnKSByZXR1cm4geCAqIDEwMFxuXHRcdFx0XHQvLyBsY2gsIGxhYiBMIC0+IDAuLjEwMFxuXHRcdFx0XHRpZiAoc3BhY2VbMF0gPT09ICdsJyAmJiAhaSkgcmV0dXJuIHggKiAxMDBcblx0XHRcdFx0Ly8gbGFiIEEgQiAtPiAtMTI1Li4xMjVcblx0XHRcdFx0aWYgKHNwYWNlID09PSAnbGFiJykgcmV0dXJuIHggKiAxMjVcblx0XHRcdFx0Ly8gbGNoIEMgLT4gMC4uMTUwLCBIIC0+IDAuLjM2MFxuXHRcdFx0XHRpZiAoc3BhY2UgPT09ICdsY2gnKSByZXR1cm4gaSA8IDIgPyB4ICogMTUwIDogeCAqIDM2MFxuXHRcdFx0XHQvLyBva2xjaC9va2xhYiBMIC0+IDAuLjFcblx0XHRcdFx0aWYgKHNwYWNlWzBdID09PSAnbycgJiYgIWkpIHJldHVybiB4XG5cdFx0XHRcdC8vIG9rbGFiIEEgQiAtPiAtMC40Li4wLjRcblx0XHRcdFx0aWYgKHNwYWNlID09PSAnb2tsYWInKSByZXR1cm4geCAqIDAuNFxuXHRcdFx0XHQvLyBva2xjaCBDIC0+IDAuLjAuNCwgSCAtPiAwLi4zNjBcblx0XHRcdFx0aWYgKHNwYWNlID09PSAnb2tsY2gnKSByZXR1cm4gaSA8IDIgPyB4ICogMC40IDogeCAqIDM2MFxuXHRcdFx0XHQvLyBjb2xvcih4eHgpIC0+IDAuLjFcblx0XHRcdFx0cmV0dXJuIHhcblx0XHRcdH1cblxuXHRcdFx0Ly9odWVcblx0XHRcdGlmIChzcGFjZVtpXSA9PT0gJ2gnIHx8IChpID09PSAyICYmIHNwYWNlW3NwYWNlLmxlbmd0aCAtIDFdID09PSAnaCcpKSB7XG5cdFx0XHRcdC8vPGJhc2UtaHVlPlxuXHRcdFx0XHRpZiAoYmFzZUh1ZXNbeF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGJhc2VIdWVzW3hdXG5cdFx0XHRcdC8vPGRlZz5cblx0XHRcdFx0aWYgKHguZW5kc1dpdGgoJ2RlZycpKSByZXR1cm4gcGFyc2VGbG9hdCh4KVxuXHRcdFx0XHQvLzx0dXJuPlxuXHRcdFx0XHRpZiAoeC5lbmRzV2l0aCgndHVybicpKSByZXR1cm4gcGFyc2VGbG9hdCh4KSAqIDM2MFxuXHRcdFx0XHRpZiAoeC5lbmRzV2l0aCgnZ3JhZCcpKSByZXR1cm4gcGFyc2VGbG9hdCh4KSAqIDM2MCAvIDQwMFxuXHRcdFx0XHRpZiAoeC5lbmRzV2l0aCgncmFkJykpIHJldHVybiBwYXJzZUZsb2F0KHgpICogMTgwIC8gTWF0aC5QSVxuXHRcdFx0fVxuXHRcdFx0aWYgKHggPT09ICdub25lJykgcmV0dXJuIDBcblx0XHRcdHJldHVybiBwYXJzZUZsb2F0KHgpXG5cdFx0fSk7XG5cblx0XHRhbHBoYSA9IHBhcnRzLmxlbmd0aCA+IGRpbXMgPyBwYXJ0cy5wb3AoKSA6IDFcblx0fVxuXG5cdC8vbmFtZWQgY2hhbm5lbHMgY2FzZVxuXHRlbHNlIGlmICgvWzAtOV0oPzpcXHN8XFwvfCwpLy50ZXN0KGNzdHIpKSB7XG5cdFx0cGFydHMgPSBjc3RyLm1hdGNoKC8oWzAtOV0rKS9nKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSlcblx0XHR9KVxuXG5cdFx0c3BhY2UgPSBjc3RyLm1hdGNoKC8oW2Etel0pL2lnKT8uam9pbignJyk/LnRvTG93ZXJDYXNlKCkgfHwgJ3JnYidcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3BhY2UsXG5cdFx0dmFsdWVzOiBwYXJ0cyxcblx0XHRhbHBoYVxuXHR9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIGNvbG9yLXNwYWNlL2hzbFxuICovXG5pbXBvcnQgcmdiIGZyb20gJy4vcmdiLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRuYW1lOiAnaHNsJyxcblx0bWluOiBbMCwwLDBdLFxuXHRtYXg6IFszNjAsMTAwLDEwMF0sXG5cdGNoYW5uZWw6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdGFsaWFzOiBbJ0hTTCddLFxuXG5cdHJnYjogZnVuY3Rpb24oaHNsKSB7XG5cdFx0dmFyIGggPSBoc2xbMF0vMzYwLCBzID0gaHNsWzFdLzEwMCwgbCA9IGhzbFsyXS8xMDAsIHQxLCB0MiwgdDMsIHJnYiwgdmFsLCBpPTA7XG5cblx0XHRpZiAocyA9PT0gMCkgcmV0dXJuIHZhbCA9IGwgKiAyNTUsIFt2YWwsIHZhbCwgdmFsXTtcblxuXHRcdHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcblx0XHR0MSA9IDIgKiBsIC0gdDI7XG5cblx0XHRyZ2IgPSBbMCwgMCwgMF07XG5cdFx0Zm9yICg7aTwzOykge1xuXHRcdFx0dDMgPSBoICsgMSAvIDMgKiAtIChpIC0gMSk7XG5cdFx0XHR0MyA8IDAgPyB0MysrIDogdDMgPiAxICYmIHQzLS07XG5cdFx0XHR2YWwgPSA2ICogdDMgPCAxID8gdDEgKyAodDIgLSB0MSkgKiA2ICogdDMgOlxuXHRcdFx0MiAqIHQzIDwgMSA/IHQyIDpcblx0XHRcdDMgKiB0MyA8IDIgPyAgdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2IDpcblx0XHRcdHQxO1xuXHRcdFx0cmdiW2krK10gPSB2YWwgKiAyNTU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJnYjtcblx0fVxufTtcblxuXG4vL2V4dGVuZCByZ2JcbnJnYi5oc2wgPSBmdW5jdGlvbihyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0vMjU1LFxuXHRcdFx0ZyA9IHJnYlsxXS8yNTUsXG5cdFx0XHRiID0gcmdiWzJdLzI1NSxcblx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0bWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdGgsIHMsIGw7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0aCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAociA9PT0gbWF4KSB7XG5cdFx0aCA9IChnIC0gYikgLyBkZWx0YTtcblx0fVxuXHRlbHNlIGlmIChnID09PSBtYXgpIHtcblx0XHRoID0gMiArIChiIC0gcikgLyBkZWx0YTtcblx0fVxuXHRlbHNlIGlmIChiID09PSBtYXgpIHtcblx0XHRoID0gNCArIChyIC0gZykvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGwgPSAobWluICsgbWF4KSAvIDI7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0cyA9IDA7XG5cdH1cblx0ZWxzZSBpZiAobCA8PSAwLjUpIHtcblx0XHRzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcblx0fVxuXHRlbHNlIHtcblx0XHRzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdH1cblxuXHRyZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcbiIsICIvKiogQG1vZHVsZSAgY29sb3ItcmdiYSAqL1xuaW1wb3J0IHBhcnNlIGZyb20gJ2NvbG9yLXBhcnNlJ1xuaW1wb3J0IHJnYiBmcm9tICdjb2xvci1zcGFjZS9yZ2IuanMnXG5pbXBvcnQgaHNsIGZyb20gJ2NvbG9yLXNwYWNlL2hzbC5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmdiYShjb2xvcikge1xuXHQvLyB0ZW1wbGF0ZSBsaXRlcmFsc1xuXHRpZiAoQXJyYXkuaXNBcnJheShjb2xvcikgJiYgY29sb3IucmF3KSBjb2xvciA9IFN0cmluZy5yYXcoLi4uYXJndW1lbnRzKVxuXHRpZiAoY29sb3IgaW5zdGFuY2VvZiBOdW1iZXIpIGNvbG9yID0gK2NvbG9yXG5cblx0dmFyIHZhbHVlcywgaSwgbFxuXG5cdC8vYXR0ZW1wdCB0byBwYXJzZSBub24tYXJyYXkgYXJndW1lbnRzXG5cdHZhciBwYXJzZWQgPSBwYXJzZShjb2xvcilcblxuXHRpZiAoIXBhcnNlZC5zcGFjZSkgcmV0dXJuIFtdXG5cblx0Y29uc3QgbWluID0gcGFyc2VkLnNwYWNlWzBdID09PSAnaCcgPyBoc2wubWluIDogcmdiLm1pblxuXHRjb25zdCBtYXggPSBwYXJzZWQuc3BhY2VbMF0gPT09ICdoJyA/IGhzbC5tYXggOiByZ2IubWF4XG5cblx0dmFsdWVzID0gQXJyYXkoMylcblx0dmFsdWVzWzBdID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VkLnZhbHVlc1swXSwgbWluWzBdKSwgbWF4WzBdKVxuXHR2YWx1ZXNbMV0gPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZWQudmFsdWVzWzFdLCBtaW5bMV0pLCBtYXhbMV0pXG5cdHZhbHVlc1syXSA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlZC52YWx1ZXNbMl0sIG1pblsyXSksIG1heFsyXSlcblxuXHRpZiAocGFyc2VkLnNwYWNlWzBdID09PSAnaCcpIHtcblx0XHR2YWx1ZXMgPSBoc2wucmdiKHZhbHVlcylcblx0fVxuXG5cdHZhbHVlcy5wdXNoKE1hdGgubWluKE1hdGgubWF4KHBhcnNlZC5hbHBoYSwgMCksIDEpKVxuXG5cdHJldHVybiB2YWx1ZXNcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvY29sb3JcbiAqL1xuaW1wb3J0IGxjaHV2IGZyb20gJ2NvbG9yLXNwYWNlL2xjaHV2LmpzJztcbmltcG9ydCBwYXJzZVJnYmEgZnJvbSAnY29sb3ItcmdiYSc7XG5pbXBvcnQgcmdiIGZyb20gJ2NvbG9yLXNwYWNlL3JnYi5qcyc7XG5pbXBvcnQgeHl6IGZyb20gJ2NvbG9yLXNwYWNlL3h5ei5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuXG4vKipcbiAqIEEgY29sb3IgcmVwcmVzZW50ZWQgYXMgYSBzaG9ydCBhcnJheSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdLlxuICogcmVkLCBncmVlbiwgYW5kIGJsdWUgc2hvdWxkIGJlIGludGVnZXJzIGluIHRoZSByYW5nZSAwLi4yNTUgaW5jbHVzaXZlLlxuICogYWxwaGEgc2hvdWxkIGJlIGEgZmxvYXQgaW4gdGhlIHJhbmdlIDAuLjEgaW5jbHVzaXZlLiBJZiBubyBhbHBoYSB2YWx1ZSBpc1xuICogZ2l2ZW4gdGhlbiBgMWAgd2lsbCBiZSB1c2VkLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IENvbG9yXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBDb2xvciB0byBpbmRpY2F0ZSB0aGF0IG5vIGNvbG9yIHNob3VsZCBiZSByZW5kZXJlZC4gVGhpcyBpcyBtZWFudCB0byBiZSB1c2VkIGZvciBwZXItcmVmZXJlbmNlXG4gKiBjb21wYXJpc29ucyBvbmx5LlxuICogQHR5cGUge0NvbG9yfVxuICovXG5leHBvcnQgY29uc3QgTk9fQ09MT1IgPSBbTmFOLCBOYU4sIE5hTiwgMF07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb2xvciBhcyBhbiByZ2JhIHN0cmluZy5cbiAqIEBwYXJhbSB7Q29sb3J8c3RyaW5nfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmdiYSBzdHJpbmcuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc1N0cmluZyhjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICByZXR1cm4gdG9TdHJpbmcoY29sb3IpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9DQUNIRV9TSVpFID0gMTAyNDtcblxuLyoqXG4gKiBXZSBtYWludGFpbiBhIHNtYWxsIGNhY2hlIG9mIHBhcnNlZCBzdHJpbmdzLiAgV2hlbmV2ZXIgdGhlIGNhY2hlIGdyb3dzIHRvbyBsYXJnZSxcbiAqIHdlIGRlbGV0ZSBhbiBhcmJpdHJhcnkgc2V0IG9mIHRoZSBlbnRyaWVzLlxuICpcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBDb2xvcj59XG4gKi9cbmNvbnN0IGNhY2hlID0ge307XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xubGV0IGNhY2hlU2l6ZSA9IDA7XG5cbi8qKlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgQSBjb2xvciB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYW4gYWxwaGEgY2hhbm5lbC5cbiAqIEByZXR1cm4ge0NvbG9yfSBUaGUgaW5wdXQgY29sb3Igd2l0aCBhbiBhbHBoYSBjaGFubmVsLiAgSWYgdGhlIGlucHV0IGNvbG9yIGhhc1xuICogYW4gYWxwaGEgY2hhbm5lbCwgdGhlIGlucHV0IGNvbG9yIHdpbGwgYmUgcmV0dXJuZWQgdW5jaGFuZ2VkLiAgT3RoZXJ3aXNlLCBhIG5ld1xuICogYXJyYXkgd2lsbCBiZSByZXR1cm5lZCB3aXRoIHRoZSBpbnB1dCBjb2xvciBhbmQgYW4gYWxwaGEgY2hhbm5lbCBvZiAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aEFscGhhKGNvbG9yKSB7XG4gIGlmIChjb2xvci5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gY29sb3Iuc2xpY2UoKTtcbiAgb3V0cHV0WzNdID0gMTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBSR0JBIGNvbG9yLlxuICogQHJldHVybiB7Q29sb3J9IExDSHV2IGNvbG9yIHdpdGggYWxwaGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JhVG9MY2hhKGNvbG9yKSB7XG4gIGNvbnN0IG91dHB1dCA9IHh5ei5sY2h1dihyZ2IueHl6KGNvbG9yKSk7XG4gIG91dHB1dFszXSA9IGNvbG9yWzNdO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIExDSHV2IGNvbG9yIHdpdGggYWxwaGEuXG4gKiBAcmV0dXJuIHtDb2xvcn0gUkdCQSBjb2xvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxjaGFUb1JnYmEoY29sb3IpIHtcbiAgY29uc3Qgb3V0cHV0ID0geHl6LnJnYihsY2h1di54eXooY29sb3IpKTtcbiAgb3V0cHV0WzNdID0gY29sb3JbM107XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyhzKSB7XG4gIGlmIChzID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gTk9fQ09MT1I7XG4gIH1cbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgcmV0dXJuIGNhY2hlW3NdO1xuICB9XG4gIGlmIChjYWNoZVNpemUgPj0gTUFYX0NBQ0hFX1NJWkUpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2FjaGUpIHtcbiAgICAgIGlmICgoaSsrICYgMykgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICAgIC0tY2FjaGVTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbG9yID0gcGFyc2VSZ2JhKHMpO1xuICBpZiAoY29sb3IubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcGFyc2UgXCInICsgcyArICdcIiBhcyBjb2xvcicpO1xuICB9XG4gIGZvciAoY29uc3QgYyBvZiBjb2xvcikge1xuICAgIGlmIChpc05hTihjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcGFyc2UgXCInICsgcyArICdcIiBhcyBjb2xvcicpO1xuICAgIH1cbiAgfVxuICBub3JtYWxpemUoY29sb3IpO1xuICBjYWNoZVtzXSA9IGNvbG9yO1xuICArK2NhY2hlU2l6ZTtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gYXJyYXkuIFRoaXMgZnVuY3Rpb24gbWFpbnRhaW5zIGEgY2FjaGUgb2YgY2FsY3VsYXRlZFxuICogYXJyYXlzIHdoaWNoIG1lYW5zIHRoZSByZXN1bHQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7Q29sb3J8c3RyaW5nfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoY29sb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKGNvbG9yKTtcbn1cblxuLyoqXG4gKiBFeHBvcnRlZCBmb3IgdGhlIHRlc3RzLlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtDb2xvcn0gQ2xhbXBlZCBjb2xvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShjb2xvcikge1xuICBjb2xvclswXSA9IGNsYW1wKChjb2xvclswXSArIDAuNSkgfCAwLCAwLCAyNTUpO1xuICBjb2xvclsxXSA9IGNsYW1wKChjb2xvclsxXSArIDAuNSkgfCAwLCAwLCAyNTUpO1xuICBjb2xvclsyXSA9IGNsYW1wKChjb2xvclsyXSArIDAuNSkgfCAwLCAwLCAyNTUpO1xuICBjb2xvclszXSA9IGNsYW1wKGNvbG9yWzNdLCAwLCAxKTtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhjb2xvcikge1xuICBsZXQgciA9IGNvbG9yWzBdO1xuICBpZiAociAhPSAociB8IDApKSB7XG4gICAgciA9IChyICsgMC41KSB8IDA7XG4gIH1cbiAgbGV0IGcgPSBjb2xvclsxXTtcbiAgaWYgKGcgIT0gKGcgfCAwKSkge1xuICAgIGcgPSAoZyArIDAuNSkgfCAwO1xuICB9XG4gIGxldCBiID0gY29sb3JbMl07XG4gIGlmIChiICE9IChiIHwgMCkpIHtcbiAgICBiID0gKGIgKyAwLjUpIHwgMDtcbiAgfVxuICBjb25zdCBhID0gY29sb3JbM10gPT09IHVuZGVmaW5lZCA/IDEgOiBNYXRoLnJvdW5kKGNvbG9yWzNdICogMTAwMCkgLyAxMDAwO1xuICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3RyaW5nIGlzIGFjdHVhbGx5IGEgdmFsaWQgY29sb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nQ29sb3Iocykge1xuICB0cnkge1xuICAgIGZyb21TdHJpbmcocyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvaGFzXG4gKi9cblxuY29uc3QgdWEgPVxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKVxuICAgIDogJyc7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIEZpcmVmb3ggYXMgYnJvd3Nlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgRklSRUZPWCA9IHVhLmluY2x1ZGVzKCdmaXJlZm94Jyk7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIFNhZmFyaSBhcyBicm93c2VyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBTQUZBUkkgPSB1YS5pbmNsdWRlcygnc2FmYXJpJykgJiYgIXVhLmluY2x1ZGVzKCdjaHJvbScpO1xuXG4vKipcbiAqIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMzc5MDZcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgU0FGQVJJX0JVR18yMzc5MDYgPVxuICBTQUZBUkkgJiZcbiAgKHVhLmluY2x1ZGVzKCd2ZXJzaW9uLzE1LjQnKSB8fFxuICAgIC9jcHUgKG9zfGlwaG9uZSBvcykgMTVfNCBsaWtlIG1hYyBvcyB4Ly50ZXN0KHVhKSk7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgV2ViS2l0IGVuZ2luZS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgV0VCS0lUID0gdWEuaW5jbHVkZXMoJ3dlYmtpdCcpICYmICF1YS5pbmNsdWRlcygnZWRnZScpO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIE1hYyBhcyBwbGF0Zm9ybS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgTUFDID0gdWEuaW5jbHVkZXMoJ21hY2ludG9zaCcpO1xuXG4vKipcbiAqIFRoZSByYXRpbyBiZXR3ZWVuIHBoeXNpY2FsIHBpeGVscyBhbmQgZGV2aWNlLWluZGVwZW5kZW50IHBpeGVsc1xuICogKGRpcHMpIG9uIHRoZSBkZXZpY2UgKGB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb2ApLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgREVWSUNFX1BJWEVMX1JBVElPID1cbiAgdHlwZW9mIGRldmljZVBpeGVsUmF0aW8gIT09ICd1bmRlZmluZWQnID8gZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG5cbi8qKlxuICogVGhlIGV4ZWN1dGlvbiBjb250ZXh0IGlzIGEgd29ya2VyIHdpdGggT2Zmc2NyZWVuQ2FudmFzIGF2YWlsYWJsZS5cbiAqIEBjb25zdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBXT1JLRVJfT0ZGU0NSRUVOX0NBTlZBUyA9XG4gIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlOyAvL2VzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBJbWFnZS5wcm90b3R5cGUuZGVjb2RlKCkgaXMgc3VwcG9ydGVkLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBJTUFHRV9ERUNPREUgPVxuICB0eXBlb2YgSW1hZ2UgIT09ICd1bmRlZmluZWQnICYmIEltYWdlLnByb3RvdHlwZS5kZWNvZGU7XG5cbi8qKlxuICogY3JlYXRlSW1hZ2VCaXRtYXAoKSBpcyBzdXBwb3J0ZWQuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IENSRUFURV9JTUFHRV9CSVRNQVAgPSB0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBQQVNTSVZFX0VWRU5UX0xJU1RFTkVSUyA9IChmdW5jdGlvbiAoKSB7XG4gIGxldCBwYXNzaXZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZSA9IHRydWU7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gQHRzLWlnbm9yZSBJZ25vcmUgaW52YWxpZCBldmVudCB0eXBlICdfJ1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdfJywgbnVsbCwgb3B0aW9ucyk7XG4gICAgLy8gQHRzLWlnbm9yZSBJZ25vcmUgaW52YWxpZCBldmVudCB0eXBlICdfJ1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdfJywgbnVsbCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gcGFzc2l2ZSBub3Qgc3VwcG9ydGVkXG4gIH1cbiAgcmV0dXJuIHBhc3NpdmU7XG59KSgpO1xuIiwgImltcG9ydCB7V09SS0VSX09GRlNDUkVFTl9DQU5WQVN9IGZyb20gJy4vaGFzLmpzJztcblxuLyoqXG4gKiBAbW9kdWxlIG9sL2RvbVxuICovXG5cbi8vRklYTUUgTW92ZSB0aGlzIGZ1bmN0aW9uIHRvIHRoZSBjYW52YXMgbW9kdWxlXG4vKipcbiAqIENyZWF0ZSBhbiBodG1sIGNhbnZhcyBlbGVtZW50IGFuZCByZXR1cm5zIGl0cyAyZCBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gQ2FudmFzIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIENhbnZhcyBoZWlnaHQuXG4gKiBAcGFyYW0ge0FycmF5PEhUTUxDYW52YXNFbGVtZW50Pn0gW2NhbnZhc1Bvb2xdIENhbnZhcyBwb29sIHRvIHRha2UgZXhpc3RpbmcgY2FudmFzIGZyb20uXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFNldHRpbmdzfSBbc2V0dGluZ3NdIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFNldHRpbmdzXG4gKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQsIGNhbnZhc1Bvb2wsIHNldHRpbmdzKSB7XG4gIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzfSAqL1xuICBsZXQgY2FudmFzO1xuICBpZiAoY2FudmFzUG9vbCAmJiBjYW52YXNQb29sLmxlbmd0aCkge1xuICAgIGNhbnZhcyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChjYW52YXNQb29sLnNoaWZ0KCkpO1xuICB9IGVsc2UgaWYgKFdPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTKSB7XG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCB8fCAzMDAsIGhlaWdodCB8fCAzMDApO1xuICB9IGVsc2Uge1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB9XG4gIGlmICh3aWR0aCkge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICB9XG4gIGlmIChoZWlnaHQpIHtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIC8vRklYTUUgQWxsb3cgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGFzIHJldHVybiB0eXBlXG4gIHJldHVybiAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi8gKFxuICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHNldHRpbmdzKVxuICApO1xufVxuXG4vKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi9cbmxldCBzaGFyZWRDYW52YXNDb250ZXh0O1xuXG4vKipcbiAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gU2hhcmVkIGNhbnZhcyBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkQ2FudmFzQ29udGV4dDJEKCkge1xuICBpZiAoIXNoYXJlZENhbnZhc0NvbnRleHQpIHtcbiAgICBzaGFyZWRDYW52YXNDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICB9XG4gIHJldHVybiBzaGFyZWRDYW52YXNDb250ZXh0O1xufVxuXG4vKipcbiAqIFJlbGVhc2VzIGNhbnZhcyBtZW1vcnkgdG8gYXZvaWQgZXhjZWVkaW5nIG1lbW9yeSBsaW1pdHMgaW4gU2FmYXJpLlxuICogU2VlIGh0dHBzOi8vcHFpbmEubmwvYmxvZy90b3RhbC1jYW52YXMtbWVtb3J5LXVzZS1leGNlZWRzLXRoZS1tYXhpbXVtLWxpbWl0L1xuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VDYW52YXMoY29udGV4dCkge1xuICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgY2FudmFzLndpZHRoID0gMTtcbiAgY2FudmFzLmhlaWdodCA9IDE7XG4gIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDEsIDEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBjb21wdXRlZCB3aWR0aCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVyV2lkdGgodHJ1ZSlgLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3V0ZXJXaWR0aChlbGVtZW50KSB7XG4gIGxldCB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgd2lkdGggKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCwgMTApICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQsIDEwKTtcblxuICByZXR1cm4gd2lkdGg7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIGhlaWdodCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVySGVpZ2h0KHRydWUpYC5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckhlaWdodChlbGVtZW50KSB7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBoZWlnaHQgKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20sIDEwKTtcblxuICByZXR1cm4gaGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBOb2RlIHRvIHJlcGxhY2Ugb2xkIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gb2xkTm9kZSBUaGUgbm9kZSB0byBiZSByZXBsYWNlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGUobmV3Tm9kZSwgb2xkTm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBvbGROb2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZSB0aGUgY2hpbGRyZW4gZnJvbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5sYXN0Q2hpbGQucmVtb3ZlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGNoaWxkcmVuIG9mIGEgcGFyZW50IG5vZGUgc28gdGhleSBtYXRjaCB0aGVcbiAqIHByb3ZpZGVkIGxpc3Qgb2YgY2hpbGRyZW4uICBUaGlzIGZ1bmN0aW9uIGFpbXMgdG8gZWZmaWNpZW50bHlcbiAqIHJlbW92ZSwgYWRkLCBhbmQgcmVvcmRlciBjaGlsZCBub2RlcyB3aGlsZSBtYWludGFpbmluZyBhIHNpbXBsZVxuICogaW1wbGVtZW50YXRpb24gKGl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIG1pbmltaXplIERPTSBvcGVyYXRpb25zKS5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgcGFyZW50IG5vZGUgd2hvc2UgY2hpbGRyZW4gbmVlZCByZXdvcmtpbmcuXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBjaGlsZHJlbiBUaGUgZGVzaXJlZCBjaGlsZHJlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZHJlbihub2RlLCBjaGlsZHJlbikge1xuICBjb25zdCBvbGRDaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcblxuICBmb3IgKGxldCBpID0gMDsgdHJ1ZTsgKytpKSB7XG4gICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRDaGlsZHJlbltpXTtcbiAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgLy8gY2hlY2sgaWYgb3VyIHdvcmsgaXMgZG9uZVxuICAgIGlmICghb2xkQ2hpbGQgJiYgIW5ld0NoaWxkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBjaGlsZHJlbiBtYXRjaFxuICAgIGlmIChvbGRDaGlsZCA9PT0gbmV3Q2hpbGQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGEgbmV3IGNoaWxkIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgaWYgKCFvbGRDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbiBvbGQgY2hpbGQgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgIGlmICghbmV3Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQob2xkQ2hpbGQpO1xuICAgICAgLS1pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVvcmRlclxuICAgIG5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VcbiAqL1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtDUkVBVEVfSU1BR0VfQklUTUFQLCBJTUFHRV9ERUNPREV9IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCB7bGlzdGVuT25jZSwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IHt0b1Byb21pc2V9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9JbWFnZX5JbWFnZVdyYXBwZXJ9IGZvciB0aGUgaW1hZ2UgYW5kIGFcbiAqIGB7c3RyaW5nfWAgZm9yIHRoZSBzcmMgYXMgYXJndW1lbnRzLiBJdCBpcyBzdXBwb3NlZCB0byBtYWtlIGl0IHNvIHRoZVxuICogdW5kZXJseWluZyBpbWFnZSB7QGxpbmsgbW9kdWxlOm9sL0ltYWdlfkltYWdlV3JhcHBlciNnZXRJbWFnZX0gaXMgYXNzaWduZWQgdGhlXG4gKiBjb250ZW50IHNwZWNpZmllZCBieSB0aGUgc3JjLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBpc1xuICpcbiAqICAgICBmdW5jdGlvbihpbWFnZSwgc3JjKSB7XG4gKiAgICAgICBpbWFnZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqICAgICB9XG4gKlxuICogUHJvdmlkaW5nIGEgY3VzdG9tIGBpbWFnZUxvYWRGdW5jdGlvbmAgY2FuIGJlIHVzZWZ1bCB0byBsb2FkIGltYWdlcyB3aXRoXG4gKiBwb3N0IHJlcXVlc3RzIG9yIC0gaW4gZ2VuZXJhbCAtIHRocm91Z2ggWEhSIHJlcXVlc3RzLCB3aGVyZSB0aGUgc3JjIG9mIHRoZVxuICogaW1hZ2UgZWxlbWVudCB3b3VsZCBiZSBzZXQgdG8gYSBkYXRhIFVSSSB3aGVuIHRoZSBjb250ZW50IGlzIGxvYWRlZC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0LCBzdHJpbmcpOiB2b2lkfSBMb2FkRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEltYWdlT2JqZWN0XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50LCBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgcmVxdWVzdGVkIG9uZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9yZXNvbHV0aW9uLmpzXCIpLlJlc29sdXRpb25MaWtlfSBbcmVzb2x1dGlvbl0gUmVzb2x1dGlvbiwgaWYgZGlmZmVyZW50IGZyb20gdGhlIHJlcXVlc3RlZCBvbmUuXG4gKiBXaGVuIHggYW5kIHkgcmVzb2x1dGlvbiBhcmUgZGlmZmVyZW50LCB1c2UgdGhlIGFycmF5IHR5cGUgKGBbeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uXWApLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbFJhdGlvXSBQaXhlbCByYXRpbywgaWYgZGlmZmVyZW50IGZyb20gdGhlIHJlcXVlc3RlZCBvbmUuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gaW1hZ2UgSW1hZ2UuXG4gKi9cblxuLyoqXG4gKiBMb2FkZXIgZnVuY3Rpb24gdXNlZCBmb3IgaW1hZ2Ugc291cmNlcy4gUmVjZWl2ZXMgZXh0ZW50LCByZXNvbHV0aW9uIGFuZCBwaXhlbCByYXRpbyBhcyBhcmd1bWVudHMuXG4gKiBGb3IgaW1hZ2VzIHRoYXQgY292ZXIgYW55IGV4dGVudCBhbmQgcmVzb2x1dGlvbiAoc3RhdGljIGltYWdlcyksIHRoZSBsb2FkZXIgZnVuY3Rpb24gc2hvdWxkIG5vdCBhY2NlcHRcbiAqIGFueSBhcmd1bWVudHMuIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFuIHtAbGluayBpbXBvcnQoXCIuL0RhdGFUaWxlLmpzXCIpLkltYWdlTGlrZSBpbWFnZX0sIGFuXG4gKiB7QGxpbmsgaW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5JbWFnZU9iamVjdCBpbWFnZSBvYmplY3R9LCBvciBhIHByb21pc2UgZm9yIHRoZSBzYW1lLlxuICogRm9yIGxvYWRlcnMgdGhhdCBnZW5lcmF0ZSBpbWFnZXMsIHRoZSBwcm9taXNlIHNob3VsZCBub3QgcmVzb2x2ZSB1bnRpbCB0aGUgaW1hZ2UgaXMgbG9hZGVkLlxuICogSWYgdGhlIHJldHVybmVkIGltYWdlIGRvZXMgbm90IG1hdGNoIHRoZSBleHRlbnQsIHJlc29sdXRpb24gb3IgcGl4ZWwgcmF0aW8gcGFzc2VkIHRvIHRoZSBsb2FkZXIsXG4gKiBpdCBoYXMgdG8gcmV0dXJuIGFuIHtAbGluayBpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLkltYWdlT2JqZWN0IGltYWdlIG9iamVjdH0gd2l0aCB0aGUgYGltYWdlYCBhbmQgdGhlXG4gKiBjb3JyZWN0IGBleHRlbnRgLCBgcmVzb2x1dGlvbmAgYW5kIGBwaXhlbFJhdGlvYC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LCBudW1iZXIsIG51bWJlciwgKGZ1bmN0aW9uKEhUTUxJbWFnZUVsZW1lbnQsIHN0cmluZyk6IHZvaWQpPSk6IGltcG9ydChcIi4vRGF0YVRpbGUuanNcIikuSW1hZ2VMaWtlfEltYWdlT2JqZWN0fFByb21pc2U8aW1wb3J0KFwiLi9EYXRhVGlsZS5qc1wiKS5JbWFnZUxpa2V8SW1hZ2VPYmplY3Q+fSBMb2FkZXJcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIExvYWRlciBmdW5jdGlvbiB1c2VkIGZvciBpbWFnZSBzb3VyY2VzLiBSZWNlaXZlcyBleHRlbnQsIHJlc29sdXRpb24gYW5kIHBpeGVsIHJhdGlvIGFzIGFyZ3VtZW50cy5cbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gIHtAbGluayBpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLkltYWdlT2JqZWN0IGltYWdlIG9iamVjdH0uXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyLCBudW1iZXIsIChmdW5jdGlvbihIVE1MSW1hZ2VFbGVtZW50LCBzdHJpbmcpOiB2b2lkKT0pOiBpbXBvcnQoXCIuL0RhdGFUaWxlLmpzXCIpLkltYWdlTGlrZXxJbWFnZU9iamVjdHxQcm9taXNlPGltcG9ydChcIi4vRGF0YVRpbGUuanNcIikuSW1hZ2VMaWtlfEltYWdlT2JqZWN0Pn0gSW1hZ2VPYmplY3RQcm9taXNlTG9hZGVyXG4gKi9cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5PG51bWJlcj58dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uIElmIHByb3ZpZGVkIGFzIGFycmF5LCB4IGFuZCB5XG4gICAqIHJlc29sdXRpb24gd2lsbCBiZSBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLkxvYWRlcn0gc3RhdGVPckxvYWRlciBTdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgc3RhdGVPckxvYWRlcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfEFycmF5PG51bWJlcj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGUgPVxuICAgICAgdHlwZW9mIHN0YXRlT3JMb2FkZXIgPT09ICdmdW5jdGlvbicgPyBJbWFnZVN0YXRlLklETEUgOiBzdGF0ZU9yTG9hZGVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLkxvYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlciA9IHR5cGVvZiBzdGF0ZU9yTG9hZGVyID09PSAnZnVuY3Rpb24nID8gc3RhdGVPckxvYWRlciA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY2hhbmdlZCgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gSW1hZ2UuXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBQaXhlbFJhdGlvLlxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gdGhpcy5waXhlbFJhdGlvXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8QXJyYXk8bnVtYmVyPn0gUmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5yZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gU3RhdGUuXG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuTE9BRElORztcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFJlc29sdXRpb24gPSBBcnJheS5pc0FycmF5KHJlc29sdXRpb24pXG4gICAgICAgICAgPyByZXNvbHV0aW9uWzBdXG4gICAgICAgICAgOiByZXNvbHV0aW9uO1xuICAgICAgICB0b1Byb21pc2UoKCkgPT5cbiAgICAgICAgICB0aGlzLmxvYWRlcihcbiAgICAgICAgICAgIHRoaXMuZ2V0RXh0ZW50KCksXG4gICAgICAgICAgICByZXF1ZXN0UmVzb2x1dGlvbixcbiAgICAgICAgICAgIHRoaXMuZ2V0UGl4ZWxSYXRpbygpLFxuICAgICAgICAgICksXG4gICAgICAgIClcbiAgICAgICAgICAudGhlbigoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgIGlmICgnaW1hZ2UnIGluIGltYWdlKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2UuaW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2V4dGVudCcgaW4gaW1hZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5leHRlbnQgPSBpbWFnZS5leHRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3Jlc29sdXRpb24nIGluIGltYWdlKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGltYWdlLnJlc29sdXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3BpeGVsUmF0aW8nIGluIGltYWdlKSB7XG4gICAgICAgICAgICAgIHRoaXMucGl4ZWxSYXRpb18gPSBpbWFnZS5waXhlbFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCB8fFxuICAgICAgICAgICAgICBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8XG4gICAgICAgICAgICAgIGltYWdlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gSW1hZ2VTdGF0ZS5FUlJPUjtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMuY2hhbmdlZCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIFRoZSBpbWFnZS5cbiAgICovXG4gIHNldEltYWdlKGltYWdlKSB7XG4gICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcnxBcnJheTxudW1iZXI+fSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIEltYWdlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6YW55fSBsb2FkSGFuZGxlciBMb2FkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbigpOmFueX0gZXJyb3JIYW5kbGVyIEVycm9yIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKTp2b2lkfSBDYWxsYmFjayB0byBzdG9wIGxpc3RlbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkltYWdlKGltYWdlLCBsb2FkSGFuZGxlciwgZXJyb3JIYW5kbGVyKSB7XG4gIGNvbnN0IGltZyA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKGltYWdlKTtcbiAgbGV0IGxpc3RlbmluZyA9IHRydWU7XG4gIGxldCBkZWNvZGluZyA9IGZhbHNlO1xuICBsZXQgbG9hZGVkID0gZmFsc2U7XG5cbiAgY29uc3QgbGlzdGVuZXJLZXlzID0gW1xuICAgIGxpc3Rlbk9uY2UoaW1nLCBFdmVudFR5cGUuTE9BRCwgZnVuY3Rpb24gKCkge1xuICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgIGlmICghZGVjb2RpbmcpIHtcbiAgICAgICAgbG9hZEhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgXTtcblxuICBpZiAoaW1nLnNyYyAmJiBJTUFHRV9ERUNPREUpIHtcbiAgICBkZWNvZGluZyA9IHRydWU7XG4gICAgaW1nXG4gICAgICAuZGVjb2RlKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgICAgIGxvYWRIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgICAgICBsb2FkSGFuZGxlcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGxpc3RlbmVyS2V5cy5wdXNoKGxpc3Rlbk9uY2UoaW1nLCBFdmVudFR5cGUuRVJST1IsIGVycm9ySGFuZGxlcikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVubGlzdGVuKCkge1xuICAgIGxpc3RlbmluZyA9IGZhbHNlO1xuICAgIGxpc3RlbmVyS2V5cy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICB9O1xufVxuXG4vKipcbiAqIExvYWRzIGFuIGltYWdlLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSBJbWFnZSwgbm90IHlldCBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gYHNyY2AgYXR0cmlidXRlIG9mIHRoZSBpbWFnZS4gT3B0aW9uYWwsIG5vdCByZXF1aXJlZCBpZiBhbHJlYWR5IHByZXNlbnQuXG4gKiBAcmV0dXJuIHtQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQ+fSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBgSFRNTEltYWdlRWxlbWVudGAuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkKGltYWdlLCBzcmMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICAgIHJlc29sdmUoaW1hZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdJbWFnZSBsb2FkIGVycm9yJykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmxpc3RlbigpIHtcbiAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVMb2FkKTtcbiAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgIH1cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaGFuZGxlTG9hZCk7XG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgaWYgKHNyYykge1xuICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSBJbWFnZSwgbm90IHlldCBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gYHNyY2AgYXR0cmlidXRlIG9mIHRoZSBpbWFnZS4gT3B0aW9uYWwsIG5vdCByZXF1aXJlZCBpZiBhbHJlYWR5IHByZXNlbnQuXG4gKiBAcmV0dXJuIHtQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQ+fSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBgSFRNTEltYWdlRWxlbWVudGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGYWxsYmFjayhpbWFnZSwgc3JjKSB7XG4gIGlmIChzcmMpIHtcbiAgICBpbWFnZS5zcmMgPSBzcmM7XG4gIH1cbiAgcmV0dXJuIGltYWdlLnNyYyAmJiBJTUFHRV9ERUNPREVcbiAgICA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIGltYWdlXG4gICAgICAgICAgLmRlY29kZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gcmVzb2x2ZShpbWFnZSkpXG4gICAgICAgICAgLmNhdGNoKChlKSA9PlxuICAgICAgICAgICAgaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2Uud2lkdGggPyByZXNvbHZlKGltYWdlKSA6IHJlamVjdChlKSxcbiAgICAgICAgICApLFxuICAgICAgKVxuICAgIDogbG9hZChpbWFnZSk7XG59XG5cbi8qKlxuICogTG9hZHMgYW4gaW1hZ2UgYW5kIGRlY29kZXMgaXQgdG8gYW4gYEltYWdlQml0bWFwYCBpZiBgY3JlYXRlSW1hZ2VCaXRtYXAoKWAgaXMgc3VwcG9ydGVkLiBSZXR1cm5zXG4gKiB0aGUgbG9hZGVkIGltYWdlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgSW1hZ2UsIG5vdCB5ZXQgbG9hZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdIGBzcmNgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UuIE9wdGlvbmFsLCBub3QgcmVxdWlyZWQgaWYgYWxyZWFkeSBwcmVzZW50LlxuICogQHJldHVybiB7UHJvbWlzZTxJbWFnZUJpdG1hcHxIVE1MSW1hZ2VFbGVtZW50Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYEltYWdlQml0bWFwYCBvciBhblxuICogYEhUTUxJbWFnZUVsZW1lbnRgIGlmIGBjcmVhdGVJbWFnZUJpdG1hcCgpYCBpcyBub3Qgc3VwcG9ydGVkLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGltYWdlLCBzcmMpIHtcbiAgaWYgKHNyYykge1xuICAgIGltYWdlLnNyYyA9IHNyYztcbiAgfVxuICByZXR1cm4gaW1hZ2Uuc3JjICYmIElNQUdFX0RFQ09ERSAmJiBDUkVBVEVfSU1BR0VfQklUTUFQXG4gICAgPyBpbWFnZVxuICAgICAgICAuZGVjb2RlKClcbiAgICAgICAgLnRoZW4oKCkgPT4gY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UpKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSlcbiAgICA6IGRlY29kZUZhbGxiYWNrKGltYWdlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZVxuICovXG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCB7YXNBcnJheX0gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHtnZXRTaGFyZWRDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2luZ2xldG9uIGNsYXNzLiBBdmFpbGFibGUgdGhyb3VnaCB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25JbWFnZUNhY2hlLnNoYXJlZH0uXG4gKi9cbmNsYXNzIEljb25JbWFnZUNhY2hlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2FjaGVfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIENhbnZhc1BhdHRlcm4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wYXR0ZXJuQ2FjaGVfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYWNoZVNpemVfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1heENhY2hlU2l6ZV8gPSAzMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2FjaGVfID0ge307XG4gICAgdGhpcy5wYXR0ZXJuQ2FjaGVfID0ge307XG4gICAgdGhpcy5jYWNoZVNpemVfID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDYW4gZXhwaXJlIGNhY2hlLlxuICAgKi9cbiAgY2FuRXhwaXJlQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVTaXplXyA+IHRoaXMubWF4Q2FjaGVTaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIGV4cGlyZSgpIHtcbiAgICBpZiAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNhY2hlXykge1xuICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSB0aGlzLmNhY2hlX1trZXldO1xuICAgICAgICBpZiAoKGkrKyAmIDMpID09PSAwICYmICFpY29uSW1hZ2UuaGFzTGlzdGVuZXIoKSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlX1trZXldO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhdHRlcm5DYWNoZV9ba2V5XTtcbiAgICAgICAgICAtLXRoaXMuY2FjaGVTaXplXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfG51bGx9IGNvbG9yIENvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBJY29uIGltYWdlLlxuICAgKi9cbiAgZ2V0KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0Q2FjaGVLZXkoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICAgIHJldHVybiBrZXkgaW4gdGhpcy5jYWNoZV8gPyB0aGlzLmNhY2hlX1trZXldIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfG51bGx9IGNvbG9yIENvbG9yLlxuICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufSBJY29uIGltYWdlLlxuICAgKi9cbiAgZ2V0UGF0dGVybihzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGdldENhY2hlS2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMucGF0dGVybkNhY2hlXyA/IHRoaXMucGF0dGVybkNhY2hlX1trZXldIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfG51bGx9IGNvbG9yIENvbG9yLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR8bnVsbH0gaWNvbkltYWdlIEljb24gaW1hZ2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhdHRlcm5dIEFsc28gY2FjaGUgYSBgJ3JlcGVhdCdgIHBhdHRlcm4gd2l0aCB0aGlzIGBpY29uSW1hZ2VgLlxuICAgKi9cbiAgc2V0KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yLCBpY29uSW1hZ2UsIHBhdHRlcm4pIHtcbiAgICBjb25zdCBrZXkgPSBnZXRDYWNoZUtleShzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gICAgY29uc3QgdXBkYXRlID0ga2V5IGluIHRoaXMuY2FjaGVfO1xuICAgIHRoaXMuY2FjaGVfW2tleV0gPSBpY29uSW1hZ2U7XG4gICAgaWYgKHBhdHRlcm4pIHtcbiAgICAgIGlmIChpY29uSW1hZ2UuZ2V0SW1hZ2VTdGF0ZSgpID09PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgICAgaWNvbkltYWdlLmxvYWQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpY29uSW1hZ2UuZ2V0SW1hZ2VTdGF0ZSgpID09PSBJbWFnZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgaWNvbkltYWdlLnJlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wYXR0ZXJuQ2FjaGVfW2tleV0gPSBnZXRTaGFyZWRDYW52YXNDb250ZXh0MkQoKS5jcmVhdGVQYXR0ZXJuKFxuICAgICAgICAgICAgaWNvbkltYWdlLmdldEltYWdlKDEpLFxuICAgICAgICAgICAgJ3JlcGVhdCcsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdHRlcm5DYWNoZV9ba2V5XSA9IGdldFNoYXJlZENhbnZhc0NvbnRleHQyRCgpLmNyZWF0ZVBhdHRlcm4oXG4gICAgICAgICAgaWNvbkltYWdlLmdldEltYWdlKDEpLFxuICAgICAgICAgICdyZXBlYXQnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXVwZGF0ZSkge1xuICAgICAgKyt0aGlzLmNhY2hlU2l6ZV87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FjaGUgc2l6ZSBvZiB0aGUgaWNvbiBjYWNoZS4gRGVmYXVsdCBpcyBgMzJgLiBDaGFuZ2UgdGhpcyB2YWx1ZSB3aGVuXG4gICAqIHlvdXIgbWFwIHVzZXMgbW9yZSB0aGFuIDMyIGRpZmZlcmVudCBpY29uIGltYWdlcyBhbmQgeW91IGFyZSBub3QgY2FjaGluZyBpY29uXG4gICAqIHN0eWxlcyBvbiB0aGUgYXBwbGljYXRpb24gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDYWNoZVNpemUgQ2FjaGUgbWF4IHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNpemUobWF4Q2FjaGVTaXplKSB7XG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gbWF4Q2FjaGVTaXplO1xuICAgIHRoaXMuZXhwaXJlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxzdHJpbmd8bnVsbH0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENhY2hlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlS2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gIGNvbnN0IGNvbG9yU3RyaW5nID0gY29sb3IgPyBhc0FycmF5KGNvbG9yKSA6ICdudWxsJztcbiAgcmV0dXJuIGNyb3NzT3JpZ2luICsgJzonICsgc3JjICsgJzonICsgY29sb3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEljb25JbWFnZUNhY2hlO1xuXG4vKipcbiAqIFRoZSB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25JbWFnZUNhY2hlfkljb25JbWFnZUNhY2hlfSBmb3JcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbn5JY29ufSBpbWFnZXMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBzaGFyZWQgPSBuZXcgSWNvbkltYWdlQ2FjaGUoKTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvbkltYWdlXG4gKi9cblxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2RlY29kZUZhbGxiYWNrfSBmcm9tICcuLi9JbWFnZS5qcyc7XG5pbXBvcnQge3NoYXJlZCBhcyBpY29uSW1hZ2VDYWNoZX0gZnJvbSAnLi9JY29uSW1hZ2VDYWNoZS5qcyc7XG5cbi8qKlxuICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xubGV0IHRhaW50ZWRUZXN0Q29udGV4dCA9IG51bGw7XG5cbmNsYXNzIEljb25JbWFnZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcHxudWxsfSBpbWFnZSBJbWFnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzcmMgU3JjLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBpbWFnZVN0YXRlIEltYWdlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfSBjb2xvciBDb2xvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGltYWdlLCBzcmMsIGNyb3NzT3JpZ2luLCBpbWFnZVN0YXRlLCBjb2xvcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbl8gPSBjcm9zc09yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxudW1iZXIsIEhUTUxDYW52YXNFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29sb3JfID0gY29sb3I7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVN0YXRlXyA9IGltYWdlU3RhdGUgPT09IHVuZGVmaW5lZCA/IEltYWdlU3RhdGUuSURMRSA6IGltYWdlU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnNpemVfID1cbiAgICAgIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodCA/IFtpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0XSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc3JjXyA9IHNyYztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50YWludGVkXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1Byb21pc2U8dm9pZD58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWR5XyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemVJbWFnZV8oKSB7XG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBpbWFnZSBjYW52YXMgaXMgdGFpbnRlZC5cbiAgICovXG4gIGlzVGFpbnRlZF8oKSB7XG4gICAgaWYgKHRoaXMudGFpbnRlZF8gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmltYWdlU3RhdGVfID09PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgaWYgKCF0YWludGVkVGVzdENvbnRleHQpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEsIHVuZGVmaW5lZCwge1xuICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0YWludGVkVGVzdENvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2VfLCAwLCAwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhaW50ZWRUZXN0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgIHRoaXMudGFpbnRlZF8gPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWludGVkXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhaW50ZWRfID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZUV2ZW50XygpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBJbWFnZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMuZGlzcGF0Y2hDaGFuZ2VFdmVudF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VMb2FkXygpIHtcbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gICAgdGhpcy5zaXplXyA9IFt0aGlzLmltYWdlXy53aWR0aCwgdGhpcy5pbWFnZV8uaGVpZ2h0XTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlRXZlbnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IEltYWdlIG9yIENhbnZhcyBlbGVtZW50IG9yIGltYWdlIGJpdG1hcC5cbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG4gICAgdGhpcy5yZXBsYWNlQ29sb3JfKHBpeGVsUmF0aW8pO1xuICAgIHJldHVybiB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPyB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gOiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHRoaXMucmVwbGFjZUNvbG9yXyhwaXhlbFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dID8gcGl4ZWxSYXRpbyA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VTdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUltYWdlXygpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfKSB7XG4gICAgICBpZiAodGhpcy5pc1RhaW50ZWRfKCkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemVfWzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSB0aGlzLmltYWdlXztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBJbWFnZSBzcmMuXG4gICAqL1xuICBnZXRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JjXztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VTdGF0ZV8gIT09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zcmNfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAodGhpcy5pbWFnZV8pLnNyYyA9IHRoaXMuc3JjXztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlXyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGRlY29kZUZhbGxiYWNrKHRoaXMuaW1hZ2VfLCB0aGlzLnNyY18pXG4gICAgICAgIC50aGVuKChpbWFnZSkgPT4ge1xuICAgICAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gICAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUltYWdlRXJyb3JfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGxhY2VDb2xvcl8ocGl4ZWxSYXRpbykge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmNvbG9yXyB8fFxuICAgICAgdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dIHx8XG4gICAgICB0aGlzLmltYWdlU3RhdGVfICE9PSBJbWFnZVN0YXRlLkxPQURFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZV87XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgTWF0aC5jZWlsKGltYWdlLndpZHRoICogcGl4ZWxSYXRpbyksXG4gICAgICBNYXRoLmNlaWwoaW1hZ2UuaGVpZ2h0ICogcGl4ZWxSYXRpbyksXG4gICAgKTtcbiAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuXG4gICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGFzU3RyaW5nKHRoaXMuY29sb3JfKTtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbywgY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW8pO1xuXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG5cbiAgICB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPSBjYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGltYWdlIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWR5KCkge1xuICAgIGlmICghdGhpcy5yZWFkeV8pIHtcbiAgICAgIHRoaXMucmVhZHlfID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPT09IEltYWdlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgdGhpcy5pbWFnZVN0YXRlXyA9PT0gSW1hZ2VTdGF0ZS5FUlJPUlxuICAgICAgICApIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPT09IEltYWdlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPT09IEltYWdlU3RhdGUuRVJST1JcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgb25DaGFuZ2UpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgb25DaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZHlfO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfG51bGx9IGltYWdlIEltYWdlLlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBjYWNoZUtleSBTcmMuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gaW1hZ2VTdGF0ZSBJbWFnZSBzdGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfG51bGx9IGNvbG9yIENvbG9yLlxuICogQHBhcmFtIHtib29sZWFufSBbcGF0dGVybl0gQWxzbyBjYWNoZSBhIGByZXBlYXRgIHBhdHRlcm4gd2l0aCB0aGUgaWNvbiBpbWFnZS5cbiAqIEByZXR1cm4ge0ljb25JbWFnZX0gSWNvbiBpbWFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChpbWFnZSwgY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBpbWFnZVN0YXRlLCBjb2xvciwgcGF0dGVybikge1xuICBsZXQgaWNvbkltYWdlID1cbiAgICBjYWNoZUtleSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBpY29uSW1hZ2VDYWNoZS5nZXQoY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gIGlmICghaWNvbkltYWdlKSB7XG4gICAgaWNvbkltYWdlID0gbmV3IEljb25JbWFnZShcbiAgICAgIGltYWdlLFxuICAgICAgaW1hZ2UgJiYgJ3NyYycgaW4gaW1hZ2UgPyBpbWFnZS5zcmMgfHwgdW5kZWZpbmVkIDogY2FjaGVLZXksXG4gICAgICBjcm9zc09yaWdpbixcbiAgICAgIGltYWdlU3RhdGUsXG4gICAgICBjb2xvcixcbiAgICApO1xuICAgIGljb25JbWFnZUNhY2hlLnNldChjYWNoZUtleSwgY3Jvc3NPcmlnaW4sIGNvbG9yLCBpY29uSW1hZ2UsIHBhdHRlcm4pO1xuICB9XG4gIGlmIChcbiAgICBwYXR0ZXJuICYmXG4gICAgaWNvbkltYWdlICYmXG4gICAgIWljb25JbWFnZUNhY2hlLmdldFBhdHRlcm4oY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBjb2xvcilcbiAgKSB7XG4gICAgaWNvbkltYWdlQ2FjaGUuc2V0KGNhY2hlS2V5LCBjcm9zc09yaWdpbiwgY29sb3IsIGljb25JbWFnZSwgcGF0dGVybik7XG4gIH1cbiAgcmV0dXJuIGljb25JbWFnZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSWNvbkltYWdlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb2xvcmxpa2VcbiAqL1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRJY29uSW1hZ2V9IGZyb20gJy4vc3R5bGUvSWNvbkltYWdlLmpzJztcbmltcG9ydCB7c2hhcmVkIGFzIGljb25DYWNoZX0gZnJvbSAnLi9zdHlsZS9JY29uSW1hZ2VDYWNoZS5qcyc7XG5pbXBvcnQge3RvU3RyaW5nfSBmcm9tICcuL2NvbG9yLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXR0ZXJuRGVzY3JpcHRvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNyYyBQYXR0ZXJuIGltYWdlIFVSTFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ30gW2NvbG9yXSBDb2xvciB0byB0aW50IHRoZSBwYXR0ZXJuIHdpdGguXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gU2l6ZSBvZiB0aGUgZGVzaXJlZCBzbGljZSBmcm9tIHRoZSBwYXR0ZXJuIGltYWdlLlxuICogVXNlIHRoaXMgdG9nZXRoZXIgd2l0aCBgb2Zmc2V0YCB3aGVuIHRoZSBwYXR0ZXJuIGltYWdlIGlzIGEgc3ByaXRlIHNoZWV0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW29mZnNldF0gT2Zmc2V0IG9mIHRoZSBkZXNpcmVkIHNsaWNlIGZyb20gdGhlIHBhdHRlcm4gaW1hZ2UuXG4gKiBVc2UgdGhpcyB0b2dldGhlciB3aXRoIGBzaXplYCB3aGVuIHRoZSBwYXR0ZXJuIGltYWdlIGlzIGEgc3ByaXRlIHNoZWV0LlxuICovXG5cbi8qKlxuICogQSB0eXBlIGFjY2VwdGVkIGJ5IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5maWxsU3R5bGVcbiAqIG9yIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5zdHJva2VTdHlsZS5cbiAqIFJlcHJlc2VudHMgYSBjb2xvciwgW0NhbnZhc1BhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNQYXR0ZXJuKSxcbiAqIG9yIFtDYW52YXNHcmFkaWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc0dyYWRpZW50KS4gVGhlIG9yaWdpbiBmb3JcbiAqIHBhdHRlcm5zIGFuZCBncmFkaWVudHMgYXMgZmlsbCBzdHlsZSBpcyBhbiBpbmNyZW1lbnQgb2YgNTEyIGNzcyBwaXhlbHMgZnJvbSBtYXAgY29vcmRpbmF0ZVxuICogYFswLCAwXWAuIEZvciBzZWFtbGVzcyByZXBlYXQgcGF0dGVybnMsIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHBhdHRlcm4gaW1hZ2VcbiAqIG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xDYW52YXNQYXR0ZXJufENhbnZhc0dyYWRpZW50fSBDb2xvckxpa2VcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb2xvci5qc1wiKS5Db2xvcnxDb2xvckxpa2V8UGF0dGVybkRlc2NyaXB0b3J8bnVsbH0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtDb2xvckxpa2V8bnVsbH0gVGhlIGNvbG9yIGFzIGFuIHtAbGluayBvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQ29sb3JMaWtlKGNvbG9yKSB7XG4gIGlmICghY29sb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoY29sb3IpO1xuICB9XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnICYmICdzcmMnIGluIGNvbG9yKSB7XG4gICAgcmV0dXJuIGFzQ2FudmFzUGF0dGVybihjb2xvcik7XG4gIH1cbiAgcmV0dXJuIGNvbG9yO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UGF0dGVybkRlc2NyaXB0b3J9IHBhdHRlcm4gUGF0dGVybiBkZXNjcmlwdG9yLlxuICogQHJldHVybiB7Q2FudmFzUGF0dGVybnxudWxsfSBDYW52YXMgcGF0dGVybiBvciBudWxsIGlmIHRoZSBwYXR0ZXJuIHJlZmVyZW5jZWQgaW4gdGhlXG4gKiBQYXR0ZXJuRGVzY3JpcHRvciB3YXMgbm90IGZvdW5kIGluIHRoZSBpY29uIGltYWdlIGNhY2hlLlxuICovXG5mdW5jdGlvbiBhc0NhbnZhc1BhdHRlcm4ocGF0dGVybikge1xuICBpZiAoIXBhdHRlcm4ub2Zmc2V0IHx8ICFwYXR0ZXJuLnNpemUpIHtcbiAgICByZXR1cm4gaWNvbkNhY2hlLmdldFBhdHRlcm4ocGF0dGVybi5zcmMsICdhbm9ueW1vdXMnLCBwYXR0ZXJuLmNvbG9yKTtcbiAgfVxuXG4gIGNvbnN0IGNhY2hlS2V5ID0gcGF0dGVybi5zcmMgKyAnOicgKyBwYXR0ZXJuLm9mZnNldDtcblxuICBjb25zdCBjYW52YXNQYXR0ZXJuID0gaWNvbkNhY2hlLmdldFBhdHRlcm4oXG4gICAgY2FjaGVLZXksXG4gICAgdW5kZWZpbmVkLFxuICAgIHBhdHRlcm4uY29sb3IsXG4gICk7XG4gIGlmIChjYW52YXNQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGNhbnZhc1BhdHRlcm47XG4gIH1cblxuICBjb25zdCBpY29uSW1hZ2UgPSBpY29uQ2FjaGUuZ2V0KHBhdHRlcm4uc3JjLCAnYW5vbnltb3VzJywgbnVsbCk7XG4gIGlmIChpY29uSW1hZ2UuZ2V0SW1hZ2VTdGF0ZSgpICE9PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhdHRlcm5DYW52YXNDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgIHBhdHRlcm4uc2l6ZVswXSxcbiAgICBwYXR0ZXJuLnNpemVbMV0sXG4gICk7XG4gIHBhdHRlcm5DYW52YXNDb250ZXh0LmRyYXdJbWFnZShcbiAgICBpY29uSW1hZ2UuZ2V0SW1hZ2UoMSksXG4gICAgcGF0dGVybi5vZmZzZXRbMF0sXG4gICAgcGF0dGVybi5vZmZzZXRbMV0sXG4gICAgcGF0dGVybi5zaXplWzBdLFxuICAgIHBhdHRlcm4uc2l6ZVsxXSxcbiAgICAwLFxuICAgIDAsXG4gICAgcGF0dGVybi5zaXplWzBdLFxuICAgIHBhdHRlcm4uc2l6ZVsxXSxcbiAgKTtcbiAgZ2V0SWNvbkltYWdlKFxuICAgIHBhdHRlcm5DYW52YXNDb250ZXh0LmNhbnZhcyxcbiAgICBjYWNoZUtleSxcbiAgICB1bmRlZmluZWQsXG4gICAgSW1hZ2VTdGF0ZS5MT0FERUQsXG4gICAgcGF0dGVybi5jb2xvcixcbiAgICB0cnVlLFxuICApO1xuICByZXR1cm4gaWNvbkNhY2hlLmdldFBhdHRlcm4oY2FjaGVLZXksIHVuZGVmaW5lZCwgcGF0dGVybi5jb2xvcik7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2Nzc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRm9udFBhcmFtZXRlcnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZSBTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YXJpYW50IFZhcmlhbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gd2VpZ2h0IFdlaWdodC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaXplIFNpemUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUhlaWdodCBMaW5lSGVpZ2h0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseSBGYW1pbHkuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGZhbWlsaWVzIEZhbWlsaWVzLlxuICovXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyBmb3IgaGlkZGVuIGZlYXR1cmUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfSElEREVOID0gJ29sLWhpZGRlbic7XG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0byBoYXZlIHRoZW0gc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19TRUxFQ1RBQkxFID0gJ29sLXNlbGVjdGFibGUnO1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdG8gaGF2ZSB0aGVtIHVuc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19VTlNFTEVDVEFCTEUgPSAnb2wtdW5zZWxlY3RhYmxlJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciB1bnN1cHBvcnRlZCBmZWF0dXJlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX1VOU1VQUE9SVEVEID0gJ29sLXVuc3VwcG9ydGVkJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciBjb250cm9scy5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19DT05UUk9MID0gJ29sLWNvbnRyb2wnO1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdGhhdCBhcmUgY29sbGFwc2VkLCBpLmUuXG4gKiB0byB0aG9zZSBlbGVtZW50cyB3aGljaCB1c3VhbGx5IGNhbiBiZSBleHBhbmRlZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19DT0xMQVBTRUQgPSAnb2wtY29sbGFwc2VkJztcblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMTM1Njk3L3JlZ2V4LXRvLXBhcnNlLWFueS1jc3MtZm9udFxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgZm9udFJlZ0V4ID0gbmV3IFJlZ0V4cChcbiAgW1xuICAgICdeXFxcXHMqKD89KD86KD86Wy1hLXpdK1xcXFxzKil7MCwyfShpdGFsaWN8b2JsaXF1ZSkpPyknLFxuICAgICcoPz0oPzooPzpbLWEtel0rXFxcXHMqKXswLDJ9KHNtYWxsLWNhcHMpKT8pJyxcbiAgICAnKD89KD86KD86Wy1hLXpdK1xcXFxzKil7MCwyfShib2xkKD86ZXIpP3xsaWdodGVyfFsxLTldMDAgKSk/KScsXG4gICAgJyg/Oig/Om5vcm1hbHxcXFxcMXxcXFxcMnxcXFxcMylcXFxccyopezAsM30oKD86eHg/LSk/JyxcbiAgICAnKD86c21hbGx8bGFyZ2UpfG1lZGl1bXxzbWFsbGVyfGxhcmdlcnxbXFxcXC5cXFxcZF0rKD86XFxcXCV8aW58W2NlbV1tfGV4fHBbY3R4XSkpJyxcbiAgICAnKD86XFxcXHMqXFxcXC9cXFxccyoobm9ybWFsfFtcXFxcLlxcXFxkXSsoPzpcXFxcJXxpbnxbY2VtXW18ZXh8cFtjdHhdKT8pKScsXG4gICAgJz9cXFxccyooWy0sXFxcXFwiXFxcXFxcJ1xcXFxzYS16XSs/KVxcXFxzKiQnLFxuICBdLmpvaW4oJycpLFxuICAnaScsXG4pO1xuLyoqIEB0eXBlIHtBcnJheTwnc3R5bGUnfCd2YXJpYW50J3wnd2VpZ2h0J3wnc2l6ZSd8J2xpbmVIZWlnaHQnfCdmYW1pbHknPn0gKi9cbmNvbnN0IGZvbnRSZWdFeE1hdGNoSW5kZXggPSBbXG4gICdzdHlsZScsXG4gICd2YXJpYW50JyxcbiAgJ3dlaWdodCcsXG4gICdzaXplJyxcbiAgJ2xpbmVIZWlnaHQnLFxuICAnZmFtaWx5Jyxcbl07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIGZvbnQgZmFtaWxpZXMgZnJvbSBhIGZvbnQgc3BlYy4gIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3Qgd29ya1xuICogZm9yIGZvbnQgZmFtaWxpZXMgdGhhdCBoYXZlIGNvbW1hcyBpbiB0aGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTcGVjIFRoZSBDU1MgZm9udCBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0ZvbnRQYXJhbWV0ZXJzfG51bGx9IFRoZSBmb250IHBhcmFtZXRlcnMgKG9yIG51bGwgaWYgdGhlIGlucHV0IHNwZWMgaXMgaW52YWxpZCkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGb250UGFyYW1ldGVycyA9IGZ1bmN0aW9uIChmb250U3BlYykge1xuICBjb25zdCBtYXRjaCA9IGZvbnRTcGVjLm1hdGNoKGZvbnRSZWdFeCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7Rm9udFBhcmFtZXRlcnN9ICovICh7XG4gICAgbGluZUhlaWdodDogJ25vcm1hbCcsXG4gICAgc2l6ZTogJzEuMmVtJyxcbiAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB2YXJpYW50OiAnbm9ybWFsJyxcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGZvbnRSZWdFeE1hdGNoSW5kZXgubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHlsZVtmb250UmVnRXhNYXRjaEluZGV4W2ldXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBzdHlsZS5mYW1pbGllcyA9IHN0eWxlLmZhbWlseS5zcGxpdCgvLFxccz8vKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhc1xuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtXT1JLRVJfT0ZGU0NSRUVOX0NBTlZBU30gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7Z2V0Rm9udFBhcmFtZXRlcnN9IGZyb20gJy4uL2Nzcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydDaXJjbGUnIHwgJ0ltYWdlJyB8ICdMaW5lU3RyaW5nJyB8ICdQb2x5Z29uJyB8ICdUZXh0JyB8ICdEZWZhdWx0J30gQnVpbGRlclR5cGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGxTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBmaWxsU3R5bGUgRmlsbFN0eWxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgTGFiZWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCBXaWR0aC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0LlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gY29udGV4dEluc3RydWN0aW9ucyBDb250ZXh0SW5zdHJ1Y3Rpb25zLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmlsbFN0cm9rZVN0YXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjdXJyZW50RmlsbFN0eWxlXSBDdXJyZW50IEZpbGxTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2N1cnJlbnRTdHJva2VTdHlsZV0gQ3VycmVudCBTdHJva2VTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUNhcH0gW2N1cnJlbnRMaW5lQ2FwXSBDdXJyZW50IExpbmVDYXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGN1cnJlbnRMaW5lRGFzaCBDdXJyZW50IExpbmVEYXNoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjdXJyZW50TGluZURhc2hPZmZzZXRdIEN1cnJlbnQgTGluZURhc2hPZmZzZXQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBbY3VycmVudExpbmVKb2luXSBDdXJyZW50IExpbmVKb2luLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjdXJyZW50TGluZVdpZHRoXSBDdXJyZW50IExpbmVXaWR0aC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudE1pdGVyTGltaXRdIEN1cnJlbnQgTWl0ZXJMaW1pdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGFzdFN0cm9rZV0gTGFzdCBzdHJva2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtmaWxsU3R5bGVdIEZpbGxTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW3N0cm9rZVN0eWxlXSBTdHJva2VTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUNhcH0gW2xpbmVDYXBdIExpbmVDYXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxpbmVEYXNoIExpbmVEYXNoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsaW5lRGFzaE9mZnNldF0gTGluZURhc2hPZmZzZXQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBbbGluZUpvaW5dIExpbmVKb2luLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsaW5lV2lkdGhdIExpbmVXaWR0aC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWl0ZXJMaW1pdF0gTWl0ZXJMaW1pdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZmlsbFBhdHRlcm5TY2FsZV0gRmlsbCBwYXR0ZXJuIHNjYWxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3Ryb2tlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUNhcH0gbGluZUNhcCBMaW5lQ2FwLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBsaW5lRGFzaCBMaW5lRGFzaC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lRGFzaE9mZnNldCBMaW5lRGFzaE9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IGxpbmVKb2luIExpbmVKb2luLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVXaWR0aCBMaW5lV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWl0ZXJMaW1pdCBNaXRlckxpbWl0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBzdHJva2VTdHlsZSBTdHJva2VTdHlsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZvbnQgRm9udC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzVGV4dEFsaWdufSBbdGV4dEFsaWduXSBUZXh0QWxpZ24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcGVhdF0gUmVwZWF0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9UZXh0LmpzXCIpLlRleHRKdXN0aWZ5fSBbanVzdGlmeV0gSnVzdGlmeS5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzVGV4dEJhc2VsaW5lfSB0ZXh0QmFzZWxpbmUgVGV4dEJhc2VsaW5lLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9UZXh0LmpzXCIpLlRleHRQbGFjZW1lbnR9IFtwbGFjZW1lbnRdIFBsYWNlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4QW5nbGVdIE1heEFuZ2xlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3ddIE92ZXJmbG93LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kRmlsbF0gQmFja2dyb3VuZEZpbGwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbYmFja2dyb3VuZFN0cm9rZV0gQmFja2dyb3VuZFN0cm9rZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGVdIFNjYWxlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbcGFkZGluZ10gUGFkZGluZy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcmlhbGl6YWJsZUluc3RydWN0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb25zIFRoZSByZW5kZXJpbmcgaW5zdHJ1Y3Rpb25zLlxuICogQHByb3BlcnR5IHtBcnJheTwqPn0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zIFRoZSByZW5kZXJpbmcgaGl0IGRldGVjdGlvbiBpbnN0cnVjdGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIFRoZSBhcnJheSBvZiBhbGwgY29vcmRpbmF0ZXMuXG4gKiBAcHJvcGVydHkgeyFPYmplY3Q8c3RyaW5nLCBUZXh0U3RhdGU+fSBbdGV4dFN0YXRlc10gVGhlIHRleHQgc3RhdGVzIChkZWNsdXR0ZXJpbmcpLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgRmlsbFN0YXRlPn0gW2ZpbGxTdGF0ZXNdIFRoZSBmaWxsIHN0YXRlcyAoZGVjbHV0dGVyaW5nKS5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIFN0cm9rZVN0YXRlPn0gW3N0cm9rZVN0YXRlc10gVGhlIHN0cm9rZSBzdGF0ZXMgKGRlY2x1dHRlcmluZykuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0PG51bWJlciwgaW1wb3J0KFwiLi9jYW52YXMvRXhlY3V0b3IuanNcIikuUmVwbGF5SW1hZ2VPckxhYmVsQXJncz59IERlY2x1dHRlckltYWdlV2l0aFRleHRcbiAqL1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGb250ID0gJzEwcHggc2Fucy1zZXJpZic7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEZpbGxTdHlsZSA9ICcjMDAwJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVDYXAgPSAncm91bmQnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZURhc2ggPSBbXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZURhc2hPZmZzZXQgPSAwO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0NhbnZhc0xpbmVKb2lufVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVKb2luID0gJ3JvdW5kJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TWl0ZXJMaW1pdCA9IDEwO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U3Ryb2tlU3R5bGUgPSAnIzAwMCc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0NhbnZhc1RleHRCYXNlbGluZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRUZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhZGRpbmcgPSBbMCwgMCwgMCwgMF07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVXaWR0aCA9IDE7XG5cbi8qKlxuICogQHR5cGUge0Jhc2VPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja2VkRm9udHMgPSBuZXcgQmFzZU9iamVjdCgpO1xuXG4vKipcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKi9cbmxldCBtZWFzdXJlQ29udGV4dCA9IG51bGw7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xubGV0IG1lYXN1cmVGb250O1xuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRleHRIZWlnaHRzID0ge307XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsYWJlbCBjYWNoZSB3aGVuIGEgZm9udCBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3BlYyBDU1MgZm9udCBzcGVjLlxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJGb250ID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgcmV0cmllcyA9IDEwMDtcbiAgY29uc3Qgc2l6ZSA9ICczMnB4ICc7XG4gIGNvbnN0IHJlZmVyZW5jZUZvbnRzID0gWydtb25vc3BhY2UnLCAnc2VyaWYnXTtcbiAgY29uc3QgbGVuID0gcmVmZXJlbmNlRm9udHMubGVuZ3RoO1xuICBjb25zdCB0ZXh0ID0gJ3dteXR6aWxXTVlUWklMQCMvJj8kJTEwXFx1RjAxMyc7XG4gIGxldCBpbnRlcnZhbCwgcmVmZXJlbmNlV2lkdGg7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3R5bGUgQ3NzIGZvbnQtc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRXZWlnaHQgQ3NzIGZvbnQtd2VpZ2h0XG4gICAqIEBwYXJhbSB7Kn0gZm9udEZhbWlseSBDc3MgZm9udC1mYW1pbHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRm9udCB3aXRoIHN0eWxlIGFuZCB3ZWlnaHQgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBpc0F2YWlsYWJsZShmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHkpIHtcbiAgICBsZXQgYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VGb250ID0gcmVmZXJlbmNlRm9udHNbaV07XG4gICAgICByZWZlcmVuY2VXaWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoXG4gICAgICAgIGZvbnRTdHlsZSArICcgJyArIGZvbnRXZWlnaHQgKyAnICcgKyBzaXplICsgcmVmZXJlbmNlRm9udCxcbiAgICAgICAgdGV4dCxcbiAgICAgICk7XG4gICAgICBpZiAoZm9udEZhbWlseSAhPSByZWZlcmVuY2VGb250KSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbWVhc3VyZVRleHRXaWR0aChcbiAgICAgICAgICBmb250U3R5bGUgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIGZvbnRXZWlnaHQgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHNpemUgK1xuICAgICAgICAgICAgZm9udEZhbWlseSArXG4gICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgcmVmZXJlbmNlRm9udCxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICApO1xuICAgICAgICAvLyBJZiB3aWR0aCBhbmQgcmVmZXJlbmNlV2lkdGggYXJlIHRoZSBzYW1lLCB0aGVuIHRoZSBmYWxsYmFjayB3YXMgdXNlZFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBmb250IHdlIHdhbnRlZCwgc28gdGhlIGZvbnQgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgICAgYXZhaWxhYmxlID0gYXZhaWxhYmxlICYmIHdpZHRoICE9IHJlZmVyZW5jZVdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgIGNvbnN0IGZvbnRzID0gY2hlY2tlZEZvbnRzLmdldEtleXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmb250cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBmb250ID0gZm9udHNbaV07XG4gICAgICBpZiAoY2hlY2tlZEZvbnRzLmdldChmb250KSA8IHJldHJpZXMpIHtcbiAgICAgICAgY29uc3QgW3N0eWxlLCB3ZWlnaHQsIGZhbWlseV0gPSBmb250LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgaWYgKGlzQXZhaWxhYmxlKHN0eWxlLCB3ZWlnaHQsIGZhbWlseSkpIHtcbiAgICAgICAgICBjbGVhcih0ZXh0SGVpZ2h0cyk7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbG9hZGVkIGZvbnRzIGFyZSBwaWNrZWQgdXAgYnkgU2FmYXJpXG4gICAgICAgICAgbWVhc3VyZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAgIG1lYXN1cmVGb250ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNoZWNrZWRGb250cy5zZXQoZm9udCwgcmV0cmllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2tlZEZvbnRzLnNldChmb250LCBjaGVja2VkRm9udHMuZ2V0KGZvbnQpICsgMSwgdHJ1ZSk7XG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkb25lKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgIGludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm9udFNwZWMpIHtcbiAgICBjb25zdCBmb250ID0gZ2V0Rm9udFBhcmFtZXRlcnMoZm9udFNwZWMpO1xuICAgIGlmICghZm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmYW1pbGllcyA9IGZvbnQuZmFtaWxpZXM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmFtaWxpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZmFtaWx5ID0gZmFtaWxpZXNbaV07XG4gICAgICBjb25zdCBrZXkgPSBmb250LnN0eWxlICsgJ1xcbicgKyBmb250LndlaWdodCArICdcXG4nICsgZmFtaWx5O1xuICAgICAgaWYgKGNoZWNrZWRGb250cy5nZXQoa2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoZWNrZWRGb250cy5zZXQoa2V5LCByZXRyaWVzLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpc0F2YWlsYWJsZShmb250LnN0eWxlLCBmb250LndlaWdodCwgZmFtaWx5KSkge1xuICAgICAgICAgIGNoZWNrZWRGb250cy5zZXQoa2V5LCAwLCB0cnVlKTtcbiAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVjaywgMzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgRm9udCB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gTWVhc3VyZW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBtZWFzdXJlVGV4dEhlaWdodCA9IChmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICBsZXQgbWVhc3VyZUVsZW1lbnQ7XG4gIHJldHVybiBmdW5jdGlvbiAoZm9udFNwZWMpIHtcbiAgICBsZXQgaGVpZ2h0ID0gdGV4dEhlaWdodHNbZm9udFNwZWNdO1xuICAgIGlmIChoZWlnaHQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoV09SS0VSX09GRlNDUkVFTl9DQU5WQVMpIHtcbiAgICAgICAgY29uc3QgZm9udCA9IGdldEZvbnRQYXJhbWV0ZXJzKGZvbnRTcGVjKTtcbiAgICAgICAgY29uc3QgbWV0cmljcyA9IG1lYXN1cmVUZXh0KGZvbnRTcGVjLCAnXHUwMTdEZycpO1xuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXNOYU4oTnVtYmVyKGZvbnQubGluZUhlaWdodCkpXG4gICAgICAgICAgPyAxLjJcbiAgICAgICAgICA6IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICAgICAgICBoZWlnaHQgPVxuICAgICAgICAgIGxpbmVIZWlnaHQgKlxuICAgICAgICAgIChtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFtZWFzdXJlRWxlbWVudCkge1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuaW5uZXJIVE1MID0gJ00nO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLm1pbkhlaWdodCA9ICcwJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5tYXhIZWlnaHQgPSAnbm9uZSc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5sZWZ0ID0gJy05OTk5OXB4JztcbiAgICAgICAgfVxuICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5mb250ID0gZm9udFNwZWM7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWVhc3VyZUVsZW1lbnQpO1xuICAgICAgICBoZWlnaHQgPSBtZWFzdXJlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobWVhc3VyZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGV4dEhlaWdodHNbZm9udFNwZWNdID0gaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBGb250LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAqIEByZXR1cm4ge1RleHRNZXRyaWNzfSBUZXh0IG1ldHJpY3MuXG4gKi9cbmZ1bmN0aW9uIG1lYXN1cmVUZXh0KGZvbnQsIHRleHQpIHtcbiAgaWYgKCFtZWFzdXJlQ29udGV4dCkge1xuICAgIG1lYXN1cmVDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICB9XG4gIGlmIChmb250ICE9IG1lYXN1cmVGb250KSB7XG4gICAgbWVhc3VyZUNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgbWVhc3VyZUZvbnQgPSBtZWFzdXJlQ29udGV4dC5mb250O1xuICB9XG4gIHJldHVybiBtZWFzdXJlQ29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBGb250LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIHRleHQpIHtcbiAgcmV0dXJuIG1lYXN1cmVUZXh0KGZvbnQsIHRleHQpLndpZHRoO1xufVxuXG4vKipcbiAqIE1lYXN1cmUgdGV4dCB3aWR0aCB1c2luZyBhIGNhY2hlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgVGhlIGZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBtZWFzdXJlLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fSBjYWNoZSBBIGxvb2t1cCBvZiBjYWNoZWQgd2lkdGhzIGJ5IHRleHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0ZXh0IHdpZHRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoKGZvbnQsIHRleHQsIGNhY2hlKSB7XG4gIGlmICh0ZXh0IGluIGNhY2hlKSB7XG4gICAgcmV0dXJuIGNhY2hlW3RleHRdO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gdGV4dFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBNYXRoLm1heChwcmV2LCBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIGN1cnIpKSwgMCk7XG4gIGNhY2hlW3RleHRdID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHRTdGF0ZX0gYmFzZVN0eWxlIEJhc2Ugc3R5bGUuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGNodW5rcyBUZXh0IGNodW5rcyB0byBtZWFzdXJlLlxuICogQHJldHVybiB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB3aWR0aHM6IEFycmF5PG51bWJlcj4sIGhlaWdodHM6IEFycmF5PG51bWJlcj4sIGxpbmVXaWR0aHM6IEFycmF5PG51bWJlcj59fX0gVGV4dCBtZXRyaWNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dERpbWVuc2lvbnMoYmFzZVN0eWxlLCBjaHVua3MpIHtcbiAgY29uc3Qgd2lkdGhzID0gW107XG4gIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgY29uc3QgbGluZVdpZHRocyA9IFtdO1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgbGluZVdpZHRoID0gMDtcbiAgbGV0IGhlaWdodCA9IDA7XG4gIGxldCBsaW5lSGVpZ2h0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2h1bmtzLmxlbmd0aDsgaSA8PSBpaTsgaSArPSAyKSB7XG4gICAgY29uc3QgdGV4dCA9IGNodW5rc1tpXTtcbiAgICBpZiAodGV4dCA9PT0gJ1xcbicgfHwgaSA9PT0gaWkpIHtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcbiAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgIGxpbmVIZWlnaHQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSBjaHVua3NbaSArIDFdIHx8IGJhc2VTdHlsZS5mb250O1xuICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCk7XG4gICAgd2lkdGhzLnB1c2goY3VycmVudFdpZHRoKTtcbiAgICBsaW5lV2lkdGggKz0gY3VycmVudFdpZHRoO1xuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBtZWFzdXJlVGV4dEhlaWdodChmb250KTtcbiAgICBoZWlnaHRzLnB1c2goY3VycmVudEhlaWdodCk7XG4gICAgbGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGN1cnJlbnRIZWlnaHQpO1xuICB9XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodCwgd2lkdGhzLCBoZWlnaHRzLCBsaW5lV2lkdGhzfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggWCBvZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBZIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9aSW5kZXhDb250ZXh0LmpzXCIpLlpJbmRleENvbnRleHRQcm94eX0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfG51bGx9IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQHBhcmFtIHtMYWJlbHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IGxhYmVsT3JJbWFnZSBMYWJlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpbiBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblkgT3JpZ2luIFkuXG4gKiBAcGFyYW0ge251bWJlcn0gdyBXaWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoIEhlaWdodC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd0ltYWdlT3JMYWJlbChcbiAgY29udGV4dCxcbiAgdHJhbnNmb3JtLFxuICBvcGFjaXR5LFxuICBsYWJlbE9ySW1hZ2UsXG4gIG9yaWdpblgsXG4gIG9yaWdpblksXG4gIHcsXG4gIGgsXG4gIHgsXG4gIHksXG4gIHNjYWxlLFxuKSB7XG4gIGNvbnRleHQuc2F2ZSgpO1xuXG4gIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgaWYgKGNvbnRleHQuZ2xvYmFsQWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IChjb250ZXh0KSA9PiAoY29udGV4dC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5O1xuICAgIH1cbiAgfVxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgY29udGV4dC50cmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIGlmICgvKiogQHR5cGUgeyp9ICovIChsYWJlbE9ySW1hZ2UpLmNvbnRleHRJbnN0cnVjdGlvbnMpIHtcbiAgICAvLyBsYWJlbFxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQuc2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKTtcbiAgICBleGVjdXRlTGFiZWxJbnN0cnVjdGlvbnMoLyoqIEB0eXBlIHtMYWJlbH0gKi8gKGxhYmVsT3JJbWFnZSksIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHNjYWxlWzBdIDwgMCB8fCBzY2FsZVsxXSA8IDApIHtcbiAgICAvLyBmbGlwcGVkIGltYWdlXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5zY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChcbiAgICAgICAgbGFiZWxPckltYWdlXG4gICAgICApLFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICB3LFxuICAgICAgaCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpbWFnZSBub3QgZmxpcHBlZCB0cmFuc2xhdGUgYW5kIHNjYWxlIGNhbiBiZSBhdm9pZGVkXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gKi8gKFxuICAgICAgICBsYWJlbE9ySW1hZ2VcbiAgICAgICksXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3ICogc2NhbGVbMF0sXG4gICAgICBoICogc2NhbGVbMV0sXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRleHQucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsIExhYmVsLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZUxhYmVsSW5zdHJ1Y3Rpb25zKGxhYmVsLCBjb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRleHRJbnN0cnVjdGlvbnMgPSBsYWJlbC5jb250ZXh0SW5zdHJ1Y3Rpb25zO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb250ZXh0SW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0SW5zdHJ1Y3Rpb25zW2kgKyAxXSkpIHtcbiAgICAgIGNvbnRleHRbY29udGV4dEluc3RydWN0aW9uc1tpXV0uYXBwbHkoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnNbaSArIDFdLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dFtjb250ZXh0SW5zdHJ1Y3Rpb25zW2ldXSA9IGNvbnRleHRJbnN0cnVjdGlvbnNbaSArIDFdO1xuICAgIH1cbiAgfVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9SZWd1bGFyU2hhcGVcbiAqL1xuXG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0TGluZUNhcCxcbiAgZGVmYXVsdExpbmVKb2luLFxuICBkZWZhdWx0TGluZVdpZHRoLFxuICBkZWZhdWx0TWl0ZXJMaW1pdCxcbiAgZGVmYXVsdFN0cm9rZVN0eWxlLFxufSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcblxuLyoqXG4gKiBTcGVjaWZ5IHJhZGl1cyBmb3IgcmVndWxhciBwb2x5Z29ucywgb3IgYm90aCByYWRpdXMgYW5kIHJhZGl1czIgZm9yIHN0YXJzLlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9pbnRzIE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLiBJbiBjYXNlIG9mIGEgcG9seWdvbiwgdGhlIG51bWJlciBvZiBwb2ludHNcbiAqIGlzIHRoZSBudW1iZXIgb2Ygc2lkZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMl0gU2Vjb25kIHJhZGl1cyB0byBtYWtlIGEgc3RhciBpbnN0ZWFkIG9mIGEgcmVndWxhciBwb2x5Z29uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthbmdsZT0wXSBTaGFwZSdzIGFuZ2xlIGluIHJhZGlhbnMuIEEgdmFsdWUgb2YgMCB3aWxsIGhhdmUgb25lIG9mIHRoZSBzaGFwZSdzIHBvaW50cyBmYWNpbmcgdXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtkaXNwbGFjZW1lbnQ9WzAsIDBdXSBEaXNwbGFjZW1lbnQgb2YgdGhlIHNoYXBlIGluIHBpeGVscy5cbiAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIHNoaWZ0IHRoZSBzaGFwZSByaWdodCBhbmQgdXAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb249MF0gUm90YXRpb24gaW4gcmFkaWFucyAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgc2hhcGUgd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlPTFdIFNjYWxlLiBVbmxlc3MgdHdvIGRpbWVuc2lvbmFsIHNjYWxpbmcgaXMgcmVxdWlyZWQgYSBiZXR0ZXJcbiAqIHJlc3VsdCBtYXkgYmUgb2J0YWluZWQgd2l0aCBhcHByb3ByaWF0ZSBzZXR0aW5ncyBmb3IgYHJhZGl1c2AgYW5kIGByYWRpdXMyYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL1N0eWxlLmpzJykuRGVjbHV0dGVyTW9kZX0gW2RlY2x1dHRlck1vZGVdIERlY2x1dHRlciBtb2RlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfHVuZGVmaW5lZH0gc3Ryb2tlU3R5bGUgU3Ryb2tlU3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3Ryb2tlV2lkdGggU3Ryb2tlV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBTaXplLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBsaW5lQ2FwIExpbmVDYXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj58bnVsbH0gbGluZURhc2ggTGluZURhc2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXQgTGluZURhc2hPZmZzZXQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBsaW5lSm9pbiBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0IE1pdGVyTGltaXQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgcmVndWxhciBzaGFwZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLiBUaGUgcmVzdWx0aW5nIHNoYXBlIHdpbGwgYmVcbiAqIGEgcmVndWxhciBwb2x5Z29uIHdoZW4gYHJhZGl1c2AgaXMgcHJvdmlkZWQsIG9yIGEgc3RhciB3aGVuIGJvdGggYHJhZGl1c2AgYW5kXG4gKiBgcmFkaXVzMmAgYXJlIHByb3ZpZGVkLlxuICogQGFwaVxuICovXG5jbGFzcyBSZWd1bGFyU2hhcGUgZXh0ZW5kcyBJbWFnZVN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICByb3RhdGVXaXRoVmlldzpcbiAgICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlLFxuICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwLFxuICAgICAgc2NhbGU6IG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2NhbGUgOiAxLFxuICAgICAgZGlzcGxhY2VtZW50OlxuICAgICAgICBvcHRpb25zLmRpc3BsYWNlbWVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kaXNwbGFjZW1lbnQgOiBbMCwgMF0sXG4gICAgICBkZWNsdXR0ZXJNb2RlOiBvcHRpb25zLmRlY2x1dHRlck1vZGUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBIVE1MQ2FudmFzRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNlc187XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbF8gPSBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZmlsbCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50c18gPSBvcHRpb25zLnBvaW50cztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzMl8gPSBvcHRpb25zLnJhZGl1czI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZV8gPSBvcHRpb25zLmFuZ2xlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuZ2xlIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyT3B0aW9uc187XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPVxuICAgICAgdGhpcy5maWxsXyAmJiB0aGlzLmZpbGxfLmxvYWRpbmcoKVxuICAgICAgICA/IEltYWdlU3RhdGUuTE9BRElOR1xuICAgICAgICA6IEltYWdlU3RhdGUuTE9BREVEO1xuICAgIGlmICh0aGlzLmltYWdlU3RhdGVfID09PSBJbWFnZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgIHRoaXMucmVhZHkoKS50aGVuKCgpID0+ICh0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FERUQpKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtSZWd1bGFyU2hhcGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICBjb25zdCBzdHlsZSA9IG5ldyBSZWd1bGFyU2hhcGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcG9pbnRzOiB0aGlzLmdldFBvaW50cygpLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgcmFkaXVzMjogdGhpcy5nZXRSYWRpdXMyKCksXG4gICAgICBhbmdsZTogdGhpcy5nZXRBbmdsZSgpLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBzY2FsZTogQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGUsXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICAgIHN0eWxlLnNldE9wYWNpdHkodGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBpbiBwaXhlbHMuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAgICogc3ltYm9saXplci5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW5jaG9yLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemVfO1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCk7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlQXJyYXkoKTtcbiAgICAvLyBhbmNob3IgaXMgc2NhbGVkIGJ5IHJlbmRlcmVyIGJ1dCBkaXNwbGFjZW1lbnQgc2hvdWxkIG5vdCBiZSBzY2FsZWRcbiAgICAvLyBzbyBkaXZpZGUgYnkgc2NhbGUgaGVyZVxuICAgIHJldHVybiBbXG4gICAgICBzaXplWzBdIC8gMiAtIGRpc3BsYWNlbWVudFswXSAvIHNjYWxlWzBdLFxuICAgICAgc2l6ZVsxXSAvIDIgKyBkaXNwbGFjZW1lbnRbMV0gLyBzY2FsZVsxXSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5nbGUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBTaGFwZSdzIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLmFuZ2xlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18oXG4gICAgICAgIHRoaXMucmVuZGVyT3B0aW9uc18sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgaWNvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBsZXQgaW1hZ2UgPSB0aGlzLmNhbnZhc2VzX1twaXhlbFJhdGlvXTtcbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICBjb25zdCByZW5kZXJPcHRpb25zID0gdGhpcy5yZW5kZXJPcHRpb25zXztcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICAgIHJlbmRlck9wdGlvbnMuc2l6ZSAqIHBpeGVsUmF0aW8sXG4gICAgICAgIHJlbmRlck9wdGlvbnMuc2l6ZSAqIHBpeGVsUmF0aW8sXG4gICAgICApO1xuICAgICAgdGhpcy5kcmF3XyhyZW5kZXJPcHRpb25zLCBjb250ZXh0LCBwaXhlbFJhdGlvKTtcblxuICAgICAgaW1hZ2UgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIHRoaXMuY2FudmFzZXNfW3BpeGVsUmF0aW9dID0gaW1hZ2U7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIHBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBQaXhlbCByYXRpby5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SW1hZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3RhdGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVN0YXRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbiBvZiB0aGUgc3ltYm9saXplci5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZ2luLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0T3JpZ2luKCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgcG9pbnRzIGZvciBnZW5lcmF0aW5nIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgcG9pbnRzIGZvciBzdGFycyBhbmQgcmVndWxhciBwb2x5Z29ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50c187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSAocHJpbWFyeSkgcmFkaXVzIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kYXJ5IHJhZGl1cyBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSYWRpdXMyLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSYWRpdXMyKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1czJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgc3ltYm9saXplciAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSBzdHlsZSBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7fVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBsb2FkKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhZGRpdGlvbmFsIGNhbnZhcyBzaXplIG5lZWRlZCBmb3IgdGhlIG1pdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZUpvaW4gTGluZSBqb2luXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VXaWR0aCBTdHJva2Ugd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pdGVyTGltaXQgTWl0ZXIgbGltaXRcbiAgICogQHJldHVybiB7bnVtYmVyfSBBZGRpdGlvbmFsIGNhbnZhcyBzaXplIG5lZWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlTGluZUpvaW5TaXplXyhsaW5lSm9pbiwgc3Ryb2tlV2lkdGgsIG1pdGVyTGltaXQpIHtcbiAgICBpZiAoXG4gICAgICBzdHJva2VXaWR0aCA9PT0gMCB8fFxuICAgICAgdGhpcy5wb2ludHNfID09PSBJbmZpbml0eSB8fFxuICAgICAgKGxpbmVKb2luICE9PSAnYmV2ZWwnICYmIGxpbmVKb2luICE9PSAnbWl0ZXInKVxuICAgICkge1xuICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICAvLyBtICB8IF5cbiAgICAvLyBpICB8IHxcXCAgICAgICAgICAgICAgICAgIC5cbiAgICAvLyB0ID58ICAjXFxcbiAgICAvLyBlICB8IHxcXCBcXCAgICAgICAgICAgICAgLlxuICAgIC8vIHIgICAgICBcXHNcXFxuICAgIC8vICAgICAgfCAgXFx0XFwgICAgICAgICAgLiAgICAgICAgICAgICAgICAgLlxuICAgIC8vICAgICAgICAgIFxcclxcICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICB8ICAgIFxcb1xcICAgICAgLiAgICAgICAgICAuICAuIC4gLlxuICAgIC8vICAgICAgICAgIGUgXFxrXFwgICAgICAgICAgICAuICAuICAgIC4gLlxuICAgIC8vICAgICAgfCAgICAgIFxcZVxcICAuICAgIC4gIC4gICAgICAgLiAuXG4gICAgLy8gICAgICAgZCAgICAgIFxcIFxcICAuICAuICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgfCBfIF9hXyBfXFwjICAuICAgICAgICAgICAgLiAuXG4gICAgLy8gICByMSAgICAgICAgICAvIGAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAuIC5cbiAgICAvLyAgICAgICBiICAgICAvICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICAgICAgIC8gcjIgICAgICAgICAgICAuIC5cbiAgICAvLyAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICB8XHUwM0IxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICBcdTAwQjAgY2VudGVyXG4gICAgbGV0IHIxID0gdGhpcy5yYWRpdXM7XG4gICAgbGV0IHIyID0gdGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkID8gcjEgOiB0aGlzLnJhZGl1czJfO1xuICAgIGlmIChyMSA8IHIyKSB7XG4gICAgICBjb25zdCB0bXAgPSByMTtcbiAgICAgIHIxID0gcjI7XG4gICAgICByMiA9IHRtcDtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRzID1cbiAgICAgIHRoaXMucmFkaXVzMl8gPT09IHVuZGVmaW5lZCA/IHRoaXMucG9pbnRzXyA6IHRoaXMucG9pbnRzXyAqIDI7XG4gICAgY29uc3QgYWxwaGEgPSAoMiAqIE1hdGguUEkpIC8gcG9pbnRzO1xuICAgIGNvbnN0IGEgPSByMiAqIE1hdGguc2luKGFscGhhKTtcbiAgICBjb25zdCBiID0gTWF0aC5zcXJ0KHIyICogcjIgLSBhICogYSk7XG4gICAgY29uc3QgZCA9IHIxIC0gYjtcbiAgICBjb25zdCBlID0gTWF0aC5zcXJ0KGEgKiBhICsgZCAqIGQpO1xuICAgIGNvbnN0IG1pdGVyUmF0aW8gPSBlIC8gYTtcbiAgICBpZiAobGluZUpvaW4gPT09ICdtaXRlcicgJiYgbWl0ZXJSYXRpbyA8PSBtaXRlckxpbWl0KSB7XG4gICAgICByZXR1cm4gbWl0ZXJSYXRpbyAqIHN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gY2VudGVyIHRvIHRoZSBzdHJva2UgY29ybmVyIHdoZXJlXG4gICAgLy8gaXQgd2FzIGN1dCBzaG9ydCBiZWNhdXNlIG9mIHRoZSBtaXRlciBsaW1pdC5cbiAgICAvLyAgICAgICAgICAgICAgbFxuICAgIC8vICAgICAgICAtLS0tKy0tLS0gPD0gZGlzdGFuY2UgZnJvbSBjZW50ZXIgdG8gaGVyZSBpcyBtYXhyXG4gICAgLy8gICAgICAgLyMjIyN8ayAjI1xcXG4gICAgLy8gICAgICAvIyMjIyNeIyMjIyNcXFxuICAgIC8vICAgICAvIyMjIyAvK1xcIyBzICNcXFxuICAgIC8vICAgIC8jIyMgaC8rKytcXCMgdCAjXFxcbiAgICAvLyAgIC8jIyMgdC8rKysrK1xcIyByICNcXFxuICAgIC8vICAvIyMjIGEvKysrKysrK1xcIyBvICNcXFxuICAgIC8vIC8jIyMgcC8rKyBmaWxsICtcXCMgayAjXFxcbiAgICAvLy8jIyMjIC8rKysrK14rKysrK1xcIyBlICNcXFxuICAgIC8vIyMjIyMvKysrKysvK1xcKysrKytcXCMjIyMjXFxcbiAgICBjb25zdCBrID0gc3Ryb2tlV2lkdGggLyAyIC8gbWl0ZXJSYXRpbztcbiAgICBjb25zdCBsID0gKHN0cm9rZVdpZHRoIC8gMikgKiAoZCAvIGUpO1xuICAgIGNvbnN0IG1heHIgPSBNYXRoLnNxcnQoKHIxICsgaykgKiAocjEgKyBrKSArIGwgKiBsKTtcbiAgICBjb25zdCBiZXZlbEFkZCA9IG1heHIgLSByMTtcbiAgICBpZiAodGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkIHx8IGxpbmVKb2luID09PSAnYmV2ZWwnKSB7XG4gICAgICByZXR1cm4gYmV2ZWxBZGQgKiAyO1xuICAgIH1cbiAgICAvLyBJZiBvdXRlciBtaXRlciBpcyBvdmVyIHRoZSBtaXRlciBsaW1pdCB0aGUgaW5uZXIgbWl0ZXIgbWF5IHJlYWNoIHRocm91Z2ggdGhlXG4gICAgLy8gY2VudGVyIGFuZCBiZSBsb25nZXIgdGhhbiB0aGUgYmV2ZWwsIHNhbWUgY2FsY3VsYXRpb24gYXMgYWJvdmUgYnV0IHN3YXAgcjEgLyByMi5cbiAgICBjb25zdCBhYSA9IHIxICogTWF0aC5zaW4oYWxwaGEpO1xuICAgIGNvbnN0IGJiID0gTWF0aC5zcXJ0KHIxICogcjEgLSBhYSAqIGFhKTtcbiAgICBjb25zdCBkZCA9IHIyIC0gYmI7XG4gICAgY29uc3QgZWUgPSBNYXRoLnNxcnQoYWEgKiBhYSArIGRkICogZGQpO1xuICAgIGNvbnN0IGlubmVyTWl0ZXJSYXRpbyA9IGVlIC8gYWE7XG4gICAgaWYgKGlubmVyTWl0ZXJSYXRpbyA8PSBtaXRlckxpbWl0KSB7XG4gICAgICBjb25zdCBpbm5lckxlbmd0aCA9IChpbm5lck1pdGVyUmF0aW8gKiBzdHJva2VXaWR0aCkgLyAyIC0gcjIgLSByMTtcbiAgICAgIHJldHVybiAyICogTWF0aC5tYXgoYmV2ZWxBZGQsIGlubmVyTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJldmVsQWRkICogMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtSZW5kZXJPcHRpb25zfSAgVGhlIHJlbmRlciBvcHRpb25zXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNyZWF0ZVJlbmRlck9wdGlvbnMoKSB7XG4gICAgbGV0IGxpbmVDYXAgPSBkZWZhdWx0TGluZUNhcDtcbiAgICBsZXQgbGluZUpvaW4gPSBkZWZhdWx0TGluZUpvaW47XG4gICAgbGV0IG1pdGVyTGltaXQgPSAwO1xuICAgIGxldCBsaW5lRGFzaCA9IG51bGw7XG4gICAgbGV0IGxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICBsZXQgc3Ryb2tlU3R5bGU7XG4gICAgbGV0IHN0cm9rZVdpZHRoID0gMDtcblxuICAgIGlmICh0aGlzLnN0cm9rZV8pIHtcbiAgICAgIHN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2UodGhpcy5zdHJva2VfLmdldENvbG9yKCkgPz8gZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VfLmdldFdpZHRoKCkgPz8gZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIGxpbmVEYXNoID0gdGhpcy5zdHJva2VfLmdldExpbmVEYXNoKCk7XG4gICAgICBsaW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lRGFzaE9mZnNldCgpID8/IDA7XG4gICAgICBsaW5lSm9pbiA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lSm9pbigpID8/IGRlZmF1bHRMaW5lSm9pbjtcbiAgICAgIGxpbmVDYXAgPSB0aGlzLnN0cm9rZV8uZ2V0TGluZUNhcCgpID8/IGRlZmF1bHRMaW5lQ2FwO1xuICAgICAgbWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlXy5nZXRNaXRlckxpbWl0KCkgPz8gZGVmYXVsdE1pdGVyTGltaXQ7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkID0gdGhpcy5jYWxjdWxhdGVMaW5lSm9pblNpemVfKGxpbmVKb2luLCBzdHJva2VXaWR0aCwgbWl0ZXJMaW1pdCk7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgodGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzMl8gfHwgMCk7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGguY2VpbCgyICogbWF4UmFkaXVzICsgYWRkKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdHJva2VTdHlsZTogc3Ryb2tlU3R5bGUsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgbGluZUNhcDogbGluZUNhcCxcbiAgICAgIGxpbmVEYXNoOiBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGxpbmVKb2luOiBsaW5lSm9pbixcbiAgICAgIG1pdGVyTGltaXQ6IG1pdGVyTGltaXQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJPcHRpb25zXyA9IHRoaXMuY3JlYXRlUmVuZGVyT3B0aW9ucygpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnJlbmRlck9wdGlvbnNfLnNpemU7XG4gICAgdGhpcy5jYW52YXNlc18gPSB7fTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBudWxsO1xuICAgIHRoaXMuc2l6ZV8gPSBbc2l6ZSwgc2l6ZV07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFRoZSBwaXhlbCByYXRpby5cbiAgICovXG4gIGRyYXdfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQsIHBpeGVsUmF0aW8pIHtcbiAgICBjb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIC8vIHNldCBvcmlnaW4gdG8gY2FudmFzIGNlbnRlclxuICAgIGNvbnRleHQudHJhbnNsYXRlKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIpO1xuXG4gICAgdGhpcy5jcmVhdGVQYXRoXyhjb250ZXh0KTtcblxuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICBsZXQgY29sb3IgPSB0aGlzLmZpbGxfLmdldENvbG9yKCk7XG4gICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgY29sb3IgPSBkZWZhdWx0RmlsbFN0eWxlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShjb2xvcik7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGUpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJPcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSByZW5kZXJPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHJlbmRlck9wdGlvbnMubGluZURhc2gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHJlbmRlck9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSByZW5kZXJPcHRpb25zLmxpbmVDYXA7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gcmVuZGVyT3B0aW9ucy5saW5lSm9pbjtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHJlbmRlck9wdGlvbnMubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcyBjb250YWluaW5nIHRoZSBpY29uXG4gICAqL1xuICBjcmVhdGVIaXREZXRlY3Rpb25DYW52YXNfKHJlbmRlck9wdGlvbnMpIHtcbiAgICBsZXQgY29udGV4dDtcbiAgICBpZiAodGhpcy5maWxsXykge1xuICAgICAgbGV0IGNvbG9yID0gdGhpcy5maWxsXy5nZXRDb2xvcigpO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgaWYgZmlsbCBpcyB0cmFuc3BhcmVudCAob3IgcGF0dGVybiBvciBncmFkaWVudClcbiAgICAgIGxldCBvcGFjaXR5ID0gMDtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbG9yID0gYXNBcnJheShjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgIG9wYWNpdHkgPSBjb2xvci5sZW5ndGggPT09IDQgPyBjb2xvclszXSA6IDE7XG4gICAgICB9XG4gICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAvLyBpZiBhIHRyYW5zcGFyZW50IGZpbGwgc3R5bGUgaXMgc2V0LCBjcmVhdGUgYW4gZXh0cmEgaGl0LWRldGVjdGlvbiBpbWFnZVxuICAgICAgICAvLyB3aXRoIGEgZGVmYXVsdCBmaWxsIHN0eWxlXG4gICAgICAgIGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQocmVuZGVyT3B0aW9ucy5zaXplLCByZW5kZXJPcHRpb25zLnNpemUpO1xuICAgICAgICB0aGlzLmRyYXdIaXREZXRlY3Rpb25DYW52YXNfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuY2FudmFzIDogdGhpcy5nZXRJbWFnZSgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dCB0byBkcmF3IGluLlxuICAgKi9cbiAgY3JlYXRlUGF0aF8oY29udGV4dCkge1xuICAgIGxldCBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgaWYgKHBvaW50cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByYWRpdXMyID0gdGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkID8gcmFkaXVzIDogdGhpcy5yYWRpdXMyXztcbiAgICAgIGlmICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnRzICo9IDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5hbmdsZV8gLSBNYXRoLlBJIC8gMjtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoMiAqIE1hdGguUEkpIC8gcG9pbnRzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHM7IGkrKykge1xuICAgICAgICBjb25zdCBhbmdsZTAgPSBzdGFydEFuZ2xlICsgaSAqIHN0ZXA7XG4gICAgICAgIGNvbnN0IHJhZGl1c0MgPSBpICUgMiA9PT0gMCA/IHJhZGl1cyA6IHJhZGl1czI7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHJhZGl1c0MgKiBNYXRoLmNvcyhhbmdsZTApLCByYWRpdXNDICogTWF0aC5zaW4oYW5nbGUwKSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnMgUmVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IFRoZSBjb250ZXh0LlxuICAgKi9cbiAgZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCkge1xuICAgIC8vIHNldCBvcmlnaW4gdG8gY2FudmFzIGNlbnRlclxuICAgIGNvbnRleHQudHJhbnNsYXRlKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIpO1xuXG4gICAgdGhpcy5jcmVhdGVQYXRoXyhjb250ZXh0KTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5zdHJva2VTdHlsZSkge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSByZW5kZXJPcHRpb25zLmxpbmVKb2luO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gcmVuZGVyT3B0aW9ucy5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXyA/IHRoaXMuZmlsbF8ucmVhZHkoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlZ3VsYXJTaGFwZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvQ2lyY2xlXG4gKi9cblxuaW1wb3J0IFJlZ3VsYXJTaGFwZSBmcm9tICcuL1JlZ3VsYXJTaGFwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzIENpcmNsZSByYWRpdXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwwXV0gZGlzcGxhY2VtZW50XG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZT0xXSBTY2FsZS4gQSB0d28gZGltZW5zaW9uYWwgc2NhbGUgd2lsbCBwcm9kdWNlIGFuIGVsbGlwc2UuXG4gKiBVbmxlc3MgdHdvIGRpbWVuc2lvbmFsIHNjYWxpbmcgaXMgcmVxdWlyZWQgYSBiZXR0ZXIgcmVzdWx0IG1heSBiZSBvYnRhaW5lZCB3aXRoIGFuIGFwcHJvcHJpYXRlIHNldHRpbmcgZm9yIGByYWRpdXNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCBtZWFuaW5nZnVsIG9ubHkgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSB0d28gZGltZW5zaW9uYWwgc2NhbGUpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3XG4gKiAobWVhbmluZ2Z1bCBvbmx5IHdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgdHdvIGRpbWVuc2lvbmFsIHNjYWxlKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuL1N0eWxlLmpzJykuRGVjbHV0dGVyTW9kZX0gW2RlY2x1dHRlck1vZGVdIERlY2x1dHRlciBtb2RlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgY2lyY2xlIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENpcmNsZVN0eWxlIGV4dGVuZHMgUmVndWxhclNoYXBlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge3JhZGl1czogNX07XG5cbiAgICBzdXBlcih7XG4gICAgICBwb2ludHM6IEluZmluaXR5LFxuICAgICAgZmlsbDogb3B0aW9ucy5maWxsLFxuICAgICAgcmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcbiAgICAgIHN0cm9rZTogb3B0aW9ucy5zdHJva2UsXG4gICAgICBzY2FsZTogb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zY2FsZSA6IDEsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGlvbiA6IDAsXG4gICAgICByb3RhdGVXaXRoVmlldzpcbiAgICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlLFxuICAgICAgZGlzcGxhY2VtZW50OlxuICAgICAgICBvcHRpb25zLmRpc3BsYWNlbWVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kaXNwbGFjZW1lbnQgOiBbMCwgMF0sXG4gICAgICBkZWNsdXR0ZXJNb2RlOiBvcHRpb25zLmRlY2x1dHRlck1vZGUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7Q2lyY2xlU3R5bGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICBjb25zdCBzdHlsZSA9IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICByYWRpdXM6IHRoaXMuZ2V0UmFkaXVzKCksXG4gICAgICBzY2FsZTogQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGUsXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gICAgc3R5bGUuc2V0T3BhY2l0eSh0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2lyY2xlIHJhZGl1cy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBDaXJjbGUgcmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSYWRpdXMocmFkaXVzKSB7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGVTdHlsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvRmlsbFxuICovXG5cbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0SWNvbkltYWdlfSBmcm9tICcuL0ljb25JbWFnZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfGltcG9ydCgnLi4vY29sb3JsaWtlLmpzJykuUGF0dGVybkRlc2NyaXB0b3J8bnVsbH0gW2NvbG9yPW51bGxdIEEgY29sb3IsXG4gKiBncmFkaWVudCBvciBwYXR0ZXJuLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGZvciBwb3NzaWJsZSBmb3JtYXRzLiBGb3IgcG9seWdvbiBmaWxscyAobm90IGZvciB7QGxpbmsgaW1wb3J0KFwiLi9SZWd1bGFyU2hhcGUuanNcIikuZGVmYXVsdH0gZmlsbHMpLFxuICogYSBwYXR0ZXJuIGNhbiBhbHNvIGJlIHByb3ZpZGVkIGFzIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlflBhdHRlcm5EZXNjcmlwdG9yfS5cbiAqIERlZmF1bHQgbnVsbDsgaWYgbnVsbCwgdGhlIENhbnZhcy9yZW5kZXJlciBkZWZhdWx0IGJsYWNrIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBmaWxsIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEZpbGwge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhdHRlcm5JbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZXxpbXBvcnQoJy4uL2NvbG9ybGlrZS5qcycpLlBhdHRlcm5EZXNjcmlwdG9yfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0Q29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuIFRoZSBjb2xvciBpcyBub3QgY2xvbmVkIGlmIGl0IGlzIGEge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAgICogQHJldHVybiB7RmlsbH0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIG5ldyBGaWxsKHtcbiAgICAgIGNvbG9yOiBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yLnNsaWNlKCkgOiBjb2xvciB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfGltcG9ydCgnLi4vY29sb3JsaWtlLmpzJykuUGF0dGVybkRlc2NyaXB0b3J8bnVsbH0gQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V8aW1wb3J0KCcuLi9jb2xvcmxpa2UuanMnKS5QYXR0ZXJuRGVzY3JpcHRvcnxudWxsfSBjb2xvciBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICBpZiAoY29sb3IgIT09IG51bGwgJiYgdHlwZW9mIGNvbG9yID09PSAnb2JqZWN0JyAmJiAnc3JjJyBpbiBjb2xvcikge1xuICAgICAgY29uc3QgcGF0dGVybkltYWdlID0gZ2V0SWNvbkltYWdlKFxuICAgICAgICBudWxsLFxuICAgICAgICBjb2xvci5zcmMsXG4gICAgICAgICdhbm9ueW1vdXMnLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGNvbG9yLm9mZnNldCA/IG51bGwgOiBjb2xvci5jb2xvciA/IGNvbG9yLmNvbG9yIDogbnVsbCxcbiAgICAgICAgIShjb2xvci5vZmZzZXQgJiYgY29sb3Iuc2l6ZSksXG4gICAgICApO1xuICAgICAgcGF0dGVybkltYWdlLnJlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMucGF0dGVybkltYWdlXyA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXR0ZXJuSW1hZ2UuZ2V0SW1hZ2VTdGF0ZSgpID09PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgICAgcGF0dGVybkltYWdlLmxvYWQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXR0ZXJuSW1hZ2UuZ2V0SW1hZ2VTdGF0ZSgpID09PSBJbWFnZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJuSW1hZ2VfID0gcGF0dGVybkltYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBmaWxsIHN0eWxlIGlzIGxvYWRpbmcgYW4gaW1hZ2UgcGF0dGVybi5cbiAgICovXG4gIGxvYWRpbmcoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wYXR0ZXJuSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IGBmYWxzZWAgb3IgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc3R5bGUgaXMgcmVhZHkgdG8gdXNlLlxuICAgKi9cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVybkltYWdlXyA/IHRoaXMucGF0dGVybkltYWdlXy5yZWFkeSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsbDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvU3Ryb2tlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjb2xvcl0gQSBjb2xvciwgZ3JhZGllbnQgb3IgcGF0dGVybi5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBhbmQge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBmb3IgcG9zc2libGUgZm9ybWF0cy5cbiAqIERlZmF1bHQgbnVsbDsgaWYgbnVsbCwgdGhlIENhbnZhcy9yZW5kZXJlciBkZWZhdWx0IGJsYWNrIHdpbGwgYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUNhcH0gW2xpbmVDYXA9J3JvdW5kJ10gTGluZSBjYXAgc3R5bGU6IGBidXR0YCwgYHJvdW5kYCwgb3IgYHNxdWFyZWAuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBbbGluZUpvaW49J3JvdW5kJ10gTGluZSBqb2luIHN0eWxlOiBgYmV2ZWxgLCBgcm91bmRgLCBvciBgbWl0ZXJgLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbbGluZURhc2hdIExpbmUgZGFzaCBwYXR0ZXJuLiBEZWZhdWx0IGlzIGBudWxsYCAobm8gZGFzaCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xpbmVEYXNoT2Zmc2V0PTBdIExpbmUgZGFzaCBvZmZzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pdGVyTGltaXQ9MTBdIE1pdGVyIGxpbWl0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gV2lkdGguXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgc3Ryb2tlIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBOb3RlIHRoYXQgdGhlIGRlZmF1bHRzIGdpdmVuIGFyZSB0aGUgQ2FudmFzIGRlZmF1bHRzLCB3aGljaCB3aWxsIGJlIHVzZWQgaWZcbiAqIG9wdGlvbiBpcyBub3QgZGVmaW5lZC4gVGhlIGBnZXRgIGZ1bmN0aW9ucyByZXR1cm4gd2hhdGV2ZXIgd2FzIGVudGVyZWQgaW5cbiAqIHRoZSBvcHRpb25zOyB0aGV5IHdpbGwgbm90IHJldHVybiB0aGUgZGVmYXVsdC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgU3Ryb2tlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuY29sb3JfID0gb3B0aW9ucy5jb2xvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xvciA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVDYXBfID0gb3B0aW9ucy5saW5lQ2FwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGluZURhc2hfID0gb3B0aW9ucy5saW5lRGFzaCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5saW5lRGFzaCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZURhc2hPZmZzZXRfID0gb3B0aW9ucy5saW5lRGFzaE9mZnNldDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc0xpbmVKb2lufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVKb2luXyA9IG9wdGlvbnMubGluZUpvaW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubWl0ZXJMaW1pdF8gPSBvcHRpb25zLm1pdGVyTGltaXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGhfID0gb3B0aW9ucy53aWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtTdHJva2V9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRDb2xvcigpO1xuICAgIHJldHVybiBuZXcgU3Ryb2tlKHtcbiAgICAgIGNvbG9yOiBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yLnNsaWNlKCkgOiBjb2xvciB8fCB1bmRlZmluZWQsXG4gICAgICBsaW5lQ2FwOiB0aGlzLmdldExpbmVDYXAoKSxcbiAgICAgIGxpbmVEYXNoOiB0aGlzLmdldExpbmVEYXNoKCkgPyB0aGlzLmdldExpbmVEYXNoKCkuc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLmdldExpbmVEYXNoT2Zmc2V0KCksXG4gICAgICBsaW5lSm9pbjogdGhpcy5nZXRMaW5lSm9pbigpLFxuICAgICAgbWl0ZXJMaW1pdDogdGhpcy5nZXRNaXRlckxpbWl0KCksXG4gICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3Ryb2tlIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGluZSBjYXAgdHlwZSBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7Q2FudmFzTGluZUNhcHx1bmRlZmluZWR9IExpbmUgY2FwLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lQ2FwKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVDYXBfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGluZSBkYXNoIHN0eWxlIGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IExpbmUgZGFzaC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZURhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZURhc2hfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGluZSBkYXNoIG9mZnNldCBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTGluZSBkYXNoIG9mZnNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZURhc2hPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZURhc2hPZmZzZXRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGluZSBqb2luIHR5cGUgZm9yIHRoZSBzdHJva2UuXG4gICAqIEByZXR1cm4ge0NhbnZhc0xpbmVKb2lufHVuZGVmaW5lZH0gTGluZSBqb2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lSm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lSm9pbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaXRlciBsaW1pdCBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTWl0ZXIgbGltaXQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pdGVyTGltaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWl0ZXJMaW1pdF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugd2lkdGguXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFdpZHRoLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2xvci5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGluZSBjYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzTGluZUNhcHx1bmRlZmluZWR9IGxpbmVDYXAgTGluZSBjYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVDYXAobGluZUNhcCkge1xuICAgIHRoaXMubGluZUNhcF8gPSBsaW5lQ2FwO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGluZSBkYXNoLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58bnVsbH0gbGluZURhc2ggTGluZSBkYXNoLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMaW5lRGFzaChsaW5lRGFzaCkge1xuICAgIHRoaXMubGluZURhc2hfID0gbGluZURhc2g7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGxpbmVEYXNoT2Zmc2V0IExpbmUgZGFzaCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldF8gPSBsaW5lRGFzaE9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpbmUgam9pbi5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNMaW5lSm9pbnx1bmRlZmluZWR9IGxpbmVKb2luIExpbmUgam9pbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZUpvaW4obGluZUpvaW4pIHtcbiAgICB0aGlzLmxpbmVKb2luXyA9IGxpbmVKb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWl0ZXIgbGltaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gbWl0ZXJMaW1pdCBNaXRlciBsaW1pdC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWl0ZXJMaW1pdChtaXRlckxpbWl0KSB7XG4gICAgdGhpcy5taXRlckxpbWl0XyA9IG1pdGVyTGltaXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB3aWR0aC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB3aWR0aCBXaWR0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICB0aGlzLndpZHRoXyA9IHdpZHRoO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0cm9rZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvU3R5bGVcbiAqL1xuXG5pbXBvcnQgQ2lyY2xlU3R5bGUgZnJvbSAnLi9DaXJjbGUuanMnO1xuaW1wb3J0IEZpbGwgZnJvbSAnLi9GaWxsLmpzJztcbmltcG9ydCBTdHJva2UgZnJvbSAnLi9TdHJva2UuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIERlZmluZXMgaG93IHN5bWJvbHMgYW5kIHRleHQgYXJlIGRlY2x1dHRlcmVkIG9uIGxheWVycyBpdGggYGRlY2x1dHRlcmAgc2V0IHRvIGB0cnVlYFxuICogKiAqKmRlY2x1dHRlcioqOiBPdmVybGFwcGluZyBzeW1ib2xzIGFuZCB0ZXh0IGFyZSBkZWNsdXR0ZXJlZC5cbiAqICogKipvYnN0YWNsZSoqOiBTeW1ib2xzIGFuZCB0ZXh0IGFyZSByZW5kZXJlZCwgYnV0IHNlcnZlIGFzIG9ic3RhY2xlIGZvciBzdWJzZXF1ZW50IGF0dGVtcHRzXG4gKiAgIHRvIHBsYWNlIGEgc3ltYm9sIG9yIHRleHQgYXQgdGhlIHNhbWUgbG9jYXRpb24uXG4gKiAqICoqbm9uZSoqOiBObyBkZWNsdXR0ZXJpbmcgaXMgZG9uZS5cbiAqXG4gKiBAdHlwZWRlZiB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ9IERlY2x1dHRlck1vZGVcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlfSBhbmQgYSBge251bWJlcn1gXG4gKiByZXByZXNlbnRpbmcgdGhlIHZpZXcncyByZXNvbHV0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlfSBvciBhbiBhcnJheSBvZiB0aGVtLiBUaGlzIHdheSBlLmcuIGFcbiAqIHZlY3RvciBsYXllciBjYW4gYmUgc3R5bGVkLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlXG4gKiBmZWF0dXJlIHdpbGwgbm90IGJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlLCBudW1iZXIpOihTdHlsZXxBcnJheTxTdHlsZT58dm9pZCl9IFN0eWxlRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEge0BsaW5rIFN0eWxlfSwgYW4gYXJyYXkgb2Yge0BsaW5rIFN0eWxlfSwgb3IgYSB7QGxpbmsgU3R5bGVGdW5jdGlvbn0uXG4gKiBAdHlwZWRlZiB7U3R5bGV8QXJyYXk8U3R5bGU+fFN0eWxlRnVuY3Rpb259IFN0eWxlTGlrZVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnl+R2VvbWV0cnl9IHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhbmQgc3R5bGVkIGZvciB0aGUgZmVhdHVyZS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSk6XG4gKiAgICAgKGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZCl9IEdlb21ldHJ5RnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi4gVGFrZXMgdHdvIGFyZ3VtZW50czpcbiAqXG4gKiAxLiBUaGUgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIGdlb21ldHJ5IGluIEdlb0pTT04gbm90YXRpb24uXG4gKiAyLiBUaGUge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXJ+U3RhdGV9IG9mIHRoZSBsYXllciByZW5kZXJlci5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fEFycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+PiksaW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLlN0YXRlKTogdm9pZH0gUmVuZGVyRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufSBbZ2VvbWV0cnldIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnlcbiAqIG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlciBmb3IgdGhpcyBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IFtpbWFnZV0gSW1hZ2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge1JlbmRlckZ1bmN0aW9ufSBbcmVuZGVyZXJdIEN1c3RvbSByZW5kZXJlci4gV2hlbiBjb25maWd1cmVkLCBgZmlsbGAsIGBzdHJva2VgIGFuZCBgaW1hZ2VgIHdpbGwgYmVcbiAqIGlnbm9yZWQsIGFuZCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBlYWNoIHJlbmRlciBmcmFtZSBmb3IgZWFjaCBnZW9tZXRyeS5cbiAqIEBwcm9wZXJ0eSB7UmVuZGVyRnVuY3Rpb259IFtoaXREZXRlY3Rpb25SZW5kZXJlcl0gQ3VzdG9tIHJlbmRlcmVyIGZvciBoaXQgZGV0ZWN0aW9uLiBJZiBwcm92aWRlZCB3aWxsIGJlIHVzZWRcbiAqIGluIGhpdCBkZXRlY3Rpb24gcmVuZGVyaW5nLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbc3Ryb2tlXSBTdHJva2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVGV4dC5qc1wiKS5kZWZhdWx0fSBbdGV4dF0gVGV4dCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBaIGluZGV4LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ29udGFpbmVyIGZvciB2ZWN0b3IgZmVhdHVyZSByZW5kZXJpbmcgc3R5bGVzLiBBbnkgY2hhbmdlcyBtYWRlIHRvIHRoZSBzdHlsZVxuICogb3IgaXRzIGNoaWxkcmVuIHRocm91Z2ggYHNldCooKWAgbWV0aG9kcyB3aWxsIG5vdCB0YWtlIGVmZmVjdCB1bnRpbCB0aGVcbiAqIGZlYXR1cmUgb3IgbGF5ZXIgdGhhdCB1c2VzIHRoZSBzdHlsZSBpcyByZS1yZW5kZXJlZC5cbiAqXG4gKiAjIyBGZWF0dXJlIHN0eWxlc1xuICpcbiAqIElmIG5vIHN0eWxlIGlzIGRlZmluZWQsIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzdHlsZSBpcyB1c2VkOlxuICogYGBganNcbiAqICBpbXBvcnQge0NpcmNsZSwgRmlsbCwgU3Ryb2tlLCBTdHlsZX0gZnJvbSAnb2wvc3R5bGUuanMnO1xuICpcbiAqICBjb25zdCBmaWxsID0gbmV3IEZpbGwoe1xuICogICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknLFxuICogIH0pO1xuICogIGNvbnN0IHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICogICAgY29sb3I6ICcjMzM5OUNDJyxcbiAqICAgIHdpZHRoOiAxLjI1LFxuICogIH0pO1xuICogIGNvbnN0IHN0eWxlcyA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICBmaWxsOiBmaWxsLFxuICogICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICogICAgICAgIHJhZGl1czogNSxcbiAqICAgICAgfSksXG4gKiAgICAgIGZpbGw6IGZpbGwsXG4gKiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICogICAgfSksXG4gKiAgXTtcbiAqIGBgYFxuICpcbiAqIEEgc2VwYXJhdGUgZWRpdGluZyBzdHlsZSBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0czpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtDaXJjbGUsIEZpbGwsIFN0cm9rZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlLmpzJztcbiAqXG4gKiAgY29uc3Qgc3R5bGVzID0ge307XG4gKiAgY29uc3Qgd2hpdGUgPSBbMjU1LCAyNTUsIDI1NSwgMV07XG4gKiAgY29uc3QgYmx1ZSA9IFswLCAxNTMsIDI1NSwgMV07XG4gKiAgY29uc3Qgd2lkdGggPSAzO1xuICogIHN0eWxlc1snUG9seWdvbiddID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICogICAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NSwgMC41XSxcbiAqICAgICAgfSksXG4gKiAgICB9KSxcbiAqICBdO1xuICogIHN0eWxlc1snTXVsdGlQb2x5Z29uJ10gPVxuICogICAgICBzdHlsZXNbJ1BvbHlnb24nXTtcbiAqICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgY29sb3I6IHdoaXRlLFxuICogICAgICAgIHdpZHRoOiB3aWR0aCArIDIsXG4gKiAgICAgIH0pLFxuICogICAgfSksXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgIGNvbG9yOiBibHVlLFxuICogICAgICAgIHdpZHRoOiB3aWR0aCxcbiAqICAgICAgfSksXG4gKiAgICB9KSxcbiAqICBdO1xuICogIHN0eWxlc1snTXVsdGlMaW5lU3RyaW5nJ10gPSBzdHlsZXNbJ0xpbmVTdHJpbmcnXTtcbiAqXG4gKiAgc3R5bGVzWydDaXJjbGUnXSA9IHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChcbiAqICAgIHN0eWxlc1snTGluZVN0cmluZyddXG4gKiAgKTtcbiAqXG4gKiAgc3R5bGVzWydQb2ludCddID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICogICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICogICAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICAgIGNvbG9yOiBibHVlLFxuICogICAgICAgIH0pLFxuICogICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgICBjb2xvcjogd2hpdGUsXG4gKiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyLFxuICogICAgICAgIH0pLFxuICogICAgICB9KSxcbiAqICAgICAgekluZGV4OiBJbmZpbml0eSxcbiAqICAgIH0pLFxuICogIF07XG4gKiAgc3R5bGVzWydNdWx0aVBvaW50J10gPVxuICogICAgICBzdHlsZXNbJ1BvaW50J107XG4gKiAgc3R5bGVzWydHZW9tZXRyeUNvbGxlY3Rpb24nXSA9XG4gKiAgICAgIHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChcbiAqICAgICAgICAgIHN0eWxlc1snTGluZVN0cmluZyddLFxuICogICAgICAgICAgc3R5bGVzWydQb2ludCddXG4gKiAgICAgICk7XG4gKiBgYGBcbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIFN0eWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb258bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshR2VvbWV0cnlGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb247XG5cbiAgICBpZiAob3B0aW9ucy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldEdlb21ldHJ5KG9wdGlvbnMuZ2VvbWV0cnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gb3B0aW9ucy5pbWFnZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbWFnZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJGdW5jdGlvbnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXJfID0gb3B0aW9ucy5yZW5kZXJlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJlciA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJGdW5jdGlvbnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uUmVuZGVyZXJfID1cbiAgICAgIG9wdGlvbnMuaGl0RGV0ZWN0aW9uUmVuZGVyZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuaGl0RGV0ZWN0aW9uUmVuZGVyZXJcbiAgICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlXyA9IG9wdGlvbnMuc3Ryb2tlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cm9rZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGV4dCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuekluZGV4XyA9IG9wdGlvbnMuekluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge1N0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBsZXQgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5ICYmIHR5cGVvZiBnZW9tZXRyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHlsZSh7XG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnkgPz8gdW5kZWZpbmVkLFxuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgaW1hZ2U6IHRoaXMuZ2V0SW1hZ2UoKSA/IHRoaXMuZ2V0SW1hZ2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyZXI6IHRoaXMuZ2V0UmVuZGVyZXIoKSA/PyB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHQoKSA/IHRoaXMuZ2V0VGV4dCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICB6SW5kZXg6IHRoaXMuZ2V0WkluZGV4KCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gdGhhdCB3YXMgY29uZmlndXJlZCB3aXRoXG4gICAqIHtAbGluayAjc2V0UmVuZGVyZXJ9IG9yIHRoZSBgcmVuZGVyZXJgIGNvbnN0cnVjdG9yIG9wdGlvbi5cbiAgICogQHJldHVybiB7UmVuZGVyRnVuY3Rpb258bnVsbH0gQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl87XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiBmb3IgdGhpcyBzdHlsZS4gV2hlbiBzZXQsIGBmaWxsYCwgYHN0cm9rZWBcbiAgICogYW5kIGBpbWFnZWAgb3B0aW9ucyBvZiB0aGUgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge1JlbmRlckZ1bmN0aW9ufG51bGx9IHJlbmRlcmVyIEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyXyA9IHJlbmRlcmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gZm9yIHRoaXMgc3R5bGUgdXNlZFxuICAgKiBpbiBoaXQgZGV0ZWN0aW9uLlxuICAgKiBAcGFyYW0ge1JlbmRlckZ1bmN0aW9ufG51bGx9IHJlbmRlcmVyIEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0SGl0RGV0ZWN0aW9uUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLmhpdERldGVjdGlvblJlbmRlcmVyXyA9IHJlbmRlcmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIHRoYXQgd2FzIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiB7QGxpbmsgI3NldEhpdERldGVjdGlvblJlbmRlcmVyfSBvciB0aGUgYGhpdERldGVjdGlvblJlbmRlcmVyYCBjb25zdHJ1Y3RvciBvcHRpb24uXG4gICAqIEByZXR1cm4ge1JlbmRlckZ1bmN0aW9ufG51bGx9IEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uUmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZ2VvbWV0cnkgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbnxudWxsfVxuICAgKiBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZ2VvbWV0cnkgdGhhdCB3aWxsXG4gICAqIGJlIHJlbmRlcmVkIHdpdGggdGhpcyBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIGdlb21ldHJ5IGZvciByZW5kZXJpbmcuXG4gICAqIEByZXR1cm4geyFHZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGEgZmVhdHVyZVxuICAgKiBhbmQgcmV0dXJucyB0aGUgZ2VvbWV0cnkgdG8gcmVuZGVyIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnlGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmaWxsIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IGZpbGwgRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RmlsbChmaWxsKSB7XG4gICAgdGhpcy5maWxsXyA9IGZpbGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fG51bGx9IEltYWdlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlIEltYWdlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRJbWFnZShpbWFnZSkge1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH0gU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0cm9rZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IHN0cm9rZSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFN0cm9rZShzdHJva2UpIHtcbiAgICB0aGlzLnN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdHxudWxsfSBUZXh0IHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dCBUZXh0IHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUZXh0KHRleHQpIHtcbiAgICB0aGlzLnRleHRfID0gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHotaW5kZXggZm9yIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gWkluZGV4LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuekluZGV4XztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBnZW9tZXRyeSB0aGF0IGlzIHJlbmRlcmVkIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb259IGdlb21ldHJ5XG4gICAqICAgICBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5IG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlclxuICAgKiAgICAgZm9yIHRoaXMgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGdlb21ldHJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdlb21ldHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGZlYXR1cmUuZ2V0KGdlb21ldHJ5KVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFnZW9tZXRyeSkge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5nZW9tZXRyeV8gPSBnZW9tZXRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHotaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gekluZGV4IFpJbmRleC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0WkluZGV4KHpJbmRleCkge1xuICAgIHRoaXMuekluZGV4XyA9IHpJbmRleDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3ZpZGVkIG9iamVjdCBpbnRvIGEgc3R5bGUgZnVuY3Rpb24uICBGdW5jdGlvbnMgcGFzc2VkIHRocm91Z2hcbiAqIHVuY2hhbmdlZC4gIEFycmF5cyBvZiBTdHlsZSBvciBzaW5nbGUgc3R5bGUgb2JqZWN0cyB3cmFwcGVkIGluIGFcbiAqIG5ldyBzdHlsZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3R5bGVGdW5jdGlvbnxBcnJheTxTdHlsZT58U3R5bGV9IG9ialxuICogICAgIEEgc3R5bGUgZnVuY3Rpb24sIGEgc2luZ2xlIHN0eWxlLCBvciBhbiBhcnJheSBvZiBzdHlsZXMuXG4gKiBAcmV0dXJuIHtTdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GdW5jdGlvbihvYmopIHtcbiAgbGV0IHN0eWxlRnVuY3Rpb247XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHlsZUZ1bmN0aW9uID0gb2JqO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdHlsZT59XG4gICAgICovXG4gICAgbGV0IHN0eWxlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBzdHlsZXMgPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvYmopLmdldFpJbmRleCkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBhbiBgU3R5bGVgIG9yIGFuIGFycmF5IG9mIGBTdHlsZWAnLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtTdHlsZX0gKi8gKG9iaik7XG4gICAgICBzdHlsZXMgPSBbc3R5bGVdO1xuICAgIH1cbiAgICBzdHlsZUZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdHlsZUZ1bmN0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxTdHlsZT58bnVsbH1cbiAqL1xubGV0IGRlZmF1bHRTdHlsZXMgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PFN0eWxlPn0gU3R5bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0U3R5bGUoZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAvLyBXZSBkb24ndCB1c2UgYW4gaW1tZWRpYXRlbHktaW52b2tlZCBmdW5jdGlvblxuICAvLyBhbmQgYSBjbG9zdXJlIHNvIHdlIGRvbid0IGdldCBhbiBlcnJvciBhdCBzY3JpcHQgZXZhbHVhdGlvbiB0aW1lIGluXG4gIC8vIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgQ2FudmFzLiAoaW1wb3J0KFwiLi9DaXJjbGUuanNcIikuQ2lyY2xlU3R5bGUgZG9lc1xuICAvLyBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhdCBjb25zdHJ1Y3Rpb24gdGltZSwgd2hpY2ggd2lsbCBjYXVzZSBhbi5lcnJvclxuICAvLyBpbiBzdWNoIGJyb3dzZXJzLilcbiAgaWYgKCFkZWZhdWx0U3R5bGVzKSB7XG4gICAgY29uc3QgZmlsbCA9IG5ldyBGaWxsKHtcbiAgICAgIGNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyxcbiAgICB9KTtcbiAgICBjb25zdCBzdHJva2UgPSBuZXcgU3Ryb2tlKHtcbiAgICAgIGNvbG9yOiAnIzMzOTlDQycsXG4gICAgICB3aWR0aDogMS4yNSxcbiAgICB9KTtcbiAgICBkZWZhdWx0U3R5bGVzID0gW1xuICAgICAgbmV3IFN0eWxlKHtcbiAgICAgICAgaW1hZ2U6IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICByYWRpdXM6IDUsXG4gICAgICAgIH0pLFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIH0pLFxuICAgIF07XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTdHlsZXM7XG59XG5cbi8qKlxuICogRGVmYXVsdCBzdHlsZXMgZm9yIGVkaXRpbmcgZmVhdHVyZXMuXG4gKiBAcmV0dXJuIHtPYmplY3Q8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5UeXBlLCBBcnJheTxTdHlsZT4+fSBTdHlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVkaXRpbmdTdHlsZSgpIHtcbiAgLyoqIEB0eXBlIHtPYmplY3Q8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5UeXBlLCBBcnJheTxTdHlsZT4+fSAqL1xuICBjb25zdCBzdHlsZXMgPSB7fTtcbiAgY29uc3Qgd2hpdGUgPSBbMjU1LCAyNTUsIDI1NSwgMV07XG4gIGNvbnN0IGJsdWUgPSBbMCwgMTUzLCAyNTUsIDFdO1xuICBjb25zdCB3aWR0aCA9IDM7XG4gIHN0eWxlc1snUG9seWdvbiddID0gW1xuICAgIG5ldyBTdHlsZSh7XG4gICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NSwgMC41XSxcbiAgICAgIH0pLFxuICAgIH0pLFxuICBdO1xuICBzdHlsZXNbJ011bHRpUG9seWdvbiddID0gc3R5bGVzWydQb2x5Z29uJ107XG5cbiAgc3R5bGVzWydMaW5lU3RyaW5nJ10gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgMixcbiAgICAgIH0pLFxuICAgIH0pLFxuICAgIG5ldyBTdHlsZSh7XG4gICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICBjb2xvcjogYmx1ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgfSksXG4gICAgfSksXG4gIF07XG4gIHN0eWxlc1snTXVsdGlMaW5lU3RyaW5nJ10gPSBzdHlsZXNbJ0xpbmVTdHJpbmcnXTtcblxuICBzdHlsZXNbJ0NpcmNsZSddID0gc3R5bGVzWydQb2x5Z29uJ10uY29uY2F0KHN0eWxlc1snTGluZVN0cmluZyddKTtcblxuICBzdHlsZXNbJ1BvaW50J10gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgICByYWRpdXM6IHdpZHRoICogMixcbiAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICAgICAgICAgIGNvbG9yOiBibHVlLFxuICAgICAgICB9KSxcbiAgICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgICBjb2xvcjogd2hpdGUsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoIC8gMixcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICAgIHpJbmRleDogSW5maW5pdHksXG4gICAgfSksXG4gIF07XG4gIHN0eWxlc1snTXVsdGlQb2ludCddID0gc3R5bGVzWydQb2ludCddO1xuXG4gIHN0eWxlc1snR2VvbWV0cnlDb2xsZWN0aW9uJ10gPSBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoXG4gICAgc3R5bGVzWydMaW5lU3RyaW5nJ10sXG4gICAgc3R5bGVzWydQb2ludCddLFxuICApO1xuXG4gIHJldHVybiBzdHlsZXM7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhIGZlYXR1cmUgYW5kIHJldHVybnMgaXRzIGRlZmF1bHQgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZSB0byBnZXQgdGhlIGdlb21ldHJ5IGZvci5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gR2VvbWV0cnkgdG8gcmVuZGVyLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0R2VvbWV0cnlGdW5jdGlvbihmZWF0dXJlKSB7XG4gIHJldHVybiBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0eWxlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JY29uXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRJY29uSW1hZ2V9IGZyb20gJy4vSWNvbkltYWdlLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J2ZyYWN0aW9uJyB8ICdwaXhlbHMnfSBJY29uQW5jaG9yVW5pdHNcbiAqIEFuY2hvciB1bml0IGNhbiBiZSBlaXRoZXIgYSBmcmFjdGlvbiBvZiB0aGUgaWNvbiBzaXplIG9yIGluIHBpeGVscy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1yaWdodCcgfCAndG9wLWxlZnQnIHwgJ3RvcC1yaWdodCd9IEljb25PcmlnaW5cbiAqIEljb24gb3JpZ2luLiBPbmUgb2YgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbYW5jaG9yPVswLjUsIDAuNV1dIEFuY2hvci4gRGVmYXVsdCB2YWx1ZSBpcyB0aGUgaWNvbiBjZW50ZXIuXG4gKiBAcHJvcGVydHkge0ljb25PcmlnaW59IFthbmNob3JPcmlnaW49J3RvcC1sZWZ0J10gT3JpZ2luIG9mIHRoZSBhbmNob3I6IGBib3R0b20tbGVmdGAsIGBib3R0b20tcmlnaHRgLFxuICogYHRvcC1sZWZ0YCBvciBgdG9wLXJpZ2h0YC5cbiAqIEBwcm9wZXJ0eSB7SWNvbkFuY2hvclVuaXRzfSBbYW5jaG9yWFVuaXRzPSdmcmFjdGlvbiddIFVuaXRzIGluIHdoaWNoIHRoZSBhbmNob3IgeCB2YWx1ZSBpc1xuICogc3BlY2lmaWVkLiBBIHZhbHVlIG9mIGAnZnJhY3Rpb24nYCBpbmRpY2F0ZXMgdGhlIHggdmFsdWUgaXMgYSBmcmFjdGlvbiBvZiB0aGUgaWNvbi4gQSB2YWx1ZSBvZiBgJ3BpeGVscydgIGluZGljYXRlc1xuICogdGhlIHggdmFsdWUgaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtJY29uQW5jaG9yVW5pdHN9IFthbmNob3JZVW5pdHM9J2ZyYWN0aW9uJ10gVW5pdHMgaW4gd2hpY2ggdGhlIGFuY2hvciB5IHZhbHVlIGlzXG4gKiBzcGVjaWZpZWQuIEEgdmFsdWUgb2YgYCdmcmFjdGlvbidgIGluZGljYXRlcyB0aGUgeSB2YWx1ZSBpcyBhIGZyYWN0aW9uIG9mIHRoZSBpY29uLiBBIHZhbHVlIG9mIGAncGl4ZWxzJ2AgaW5kaWNhdGVzXG4gKiB0aGUgeSB2YWx1ZSBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ30gW2NvbG9yXSBDb2xvciB0byB0aW50IHRoZSBpY29uLiBJZiBub3Qgc3BlY2lmaWVkLFxuICogdGhlIGljb24gd2lsbCBiZSBsZWZ0IGFzIGlzLlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuIE5vdGUgdGhhdCB5b3UgbXVzdCBwcm92aWRlIGFcbiAqIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gW2ltZ10gSW1hZ2Ugb2JqZWN0IGZvciB0aGUgaWNvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwgMF1dIERpc3BsYWNlbWVudCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuXG4gKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBzaGlmdCB0aGUgaWNvbiByaWdodCBhbmQgdXAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSBvZiB0aGUgaWNvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIFRoZSB3aWR0aCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuIFRoaXMgY2FuJ3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIGBzY2FsZWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gVGhlIGhlaWdodCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuIFRoaXMgY2FuJ3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIGBzY2FsZWAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZT0xXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgaWNvbiB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbb2Zmc2V0PVswLCAwXV0gT2Zmc2V0IHdoaWNoLCB0b2dldGhlciB3aXRoIGBzaXplYCBhbmQgYG9mZnNldE9yaWdpbmAsIGRlZmluZXMgdGhlXG4gKiBzdWItcmVjdGFuZ2xlIHRvIHVzZSBmcm9tIHRoZSBvcmlnaW5hbCAoc3ByaXRlKSBpbWFnZS5cbiAqIEBwcm9wZXJ0eSB7SWNvbk9yaWdpbn0gW29mZnNldE9yaWdpbj0ndG9wLWxlZnQnXSBPcmlnaW4gb2YgdGhlIG9mZnNldDogYGJvdHRvbS1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsXG4gKiBgdG9wLWxlZnRgIG9yIGB0b3AtcmlnaHRgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBJY29uIHNpemUgaW4gcGl4ZWxzLiBVc2VkIHRvZ2V0aGVyIHdpdGggYG9mZnNldGAgdG8gZGVmaW5lIHRoZVxuICogc3ViLXJlY3RhbmdsZSB0byB1c2UgZnJvbSB0aGUgb3JpZ2luYWwgKHNwcml0ZSkgaW1hZ2UuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NyY10gSW1hZ2Ugc291cmNlIFVSSS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHlsZS5qc1wiKS5EZWNsdXR0ZXJNb2RlfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGUuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB3YW50ZWRXaWR0aCBUaGUgd2FudGVkIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB3YW50ZWRIZWlnaHQgVGhlIHdhbnRlZCBoZWlnaHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ8QXJyYXk8bnVtYmVyPn0gVGhlIHNjYWxlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTY2FsZSh3aWR0aCwgaGVpZ2h0LCB3YW50ZWRXaWR0aCwgd2FudGVkSGVpZ2h0KSB7XG4gIGlmICh3YW50ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIHdhbnRlZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt3YW50ZWRXaWR0aCAvIHdpZHRoLCB3YW50ZWRIZWlnaHQgLyBoZWlnaHRdO1xuICB9XG4gIGlmICh3YW50ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHdhbnRlZFdpZHRoIC8gd2lkdGg7XG4gIH1cbiAgaWYgKHdhbnRlZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHdhbnRlZEhlaWdodCAvIGhlaWdodDtcbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgaWNvbiBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBJY29uIGV4dGVuZHMgSW1hZ2VTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCBvcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYWNpdHkgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0ZVdpdGhWaWV3ID1cbiAgICAgIG9wdGlvbnMucm90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlV2l0aFZpZXcgOiBmYWxzZTtcblxuICAgIHN1cGVyKHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBkaXNwbGFjZW1lbnQ6XG4gICAgICAgIG9wdGlvbnMuZGlzcGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRpc3BsYWNlbWVudCA6IFswLCAwXSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlldyxcbiAgICAgIGRlY2x1dHRlck1vZGU6IG9wdGlvbnMuZGVjbHV0dGVyTW9kZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gb3B0aW9ucy5hbmNob3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5jaG9yIDogWzAuNSwgMC41XTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtJY29uT3JpZ2lufVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9XG4gICAgICBvcHRpb25zLmFuY2hvck9yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JPcmlnaW4gOiAndG9wLWxlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbkFuY2hvclVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWFVuaXRzXyA9XG4gICAgICBvcHRpb25zLmFuY2hvclhVbml0cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JYVW5pdHMgOiAnZnJhY3Rpb24nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbkFuY2hvclVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWVVuaXRzXyA9XG4gICAgICBvcHRpb25zLmFuY2hvcllVbml0cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JZVW5pdHMgOiAnZnJhY3Rpb24nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNyb3NzT3JpZ2luIDogbnVsbDtcblxuICAgIGNvbnN0IGltYWdlID0gb3B0aW9ucy5pbWcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW1nIDogbnVsbDtcblxuICAgIGxldCBjYWNoZUtleSA9IG9wdGlvbnMuc3JjO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgIShjYWNoZUtleSAhPT0gdW5kZWZpbmVkICYmIGltYWdlKSxcbiAgICAgICdgaW1hZ2VgIGFuZCBgc3JjYCBjYW5ub3QgYmUgcHJvdmlkZWQgYXQgdGhlIHNhbWUgdGltZScsXG4gICAgKTtcblxuICAgIGlmICgoY2FjaGVLZXkgPT09IHVuZGVmaW5lZCB8fCBjYWNoZUtleS5sZW5ndGggPT09IDApICYmIGltYWdlKSB7XG4gICAgICBjYWNoZUtleSA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKGltYWdlKS5zcmMgfHwgZ2V0VWlkKGltYWdlKTtcbiAgICB9XG4gICAgYXNzZXJ0KFxuICAgICAgY2FjaGVLZXkgIT09IHVuZGVmaW5lZCAmJiBjYWNoZUtleS5sZW5ndGggPiAwLFxuICAgICAgJ0EgZGVmaW5lZCBhbmQgbm9uLWVtcHR5IGBzcmNgIG9yIGBpbWFnZWAgbXVzdCBiZSBwcm92aWRlZCcsXG4gICAgKTtcblxuICAgIGFzc2VydChcbiAgICAgICEoXG4gICAgICAgIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkXG4gICAgICApLFxuICAgICAgJ2B3aWR0aGAgb3IgYGhlaWdodGAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyIHdpdGggYHNjYWxlYCcsXG4gICAgKTtcblxuICAgIGxldCBpbWFnZVN0YXRlO1xuICAgIGlmIChvcHRpb25zLnNyYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbWFnZVN0YXRlID0gSW1hZ2VTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSBpZiAoaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdjb21wbGV0ZScgaW4gaW1hZ2UpIHtcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlLnNyYyA/IEltYWdlU3RhdGUuTE9BREVEIDogSW1hZ2VTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltYWdlU3RhdGUgPSBJbWFnZVN0YXRlLkxPQURJTkc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlU3RhdGUgPSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGFzQXJyYXkob3B0aW9ucy5jb2xvcikgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmljb25JbWFnZV8gPSBnZXRJY29uSW1hZ2UoXG4gICAgICBpbWFnZSxcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY2FjaGVLZXkpLFxuICAgICAgdGhpcy5jcm9zc09yaWdpbl8sXG4gICAgICBpbWFnZVN0YXRlLFxuICAgICAgdGhpcy5jb2xvcl8sXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRfID0gb3B0aW9ucy5vZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0IDogWzAsIDBdO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0ljb25PcmlnaW59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRPcmlnaW5fID1cbiAgICAgIG9wdGlvbnMub2Zmc2V0T3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldE9yaWdpbiA6ICd0b3AtbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaXplIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbml0aWFsT3B0aW9uc187XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNjYWxlIGlmIHdpZHRoIG9yIGhlaWdodCB3ZXJlIGdpdmVuLlxuICAgICAqL1xuICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgICBpZiAob3B0aW9ucy5zaXplKSB7XG4gICAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IG9wdGlvbnMuc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5nZXRJbWFnZSgxKTtcbiAgICAgICAgaWYgKGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodCkge1xuICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbE9wdGlvbnNfID0gb3B0aW9ucztcbiAgICAgICAgICBjb25zdCBvbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVubGlzdGVuSW1hZ2VDaGFuZ2Uob25sb2FkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbml0aWFsT3B0aW9uc18pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW1hZ2VTaXplID0gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NhbGUoXG4gICAgICAgICAgICAgIGNhbGN1bGF0ZVNjYWxlKFxuICAgICAgICAgICAgICAgIGltYWdlU2l6ZVswXSxcbiAgICAgICAgICAgICAgICBpbWFnZVNpemVbMV0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxpc3RlbkltYWdlQ2hhbmdlKG9ubG9hZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFNjYWxlKFxuICAgICAgICAgIGNhbGN1bGF0ZVNjYWxlKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS4gVGhlIHVuZGVybHlpbmcgSW1hZ2UvSFRNTENhbnZhc0VsZW1lbnQgaXMgbm90IGNsb25lZC5cbiAgICogQHJldHVybiB7SWNvbn0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGxldCBzY2FsZSwgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAodGhpcy5pbml0aWFsT3B0aW9uc18pIHtcbiAgICAgIHdpZHRoID0gdGhpcy5pbml0aWFsT3B0aW9uc18ud2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmluaXRpYWxPcHRpb25zXy5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgICAgc2NhbGUgPSBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJY29uKHtcbiAgICAgIGFuY2hvcjogdGhpcy5hbmNob3JfLnNsaWNlKCksXG4gICAgICBhbmNob3JPcmlnaW46IHRoaXMuYW5jaG9yT3JpZ2luXyxcbiAgICAgIGFuY2hvclhVbml0czogdGhpcy5hbmNob3JYVW5pdHNfLFxuICAgICAgYW5jaG9yWVVuaXRzOiB0aGlzLmFuY2hvcllVbml0c18sXG4gICAgICBjb2xvcjpcbiAgICAgICAgdGhpcy5jb2xvcl8gJiYgdGhpcy5jb2xvcl8uc2xpY2VcbiAgICAgICAgICA/IHRoaXMuY29sb3JfLnNsaWNlKClcbiAgICAgICAgICA6IHRoaXMuY29sb3JfIHx8IHVuZGVmaW5lZCxcbiAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luXyxcbiAgICAgIG9mZnNldDogdGhpcy5vZmZzZXRfLnNsaWNlKCksXG4gICAgICBvZmZzZXRPcmlnaW46IHRoaXMub2Zmc2V0T3JpZ2luXyxcbiAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICBzY2FsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgc2l6ZTogdGhpcy5zaXplXyAhPT0gbnVsbCA/IHRoaXMuc2l6ZV8uc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4gICAqIHN5bWJvbGl6ZXIuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuY2hvci5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEFuY2hvcigpIHtcbiAgICBsZXQgYW5jaG9yID0gdGhpcy5ub3JtYWxpemVkQW5jaG9yXztcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmFuY2hvclhVbml0c18gPT0gJ2ZyYWN0aW9uJyB8fFxuICAgICAgICB0aGlzLmFuY2hvcllVbml0c18gPT0gJ2ZyYWN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFuY2hvciA9IHRoaXMuYW5jaG9yXy5zbGljZSgpO1xuICAgICAgICBpZiAodGhpcy5hbmNob3JYVW5pdHNfID09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBhbmNob3JbMF0gKj0gc2l6ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbmNob3JZVW5pdHNfID09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICBhbmNob3JbMV0gKj0gc2l6ZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hbmNob3JPcmlnaW5fICE9ICd0b3AtbGVmdCcpIHtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvciA9PT0gdGhpcy5hbmNob3JfKSB7XG4gICAgICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAndG9wLXJpZ2h0JyB8fFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgICApIHtcbiAgICAgICAgICBhbmNob3JbMF0gPSAtYW5jaG9yWzBdICsgc2l6ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5hbmNob3JPcmlnaW5fID09ICdib3R0b20tbGVmdCcgfHxcbiAgICAgICAgICB0aGlzLmFuY2hvck9yaWdpbl8gPT0gJ2JvdHRvbS1yaWdodCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgYW5jaG9yWzFdID0gLWFuY2hvclsxXSArIHNpemVbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubm9ybWFsaXplZEFuY2hvcl8gPSBhbmNob3I7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCk7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlQXJyYXkoKTtcbiAgICAvLyBhbmNob3IgaXMgc2NhbGVkIGJ5IHJlbmRlcmVyIGJ1dCBkaXNwbGFjZW1lbnQgc2hvdWxkIG5vdCBiZSBzY2FsZWRcbiAgICAvLyBzbyBkaXZpZGUgYnkgc2NhbGUgaGVyZVxuICAgIHJldHVybiBbXG4gICAgICBhbmNob3JbMF0gLSBkaXNwbGFjZW1lbnRbMF0gLyBzY2FsZVswXSxcbiAgICAgIGFuY2hvclsxXSArIGRpc3BsYWNlbWVudFsxXSAvIHNjYWxlWzFdLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAgICogc3ltYm9saXplci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgQW5jaG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBbmNob3IoYW5jaG9yKSB7XG4gICAgdGhpcy5hbmNob3JfID0gYW5jaG9yO1xuICAgIHRoaXMubm9ybWFsaXplZEFuY2hvcl8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWNvbiBjb2xvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBpY29uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2Ugb3IgQ2FudmFzIGVsZW1lbnQuIElmIHRoZSBJY29uXG4gICAqIHN0eWxlIHdhcyBjb25maWd1cmVkIHdpdGggYHNyY2Agb3Igd2l0aCBhIG5vdCBsZXQgbG9hZGVkIGBpbWdgLCBhbiBgSW1hZ2VCaXRtYXBgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRJbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRJbWFnZShwaXhlbFJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIGltYWdlLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRJbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRJbWFnZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2VTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IEltYWdlIGVsZW1lbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRIaXREZXRlY3Rpb25JbWFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIG9mIHRoZSBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luXykge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0XztcblxuICAgIGlmICh0aGlzLm9mZnNldE9yaWdpbl8gIT0gJ3RvcC1sZWZ0Jykge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgY29uc3QgaWNvbkltYWdlU2l6ZSA9IHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCk7XG4gICAgICBpZiAoIXNpemUgfHwgIWljb25JbWFnZVNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSBvZmZzZXQuc2xpY2UoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vZmZzZXRPcmlnaW5fID09ICd0b3AtcmlnaHQnIHx8XG4gICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgKSB7XG4gICAgICAgIG9mZnNldFswXSA9IGljb25JbWFnZVNpemVbMF0gLSBzaXplWzBdIC0gb2Zmc2V0WzBdO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ2JvdHRvbS1sZWZ0JyB8fFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ2JvdHRvbS1yaWdodCdcbiAgICAgICkge1xuICAgICAgICBvZmZzZXRbMV0gPSBpY29uSW1hZ2VTaXplWzFdIC0gc2l6ZVsxXSAtIG9mZnNldFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vcmlnaW5fID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBVUkwuXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IEltYWdlIHNyYy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3JjKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0U3JjKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBpY29uIChpbiBwaXhlbHMpLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIHJldHVybiAhdGhpcy5zaXplXyA/IHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCkgOiB0aGlzLnNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGljb24gKGluIHBpeGVscykuIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCB3aGVuIHRoZSBpY29uIGltYWdlIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEljb24gd2lkdGggKGluIHBpeGVscykuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZUFycmF5KCk7XG4gICAgaWYgKHRoaXMuc2l6ZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemVfWzBdICogc2NhbGVbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2VTdGF0ZSgpID09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKVswXSAqIHNjYWxlWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBpY29uIChpbiBwaXhlbHMpLiBXaWxsIHJldHVybiB1bmRlZmluZWQgd2hlbiB0aGUgaWNvbiBpbWFnZSBpcyBub3QgeWV0IGxvYWRlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJY29uIGhlaWdodCAoaW4gcGl4ZWxzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZUFycmF5KCk7XG4gICAgaWYgKHRoaXMuc2l6ZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemVfWzFdICogc2NhbGVbMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2VTdGF0ZSgpID09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKVsxXSAqIHNjYWxlWzFdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIGRlbGV0ZSB0aGlzLmluaXRpYWxPcHRpb25zXztcbiAgICBzdXBlci5zZXRTY2FsZShzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5pY29uSW1hZ2VfLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBXaGVuIHJlbmRlcmluZyBhIGZlYXR1cmUgd2l0aCBhbiBpY29uIHN0eWxlLCB0aGUgdmVjdG9yIHJlbmRlcmVyIHdpbGxcbiAgICogYXV0b21hdGljYWxseSBjYWxsIHRoaXMgbWV0aG9kLiBIb3dldmVyLCB5b3UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXNcbiAgICogbWV0aG9kIHlvdXJzZWxmIGZvciBwcmVsb2FkaW5nIG9yIG90aGVyIHB1cnBvc2VzLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICB0aGlzLmljb25JbWFnZV8ubG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5pY29uSW1hZ2VfLnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5yZWFkeSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1RleHRcbiAqL1xuaW1wb3J0IEZpbGwgZnJvbSAnLi9GaWxsLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3BvaW50JyB8ICdsaW5lJ30gVGV4dFBsYWNlbWVudFxuICogRGVmYXVsdCB0ZXh0IHBsYWNlbWVudCBpcyBgJ3BvaW50J2AuIE5vdGUgdGhhdFxuICogYCdsaW5lJ2AgcmVxdWlyZXMgdGhlIHVuZGVybHlpbmcgZ2VvbWV0cnkgdG8gYmUgYSB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTGluZVN0cmluZ35MaW5lU3RyaW5nfSxcbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9Qb2x5Z29uflBvbHlnb259LCB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlMaW5lU3RyaW5nfk11bHRpTGluZVN0cmluZ30gb3JcbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aVBvbHlnb25+TXVsdGlQb2x5Z29ufS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCd9IFRleHRKdXN0aWZ5XG4gKi9cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmaWxsIGNvbG9yIHRvIHVzZSBpZiBubyBmaWxsIHdhcyBzZXQgYXQgY29uc3RydWN0aW9uIHRpbWU7IGFcbiAqIGJsYWNraXNoIGAjMzMzYC5cbiAqXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuY29uc3QgREVGQVVMVF9GSUxMX0NPTE9SID0gJyMzMzMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udF0gRm9udCBzdHlsZSBhcyBDU1MgYGZvbnRgIHZhbHVlLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZvbnQuIERlZmF1bHQgaXMgYCcxMHB4IHNhbnMtc2VyaWYnYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhBbmdsZT1NYXRoLlBJLzRdIFdoZW4gYHBsYWNlbWVudGAgaXMgc2V0IHRvIGAnbGluZSdgLCBhbGxvdyBhIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICogVGhlIGV4cGVjdGVkIHZhbHVlIGlzIGluIHJhZGlhbnMsIGFuZCB0aGUgZGVmYXVsdCBpcyA0NVx1MDBCMCAoYE1hdGguUEkgLyA0YCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldFg9MF0gSG9yaXpvbnRhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCByaWdodC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0WT0wXSBWZXJ0aWNhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCBkb3duLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3c9ZmFsc2VdIEZvciBwb2x5Z29uIGxhYmVscyBvciB3aGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYCwgYWxsb3cgdGV4dCB0byBleGNlZWRcbiAqIHRoZSB3aWR0aCBvZiB0aGUgcG9seWdvbiBhdCB0aGUgbGFiZWwgcG9zaXRpb24gb3IgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gKiBAcHJvcGVydHkge1RleHRQbGFjZW1lbnR9IFtwbGFjZW1lbnQ9J3BvaW50J10gVGV4dCBwbGFjZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcGVhdF0gUmVwZWF0IGludGVydmFsLiBXaGVuIHNldCwgdGhlIHRleHQgd2lsbCBiZSByZXBlYXRlZCBhdCB0aGlzIGludGVydmFsLCB3aGljaCBzcGVjaWZpZXNcbiAqIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0ZXh0IGFuY2hvcnMgaW4gcGl4ZWxzLiBPbmx5IGF2YWlsYWJsZSB3aGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYC4gT3ZlcnJpZGVzICd0ZXh0QWxpZ24nLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGVdIFNjYWxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSB0ZXh0IHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnMgKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSkuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBbdGV4dF0gVGV4dCBjb250ZW50IG9yIHJpY2ggdGV4dCBjb250ZW50LiBGb3IgcGxhaW4gdGV4dCBwcm92aWRlIGEgc3RyaW5nLCB3aGljaCBjYW5cbiAqIGNvbnRhaW4gbGluZSBicmVha3MgKGBcXG5gKS4gRm9yIHJpY2ggdGV4dCBwcm92aWRlIGFuIGFycmF5IG9mIHRleHQvZm9udCB0dXBsZXMuIEEgdHVwbGUgY29uc2lzdHMgb2YgdGhlIHRleHQgdG9cbiAqIHJlbmRlciBhbmQgdGhlIGZvbnQgdG8gdXNlIChvciBgJydgIHRvIHVzZSB0aGUgdGV4dCBzdHlsZSdzIGZvbnQpLiBBIGxpbmUgYnJlYWsgaGFzIHRvIGJlIGEgc2VwYXJhdGUgdHVwbGUgKGkuZS4gYCdcXG4nLCAnJ2ApLlxuICogKipFeGFtcGxlOioqIGBbJ2ZvbycsICdib2xkIDEwcHggc2Fucy1zZXJpZicsICcgYmFyJywgJ2l0YWxpYyAxMHB4IHNhbnMtc2VyaWYnLCAnIGJheicsICcnXWAgd2lsbCB5aWVsZCBcIioqZm9vKiogKmJhciogYmF6XCIuXG4gKiAqKk5vdGU6KiogUmljaCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2Agb3IgdGhlIGltbWVkaWF0ZSByZW5kZXJpbmcgQVBJLlxuICogQHByb3BlcnR5IHtDYW52YXNUZXh0QWxpZ259IFt0ZXh0QWxpZ25dIFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IGAnbGVmdCdgLCBgJ3JpZ2h0J2AsIGAnY2VudGVyJ2AsIGAnZW5kJ2Agb3IgYCdzdGFydCdgLlxuICogRGVmYXVsdCBpcyBgJ2NlbnRlcidgIGZvciBgcGxhY2VtZW50OiAncG9pbnQnYC4gRm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2AsIHRoZSBkZWZhdWx0IGlzIHRvIGxldCB0aGUgcmVuZGVyZXIgY2hvb3NlIGFcbiAqIHBsYWNlbWVudCB3aGVyZSBgbWF4QW5nbGVgIGlzIG5vdCBleGNlZWRlZC5cbiAqIEBwcm9wZXJ0eSB7VGV4dEp1c3RpZnl9IFtqdXN0aWZ5XSBUZXh0IGp1c3RpZmljYXRpb24gd2l0aGluIHRoZSB0ZXh0IGJveC5cbiAqIElmIG5vdCBzZXQsIHRleHQgaXMganVzdGlmaWVkIHRvd2FyZHMgdGhlIGB0ZXh0QWxpZ25gIGFuY2hvci5cbiAqIE90aGVyd2lzZSwgdXNlIG9wdGlvbnMgYCdsZWZ0J2AsIGAnY2VudGVyJ2AsIG9yIGAncmlnaHQnYCB0byBqdXN0aWZ5IHRoZSB0ZXh0IHdpdGhpbiB0aGUgdGV4dCBib3guXG4gKiAqKk5vdGU6KiogYGp1c3RpZnlgIGlzIGlnbm9yZWQgZm9yIGltbWVkaWF0ZSByZW5kZXJpbmcgYW5kIGFsc28gZm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2AuXG4gKiBAcHJvcGVydHkge0NhbnZhc1RleHRCYXNlbGluZX0gW3RleHRCYXNlbGluZT0nbWlkZGxlJ10gVGV4dCBiYXNlIGxpbmUuIFBvc3NpYmxlIHZhbHVlczogYCdib3R0b20nYCwgYCd0b3AnYCwgYCdtaWRkbGUnYCwgYCdhbHBoYWJldGljJ2AsXG4gKiBgJ2hhbmdpbmcnYCwgYCdpZGVvZ3JhcGhpYydgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfSBbZmlsbF0gRmlsbCBzdHlsZS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgd2UnbGwgdXNlIGEgZGFyayBmaWxsLXN0eWxlICgjMzMzKS4gU3BlY2lmeSBgbnVsbGAgZm9yIG5vIGZpbGwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kRmlsbF0gRmlsbCBzdHlsZSBmb3IgdGhlIHRleHQgYmFja2dyb3VuZCB3aGVuIGBwbGFjZW1lbnRgIGlzXG4gKiBgJ3BvaW50J2AuIERlZmF1bHQgaXMgbm8gZmlsbC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRTdHJva2VdIFN0cm9rZSBzdHlsZSBmb3IgdGhlIHRleHQgYmFja2dyb3VuZCAgd2hlbiBgcGxhY2VtZW50YFxuICogaXMgYCdwb2ludCdgLiBEZWZhdWx0IGlzIG5vIHN0cm9rZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIGluIHBpeGVscyBhcm91bmQgdGhlIHRleHQgZm9yIGRlY2x1dHRlcmluZyBhbmQgYmFja2dyb3VuZC4gVGhlIG9yZGVyIG9mXG4gKiB2YWx1ZXMgaW4gdGhlIGFycmF5IGlzIGBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XWAuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vc3R5bGUvU3R5bGUuanMnKS5EZWNsdXR0ZXJNb2RlfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGU6IGBkZWNsdXR0ZXJgLCBgb2JzdGFjbGVgLCBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCB0ZXh0IHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mb250XyA9IG9wdGlvbnMuZm9udDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zY2FsZSA6IDEpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduXyA9IG9wdGlvbnMudGV4dEFsaWduO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGV4dEp1c3RpZnl8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuanVzdGlmeV8gPSBvcHRpb25zLmp1c3RpZnk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVwZWF0XyA9IG9wdGlvbnMucmVwZWF0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRCYXNlbGluZV8gPSBvcHRpb25zLnRleHRCYXNlbGluZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9XG4gICAgICBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuZmlsbFxuICAgICAgICA6IG5ldyBGaWxsKHtjb2xvcjogREVGQVVMVF9GSUxMX0NPTE9SfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhBbmdsZV8gPVxuICAgICAgb3B0aW9ucy5tYXhBbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhBbmdsZSA6IE1hdGguUEkgLyA0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGV4dFBsYWNlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnBsYWNlbWVudF8gPVxuICAgICAgb3B0aW9ucy5wbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGxhY2VtZW50IDogJ3BvaW50JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVyZmxvd18gPSAhIW9wdGlvbnMub3ZlcmZsb3c7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFhfID0gb3B0aW9ucy5vZmZzZXRYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldFggOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0WV8gPSBvcHRpb25zLm9mZnNldFkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0WSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuYmFja2dyb3VuZEZpbGxfID0gb3B0aW9ucy5iYWNrZ3JvdW5kRmlsbFxuICAgICAgPyBvcHRpb25zLmJhY2tncm91bmRGaWxsXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5iYWNrZ3JvdW5kU3Ryb2tlXyA9IG9wdGlvbnMuYmFja2dyb3VuZFN0cm9rZVxuICAgICAgPyBvcHRpb25zLmJhY2tncm91bmRTdHJva2VcbiAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhZGRpbmdfID0gb3B0aW9ucy5wYWRkaW5nID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5wYWRkaW5nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi9zdHlsZS9TdHlsZS5qcycpLkRlY2x1dHRlck1vZGV9XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJNb2RlXyA9IG9wdGlvbnMuZGVjbHV0dGVyTW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtUZXh0fSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICByZXR1cm4gbmV3IFRleHQoe1xuICAgICAgZm9udDogdGhpcy5nZXRGb250KCksXG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuZ2V0UGxhY2VtZW50KCksXG4gICAgICByZXBlYXQ6IHRoaXMuZ2V0UmVwZWF0KCksXG4gICAgICBtYXhBbmdsZTogdGhpcy5nZXRNYXhBbmdsZSgpLFxuICAgICAgb3ZlcmZsb3c6IHRoaXMuZ2V0T3ZlcmZsb3coKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgc2NhbGU6IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGUuc2xpY2UoKSA6IHNjYWxlLFxuICAgICAgdGV4dDogdGhpcy5nZXRUZXh0KCksXG4gICAgICB0ZXh0QWxpZ246IHRoaXMuZ2V0VGV4dEFsaWduKCksXG4gICAgICBqdXN0aWZ5OiB0aGlzLmdldEp1c3RpZnkoKSxcbiAgICAgIHRleHRCYXNlbGluZTogdGhpcy5nZXRUZXh0QmFzZWxpbmUoKSxcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9mZnNldFg6IHRoaXMuZ2V0T2Zmc2V0WCgpLFxuICAgICAgb2Zmc2V0WTogdGhpcy5nZXRPZmZzZXRZKCksXG4gICAgICBiYWNrZ3JvdW5kRmlsbDogdGhpcy5nZXRCYWNrZ3JvdW5kRmlsbCgpXG4gICAgICAgID8gdGhpcy5nZXRCYWNrZ3JvdW5kRmlsbCgpLmNsb25lKClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBiYWNrZ3JvdW5kU3Ryb2tlOiB0aGlzLmdldEJhY2tncm91bmRTdHJva2UoKVxuICAgICAgICA/IHRoaXMuZ2V0QmFja2dyb3VuZFN0cm9rZSgpLmNsb25lKClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBwYWRkaW5nOiB0aGlzLmdldFBhZGRpbmcoKSB8fCB1bmRlZmluZWQsXG4gICAgICBkZWNsdXR0ZXJNb2RlOiB0aGlzLmdldERlY2x1dHRlck1vZGUoKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBvdmVyZmxvd2AgY29uZmlndXJhdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gTGV0IHRleHQgb3ZlcmZsb3cgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0aGV5IGZvbGxvdy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmZsb3dfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZm9udCBuYW1lLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBGb250LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGb250KCkge1xuICAgIHJldHVybiB0aGlzLmZvbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSBhbmdsZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWF4QW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4QW5nbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFiZWwgcGxhY2VtZW50LlxuICAgKiBAcmV0dXJuIHtUZXh0UGxhY2VtZW50fSBUZXh0IHBsYWNlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UGxhY2VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBsYWNlbWVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXBlYXQgaW50ZXJ2YWwgb2YgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlcGVhdCBpbnRlcnZhbCBpbiBwaXhlbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlcGVhdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBlYXRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeC1vZmZzZXQgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhvcml6b250YWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9mZnNldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0WF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5LW9mZnNldCBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVmVydGljYWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9mZnNldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0WV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIHN0eWxlIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdGV4dCByb3RhdGVzIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRlV2l0aFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRleHQgc2NhbGUuXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZSBhcnJheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTY2FsZSBhcnJheS5cbiAgICovXG4gIGdldFNjYWxlQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVBcnJheV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fG51bGx9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IFRleHQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGFsaWdubWVudC5cbiAgICogQHJldHVybiB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH0gVGV4dCBhbGlnbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGV4dEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLnRleHRBbGlnbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBqdXN0aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJuIHtUZXh0SnVzdGlmeXx1bmRlZmluZWR9IEp1c3RpZmljYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEp1c3RpZnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuanVzdGlmeV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGJhc2VsaW5lLlxuICAgKiBAcmV0dXJuIHtDYW52YXNUZXh0QmFzZWxpbmV8dW5kZWZpbmVkfSBUZXh0IGJhc2VsaW5lLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEJhc2VsaW5lXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgZmlsbCBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fG51bGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEJhY2tncm91bmRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRGaWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgc3Ryb2tlIHN0eWxlIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEJhY2tncm91bmRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZFN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYWRkaW5nIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBQYWRkaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBhZGRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVjbHV0dGVyIG1vZGUgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3R5bGUuanNcIikuRGVjbHV0dGVyTW9kZX0gU2hhcGUncyBkZWNsdXR0ZXIgbW9kZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXREZWNsdXR0ZXJNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2x1dHRlck1vZGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVyZmxvdyBMZXQgdGV4dCBvdmVyZmxvdyB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE92ZXJmbG93KG92ZXJmbG93KSB7XG4gICAgdGhpcy5vdmVyZmxvd18gPSBvdmVyZmxvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9udCBGb250LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGb250KGZvbnQpIHtcbiAgICB0aGlzLmZvbnRfID0gZm9udDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgQW5nbGUgaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4QW5nbGUobWF4QW5nbGUpIHtcbiAgICB0aGlzLm1heEFuZ2xlXyA9IG1heEFuZ2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIEhvcml6b250YWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9mZnNldFgob2Zmc2V0WCkge1xuICAgIHRoaXMub2Zmc2V0WF8gPSBvZmZzZXRYO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeSBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIFZlcnRpY2FsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRPZmZzZXRZKG9mZnNldFkpIHtcbiAgICB0aGlzLm9mZnNldFlfID0gb2Zmc2V0WTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgcGxhY2VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRQbGFjZW1lbnR9IHBsYWNlbWVudCBQbGFjZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICB0aGlzLnBsYWNlbWVudF8gPSBwbGFjZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXBlYXQgaW50ZXJ2YWwgb2YgdGhlIHRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gW3JlcGVhdF0gUmVwZWF0IGludGVydmFsIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVwZWF0KHJlcGVhdCkge1xuICAgIHRoaXMucmVwZWF0XyA9IHJlcGVhdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0byByb3RhdGUgdGhlIHRleHQgd2l0aCB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByb3RhdGVXaXRoVmlldyBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0ZVdpdGhWaWV3KHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3Ryb2tlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR8bnVsbH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuc3Ryb2tlXyA9IHN0cm9rZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfSB0ZXh0IFRleHQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHQodGV4dCkge1xuICAgIHRoaXMudGV4dF8gPSB0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBhbGlnbm1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH0gdGV4dEFsaWduIFRleHQgYWxpZ24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHRBbGlnbih0ZXh0QWxpZ24pIHtcbiAgICB0aGlzLnRleHRBbGlnbl8gPSB0ZXh0QWxpZ247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBqdXN0aWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRKdXN0aWZ5fHVuZGVmaW5lZH0ganVzdGlmeSBKdXN0aWZpY2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRKdXN0aWZ5KGp1c3RpZnkpIHtcbiAgICB0aGlzLmp1c3RpZnlfID0ganVzdGlmeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgYmFzZWxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH0gdGV4dEJhc2VsaW5lIFRleHQgYmFzZWxpbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpIHtcbiAgICB0aGlzLnRleHRCYXNlbGluZV8gPSB0ZXh0QmFzZWxpbmU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBiYWNrZ3JvdW5kIGZpbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR8bnVsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kRmlsbChmaWxsKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRmlsbF8gPSBmaWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFja2dyb3VuZCBzdHJva2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdHxudWxsfSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kU3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuYmFja2dyb3VuZFN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwYWRkaW5nIChgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF1gKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fG51bGx9IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UGFkZGluZyhwYWRkaW5nKSB7XG4gICAgdGhpcy5wYWRkaW5nXyA9IHBhZGRpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZXhwci9leHByZXNzaW9uXG4gKi9cbmltcG9ydCB7YXNjZW5kaW5nfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Zyb21TdHJpbmcgYXMgY29sb3JGcm9tU3RyaW5nfSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBpbmNsdWRlcyB0eXBlcyBhbmQgZnVuY3Rpb25zIGZvciBwYXJzaW5nIGFycmF5IGVuY29kZWQgZXhwcmVzc2lvbnMuXG4gKiBUaGUgcmVzdWx0IG9mIHBhcnNpbmcgYW4gZW5jb2RlZCBleHByZXNzaW9uIGlzIG9uZSBvZiB0aGUgc3BlY2lmaWMgZXhwcmVzc2lvbiBjbGFzc2VzLlxuICogRHVyaW5nIHBhcnNpbmcsIGluZm9ybWF0aW9uIGlzIGFkZGVkIHRvIHRoZSBwYXJzaW5nIGNvbnRleHQgYWJvdXQgdGhlIGRhdGEgYWNjZXNzZWQgYnkgdGhlXG4gKiBleHByZXNzaW9uLlxuICovXG5cbi8qKlxuICogQmFzZSB0eXBlIHVzZWQgZm9yIGxpdGVyYWwgc3R5bGUgcGFyYW1ldGVyczsgY2FuIGJlIGEgbnVtYmVyIGxpdGVyYWwgb3IgdGhlIG91dHB1dCBvZiBhbiBvcGVyYXRvcixcbiAqIHdoaWNoIGluIHR1cm5zIHRha2VzIHtAbGluayBpbXBvcnQoXCIuL2V4cHJlc3Npb24uanNcIikuRXhwcmVzc2lvblZhbHVlfSBhcmd1bWVudHMuXG4gKlxuICogU2VlIGJlbG93IGZvciBkZXRhaWxzIG9uIHRoZSBhdmFpbGFibGUgb3BlcmF0b3JzICh3aXRoIG5vdGVzIGZvciB0aG9zZSB0aGF0IGFyZSBXZWJHTCBvciBDYW52YXMgb25seSkuXG4gKlxuICogKiBSZWFkaW5nIG9wZXJhdG9yczpcbiAqICAgKiBgWydiYW5kJywgYmFuZEluZGV4LCB4T2Zmc2V0LCB5T2Zmc2V0XWAgRm9yIHRpbGUgbGF5ZXJzIG9ubHkuIEZldGNoZXMgcGl4ZWwgdmFsdWVzIGZyb20gYmFuZFxuICogICAgIGBiYW5kSW5kZXhgIG9mIHRoZSBzb3VyY2UncyBkYXRhLiBUaGUgZmlyc3QgYGJhbmRJbmRleGAgb2YgdGhlIHNvdXJjZSBkYXRhIGlzIGAxYC4gRmV0Y2hlZCB2YWx1ZXNcbiAqICAgICBhcmUgaW4gdGhlIDAuLjEgcmFuZ2UuIHtAbGluayBpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZUltYWdlLmpzXCIpLmRlZmF1bHR9IHNvdXJjZXMgaGF2ZSA0IGJhbmRzOiByZWQsXG4gKiAgICAgZ3JlZW4sIGJsdWUgYW5kIGFscGhhLiB7QGxpbmsgaW1wb3J0KFwiLi4vc291cmNlL0RhdGFUaWxlLmpzXCIpLmRlZmF1bHR9IHNvdXJjZXMgY2FuIGhhdmUgYW55IG51bWJlclxuICogICAgIG9mIGJhbmRzLCBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgZGF0YSBzb3VyY2UgYW5kXG4gKiAgICAge0BsaW5rIGltcG9ydChcIi4uL3NvdXJjZS9HZW9USUZGLmpzXCIpLk9wdGlvbnMgY29uZmlndXJhdGlvbn0uIGB4T2Zmc2V0YCBhbmQgYHlPZmZzZXRgIGFyZSBvcHRpb25hbFxuICogICAgIGFuZCBhbGxvdyBzcGVjaWZ5aW5nIHBpeGVsIG9mZnNldHMgZm9yIHggYW5kIHkuIFRoaXMgaXMgdXNlZCBmb3Igc2FtcGxpbmcgZGF0YSBmcm9tIG5laWdoYm9yaW5nIHBpeGVscyAoV2ViR0wgb25seSkuXG4gKiAgICogYFsnZ2V0JywgYXR0cmlidXRlTmFtZV1gIGZldGNoZXMgYSBmZWF0dXJlIHByb3BlcnR5IHZhbHVlLCBzaW1pbGFyIHRvIGBmZWF0dXJlLmdldCgnYXR0cmlidXRlTmFtZScpYC5cbiAqICAgKiBgWydnZXQnLCBhdHRyaWJ1dGVOYW1lLCBrZXlPckFycmF5SW5kZXgsIC4uLl1gIChDYW52YXMgb25seSkgQWNjZXNzIG5lc3RlZCBwcm9wZXJ0aWVzIGFuZCBhcnJheSBpdGVtcyBvZiBhXG4gKiAgICAgZmVhdHVyZSBwcm9wZXJ0eS4gVGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgYXQgdGhlIHNwZWNpZmllZCBrZXkgb3IgaW5kZXguXG4gKiAgICogYFsnZ2VvbWV0cnktdHlwZSddYCByZXR1cm5zIGEgZmVhdHVyZSdzIGdlb21ldHJ5IHR5cGUgYXMgc3RyaW5nLCBlaXRoZXI6ICdMaW5lU3RyaW5nJywgJ1BvaW50JyBvciAnUG9seWdvbidcbiAqICAgICBgTXVsdGkqYCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIHRoZWlyIHNpbmd1bGFyIGVxdWl2YWxlbnRcbiAqICAgICBgQ2lyY2xlYCBnZW9tZXRyaWVzIGFyZSByZXR1cm5lZCBhcyAnUG9seWdvbidcbiAqICAgICBgR2VvbWV0cnlDb2xsZWN0aW9uYCBnZW9tZXRyaWVzIGFyZSByZXR1cm5lZCBhcyB0aGUgdHlwZSBvZiB0aGUgZmlyc3QgZ2VvbWV0cnkgZm91bmQgaW4gdGhlIGNvbGxlY3Rpb24gKFdlYkdMIG9ubHkpLlxuICogICAqIGBbJ3Jlc29sdXRpb24nXWAgcmV0dXJucyB0aGUgY3VycmVudCByZXNvbHV0aW9uXG4gKiAgICogYFsndGltZSddYCBUaGUgdGltZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBjcmVhdGlvbiBvZiB0aGUgbGF5ZXIgKFdlYkdMIG9ubHkpLlxuICogICAqIGBbJ3ZhcicsICd2YXJOYW1lJ11gIGZldGNoZXMgYSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSB2YXJpYWJsZXM7IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhhdCB2YXJpYWJsZSBpcyB1bmRlZmluZWRcbiAqICAgKiBgWyd6b29tJ11gIFRoZSBjdXJyZW50IHpvb20gbGV2ZWwgKFdlYkdMIG9ubHkpLlxuICogICAqIGBbJ2xpbmUtbWV0cmljJ11gIHJldHVybnMgdGhlIE0gY29tcG9uZW50IG9mIHRoZSBjdXJyZW50IHBvaW50IG9uIGEgbGluZSAoV2ViR0wgb25seSk7IGluIGNhc2Ugd2hlcmUgdGhlIGdlb21ldHJ5IGxheW91dCBvZiB0aGUgbGluZVxuICogICAgICBkb2VzIG5vdCBjb250YWluIGFuIE0gY29tcG9uZW50IChlLmcuIFhZIG9yIFhZWiksIDAgaXMgcmV0dXJuZWQ7IDAgaXMgYWxzbyByZXR1cm5lZCBmb3IgZ2VvbWV0cmllcyBvdGhlciB0aGFuIGxpbmVzLlxuICogICAgICBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBNIGNvbXBvbmVudCB3aWxsIGJlIGxpbmVhcmx5IGludGVycG9sYXRlZCBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzIGNvbXBvc2luZyBhIHNlZ21lbnQuXG4gKlxuICogKiBNYXRoIG9wZXJhdG9yczpcbiAqICAgKiBgWycqJywgdmFsdWUxLCB2YWx1ZTIsIC4uLl1gIG11bHRpcGxpZXMgdGhlIHZhbHVlcyAoZWl0aGVyIG51bWJlcnMgb3IgY29sb3JzKVxuICogICAqIGBbJy8nLCB2YWx1ZTEsIHZhbHVlMl1gIGRpdmlkZXMgYHZhbHVlMWAgYnkgYHZhbHVlMmBcbiAqICAgKiBgWycrJywgdmFsdWUxLCB2YWx1ZTIsIC4uLl1gIGFkZHMgdGhlIHZhbHVlc1xuICogICAqIGBbJy0nLCB2YWx1ZTEsIHZhbHVlMl1gIHN1YnRyYWN0cyBgdmFsdWUyYCBmcm9tIGB2YWx1ZTFgXG4gKiAgICogYFsnY2xhbXAnLCB2YWx1ZSwgbG93LCBoaWdoXWAgY2xhbXBzIGB2YWx1ZWAgYmV0d2VlbiBgbG93YCBhbmQgYGhpZ2hgXG4gKiAgICogYFsnJScsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGB2YWx1ZTEgJSB2YWx1ZTJgIChtb2R1bG8pXG4gKiAgICogYFsnXicsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyB0aGUgdmFsdWUgb2YgYHZhbHVlMWAgcmFpc2VkIHRvIHRoZSBgdmFsdWUyYCBwb3dlclxuICogICAqIGBbJ2FicycsIHZhbHVlMV1gIHJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIGB2YWx1ZTFgXG4gKiAgICogYFsnZmxvb3InLCB2YWx1ZTFdYCByZXR1cm5zIHRoZSBuZWFyZXN0IGludGVnZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZTFgXG4gKiAgICogYFsncm91bmQnLCB2YWx1ZTFdYCByZXR1cm5zIHRoZSBuZWFyZXN0IGludGVnZXIgdG8gYHZhbHVlMWBcbiAqICAgKiBgWydjZWlsJywgdmFsdWUxXWAgcmV0dXJucyB0aGUgbmVhcmVzdCBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWUxYFxuICogICAqIGBbJ3NpbicsIHZhbHVlMV1gIHJldHVybnMgdGhlIHNpbmUgb2YgYHZhbHVlMWBcbiAqICAgKiBgWydjb3MnLCB2YWx1ZTFdYCByZXR1cm5zIHRoZSBjb3NpbmUgb2YgYHZhbHVlMWBcbiAqICAgKiBgWydhdGFuJywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIGBhdGFuMih2YWx1ZTEsIHZhbHVlMilgLiBJZiBgdmFsdWUyYCBpcyBub3QgcHJvdmlkZWQsIHJldHVybnMgYGF0YW4odmFsdWUxKWBcbiAqICAgKiBgWydzcXJ0JywgdmFsdWUxXWAgcmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgYHZhbHVlMWBcbiAqXG4gKiAqIFRyYW5zZm9ybSBvcGVyYXRvcnM6XG4gKiAgICogYFsnY2FzZScsIGNvbmRpdGlvbjEsIG91dHB1dDEsIC4uLmNvbmRpdGlvbk4sIG91dHB1dE4sIGZhbGxiYWNrXWAgc2VsZWN0cyB0aGUgZmlyc3Qgb3V0cHV0IHdob3NlIGNvcnJlc3BvbmRpbmdcbiAqICAgICBjb25kaXRpb24gZXZhbHVhdGVzIHRvIGB0cnVlYC4gSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHJldHVybnMgdGhlIGBmYWxsYmFja2AgdmFsdWUuXG4gKiAgICAgQWxsIGNvbmRpdGlvbnMgc2hvdWxkIGJlIGBib29sZWFuYCwgb3V0cHV0IGFuZCBmYWxsYmFjayBjYW4gYmUgYW55IGtpbmQuXG4gKiAgICogYFsnbWF0Y2gnLCBpbnB1dCwgbWF0Y2gxLCBvdXRwdXQxLCAuLi5tYXRjaE4sIG91dHB1dE4sIGZhbGxiYWNrXWAgY29tcGFyZXMgdGhlIGBpbnB1dGAgdmFsdWUgYWdhaW5zdCBhbGxcbiAqICAgICBwcm92aWRlZCBgbWF0Y2hYYCB2YWx1ZXMsIHJldHVybmluZyB0aGUgb3V0cHV0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlyc3QgdmFsaWQgbWF0Y2guIElmIG5vIG1hdGNoIGlzIGZvdW5kLFxuICogICAgIHJldHVybnMgdGhlIGBmYWxsYmFja2AgdmFsdWUuXG4gKiAgICAgYGlucHV0YCBhbmQgYG1hdGNoWGAgdmFsdWVzIG11c3QgYWxsIGJlIG9mIHRoZSBzYW1lIHR5cGUsIGFuZCBjYW4gYmUgYG51bWJlcmAgb3IgYHN0cmluZ2AuIGBvdXRwdXRYYCBhbmRcbiAqICAgICBgZmFsbGJhY2tgIHZhbHVlcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGUsIGFuZCBjYW4gYmUgb2YgYW55IGtpbmQuXG4gKiAgICogYFsnaW50ZXJwb2xhdGUnLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgc3RvcDEsIG91dHB1dDEsIC4uLnN0b3BOLCBvdXRwdXROXWAgcmV0dXJucyBhIHZhbHVlIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlblxuICogICAgIHBhaXJzIG9mIGlucHV0cyBhbmQgb3V0cHV0czsgYGludGVycG9sYXRpb25gIGNhbiBlaXRoZXIgYmUgYFsnbGluZWFyJ11gIG9yIGBbJ2V4cG9uZW50aWFsJywgYmFzZV1gIHdoZXJlIGBiYXNlYCBpc1xuICogICAgIHRoZSByYXRlIG9mIGluY3JlYXNlIGZyb20gc3RvcCBBIHRvIHN0b3AgQiAoaS5lLiBwb3dlciB0byB3aGljaCB0aGUgaW50ZXJwb2xhdGlvbiByYXRpbyBpcyByYWlzZWQpOyBhIHZhbHVlXG4gKiAgICAgb2YgMSBpcyBlcXVpdmFsZW50IHRvIGBbJ2xpbmVhciddYC5cbiAqICAgICBgaW5wdXRgIGFuZCBgc3RvcFhgIHZhbHVlcyBtdXN0IGFsbCBiZSBvZiB0eXBlIGBudW1iZXJgLiBgb3V0cHV0WGAgdmFsdWVzIGNhbiBiZSBgbnVtYmVyYCBvciBgY29sb3JgIHZhbHVlcy5cbiAqICAgICBOb3RlOiBgaW5wdXRgIHdpbGwgYmUgY2xhbXBlZCBiZXR3ZWVuIGBzdG9wMWAgYW5kIGBzdG9wTmAsIG1lYW5pbmcgdGhhdCBhbGwgb3V0cHV0IHZhbHVlcyB3aWxsIGJlIGNvbXByaXNlZFxuICogICAgIGJldHdlZW4gYG91dHB1dDFgIGFuZCBgb3V0cHV0TmAuXG4gKiAgICogYFsnc3RyaW5nJywgdmFsdWUxLCB2YWx1ZTIsIC4uLl1gIHJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBsaXN0IHRoYXQgZXZhbHVhdGVzIHRvIGEgc3RyaW5nLlxuICogICAgIEFuIGV4YW1wbGUgd291bGQgYmUgdG8gcHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgZm9yIGdldDogYFsnc3RyaW5nJywgWydnZXQnLCAncHJvcGVydHluYW1lJ10sICdkZWZhdWx0IHZhbHVlJ11dYFxuICogICAgIChDYW52YXMgb25seSkuXG4gKiAgICogYFsnbnVtYmVyJywgdmFsdWUxLCB2YWx1ZTIsIC4uLl1gIHJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBsaXN0IHRoYXQgZXZhbHVhdGVzIHRvIGEgbnVtYmVyLlxuICogICAgIEFuIGV4YW1wbGUgd291bGQgYmUgdG8gcHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgZm9yIGdldDogYFsnc3RyaW5nJywgWydnZXQnLCAncHJvcGVydHluYW1lJ10sIDQyXV1gXG4gKiAgICAgKENhbnZhcyBvbmx5KS5cbiAqICAgKiBgWydjb2FsZXNjZScsIHZhbHVlMSwgdmFsdWUyLCAuLi5dYCByZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgbGlzdCB3aGljaCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQuXG4gKiAgICAgQW4gZXhhbXBsZSB3b3VsZCBiZSB0byBwcm92aWRlIGEgZGVmYXVsdCB2YWx1ZSBmb3IgZ2V0OiBgWydjb2FsZXNjZScsIFsnZ2V0JywncHJvcGVydHluYW1lJ10sICdkZWZhdWx0IHZhbHVlJ11dYFxuICogICAgIChDYW52YXMgb25seSkuXG4gKlxuICogKiBMb2dpY2FsIG9wZXJhdG9yczpcbiAqICAgKiBgWyc8JywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBpcyBzdHJpY3RseSBsb3dlciB0aGFuIGB2YWx1ZTJgLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWyc8PScsIHZhbHVlMSwgdmFsdWUyXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlMWAgaXMgbG93ZXIgdGhhbiBvciBlcXVhbHMgYHZhbHVlMmAsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJz4nLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgYHRydWVgIGlmIGB2YWx1ZTFgIGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiBgdmFsdWUyYCwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnPj0nLCB2YWx1ZTEsIHZhbHVlMl1gIHJldHVybnMgYHRydWVgIGlmIGB2YWx1ZTFgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbHMgYHZhbHVlMmAsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJz09JywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBlcXVhbHMgYHZhbHVlMmAsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJyE9JywgdmFsdWUxLCB2YWx1ZTJdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBkb2VzIG5vdCBlcXVhbCBgdmFsdWUyYCwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnIScsIHZhbHVlMV1gIHJldHVybnMgYGZhbHNlYCBpZiBgdmFsdWUxYCBpcyBgdHJ1ZWAgb3IgZ3JlYXRlciB0aGFuIGAwYCwgb3IgYHRydWVgIG90aGVyd2lzZS5cbiAqICAgKiBgWydhbGwnLCB2YWx1ZTEsIHZhbHVlMiwgLi4uXWAgcmV0dXJucyBgdHJ1ZWAgaWYgYWxsIHRoZSBpbnB1dHMgYXJlIGB0cnVlYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnYW55JywgdmFsdWUxLCB2YWx1ZTIsIC4uLl1gIHJldHVybnMgYHRydWVgIGlmIGFueSBvZiB0aGUgaW5wdXRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogICAqIGBbJ2hhcycsIGF0dHJpYnV0ZU5hbWUsIGtleU9yQXJyYXlJbmRleCwgLi4uXWAgcmV0dXJucyBgdHJ1ZWAgaWYgZmVhdHVyZSBwcm9wZXJ0aWVzIGluY2x1ZGUgdGhlIChuZXN0ZWQpIGtleSBgYXR0cmlidXRlTmFtZWAsXG4gKiAgICAgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiAgICogYFsnYmV0d2VlbicsIHZhbHVlMSwgdmFsdWUyLCB2YWx1ZTNdYCByZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWUxYCBpcyBjb250YWluZWQgYmV0d2VlbiBgdmFsdWUyYCBhbmQgYHZhbHVlM2BcbiAqICAgICAoaW5jbHVzaXZlbHkpLCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgKiBgWydpbicsIG5lZWRsZSwgaGF5c3RhY2tdYCByZXR1cm5zIGB0cnVlYCBpZiBgbmVlZGxlYCBpcyBmb3VuZCBpbiBgaGF5c3RhY2tgLCBhbmRcbiAqICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAqICAgICBUaGlzIG9wZXJhdG9yIGhhcyB0aGUgZm9sbG93aW5nIGxpbWl0YXRpb25zOlxuICogICAgICogYGhheXN0YWNrYCBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChzZWFyY2hpbmcgZm9yIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nIGlzIG5vdCBzdXBwb3J0ZWQgeWV0KVxuICogICAgICogT25seSBsaXRlcmFsIGFycmF5cyBhcmUgc3VwcG9ydGVkIGFzIGBoYXlzdGFja2AgZm9yIG5vdzsgdGhpcyBtZWFucyB0aGF0IGBoYXlzdGFja2AgY2Fubm90IGJlIHRoZSByZXN1bHQgb2YgYW5cbiAqICAgICBleHByZXNzaW9uLiBJZiBgaGF5c3RhY2tgIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHVzZSB0aGUgYGxpdGVyYWxgIG9wZXJhdG9yIHRvIGRpc2FtYmlndWF0ZSBmcm9tIGFuIGV4cHJlc3Npb246XG4gKiAgICAgYFsnbGl0ZXJhbCcsIFsnYWJjJywgJ2RlZicsICdnaGknXV1gXG4gKlxuICogKiBDb252ZXJzaW9uIG9wZXJhdG9yczpcbiAqICAgKiBgWydhcnJheScsIHZhbHVlMSwgLi4udmFsdWVOXWAgY3JlYXRlcyBhIG51bWVyaWNhbCBhcnJheSBmcm9tIGBudW1iZXJgIHZhbHVlczsgcGxlYXNlIG5vdGUgdGhhdCB0aGUgYW1vdW50IG9mXG4gKiAgICAgdmFsdWVzIGNhbiBjdXJyZW50bHkgb25seSBiZSAyLCAzIG9yIDQgKFdlYkdMIG9ubHkpLlxuICogICAqIGBbJ2NvbG9yJywgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdYCBvciBgWydjb2xvcicsIHNoYWRlLCBhbHBoYV1gIGNyZWF0ZXMgYSBgY29sb3JgIHZhbHVlIGZyb20gYG51bWJlcmAgdmFsdWVzO1xuICogICAgIHRoZSBgYWxwaGFgIHBhcmFtZXRlciBpcyBvcHRpb25hbDsgaWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBiZSBzZXQgdG8gMSAoV2ViR0wgb25seSkuXG4gKiAgICAgTm90ZTogYHJlZGAsIGBncmVlbmAgYW5kIGBibHVlYCBvciBgc2hhZGVgIGNvbXBvbmVudHMgbXVzdCBiZSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTU7IGBhbHBoYWAgYmV0d2VlbiAwIGFuZCAxLlxuICogICAqIGBbJ3BhbGV0dGUnLCBpbmRleCwgY29sb3JzXWAgcGlja3MgYSBgY29sb3JgIHZhbHVlIGZyb20gYW4gYXJyYXkgb2YgY29sb3JzIHVzaW5nIHRoZSBnaXZlbiBpbmRleDsgdGhlIGBpbmRleGBcbiAqICAgICBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gYSBudW1iZXI7IHRoZSBpdGVtcyBpbiB0aGUgYGNvbG9yc2AgYXJyYXkgbXVzdCBiZSBzdHJpbmdzIHdpdGggaGV4IGNvbG9yc1xuICogICAgIChlLmcuIGAnIzg2QTEzNidgKSwgY29sb3JzIHVzaW5nIHRoZSByZ2JhW2FdIGZ1bmN0aW9uYWwgbm90YXRpb24gKGUuZy4gYCdyZ2IoMTM0LCAxNjEsIDU0KSdgIG9yIGAncmdiYSgxMzQsIDE2MSwgNTQsIDEpJ2ApLFxuICogICAgIG5hbWVkIGNvbG9ycyAoZS5nLiBgJ3JlZCdgKSwgb3IgYXJyYXkgbGl0ZXJhbHMgd2l0aCAzIChbciwgZywgYl0pIG9yIDQgKFtyLCBnLCBiLCBhXSkgdmFsdWVzICh3aXRoIHIsIGcsIGFuZCBiXG4gKiAgICAgaW4gdGhlIDAtMjU1IHJhbmdlIGFuZCBhIGluIHRoZSAwLTEgcmFuZ2UpIChXZWJHTCBvbmx5KS5cbiAqICAgKiBgWyd0by1zdHJpbmcnLCB2YWx1ZV1gIGNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIHN0cmluZy4gSWYgdGhlIGlucHV0IGlzIGEgYm9vbGVhbiwgdGhlIHJlc3VsdCBpcyBcInRydWVcIiBvciBcImZhbHNlXCIuXG4gKiAgICAgSWYgdGhlIGlucHV0IGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgc3BlY2lmaWVkIGJ5IHRoZSBcIk51bWJlclRvU3RyaW5nXCIgYWxnb3JpdGhtIG9mIHRoZSBFQ01BU2NyaXB0XG4gKiAgICAgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbi4gSWYgdGhlIGlucHV0IGlzIGEgY29sb3IsIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBvZiB0aGUgZm9ybSBcInJnYmEocixnLGIsYSlcIi4gKENhbnZhcyBvbmx5KVxuICpcbiAqIFZhbHVlcyBjYW4gZWl0aGVyIGJlIGxpdGVyYWxzIG9yIGFub3RoZXIgb3BlcmF0b3IsIGFzIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcmVjdXJzaXZlbHkuXG4gKiBMaXRlcmFsIHZhbHVlcyBjYW4gYmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczpcbiAqICogYGJvb2xlYW5gXG4gKiAqIGBudW1iZXJgXG4gKiAqIGBudW1iZXJbXWAgKG51bWJlciBhcnJheXMgY2FuIG9ubHkgaGF2ZSBhIGxlbmd0aCBvZiAyLCAzIG9yIDQpXG4gKiAqIGBzdHJpbmdgXG4gKiAqIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9XG4gKlxuICogQHR5cGVkZWYge0FycmF5PCo+fGltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gRXhwcmVzc2lvblZhbHVlXG4gKiBAYXBpXG4gKi9cblxubGV0IG51bVR5cGVzID0gMDtcbmV4cG9ydCBjb25zdCBOb25lVHlwZSA9IDA7XG5leHBvcnQgY29uc3QgQm9vbGVhblR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgTnVtYmVyVHlwZSA9IDEgPDwgbnVtVHlwZXMrKztcbmV4cG9ydCBjb25zdCBTdHJpbmdUeXBlID0gMSA8PCBudW1UeXBlcysrO1xuZXhwb3J0IGNvbnN0IENvbG9yVHlwZSA9IDEgPDwgbnVtVHlwZXMrKztcbmV4cG9ydCBjb25zdCBOdW1iZXJBcnJheVR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgU2l6ZVR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgQW55VHlwZSA9IE1hdGgucG93KDIsIG51bVR5cGVzKSAtIDE7XG5cbmNvbnN0IHR5cGVOYW1lcyA9IHtcbiAgW0Jvb2xlYW5UeXBlXTogJ2Jvb2xlYW4nLFxuICBbTnVtYmVyVHlwZV06ICdudW1iZXInLFxuICBbU3RyaW5nVHlwZV06ICdzdHJpbmcnLFxuICBbQ29sb3JUeXBlXTogJ2NvbG9yJyxcbiAgW051bWJlckFycmF5VHlwZV06ICdudW1iZXJbXScsXG4gIFtTaXplVHlwZV06ICdzaXplJyxcbn07XG5cbmNvbnN0IG5hbWVkVHlwZXMgPSBPYmplY3Qua2V5cyh0eXBlTmFtZXMpLm1hcChOdW1iZXIpLnNvcnQoYXNjZW5kaW5nKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdHlwZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0eXBlIGlzIG9uZSBvZiB0aGUgc3BlY2lmaWMgdHlwZXMgKG5vdCBhbnkgb3IgYSB1bmlvbiB0eXBlKS5cbiAqL1xuZnVuY3Rpb24gaXNTcGVjaWZpYyh0eXBlKSB7XG4gIHJldHVybiB0eXBlIGluIHR5cGVOYW1lcztcbn1cblxuLyoqXG4gKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGEgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSB0eXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdHlwZSBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZU5hbWUodHlwZSkge1xuICBjb25zdCBuYW1lcyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWVkVHlwZSBvZiBuYW1lZFR5cGVzKSB7XG4gICAgaWYgKGluY2x1ZGVzVHlwZSh0eXBlLCBuYW1lZFR5cGUpKSB7XG4gICAgICBuYW1lcy5wdXNoKHR5cGVOYW1lc1tuYW1lZFR5cGVdKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAndW50eXBlZCc7XG4gIH1cbiAgaWYgKG5hbWVzLmxlbmd0aCA8IDMpIHtcbiAgICByZXR1cm4gbmFtZXMuam9pbignIG9yICcpO1xuICB9XG4gIHJldHVybiBuYW1lcy5zbGljZSgwLCAtMSkuam9pbignLCAnKSArICcsIG9yICcgKyBuYW1lc1tuYW1lcy5sZW5ndGggLSAxXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnJvYWQgVGhlIGJyb2FkIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3BlY2lmaWMgVGhlIHNwZWNpZmljIHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgYnJvYWQgdHlwZSBpbmNsdWRlcyB0aGUgc3BlY2lmaWMgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzVHlwZShicm9hZCwgc3BlY2lmaWMpIHtcbiAgcmV0dXJuIChicm9hZCAmIHNwZWNpZmljKSA9PT0gc3BlY2lmaWM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9uZVR5cGUgT25lIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gb3RoZXJUeXBlIEFub3RoZXIgdHlwZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZXQgb2YgdHlwZXMgb3ZlcmxhcCAoc2hhcmUgYSBjb21tb24gc3BlY2lmaWMgdHlwZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG92ZXJsYXBzVHlwZShvbmVUeXBlLCBvdGhlclR5cGUpIHtcbiAgcmV0dXJuICEhKG9uZVR5cGUgJiBvdGhlclR5cGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGVjdGVkIFRoZSBleHBlY3RlZCB0eXBlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGdpdmVuIHR5cGUgaXMgZXhhY3RseSB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZSh0eXBlLCBleHBlY3RlZCkge1xuICByZXR1cm4gdHlwZSA9PT0gZXhwZWN0ZWQ7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Jvb2xlYW58bnVtYmVyfHN0cmluZ3xBcnJheTxudW1iZXI+fSBMaXRlcmFsVmFsdWVcbiAqL1xuXG5leHBvcnQgY2xhc3MgTGl0ZXJhbEV4cHJlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHZhbHVlIHR5cGUuXG4gICAqIEBwYXJhbSB7TGl0ZXJhbFZhbHVlfSB2YWx1ZSBUaGUgbGl0ZXJhbCB2YWx1ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc1NwZWNpZmljKHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBsaXRlcmFsIGV4cHJlc3Npb25zIG11c3QgaGF2ZSBhIHNwZWNpZmljIHR5cGUsIGdvdCAke3R5cGVOYW1lKHR5cGUpfWAsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2FsbEV4cHJlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHJldHVybiB0eXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgVGhlIG9wZXJhdG9yLlxuICAgKiBAcGFyYW0gey4uLkV4cHJlc3Npb259IGFyZ3MgVGhlIGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wZXJhdG9yLCAuLi5hcmdzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtMaXRlcmFsRXhwcmVzc2lvbnxDYWxsRXhwcmVzc2lvbn0gRXhwcmVzc2lvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFyc2luZ0NvbnRleHRcbiAqIEBwcm9wZXJ0eSB7U2V0PHN0cmluZz59IHZhcmlhYmxlcyBWYXJpYWJsZXMgcmVmZXJlbmNlZCB3aXRoIHRoZSAndmFyJyBvcGVyYXRvci5cbiAqIEBwcm9wZXJ0eSB7U2V0PHN0cmluZz59IHByb3BlcnRpZXMgUHJvcGVydGllcyByZWZlcmVuY2VkIHdpdGggdGhlICdnZXQnIG9wZXJhdG9yLlxuICogQHByb3BlcnR5IHtib29sZWFufSBmZWF0dXJlSWQgVGhlIHN0eWxlIHVzZXMgdGhlIGZlYXR1cmUgaWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGdlb21ldHJ5VHlwZSBUaGUgc3R5bGUgdXNlcyB0aGUgZmVhdHVyZSBnZW9tZXRyeSB0eXBlLlxuICovXG5cbi8qKlxuICogQHJldHVybiB7UGFyc2luZ0NvbnRleHR9IEEgbmV3IHBhcnNpbmcgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5ld1BhcnNpbmdDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIHZhcmlhYmxlczogbmV3IFNldCgpLFxuICAgIHByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgICBmZWF0dXJlSWQ6IGZhbHNlLFxuICAgIGdlb21ldHJ5VHlwZTogZmFsc2UsXG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge0xpdGVyYWxWYWx1ZXxBcnJheX0gRW5jb2RlZEV4cHJlc3Npb25cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2RlZEV4cHJlc3Npb259IGVuY29kZWQgVGhlIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZFR5cGUgVGhlIGV4cGVjdGVkIHR5cGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9ufSBUaGUgcGFyc2VkIGV4cHJlc3Npb24gcmVzdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoZW5jb2RlZCwgZXhwZWN0ZWRUeXBlLCBjb250ZXh0KSB7XG4gIHN3aXRjaCAodHlwZW9mIGVuY29kZWQpIHtcbiAgICBjYXNlICdib29sZWFuJzoge1xuICAgICAgaWYgKGlzVHlwZShleHBlY3RlZFR5cGUsIFN0cmluZ1R5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oU3RyaW5nVHlwZSwgZW5jb2RlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgfVxuICAgICAgaWYgKCFpbmNsdWRlc1R5cGUoZXhwZWN0ZWRUeXBlLCBCb29sZWFuVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBnb3QgYSBib29sZWFuLCBidXQgZXhwZWN0ZWQgJHt0eXBlTmFtZShleHBlY3RlZFR5cGUpfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKEJvb2xlYW5UeXBlLCBlbmNvZGVkKTtcbiAgICB9XG4gICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgaWYgKGlzVHlwZShleHBlY3RlZFR5cGUsIFNpemVUeXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKFNpemVUeXBlLCB0b1NpemUoZW5jb2RlZCkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHlwZShleHBlY3RlZFR5cGUsIEJvb2xlYW5UeXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKEJvb2xlYW5UeXBlLCAhIWVuY29kZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHlwZShleHBlY3RlZFR5cGUsIFN0cmluZ1R5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oU3RyaW5nVHlwZSwgZW5jb2RlZC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5jbHVkZXNUeXBlKGV4cGVjdGVkVHlwZSwgTnVtYmVyVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnb3QgYSBudW1iZXIsIGJ1dCBleHBlY3RlZCAke3R5cGVOYW1lKGV4cGVjdGVkVHlwZSl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKE51bWJlclR5cGUsIGVuY29kZWQpO1xuICAgIH1cbiAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICBpZiAoaXNUeXBlKGV4cGVjdGVkVHlwZSwgQ29sb3JUeXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKENvbG9yVHlwZSwgY29sb3JGcm9tU3RyaW5nKGVuY29kZWQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1R5cGUoZXhwZWN0ZWRUeXBlLCBCb29sZWFuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihCb29sZWFuVHlwZSwgISFlbmNvZGVkKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5jbHVkZXNUeXBlKGV4cGVjdGVkVHlwZSwgU3RyaW5nVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnb3QgYSBzdHJpbmcsIGJ1dCBleHBlY3RlZCAke3R5cGVOYW1lKGV4cGVjdGVkVHlwZSl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKFN0cmluZ1R5cGUsIGVuY29kZWQpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAvLyBwYXNzXG4gICAgfVxuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGVuY29kZWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHByZXNzaW9uIG11c3QgYmUgYW4gYXJyYXkgb3IgYSBwcmltaXRpdmUgdmFsdWUnKTtcbiAgfVxuXG4gIGlmIChlbmNvZGVkLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZW1wdHkgZXhwcmVzc2lvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGVkWzBdID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZUNhbGxFeHByZXNzaW9uKGVuY29kZWQsIGV4cGVjdGVkVHlwZSwgY29udGV4dCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgZW5jb2RlZCkge1xuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1R5cGUoZXhwZWN0ZWRUeXBlLCBTaXplVHlwZSkpIHtcbiAgICBpZiAoZW5jb2RlZC5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGV4cGVjdGVkIGFuIGFycmF5IG9mIHR3byB2YWx1ZXMgZm9yIGEgc2l6ZSwgZ290ICR7ZW5jb2RlZC5sZW5ndGh9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oU2l6ZVR5cGUsIGVuY29kZWQpO1xuICB9XG5cbiAgaWYgKGlzVHlwZShleHBlY3RlZFR5cGUsIENvbG9yVHlwZSkpIHtcbiAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oQ29sb3JUeXBlLCBbLi4uZW5jb2RlZCwgMV0pO1xuICAgIH1cbiAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oQ29sb3JUeXBlLCBlbmNvZGVkKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGV4cGVjdGVkIGFuIGFycmF5IG9mIDMgb3IgNCB2YWx1ZXMgZm9yIGEgY29sb3IsIGdvdCAke2VuY29kZWQubGVuZ3RofWAsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaW5jbHVkZXNUeXBlKGV4cGVjdGVkVHlwZSwgTnVtYmVyQXJyYXlUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBnb3QgYW4gYXJyYXkgb2YgbnVtYmVycywgYnV0IGV4cGVjdGVkICR7dHlwZU5hbWUoZXhwZWN0ZWRUeXBlKX1gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKE51bWJlckFycmF5VHlwZSwgZW5jb2RlZCk7XG59XG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBPcHMgPSB7XG4gIEdldDogJ2dldCcsXG4gIFZhcjogJ3ZhcicsXG4gIENvbmNhdDogJ2NvbmNhdCcsXG4gIEdlb21ldHJ5VHlwZTogJ2dlb21ldHJ5LXR5cGUnLFxuICBMaW5lTWV0cmljOiAnbGluZS1tZXRyaWMnLFxuICBBbnk6ICdhbnknLFxuICBBbGw6ICdhbGwnLFxuICBOb3Q6ICchJyxcbiAgUmVzb2x1dGlvbjogJ3Jlc29sdXRpb24nLFxuICBab29tOiAnem9vbScsXG4gIFRpbWU6ICd0aW1lJyxcbiAgRXF1YWw6ICc9PScsXG4gIE5vdEVxdWFsOiAnIT0nLFxuICBHcmVhdGVyVGhhbjogJz4nLFxuICBHcmVhdGVyVGhhbk9yRXF1YWxUbzogJz49JyxcbiAgTGVzc1RoYW46ICc8JyxcbiAgTGVzc1RoYW5PckVxdWFsVG86ICc8PScsXG4gIE11bHRpcGx5OiAnKicsXG4gIERpdmlkZTogJy8nLFxuICBBZGQ6ICcrJyxcbiAgU3VidHJhY3Q6ICctJyxcbiAgQ2xhbXA6ICdjbGFtcCcsXG4gIE1vZDogJyUnLFxuICBQb3c6ICdeJyxcbiAgQWJzOiAnYWJzJyxcbiAgRmxvb3I6ICdmbG9vcicsXG4gIENlaWw6ICdjZWlsJyxcbiAgUm91bmQ6ICdyb3VuZCcsXG4gIFNpbjogJ3NpbicsXG4gIENvczogJ2NvcycsXG4gIEF0YW46ICdhdGFuJyxcbiAgU3FydDogJ3NxcnQnLFxuICBNYXRjaDogJ21hdGNoJyxcbiAgQmV0d2VlbjogJ2JldHdlZW4nLFxuICBJbnRlcnBvbGF0ZTogJ2ludGVycG9sYXRlJyxcbiAgQ29hbGVzY2U6ICdjb2FsZXNjZScsXG4gIENhc2U6ICdjYXNlJyxcbiAgSW46ICdpbicsXG4gIE51bWJlcjogJ251bWJlcicsXG4gIFN0cmluZzogJ3N0cmluZycsXG4gIEFycmF5OiAnYXJyYXknLFxuICBDb2xvcjogJ2NvbG9yJyxcbiAgSWQ6ICdpZCcsXG4gIEJhbmQ6ICdiYW5kJyxcbiAgUGFsZXR0ZTogJ3BhbGV0dGUnLFxuICBUb1N0cmluZzogJ3RvLXN0cmluZycsXG4gIEhhczogJ2hhcycsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihBcnJheSwgbnVtYmVyLCBQYXJzaW5nQ29udGV4dCk6RXhwcmVzc2lvbn0gUGFyc2VyXG4gKlxuICogU2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBleHBlY3RlZCB0eXBlLlxuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIFBhcnNlcj59XG4gKi9cbmNvbnN0IHBhcnNlcnMgPSB7XG4gIFtPcHMuR2V0XTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoaGFzQXJnc0NvdW50KDEsIEluZmluaXR5KSwgd2l0aEdldEFyZ3MpLFxuICBbT3BzLlZhcl06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKGhhc0FyZ3NDb3VudCgxLCAxKSwgd2l0aFZhckFyZ3MpLFxuICBbT3BzLkhhc106IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKGhhc0FyZ3NDb3VudCgxLCBJbmZpbml0eSksIHdpdGhHZXRBcmdzKSxcbiAgW09wcy5JZF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKHVzZXNGZWF0dXJlSWQsIHdpdGhOb0FyZ3MpLFxuICBbT3BzLkNvbmNhdF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoU3RyaW5nVHlwZSksXG4gICksXG4gIFtPcHMuR2VvbWV0cnlUeXBlXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIodXNlc0dlb21ldHJ5VHlwZSwgd2l0aE5vQXJncyksXG4gIFtPcHMuTGluZU1ldHJpY106IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKHdpdGhOb0FyZ3MpLFxuICBbT3BzLlJlc29sdXRpb25dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcih3aXRoTm9BcmdzKSxcbiAgW09wcy5ab29tXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIod2l0aE5vQXJncyksXG4gIFtPcHMuVGltZV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKHdpdGhOb0FyZ3MpLFxuICBbT3BzLkFueV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQm9vbGVhblR5cGUpLFxuICApLFxuICBbT3BzLkFsbF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQm9vbGVhblR5cGUpLFxuICApLFxuICBbT3BzLk5vdF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShCb29sZWFuVHlwZSksXG4gICksXG4gIFtPcHMuRXF1YWxdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQW55VHlwZSksXG4gICksXG4gIFtPcHMuTm90RXF1YWxdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQW55VHlwZSksXG4gICksXG4gIFtPcHMuR3JlYXRlclRoYW5dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuR3JlYXRlclRoYW5PckVxdWFsVG9dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuTGVzc1RoYW5dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuTGVzc1RoYW5PckVxdWFsVG9dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuTXVsdGlwbHldOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgSW5maW5pdHkpLFxuICAgIHdpdGhBcmdzT2ZSZXR1cm5UeXBlLFxuICApLFxuICBbT3BzLkNvYWxlc2NlXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIEluZmluaXR5KSxcbiAgICB3aXRoQXJnc09mUmV0dXJuVHlwZSxcbiAgKSxcbiAgW09wcy5EaXZpZGVdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuQWRkXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIEluZmluaXR5KSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5TdWJ0cmFjdF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgyLCAyKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5DbGFtcF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgzLCAzKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5Nb2RdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMiwgMiksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuUG93XTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLkFic106IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5GbG9vcl06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5DZWlsXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDEsIDEpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLlJvdW5kXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDEsIDEpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLlNpbl06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5Db3NdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgMSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuQXRhbl06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAyKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5TcXJ0XTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDEsIDEpLFxuICAgIHdpdGhBcmdzT2ZUeXBlKE51bWJlclR5cGUpLFxuICApLFxuICBbT3BzLk1hdGNoXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDQsIEluZmluaXR5KSxcbiAgICBoYXNFdmVuQXJncyxcbiAgICB3aXRoTWF0Y2hBcmdzLFxuICApLFxuICBbT3BzLkJldHdlZW5dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMywgMyksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuSW50ZXJwb2xhdGVdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoNiwgSW5maW5pdHkpLFxuICAgIGhhc0V2ZW5BcmdzLFxuICAgIHdpdGhJbnRlcnBvbGF0ZUFyZ3MsXG4gICksXG4gIFtPcHMuQ2FzZV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgzLCBJbmZpbml0eSksXG4gICAgaGFzT2RkQXJncyxcbiAgICB3aXRoQ2FzZUFyZ3MsXG4gICksXG4gIFtPcHMuSW5dOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihoYXNBcmdzQ291bnQoMiwgMiksIHdpdGhJbkFyZ3MpLFxuICBbT3BzLk51bWJlcl06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoQW55VHlwZSksXG4gICksXG4gIFtPcHMuU3RyaW5nXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDEsIEluZmluaXR5KSxcbiAgICB3aXRoQXJnc09mVHlwZShBbnlUeXBlKSxcbiAgKSxcbiAgW09wcy5BcnJheV06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCBJbmZpbml0eSksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuQ29sb3JdOiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlcihcbiAgICBoYXNBcmdzQ291bnQoMSwgNCksXG4gICAgd2l0aEFyZ3NPZlR5cGUoTnVtYmVyVHlwZSksXG4gICksXG4gIFtPcHMuQmFuZF06IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAzKSxcbiAgICB3aXRoQXJnc09mVHlwZShOdW1iZXJUeXBlKSxcbiAgKSxcbiAgW09wcy5QYWxldHRlXTogY3JlYXRlQ2FsbEV4cHJlc3Npb25QYXJzZXIoXG4gICAgaGFzQXJnc0NvdW50KDIsIDIpLFxuICAgIHdpdGhQYWxldHRlQXJncyxcbiAgKSxcbiAgW09wcy5Ub1N0cmluZ106IGNyZWF0ZUNhbGxFeHByZXNzaW9uUGFyc2VyKFxuICAgIGhhc0FyZ3NDb3VudCgxLCAxKSxcbiAgICB3aXRoQXJnc09mVHlwZShCb29sZWFuVHlwZSB8IE51bWJlclR5cGUgfCBTdHJpbmdUeXBlIHwgQ29sb3JUeXBlKSxcbiAgKSxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEFycmF5PEVuY29kZWRFeHByZXNzaW9uPiwgbnVtYmVyLCBQYXJzaW5nQ29udGV4dCk6QXJyYXk8RXhwcmVzc2lvbj58dm9pZH0gQXJnVmFsaWRhdG9yXG4gKlxuICogQW4gYXJndW1lbnQgdmFsaWRhdG9yIGFwcGxpZXMgdmFyaW91cyBjaGVja3MgdG8gYW4gZW5jb2RlZCBleHByZXNzaW9uIGFyZ3VtZW50cyBhbmRcbiAqIHJldHVybnMgdGhlIHBhcnNlZCBhcmd1bWVudHMgaWYgYW55LiAgVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB3aXRoR2V0QXJncyhlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3NDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmdzQ291bnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3NDb3VudDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0gZW5jb2RlZFtpICsgMV07XG4gICAgc3dpdGNoICh0eXBlb2Yga2V5KSB7XG4gICAgICBjYXNlICdudW1iZXInOiB7XG4gICAgICAgIGFyZ3NbaV0gPSBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oTnVtYmVyVHlwZSwga2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgIGFyZ3NbaV0gPSBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oU3RyaW5nVHlwZSwga2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgZXhwZWN0ZWQgYSBzdHJpbmcga2V5IG9yIG51bWVyaWMgYXJyYXkgaW5kZXggZm9yIGEgZ2V0IG9wZXJhdGlvbiwgZ290ICR7a2V5fWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBjb250ZXh0LnByb3BlcnRpZXMuYWRkKFN0cmluZyhrZXkpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhWYXJBcmdzKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbmFtZSA9IGVuY29kZWRbMV07XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nIGFyZ3VtZW50IGZvciB2YXIgb3BlcmF0aW9uJyk7XG4gIH1cbiAgY29udGV4dC52YXJpYWJsZXMuYWRkKG5hbWUpO1xuXG4gIHJldHVybiBbbmV3IExpdGVyYWxFeHByZXNzaW9uKFN0cmluZ1R5cGUsIG5hbWUpXTtcbn1cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gdXNlc0ZlYXR1cmVJZChlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuZmVhdHVyZUlkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gdXNlc0dlb21ldHJ5VHlwZShlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuZ2VvbWV0cnlUeXBlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aE5vQXJncyhlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wZXJhdGlvbiA9IGVuY29kZWRbMF07XG4gIGlmIChlbmNvZGVkLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgbm8gYXJndW1lbnRzIGZvciAke29wZXJhdGlvbn0gb3BlcmF0aW9uYCk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5BcmdzIFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QXJncyBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzLlxuICogQHJldHVybiB7QXJnVmFsaWRhdG9yfSBUaGUgYXJndW1lbnQgdmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIGhhc0FyZ3NDb3VudChtaW5BcmdzLCBtYXhBcmdzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IGVuY29kZWRbMF07XG4gICAgY29uc3QgYXJnQ291bnQgPSBlbmNvZGVkLmxlbmd0aCAtIDE7XG4gICAgaWYgKG1pbkFyZ3MgPT09IG1heEFyZ3MpIHtcbiAgICAgIGlmIChhcmdDb3VudCAhPT0gbWluQXJncykge1xuICAgICAgICBjb25zdCBwbHVyYWwgPSBtaW5BcmdzID09PSAxID8gJycgOiAncyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgZXhwZWN0ZWQgJHttaW5BcmdzfSBhcmd1bWVudCR7cGx1cmFsfSBmb3IgJHtvcGVyYXRpb259LCBnb3QgJHthcmdDb3VudH1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJnQ291bnQgPCBtaW5BcmdzIHx8IGFyZ0NvdW50ID4gbWF4QXJncykge1xuICAgICAgY29uc3QgcmFuZ2UgPVxuICAgICAgICBtYXhBcmdzID09PSBJbmZpbml0eVxuICAgICAgICAgID8gYCR7bWluQXJnc30gb3IgbW9yZWBcbiAgICAgICAgICA6IGAke21pbkFyZ3N9IHRvICR7bWF4QXJnc31gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZXhwZWN0ZWQgJHtyYW5nZX0gYXJndW1lbnRzIGZvciAke29wZXJhdGlvbn0sIGdvdCAke2FyZ0NvdW50fWAsXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7QXJnVmFsaWRhdG9yfVxuICovXG5mdW5jdGlvbiB3aXRoQXJnc09mUmV0dXJuVHlwZShlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ0NvdW50ID0gZW5jb2RlZC5sZW5ndGggLSAxO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEV4cHJlc3Npb24+fVxuICAgKi9cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmdDb3VudCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnQ291bnQ7ICsraSkge1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShlbmNvZGVkW2kgKyAxXSwgcmV0dXJuVHlwZSwgY29udGV4dCk7XG4gICAgYXJnc1tpXSA9IGV4cHJlc3Npb247XG4gIH1cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ1R5cGUgVGhlIGFyZ3VtZW50IHR5cGUuXG4gKiBAcmV0dXJuIHtBcmdWYWxpZGF0b3J9IFRoZSBhcmd1bWVudCB2YWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aEFyZ3NPZlR5cGUoYXJnVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBhcmdDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RXhwcmVzc2lvbj59XG4gICAgICovXG4gICAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmdDb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UoZW5jb2RlZFtpICsgMV0sIGFyZ1R5cGUsIGNvbnRleHQpO1xuICAgICAgYXJnc1tpXSA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlIHtBcmdWYWxpZGF0b3J9XG4gKi9cbmZ1bmN0aW9uIGhhc09kZEFyZ3MoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb25zdCBvcGVyYXRpb24gPSBlbmNvZGVkWzBdO1xuICBjb25zdCBhcmdDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcbiAgaWYgKGFyZ0NvdW50ICUgMiA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBleHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgJHtvcGVyYXRpb259LCBnb3QgJHthcmdDb3VudH0gaW5zdGVhZGAsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlIHtBcmdWYWxpZGF0b3J9XG4gKi9cbmZ1bmN0aW9uIGhhc0V2ZW5BcmdzKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3BlcmF0aW9uID0gZW5jb2RlZFswXTtcbiAgY29uc3QgYXJnQ291bnQgPSBlbmNvZGVkLmxlbmd0aCAtIDE7XG4gIGlmIChhcmdDb3VudCAlIDIgPT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgZXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBvcGVyYXRpb24gJHtvcGVyYXRpb259LCBnb3QgJHthcmdDb3VudH0gaW5zdGVhZGAsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB3aXRoTWF0Y2hBcmdzKGVuY29kZWQsIHJldHVyblR5cGUsIGNvbnRleHQpIHtcbiAgY29uc3QgYXJnc0NvdW50ID0gZW5jb2RlZC5sZW5ndGggLSAxO1xuXG4gIGNvbnN0IGlucHV0VHlwZSA9IFN0cmluZ1R5cGUgfCBOdW1iZXJUeXBlIHwgQm9vbGVhblR5cGU7XG5cbiAgY29uc3QgaW5wdXQgPSBwYXJzZShlbmNvZGVkWzFdLCBpbnB1dFR5cGUsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGZhbGxiYWNrID0gcGFyc2UoZW5jb2RlZFtlbmNvZGVkLmxlbmd0aCAtIDFdLCByZXR1cm5UeXBlLCBjb250ZXh0KTtcblxuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3NDb3VudCAtIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3NDb3VudCAtIDI7IGkgKz0gMikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHBhcnNlKGVuY29kZWRbaSArIDJdLCBpbnB1dC50eXBlLCBjb250ZXh0KTtcbiAgICAgIGFyZ3NbaV0gPSBtYXRjaDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBwYXJzZSBhcmd1bWVudCAke2kgKyAxfSBvZiBtYXRjaCBleHByZXNzaW9uOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gcGFyc2UoZW5jb2RlZFtpICsgM10sIGZhbGxiYWNrLnR5cGUsIGNvbnRleHQpO1xuICAgICAgYXJnc1tpICsgMV0gPSBvdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gcGFyc2UgYXJndW1lbnQgJHtpICsgMn0gb2YgbWF0Y2ggZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2lucHV0LCAuLi5hcmdzLCBmYWxsYmFja107XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhJbnRlcnBvbGF0ZUFyZ3MoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb25zdCBpbnRlcnBvbGF0aW9uVHlwZSA9IGVuY29kZWRbMV07XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGV0IGJhc2U7XG4gIHN3aXRjaCAoaW50ZXJwb2xhdGlvblR5cGVbMF0pIHtcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgYmFzZSA9IDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdleHBvbmVudGlhbCc6XG4gICAgICBjb25zdCBiID0gaW50ZXJwb2xhdGlvblR5cGVbMV07XG4gICAgICBpZiAodHlwZW9mIGIgIT09ICdudW1iZXInIHx8IGIgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYGV4cGVjdGVkIGEgbnVtYmVyIGJhc2UgZm9yIGV4cG9uZW50aWFsIGludGVycG9sYXRpb25gICtcbiAgICAgICAgICAgIGAsIGdvdCAke0pTT04uc3RyaW5naWZ5KGIpfSBpbnN0ZWFkYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSBiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGludmFsaWQgaW50ZXJwb2xhdGlvbiB0eXBlOiAke0pTT04uc3RyaW5naWZ5KGludGVycG9sYXRpb25UeXBlKX1gLFxuICAgICAgKTtcbiAgfVxuXG4gIGNvbnN0IGludGVycG9sYXRpb24gPSBuZXcgTGl0ZXJhbEV4cHJlc3Npb24oTnVtYmVyVHlwZSwgYmFzZSk7XG5cbiAgbGV0IGlucHV0O1xuICB0cnkge1xuICAgIGlucHV0ID0gcGFyc2UoZW5jb2RlZFsyXSwgTnVtYmVyVHlwZSwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBmYWlsZWQgdG8gcGFyc2UgYXJndW1lbnQgMSBpbiBpbnRlcnBvbGF0ZSBleHByZXNzaW9uOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoZW5jb2RlZC5sZW5ndGggLSAzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3AgPSBwYXJzZShlbmNvZGVkW2kgKyAzXSwgTnVtYmVyVHlwZSwgY29udGV4dCk7XG4gICAgICBhcmdzW2ldID0gc3RvcDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBwYXJzZSBhcmd1bWVudCAke2kgKyAyfSBmb3IgaW50ZXJwb2xhdGUgZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHBhcnNlKGVuY29kZWRbaSArIDRdLCByZXR1cm5UeXBlLCBjb250ZXh0KTtcbiAgICAgIGFyZ3NbaSArIDFdID0gb3V0cHV0O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZmFpbGVkIHRvIHBhcnNlIGFyZ3VtZW50ICR7aSArIDN9IGZvciBpbnRlcnBvbGF0ZSBleHByZXNzaW9uOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbaW50ZXJwb2xhdGlvbiwgaW5wdXQsIC4uLmFyZ3NdO1xufVxuXG4vKipcbiAqIEB0eXBlIEFyZ1ZhbGlkYXRvclxuICovXG5mdW5jdGlvbiB3aXRoQ2FzZUFyZ3MoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICBjb25zdCBmYWxsYmFjayA9IHBhcnNlKGVuY29kZWRbZW5jb2RlZC5sZW5ndGggLSAxXSwgcmV0dXJuVHlwZSwgY29udGV4dCk7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShlbmNvZGVkLmxlbmd0aCAtIDEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHBhcnNlKGVuY29kZWRbaSArIDFdLCBCb29sZWFuVHlwZSwgY29udGV4dCk7XG4gICAgICBhcmdzW2ldID0gY29uZGl0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgZmFpbGVkIHRvIHBhcnNlIGFyZ3VtZW50ICR7aX0gb2YgY2FzZSBleHByZXNzaW9uOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gcGFyc2UoZW5jb2RlZFtpICsgMl0sIGZhbGxiYWNrLnR5cGUsIGNvbnRleHQpO1xuICAgICAgYXJnc1tpICsgMV0gPSBvdXRwdXQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gcGFyc2UgYXJndW1lbnQgJHtpICsgMX0gb2YgY2FzZSBleHByZXNzaW9uOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGZhbGxiYWNrO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aEluQXJncyhlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGxldCBoYXlzdGFjayA9IGVuY29kZWRbMl07XG4gIGlmICghQXJyYXkuaXNBcnJheShoYXlzdGFjaykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgdGhlIHNlY29uZCBhcmd1bWVudCBmb3IgdGhlIFwiaW5cIiBvcGVyYXRvciBtdXN0IGJlIGFuIGFycmF5YCxcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGV0IG5lZWRsZVR5cGU7XG4gIGlmICh0eXBlb2YgaGF5c3RhY2tbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGhheXN0YWNrWzBdICE9PSAnbGl0ZXJhbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZvciB0aGUgXCJpblwiIG9wZXJhdG9yLCBhIHN0cmluZyBhcnJheSBzaG91bGQgYmUgd3JhcHBlZCBpbiBhIFwibGl0ZXJhbFwiIG9wZXJhdG9yIHRvIGRpc2FtYmlndWF0ZSBmcm9tIGV4cHJlc3Npb25zYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShoYXlzdGFja1sxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBwYXJzZSBcImluXCIgZXhwcmVzc2lvbjogdGhlIGxpdGVyYWwgb3BlcmF0b3IgbXVzdCBiZSBmb2xsb3dlZCBieSBhbiBhcnJheWAsXG4gICAgICApO1xuICAgIH1cbiAgICBoYXlzdGFjayA9IGhheXN0YWNrWzFdO1xuICAgIG5lZWRsZVR5cGUgPSBTdHJpbmdUeXBlO1xuICB9IGVsc2Uge1xuICAgIG5lZWRsZVR5cGUgPSBOdW1iZXJUeXBlO1xuICB9XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShoYXlzdGFjay5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXJnID0gcGFyc2UoaGF5c3RhY2tbaV0sIG5lZWRsZVR5cGUsIGNvbnRleHQpO1xuICAgICAgYXJnc1tpXSA9IGFyZztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBwYXJzZSBoYXlzdGFjayBpdGVtICR7aX0gZm9yIFwiaW5cIiBleHByZXNzaW9uOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5lZWRsZSA9IHBhcnNlKGVuY29kZWRbMV0sIG5lZWRsZVR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gW25lZWRsZSwgLi4uYXJnc107XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhQYWxldHRlQXJncyhlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleDtcbiAgdHJ5IHtcbiAgICBpbmRleCA9IHBhcnNlKGVuY29kZWRbMV0sIE51bWJlclR5cGUsIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgZmFpbGVkIHRvIHBhcnNlIGZpcnN0IGFyZ3VtZW50IGluIHBhbGV0dGUgZXhwcmVzc2lvbjogJHtlcnIubWVzc2FnZX1gLFxuICAgICk7XG4gIH1cbiAgY29uc3QgY29sb3JzID0gZW5jb2RlZFsyXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9ycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBzZWNvbmQgYXJndW1lbnQgb2YgcGFsZXR0ZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cbiAgY29uc3QgcGFyc2VkQ29sb3JzID0gbmV3IEFycmF5KGNvbG9ycy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZENvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjb2xvcjtcbiAgICB0cnkge1xuICAgICAgY29sb3IgPSBwYXJzZShjb2xvcnNbaV0sIENvbG9yVHlwZSwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmYWlsZWQgdG8gcGFyc2UgY29sb3IgYXQgaW5kZXggJHtpfSBpbiBwYWxldHRlIGV4cHJlc3Npb246ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghKGNvbG9yIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0aGUgcGFsZXR0ZSBjb2xvciBhdCBpbmRleCAke2l9IG11c3QgYmUgYSBsaXRlcmFsIHZhbHVlYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHBhcnNlZENvbG9yc1tpXSA9IGNvbG9yO1xuICB9XG4gIHJldHVybiBbaW5kZXgsIC4uLnBhcnNlZENvbG9yc107XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBcmdWYWxpZGF0b3I+fSB2YWxpZGF0b3JzIEEgY2hhaW4gb2YgYXJndW1lbnQgdmFsaWRhdG9ycy4gIFRoZSBsYXN0IHZhbGlkYXRvciBpcyBleHBlY3RlZFxuICogdG8gcmV0dXJuIHRoZSBwYXJzZWQgYXJndW1lbnRzLlxuICogQHJldHVybiB7UGFyc2VyfSBUaGUgcGFyc2VyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvblBhcnNlciguLi52YWxpZGF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCkge1xuICAgIGNvbnN0IG9wZXJhdG9yID0gZW5jb2RlZFswXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxFeHByZXNzaW9uPn1cbiAgICAgKi9cbiAgICBsZXQgYXJncztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHZhbGlkYXRvcnNbaV0oZW5jb2RlZCwgcmV0dXJuVHlwZSwgY29udGV4dCk7XG4gICAgICBpZiAoaSA9PSB2YWxpZGF0b3JzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnZXhwZWN0ZWQgbGFzdCBhcmd1bWVudCB2YWxpZGF0b3IgdG8gcmV0dXJuIHRoZSBwYXJzZWQgYXJncycsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzID0gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENhbGxFeHByZXNzaW9uKHJldHVyblR5cGUsIG9wZXJhdG9yLCAuLi5hcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBlbmNvZGVkIFRoZSBlbmNvZGVkIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0dXJuVHlwZSBUaGUgZXhwZWN0ZWQgcmV0dXJuIHR5cGUgb2YgdGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb259IFRoZSBwYXJzZWQgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDYWxsRXhwcmVzc2lvbihlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wZXJhdG9yID0gZW5jb2RlZFswXTtcblxuICBjb25zdCBwYXJzZXIgPSBwYXJzZXJzW29wZXJhdG9yXTtcbiAgaWYgKCFwYXJzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gb3BlcmF0b3I6ICR7b3BlcmF0b3J9YCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlcihlbmNvZGVkLCByZXR1cm5UeXBlLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2ltcGxpZmllZCBnZW9tZXRyeSB0eXBlIHN1aXRlZCBmb3IgdGhlIGBnZW9tZXRyeS10eXBlYCBvcGVyYXRvclxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2dlb20vR2VvbWV0cnkuanMnKS5kZWZhdWx0fGltcG9ydCgnLi4vcmVuZGVyL0ZlYXR1cmUuanMnKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeSBvYmplY3RcbiAqIEByZXR1cm4geydQb2ludCd8J0xpbmVTdHJpbmcnfCdQb2x5Z29uJ3wnJ30gU2ltcGxpZmllZCBnZW9tZXRyeSB0eXBlOyBlbXB0eSBzdHJpbmcgb2Ygbm8gZ2VvbWV0cnkgZm91bmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVHZW9tZXRyeVR5cGUoZ2VvbWV0cnkpIHtcbiAgaWYgKCFnZW9tZXRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHsnUG9pbnQnfCdMaW5lU3RyaW5nJ3wnUG9seWdvbid9ICovICh0eXBlLnN1YnN0cmluZyg1KSk7XG4gICAgY2FzZSAnQ2lyY2xlJzpcbiAgICAgIHJldHVybiAnUG9seWdvbic7XG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgIHJldHVybiBjb21wdXRlR2VvbWV0cnlUeXBlKFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICApLmdldEdlb21ldHJpZXMoKVswXSxcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9leHByL2NwdVxuICovXG5cbmltcG9ydCB7Q29sb3JUeXBlLCBMaXRlcmFsRXhwcmVzc2lvbiwgT3BzLCBwYXJzZX0gZnJvbSAnLi9leHByZXNzaW9uLmpzJztcbmltcG9ydCB7XG4gIGZyb21TdHJpbmcsXG4gIGxjaGFUb1JnYmEsXG4gIG5vcm1hbGl6ZSxcbiAgcmdiYVRvTGNoYSxcbiAgdG9TdHJpbmcsXG4gIHdpdGhBbHBoYSxcbn0gZnJvbSAnLi4vY29sb3IuanMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaW5jbHVkZXMgZnVuY3Rpb25zIHRvIGJ1aWxkIGV4cHJlc3Npb25zIGZvciBldmFsdWF0aW9uIG9uIHRoZSBDUFUuXG4gKiBCdWlsZGluZyBpcyBjb21wb3NlZCBvZiB0d28gc3RlcHM6IHBhcnNpbmcgYW5kIGNvbXBpbGluZy4gIFRoZSBwYXJzaW5nIHN0ZXAgdGFrZXMgYW4gZW5jb2RlZFxuICogZXhwcmVzc2lvbiBhbmQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBvbmUgb2YgdGhlIGV4cHJlc3Npb24gY2xhc3Nlcy4gIFRoZSBjb21waWxpbmcgc3RlcCB0YWtlc1xuICogdGhlIGV4cHJlc3Npb24gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgaW4gdG8gcmV0dXJuIGEgbGl0ZXJhbFxuICogdmFsdWUuICBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uIHNob3VsZCBkbyBhcyBsaXR0bGUgYWxsb2NhdGlvbiBhbmQgd29yayBhcyBwb3NzaWJsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2YWx1YXRpb25Db250ZXh0XG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydGllcyBUaGUgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHVzZWQgaW4gJ2dldCcgZXhwcmVzc2lvbnMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gdmFyaWFibGVzIFRoZSB2YWx1ZXMgZm9yIHZhcmlhYmxlcyB1c2VkIGluICd2YXInIGV4cHJlc3Npb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIG1hcCByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfG51bGx9IGZlYXR1cmVJZCBUaGUgZmVhdHVyZSBpZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnZW9tZXRyeVR5cGUgR2VvbWV0cnkgdHlwZSBvZiB0aGUgY3VycmVudCBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtFdmFsdWF0aW9uQ29udGV4dH0gQSBuZXcgZXZhbHVhdGlvbiBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmV3RXZhbHVhdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgdmFyaWFibGVzOiB7fSxcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICByZXNvbHV0aW9uOiBOYU4sXG4gICAgZmVhdHVyZUlkOiBudWxsLFxuICAgIGdlb21ldHJ5VHlwZTogJycsXG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTppbXBvcnQoXCIuL2V4cHJlc3Npb24uanNcIikuTGl0ZXJhbFZhbHVlfSBFeHByZXNzaW9uRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOmJvb2xlYW59IEJvb2xlYW5FdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6bnVtYmVyfSBOdW1iZXJFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6c3RyaW5nfSBTdHJpbmdFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6KEFycmF5PG51bWJlcj58c3RyaW5nKX0gQ29sb3JMaWtlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOkFycmF5PG51bWJlcj59IE51bWJlckFycmF5RXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOkFycmF5PG51bWJlcj59IENvb3JkaW5hdGVFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6KEFycmF5PG51bWJlcj4pfSBTaXplRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOihBcnJheTxudW1iZXI+fG51bWJlcil9IFNpemVMaWtlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuRW5jb2RlZEV4cHJlc3Npb259IGVuY29kZWQgVGhlIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZW5jb2RlZCwgdHlwZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UoZW5jb2RlZCwgdHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXhwcmVzc2lvbi5qc1wiKS5FeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pIHtcbiAgICAvLyBjb252ZXJ0IGNvbG9ycyB0byBhcnJheSBpZiBwb3NzaWJsZVxuICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IENvbG9yVHlwZSAmJiB0eXBlb2YgZXhwcmVzc2lvbi52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBmcm9tU3RyaW5nKGV4cHJlc3Npb24udmFsdWUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yVmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcGVyYXRvciA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlIE9wcy5OdW1iZXI6XG4gICAgY2FzZSBPcHMuU3RyaW5nOlxuICAgIGNhc2UgT3BzLkNvYWxlc2NlOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUFzc2VydGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdldDpcbiAgICBjYXNlIE9wcy5WYXI6XG4gICAgY2FzZSBPcHMuSGFzOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUFjY2Vzc29yRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuSWQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gY29udGV4dC5mZWF0dXJlSWQ7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdlb21ldHJ5VHlwZToge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBjb250ZXh0Lmdlb21ldHJ5VHlwZTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQ29uY2F0OiB7XG4gICAgICBjb25zdCBhcmdzID0gZXhwcmVzc2lvbi5hcmdzLm1hcCgoZSkgPT4gY29tcGlsZUV4cHJlc3Npb24oZSwgY29udGV4dCkpO1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PlxuICAgICAgICAnJy5jb25jYXQoLi4uYXJncy5tYXAoKGFyZykgPT4gYXJnKGNvbnRleHQpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuUmVzb2x1dGlvbjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBjb250ZXh0LnJlc29sdXRpb247XG4gICAgfVxuICAgIGNhc2UgT3BzLkFueTpcbiAgICBjYXNlIE9wcy5BbGw6XG4gICAgY2FzZSBPcHMuQmV0d2VlbjpcbiAgICBjYXNlIE9wcy5JbjpcbiAgICBjYXNlIE9wcy5Ob3Q6IHtcbiAgICAgIHJldHVybiBjb21waWxlTG9naWNhbEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkVxdWFsOlxuICAgIGNhc2UgT3BzLk5vdEVxdWFsOlxuICAgIGNhc2UgT3BzLkxlc3NUaGFuOlxuICAgIGNhc2UgT3BzLkxlc3NUaGFuT3JFcXVhbFRvOlxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuOlxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUNvbXBhcmlzb25FeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5NdWx0aXBseTpcbiAgICBjYXNlIE9wcy5EaXZpZGU6XG4gICAgY2FzZSBPcHMuQWRkOlxuICAgIGNhc2UgT3BzLlN1YnRyYWN0OlxuICAgIGNhc2UgT3BzLkNsYW1wOlxuICAgIGNhc2UgT3BzLk1vZDpcbiAgICBjYXNlIE9wcy5Qb3c6XG4gICAgY2FzZSBPcHMuQWJzOlxuICAgIGNhc2UgT3BzLkZsb29yOlxuICAgIGNhc2UgT3BzLkNlaWw6XG4gICAgY2FzZSBPcHMuUm91bmQ6XG4gICAgY2FzZSBPcHMuU2luOlxuICAgIGNhc2UgT3BzLkNvczpcbiAgICBjYXNlIE9wcy5BdGFuOlxuICAgIGNhc2UgT3BzLlNxcnQ6IHtcbiAgICAgIHJldHVybiBjb21waWxlTnVtZXJpY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkNhc2U6IHtcbiAgICAgIHJldHVybiBjb21waWxlQ2FzZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLk1hdGNoOiB7XG4gICAgICByZXR1cm4gY29tcGlsZU1hdGNoRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuSW50ZXJwb2xhdGU6IHtcbiAgICAgIHJldHVybiBjb21waWxlSW50ZXJwb2xhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Ub1N0cmluZzoge1xuICAgICAgcmV0dXJuIGNvbXBpbGVDb252ZXJ0RXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRvciAke29wZXJhdG9yfWApO1xuICAgIH1cbiAgICAvLyBUT0RPOiB1bmltcGxlbWVudGVkXG4gICAgLy8gT3BzLlpvb21cbiAgICAvLyBPcHMuVGltZVxuICAgIC8vIE9wcy5BcnJheVxuICAgIC8vIE9wcy5Db2xvclxuICAgIC8vIE9wcy5CYW5kXG4gICAgLy8gT3BzLlBhbGV0dGVcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQXNzZXJ0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBleHByZXNzaW9uLm9wZXJhdG9yO1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3NbaV0sIGNvbnRleHQpO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgT3BzLkNvYWxlc2NlOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG9uZSBvZiB0aGUgdmFsdWVzIHRvIGJlIG5vbi1udWxsJyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5OdW1iZXI6XG4gICAgY2FzZSBPcHMuU3RyaW5nOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgb25lIG9mIHRoZSB2YWx1ZXMgdG8gYmUgYSAke3R5cGV9YCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFzc2VydGlvbiBvcGVyYXRvciAke3R5cGV9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVBY2Nlc3NvckV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBuYW1lRXhwcmVzc2lvbiA9IC8qKiBAdHlwZSB7TGl0ZXJhbEV4cHJlc3Npb259ICovIChleHByZXNzaW9uLmFyZ3NbMF0pO1xuICBjb25zdCBuYW1lID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChuYW1lRXhwcmVzc2lvbi52YWx1ZSk7XG4gIHN3aXRjaCAoZXhwcmVzc2lvbi5vcGVyYXRvcikge1xuICAgIGNhc2UgT3BzLkdldDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBleHByZXNzaW9uLmFyZ3M7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvbnRleHQucHJvcGVydGllc1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDEsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgY29uc3Qga2V5RXhwcmVzc2lvbiA9IC8qKiBAdHlwZSB7TGl0ZXJhbEV4cHJlc3Npb259ICovIChhcmdzW2ldKTtcbiAgICAgICAgICBjb25zdCBrZXkgPSAvKiogQHR5cGUge3N0cmluZ3xudW1iZXJ9ICovIChrZXlFeHByZXNzaW9uLnZhbHVlKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuVmFyOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGNvbnRleHQudmFyaWFibGVzW25hbWVdO1xuICAgIH1cbiAgICBjYXNlIE9wcy5IYXM6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBhcmdzID0gZXhwcmVzc2lvbi5hcmdzO1xuICAgICAgICBpZiAoIShuYW1lIGluIGNvbnRleHQucHJvcGVydGllcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlID0gY29udGV4dC5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgICBmb3IgKGxldCBpID0gMSwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBrZXlFeHByZXNzaW9uID0gLyoqIEB0eXBlIHtMaXRlcmFsRXhwcmVzc2lvbn0gKi8gKGFyZ3NbaV0pO1xuICAgICAgICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfG51bWJlcn0gKi8gKGtleUV4cHJlc3Npb24udmFsdWUpO1xuICAgICAgICAgIGlmICghdmFsdWUgfHwgIU9iamVjdC5oYXNPd24odmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhY2Nlc3NvciBvcGVyYXRvciAke2V4cHJlc3Npb24ub3BlcmF0b3J9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0Jvb2xlYW5FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDb21wYXJpc29uRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wID0gZXhwcmVzc2lvbi5vcGVyYXRvcjtcbiAgY29uc3QgbGVmdCA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1swXSwgY29udGV4dCk7XG4gIGNvbnN0IHJpZ2h0ID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzWzFdLCBjb250ZXh0KTtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLkVxdWFsOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGxlZnQoY29udGV4dCkgPT09IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Ob3RFcXVhbDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpICE9PSByaWdodChjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTGVzc1RoYW46IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gbGVmdChjb250ZXh0KSA8IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5MZXNzVGhhbk9yRXF1YWxUbzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpIDw9IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5HcmVhdGVyVGhhbjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpID4gcmlnaHQoY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGxlZnQoY29udGV4dCkgPj0gcmlnaHQoY29udGV4dCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcGFyaXNvbiBvcGVyYXRvciAke29wfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtCb29sZWFuRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlTG9naWNhbEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBvcCA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLkFueToge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoYXJnc1tpXShjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgT3BzLkFsbDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWFyZ3NbaV0oY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5CZXR3ZWVuOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzBdKGNvbnRleHQpO1xuICAgICAgICBjb25zdCBtaW4gPSBhcmdzWzFdKGNvbnRleHQpO1xuICAgICAgICBjb25zdCBtYXggPSBhcmdzWzJdKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgT3BzLkluOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzBdKGNvbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBhcmdzW2ldKGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTm90OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+ICFhcmdzWzBdKGNvbnRleHQpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2ljYWwgb3BlcmF0b3IgJHtvcH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7TnVtYmVyRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlTnVtZXJpY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBvcCA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLk11bHRpcGx5OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhbHVlICo9IGFyZ3NbaV0oY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBPcHMuRGl2aWRlOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGFyZ3NbMF0oY29udGV4dCkgLyBhcmdzWzFdKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5BZGQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFsdWUgKz0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5TdWJ0cmFjdDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBhcmdzWzBdKGNvbnRleHQpIC0gYXJnc1sxXShjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQ2xhbXA6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF0oY29udGV4dCk7XG4gICAgICAgIGNvbnN0IG1pbiA9IGFyZ3NbMV0oY29udGV4dCk7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4ID0gYXJnc1syXShjb250ZXh0KTtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5Nb2Q6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gYXJnc1swXShjb250ZXh0KSAlIGFyZ3NbMV0oY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLlBvdzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLnBvdyhhcmdzWzBdKGNvbnRleHQpLCBhcmdzWzFdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQWJzOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguYWJzKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5GbG9vcjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmZsb29yKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5DZWlsOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguY2VpbChhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuUm91bmQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5yb3VuZChhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuU2luOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguc2luKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Db3M6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5jb3MoYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkF0YW46IHtcbiAgICAgIGlmIChsZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmF0YW4yKGFyZ3NbMF0oY29udGV4dCksIGFyZ3NbMV0oY29udGV4dCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmF0YW4oYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLlNxcnQ6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5zcXJ0KGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG51bWVyaWMgb3BlcmF0b3IgJHtvcH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbkV2YWx1YXRvcn0gVGhlIGV2YWx1YXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUNhc2VFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbi5hcmdzLmxlbmd0aDtcbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGFyZ3NbaV0oY29udGV4dCk7XG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2kgKyAxXShjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3NbbGVuZ3RoIC0gMV0oY29udGV4dCk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVNYXRjaEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2ldID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzW2ldLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF0oY29udGV4dCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKHZhbHVlID09PSBhcmdzW2ldKGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2kgKyAxXShjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3NbbGVuZ3RoIC0gMV0oY29udGV4dCk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVJbnRlcnBvbGF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2ldID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzW2ldLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBiYXNlID0gYXJnc1swXShjb250ZXh0KTtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMV0oY29udGV4dCk7XG5cbiAgICBsZXQgcHJldmlvdXNJbnB1dDtcbiAgICBsZXQgcHJldmlvdXNPdXRwdXQ7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBhcmdzW2ldKGNvbnRleHQpO1xuICAgICAgbGV0IG91dHB1dCA9IGFyZ3NbaSArIDFdKGNvbnRleHQpO1xuICAgICAgY29uc3QgaXNDb2xvciA9IEFycmF5LmlzQXJyYXkob3V0cHV0KTtcbiAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgIG91dHB1dCA9IHdpdGhBbHBoYShvdXRwdXQpO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0ID49IHZhbHVlKSB7XG4gICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUNvbG9yKFxuICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcHJldmlvdXNJbnB1dCxcbiAgICAgICAgICAgIHByZXZpb3VzT3V0cHV0LFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVOdW1iZXIoXG4gICAgICAgICAgYmFzZSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91c0lucHV0LFxuICAgICAgICAgIHByZXZpb3VzT3V0cHV0LFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzSW5wdXQgPSBpbnB1dDtcbiAgICAgIHByZXZpb3VzT3V0cHV0ID0gb3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNPdXRwdXQ7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0V4cHJlc3Npb25FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDb252ZXJ0RXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wID0gZXhwcmVzc2lvbi5vcGVyYXRvcjtcbiAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbi5hcmdzLmxlbmd0aDtcblxuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2ldID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzW2ldLCBjb250ZXh0KTtcbiAgfVxuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSBPcHMuVG9TdHJpbmc6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF0oY29udGV4dCk7XG4gICAgICAgIGlmIChleHByZXNzaW9uLmFyZ3NbMF0udHlwZSA9PT0gQ29sb3JUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29udmVydCBvcGVyYXRvciAke29wfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlIFRoZSBiYXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dDEgVGhlIGZpcnN0IGlucHV0IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IG91dHB1dDEgVGhlIGZpcnN0IG91dHB1dCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dDIgVGhlIHNlY29uZCBpbnB1dCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRwdXQyIFRoZSBzZWNvbmQgb3V0cHV0IHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCBvdXRwdXQxLCBpbnB1dDIsIG91dHB1dDIpIHtcbiAgY29uc3QgZGVsdGEgPSBpbnB1dDIgLSBpbnB1dDE7XG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIHJldHVybiBvdXRwdXQxO1xuICB9XG4gIGNvbnN0IGFsb25nID0gdmFsdWUgLSBpbnB1dDE7XG4gIGNvbnN0IGZhY3RvciA9XG4gICAgYmFzZSA9PT0gMVxuICAgICAgPyBhbG9uZyAvIGRlbHRhXG4gICAgICA6IChNYXRoLnBvdyhiYXNlLCBhbG9uZykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCBkZWx0YSkgLSAxKTtcbiAgcmV0dXJuIG91dHB1dDEgKyBmYWN0b3IgKiAob3V0cHV0MiAtIG91dHB1dDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlIFRoZSBiYXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dDEgVGhlIGZpcnN0IGlucHV0IHZhbHVlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvbG9yLmpzJykuQ29sb3J9IHJnYmExIFRoZSBmaXJzdCBvdXRwdXQgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5wdXQyIFRoZSBzZWNvbmQgaW5wdXQgdmFsdWUuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29sb3IuanMnKS5Db2xvcn0gcmdiYTIgVGhlIHNlY29uZCBvdXRwdXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uL2NvbG9yLmpzJykuQ29sb3J9IFRoZSBpbnRlcnBvbGF0ZWQgY29sb3IuXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoYmFzZSwgdmFsdWUsIGlucHV0MSwgcmdiYTEsIGlucHV0MiwgcmdiYTIpIHtcbiAgY29uc3QgZGVsdGEgPSBpbnB1dDIgLSBpbnB1dDE7XG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIHJldHVybiByZ2JhMTtcbiAgfVxuICBjb25zdCBsY2hhMSA9IHJnYmFUb0xjaGEocmdiYTEpO1xuICBjb25zdCBsY2hhMiA9IHJnYmFUb0xjaGEocmdiYTIpO1xuICBsZXQgZGVsdGFIdWUgPSBsY2hhMlsyXSAtIGxjaGExWzJdO1xuICBpZiAoZGVsdGFIdWUgPiAxODApIHtcbiAgICBkZWx0YUh1ZSAtPSAzNjA7XG4gIH0gZWxzZSBpZiAoZGVsdGFIdWUgPCAtMTgwKSB7XG4gICAgZGVsdGFIdWUgKz0gMzYwO1xuICB9XG5cbiAgY29uc3QgbGNoYSA9IFtcbiAgICBpbnRlcnBvbGF0ZU51bWJlcihiYXNlLCB2YWx1ZSwgaW5wdXQxLCBsY2hhMVswXSwgaW5wdXQyLCBsY2hhMlswXSksXG4gICAgaW50ZXJwb2xhdGVOdW1iZXIoYmFzZSwgdmFsdWUsIGlucHV0MSwgbGNoYTFbMV0sIGlucHV0MiwgbGNoYTJbMV0pLFxuICAgIGxjaGExWzJdICsgaW50ZXJwb2xhdGVOdW1iZXIoYmFzZSwgdmFsdWUsIGlucHV0MSwgMCwgaW5wdXQyLCBkZWx0YUh1ZSksXG4gICAgaW50ZXJwb2xhdGVOdW1iZXIoYmFzZSwgdmFsdWUsIGlucHV0MSwgcmdiYTFbM10sIGlucHV0MiwgcmdiYTJbM10pLFxuICBdO1xuICByZXR1cm4gbm9ybWFsaXplKGxjaGFUb1JnYmEobGNoYSkpO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL3N0eWxlXG4gKi9cblxuaW1wb3J0IENpcmNsZSBmcm9tICcuLi8uLi9zdHlsZS9DaXJjbGUuanMnO1xuaW1wb3J0IEZpbGwgZnJvbSAnLi4vLi4vc3R5bGUvRmlsbC5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuLi8uLi9zdHlsZS9JY29uLmpzJztcbmltcG9ydCBSZWd1bGFyU2hhcGUgZnJvbSAnLi4vLi4vc3R5bGUvUmVndWxhclNoYXBlLmpzJztcbmltcG9ydCBTdHJva2UgZnJvbSAnLi4vLi4vc3R5bGUvU3Ryb2tlLmpzJztcbmltcG9ydCBTdHlsZSBmcm9tICcuLi8uLi9zdHlsZS9TdHlsZS5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuLi8uLi9zdHlsZS9UZXh0LmpzJztcbmltcG9ydCB7XG4gIEJvb2xlYW5UeXBlLFxuICBDb2xvclR5cGUsXG4gIE51bWJlckFycmF5VHlwZSxcbiAgTnVtYmVyVHlwZSxcbiAgU3RyaW5nVHlwZSxcbiAgY29tcHV0ZUdlb21ldHJ5VHlwZSxcbiAgbmV3UGFyc2luZ0NvbnRleHQsXG59IGZyb20gJy4uLy4uL2V4cHIvZXhwcmVzc2lvbi5qcyc7XG5pbXBvcnQge05PX0NPTE9SfSBmcm9tICcuLi8uLi9jb2xvci5qcyc7XG5pbXBvcnQge2J1aWxkRXhwcmVzc2lvbiwgbmV3RXZhbHVhdGlvbkNvbnRleHR9IGZyb20gJy4uLy4uL2V4cHIvY3B1LmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vLi4vb2JqLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi8uLi9zaXplLmpzJztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgbW9kdWxlIGluY2x1ZGVzIGZ1bmN0aW9ucyB0byBidWlsZCBzdHlsZXMgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIuICBCdWlsZGluZ1xuICogaXMgY29tcG9zZWQgb2YgdHdvIHN0ZXBzOiBwYXJzaW5nIGFuZCBjb21waWxpbmcuICBUaGUgcGFyc2luZyBzdGVwIHRha2VzIGFuIGVuY29kZWQgZXhwcmVzc2lvblxuICogYW5kIHJldHVybnMgYW4gaW5zdGFuY2Ugb2Ygb25lIG9mIHRoZSBleHByZXNzaW9uIGNsYXNzZXMuICBUaGUgY29tcGlsaW5nIHN0ZXAgdGFrZXMgdGhlXG4gKiBleHByZXNzaW9uIGluc3RhbmNlIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgZXZhbHVhdGVkIHRvIHJldHVybiBhIGxpdGVyYWwgdmFsdWUuICBUaGVcbiAqIGV2YWx1YXRvciBmdW5jdGlvbiBzaG91bGQgZG8gYXMgbGl0dGxlIGFsbG9jYXRpb24gYW5kIHdvcmsgYXMgcG9zc2libGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGV9IEZsYXRTdHlsZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2V4cHIvZXhwcmVzc2lvbi5qc1wiKS5FbmNvZGVkRXhwcmVzc2lvbn0gRW5jb2RlZEV4cHJlc3Npb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9leHByL2V4cHJlc3Npb24uanNcIikuUGFyc2luZ0NvbnRleHR9IFBhcnNpbmdDb250ZXh0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9leHByZXNzaW9uLmpzXCIpLkNhbGxFeHByZXNzaW9ufSBDYWxsRXhwcmVzc2lvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2V4cHIvY3B1LmpzXCIpLkV2YWx1YXRpb25Db250ZXh0fSBFdmFsdWF0aW9uQ29udGV4dFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2V4cHIvY3B1LmpzXCIpLkV4cHJlc3Npb25FdmFsdWF0b3J9IEV4cHJlc3Npb25FdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RXZhbHVhdGlvbkNvbnRleHR9IGNvbnRleHQgVGhlIGV2YWx1YXRpb24gY29udGV4dC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEFsd2F5cyB0cnVlLlxuICovXG5mdW5jdGlvbiBhbHdheXMoY29udGV4dCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkYXB0cyBhIHJ1bGUgZXZhbHVhdG9yIHRvIHRoZSBleGlzdGluZyBzdHlsZSBmdW5jdGlvbiBpbnRlcmZhY2UuXG4gKiBBZnRlciB3ZSBoYXZlIGRlcHJlY2F0ZWQgdGhlIHN0eWxlIGZ1bmN0aW9uLCB3ZSBjYW4gdXNlIHRoZSBjb21waWxlZCBydWxlcyBkaXJlY3RseVxuICogYW5kIHBhc3MgYSBtb3JlIGNvbXBsZXRlIGV2YWx1YXRpb24gY29udGV4dCAodmFyaWFibGVzLCB6b29tLCB0aW1lLCBldGMuKS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vLi4vc3R5bGUvZmxhdC5qcycpLlJ1bGU+fSBydWxlcyBUaGUgcnVsZXMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3N0eWxlL1N0eWxlLmpzJykuU3R5bGVGdW5jdGlvbn0gQSBzdHlsZSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVzVG9TdHlsZUZ1bmN0aW9uKHJ1bGVzKSB7XG4gIGNvbnN0IHBhcnNpbmdDb250ZXh0ID0gbmV3UGFyc2luZ0NvbnRleHQoKTtcbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRSdWxlU2V0KHJ1bGVzLCBwYXJzaW5nQ29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRpb25Db250ZXh0ID0gbmV3RXZhbHVhdGlvbkNvbnRleHQoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgZXZhbHVhdGlvbkNvbnRleHQucHJvcGVydGllcyA9IGZlYXR1cmUuZ2V0UHJvcGVydGllc0ludGVybmFsKCk7XG4gICAgZXZhbHVhdGlvbkNvbnRleHQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgaWYgKHBhcnNpbmdDb250ZXh0LmZlYXR1cmVJZCkge1xuICAgICAgY29uc3QgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBldmFsdWF0aW9uQ29udGV4dC5mZWF0dXJlSWQgPSBpZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2YWx1YXRpb25Db250ZXh0LmZlYXR1cmVJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzaW5nQ29udGV4dC5nZW9tZXRyeVR5cGUpIHtcbiAgICAgIGV2YWx1YXRpb25Db250ZXh0Lmdlb21ldHJ5VHlwZSA9IGNvbXB1dGVHZW9tZXRyeVR5cGUoXG4gICAgICAgIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBldmFsdWF0b3IoZXZhbHVhdGlvbkNvbnRleHQpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRhcHRzIGEgc3R5bGUgZXZhbHVhdG9yIHRvIHRoZSBleGlzdGluZyBzdHlsZSBmdW5jdGlvbiBpbnRlcmZhY2UuXG4gKiBBZnRlciB3ZSBoYXZlIGRlcHJlY2F0ZWQgdGhlIHN0eWxlIGZ1bmN0aW9uLCB3ZSBjYW4gdXNlIHRoZSBjb21waWxlZCBydWxlcyBkaXJlY3RseVxuICogYW5kIHBhc3MgYSBtb3JlIGNvbXBsZXRlIGV2YWx1YXRpb24gY29udGV4dCAodmFyaWFibGVzLCB6b29tLCB0aW1lLCBldGMuKS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vLi4vc3R5bGUvZmxhdC5qcycpLkZsYXRTdHlsZT59IGZsYXRTdHlsZXMgVGhlIGZsYXQgc3R5bGVzLlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9zdHlsZS9TdHlsZS5qcycpLlN0eWxlRnVuY3Rpb259IEEgc3R5bGUgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0U3R5bGVzVG9TdHlsZUZ1bmN0aW9uKGZsYXRTdHlsZXMpIHtcbiAgY29uc3QgcGFyc2luZ0NvbnRleHQgPSBuZXdQYXJzaW5nQ29udGV4dCgpO1xuICBjb25zdCBsZW5ndGggPSBmbGF0U3R5bGVzLmxlbmd0aDtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PFN0eWxlRXZhbHVhdG9yPn1cbiAgICovXG4gIGNvbnN0IGV2YWx1YXRvcnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGV2YWx1YXRvcnNbaV0gPSBidWlsZFN0eWxlKGZsYXRTdHlsZXNbaV0sIHBhcnNpbmdDb250ZXh0KTtcbiAgfVxuICBjb25zdCBldmFsdWF0aW9uQ29udGV4dCA9IG5ld0V2YWx1YXRpb25Db250ZXh0KCk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxTdHlsZT59XG4gICAqL1xuICBjb25zdCBzdHlsZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICBldmFsdWF0aW9uQ29udGV4dC5wcm9wZXJ0aWVzID0gZmVhdHVyZS5nZXRQcm9wZXJ0aWVzSW50ZXJuYWwoKTtcbiAgICBldmFsdWF0aW9uQ29udGV4dC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBpZiAocGFyc2luZ0NvbnRleHQuZmVhdHVyZUlkKSB7XG4gICAgICBjb25zdCBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV2YWx1YXRpb25Db250ZXh0LmZlYXR1cmVJZCA9IGlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZhbHVhdGlvbkNvbnRleHQuZmVhdHVyZUlkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5vbk51bGxDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBldmFsdWF0b3JzW2ldKGV2YWx1YXRpb25Db250ZXh0KTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBzdHlsZXNbbm9uTnVsbENvdW50XSA9IHN0eWxlO1xuICAgICAgICBub25OdWxsQ291bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3R5bGVzLmxlbmd0aCA9IG5vbk51bGxDb3VudDtcbiAgICByZXR1cm4gc3R5bGVzO1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6QXJyYXk8U3R5bGU+fSBSdWxlU2V0RXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb21waWxlZFJ1bGVcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbkV2YWx1YXRvcn0gZmlsdGVyIFRoZSBjb21waWxlZCBmaWx0ZXIgZXZhbHVhdG9yLlxuICogQHByb3BlcnR5IHtBcnJheTxTdHlsZUV2YWx1YXRvcj59IHN0eWxlcyBUaGUgbGlzdCBvZiBjb21waWxlZCBzdHlsZSBldmFsdWF0b3JzLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uLy4uL3N0eWxlL2ZsYXQuanMnKS5SdWxlPn0gcnVsZXMgVGhlIHJ1bGVzLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7UnVsZVNldEV2YWx1YXRvcn0gVGhlIGV2YWx1YXRvciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUnVsZVNldChydWxlcywgY29udGV4dCkge1xuICBjb25zdCBsZW5ndGggPSBydWxlcy5sZW5ndGg7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxDb21waWxlZFJ1bGU+fVxuICAgKi9cbiAgY29uc3QgY29tcGlsZWRSdWxlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBydWxlID0gcnVsZXNbaV07XG4gICAgY29uc3QgZmlsdGVyID1cbiAgICAgICdmaWx0ZXInIGluIHJ1bGVcbiAgICAgICAgPyBidWlsZEV4cHJlc3Npb24ocnVsZS5maWx0ZXIsIEJvb2xlYW5UeXBlLCBjb250ZXh0KVxuICAgICAgICA6IGFsd2F5cztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdHlsZUV2YWx1YXRvcj59XG4gICAgICovXG4gICAgbGV0IHN0eWxlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShydWxlLnN0eWxlKSkge1xuICAgICAgY29uc3Qgc3R5bGVMZW5ndGggPSBydWxlLnN0eWxlLmxlbmd0aDtcbiAgICAgIHN0eWxlcyA9IG5ldyBBcnJheShzdHlsZUxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0eWxlTGVuZ3RoOyArK2opIHtcbiAgICAgICAgc3R5bGVzW2pdID0gYnVpbGRTdHlsZShydWxlLnN0eWxlW2pdLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW2J1aWxkU3R5bGUocnVsZS5zdHlsZSwgY29udGV4dCldO1xuICAgIH1cblxuICAgIGNvbXBpbGVkUnVsZXNbaV0gPSB7ZmlsdGVyLCBzdHlsZXN9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAgICAgKi9cbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcblxuICAgIGxldCBzb21lTWF0Y2hlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGZpbHRlckV2YWx1YXRvciA9IGNvbXBpbGVkUnVsZXNbaV0uZmlsdGVyO1xuICAgICAgaWYgKCFmaWx0ZXJFdmFsdWF0b3IoY29udGV4dCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocnVsZXNbaV0uZWxzZSAmJiBzb21lTWF0Y2hlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvbWVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3Qgc3R5bGVFdmFsdWF0b3Igb2YgY29tcGlsZWRSdWxlc1tpXS5zdHlsZXMpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZUV2YWx1YXRvcihjb250ZXh0KTtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6U3R5bGV8bnVsbH0gU3R5bGVFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgQSBmbGF0IHN0eWxlIGxpdGVyYWwuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtTdHlsZUV2YWx1YXRvcn0gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhIHN0eWxlLiAgVGhlIHN0eWxlIHJldHVybmVkIGJ5XG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmV1c2VkIGJldHdlZW4gaW52b2NhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFN0eWxlKGZsYXRTdHlsZSwgY29udGV4dCkge1xuICBjb25zdCBldmFsdWF0ZUZpbGwgPSBidWlsZEZpbGwoZmxhdFN0eWxlLCAnJywgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU3Ryb2tlID0gYnVpbGRTdHJva2UoZmxhdFN0eWxlLCAnJywgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlVGV4dCA9IGJ1aWxkVGV4dChmbGF0U3R5bGUsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZUltYWdlID0gYnVpbGRJbWFnZShmbGF0U3R5bGUsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVpJbmRleCA9IG51bWJlckV2YWx1YXRvcihmbGF0U3R5bGUsICd6LWluZGV4JywgY29udGV4dCk7XG5cbiAgaWYgKFxuICAgICFldmFsdWF0ZUZpbGwgJiZcbiAgICAhZXZhbHVhdGVTdHJva2UgJiZcbiAgICAhZXZhbHVhdGVUZXh0ICYmXG4gICAgIWV2YWx1YXRlSW1hZ2UgJiZcbiAgICAhaXNFbXB0eShmbGF0U3R5bGUpXG4gICkge1xuICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgdXNlciBlcnJvclxuICAgIC8vIHdvdWxkIGJlIG5pY2UgdG8gY2hlY2sgdGhlIHByb3BlcnRpZXMgYW5kIHN1Z2dlc3QgXCJkaWQgeW91IG1lYW4uLi5cIlxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdObyBmaWxsLCBzdHJva2UsIHBvaW50LCBvciB0ZXh0IHN5bWJvbGl6ZXIgcHJvcGVydGllcyBpbiBzdHlsZTogJyArXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGZsYXRTdHlsZSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gbmV3IFN0eWxlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgY29uc3QgZmlsbCA9IGV2YWx1YXRlRmlsbChjb250ZXh0KTtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdHlsZS5zZXRGaWxsKGZpbGwpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVTdHJva2UpIHtcbiAgICAgIGNvbnN0IHN0cm9rZSA9IGV2YWx1YXRlU3Ryb2tlKGNvbnRleHQpO1xuICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3R5bGUuc2V0U3Ryb2tlKHN0cm9rZSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVRleHQpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBldmFsdWF0ZVRleHQoY29udGV4dCk7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3R5bGUuc2V0VGV4dCh0ZXh0KTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlSW1hZ2UpIHtcbiAgICAgIGNvbnN0IGltYWdlID0gZXZhbHVhdGVJbWFnZShjb250ZXh0KTtcbiAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3R5bGUuc2V0SW1hZ2UoaW1hZ2UpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVaSW5kZXgpIHtcbiAgICAgIHN0eWxlLnNldFpJbmRleChldmFsdWF0ZVpJbmRleChjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChlbXB0eSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOkZpbGx8bnVsbH0gRmlsbEV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggVGhlIHByb3BlcnR5IHByZWZpeC5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0ZpbGxFdmFsdWF0b3I/fSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgZmlsbC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KSB7XG4gIGxldCBldmFsdWF0ZUNvbG9yO1xuICBpZiAocHJlZml4ICsgJ2ZpbGwtcGF0dGVybi1zcmMnIGluIGZsYXRTdHlsZSkge1xuICAgIGV2YWx1YXRlQ29sb3IgPSBwYXR0ZXJuRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2ZpbGwtJywgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZsYXRTdHlsZVtwcmVmaXggKyAnZmlsbC1jb2xvciddID09PSAnbm9uZScpIHtcbiAgICAgIC8vIGF2b2lkcyBoaXQgZGV0ZWN0aW9uXG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IG51bGw7XG4gICAgfVxuXG4gICAgZXZhbHVhdGVDb2xvciA9IGNvbG9yTGlrZUV2YWx1YXRvcihcbiAgICAgIGZsYXRTdHlsZSxcbiAgICAgIHByZWZpeCArICdmaWxsLWNvbG9yJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKTtcbiAgfVxuICBpZiAoIWV2YWx1YXRlQ29sb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZpbGwgPSBuZXcgRmlsbCgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCBjb2xvciA9IGV2YWx1YXRlQ29sb3IoY29udGV4dCk7XG4gICAgaWYgKGNvbG9yID09PSBOT19DT0xPUikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbGwuc2V0Q29sb3IoY29sb3IpO1xuICAgIHJldHVybiBmaWxsO1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6U3Ryb2tlfG51bGx9IFN0cm9rZUV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggVGhlIHByb3BlcnR5IHByZWZpeC5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge1N0cm9rZUV2YWx1YXRvcj99IEEgZnVuY3Rpb24gdGhlIGV2YWx1YXRlcyB0byBhIHN0cm9rZS5cbiAqL1xuZnVuY3Rpb24gYnVpbGRTdHJva2UoZmxhdFN0eWxlLCBwcmVmaXgsIGNvbnRleHQpIHtcbiAgY29uc3QgZXZhbHVhdGVXaWR0aCA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS13aWR0aCcsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUNvbG9yID0gY29sb3JMaWtlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWNvbG9yJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGlmICghZXZhbHVhdGVXaWR0aCAmJiAhZXZhbHVhdGVDb2xvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGVMaW5lQ2FwID0gc3RyaW5nRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWxpbmUtY2FwJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlTGluZUpvaW4gPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbGluZS1qb2luJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlTGluZURhc2ggPSBudW1iZXJBcnJheUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS1saW5lLWRhc2gnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVMaW5lRGFzaE9mZnNldCA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS1saW5lLWRhc2gtb2Zmc2V0JyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlTWl0ZXJMaW1pdCA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS1taXRlci1saW1pdCcsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBzdHJva2UgPSBuZXcgU3Ryb2tlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmIChldmFsdWF0ZUNvbG9yKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2YWx1YXRlQ29sb3IoY29udGV4dCk7XG4gICAgICBpZiAoY29sb3IgPT09IE5PX0NPTE9SKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3Ryb2tlLnNldENvbG9yKGNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVXaWR0aCkge1xuICAgICAgc3Ryb2tlLnNldFdpZHRoKGV2YWx1YXRlV2lkdGgoY29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUxpbmVDYXApIHtcbiAgICAgIGNvbnN0IGxpbmVDYXAgPSBldmFsdWF0ZUxpbmVDYXAoY29udGV4dCk7XG4gICAgICBpZiAobGluZUNhcCAhPT0gJ2J1dHQnICYmIGxpbmVDYXAgIT09ICdyb3VuZCcgJiYgbGluZUNhcCAhPT0gJ3NxdWFyZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBidXR0LCByb3VuZCwgb3Igc3F1YXJlIGxpbmUgY2FwJyk7XG4gICAgICB9XG4gICAgICBzdHJva2Uuc2V0TGluZUNhcChsaW5lQ2FwKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVMaW5lSm9pbikge1xuICAgICAgY29uc3QgbGluZUpvaW4gPSBldmFsdWF0ZUxpbmVKb2luKGNvbnRleHQpO1xuICAgICAgaWYgKFxuICAgICAgICBsaW5lSm9pbiAhPT0gJ2JldmVsJyAmJlxuICAgICAgICBsaW5lSm9pbiAhPT0gJ3JvdW5kJyAmJlxuICAgICAgICBsaW5lSm9pbiAhPT0gJ21pdGVyJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYmV2ZWwsIHJvdW5kLCBvciBtaXRlciBsaW5lIGpvaW4nKTtcbiAgICAgIH1cbiAgICAgIHN0cm9rZS5zZXRMaW5lSm9pbihsaW5lSm9pbik7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTGluZURhc2gpIHtcbiAgICAgIHN0cm9rZS5zZXRMaW5lRGFzaChldmFsdWF0ZUxpbmVEYXNoKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVMaW5lRGFzaE9mZnNldCkge1xuICAgICAgc3Ryb2tlLnNldExpbmVEYXNoT2Zmc2V0KGV2YWx1YXRlTGluZURhc2hPZmZzZXQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZU1pdGVyTGltaXQpIHtcbiAgICAgIHN0cm9rZS5zZXRNaXRlckxpbWl0KGV2YWx1YXRlTWl0ZXJMaW1pdChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cm9rZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOlRleHR9IFRleHRFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtUZXh0RXZhbHVhdG9yP30gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhIHRleHQgc3ltYm9saXplci5cbiAqL1xuZnVuY3Rpb24gYnVpbGRUZXh0KGZsYXRTdHlsZSwgY29udGV4dCkge1xuICBjb25zdCBwcmVmaXggPSAndGV4dC0nO1xuXG4gIC8vIEN1cnJlbnRseSwgYW4gQXJyYXk8c3RyaW5nPiBtYXkgYmUgdXNlZCBmb3IgcmljaCB0ZXh0IHN1cHBvcnQuICBUaGlzIGRvZXNuJ3RcbiAgLy8gd29yayB3aXRoIG91ciBleHByZXNzaW9uIHN5bnRheCB3aGVyZSBhcnJheXMgb2Ygc3RyaW5ncyBhcmUgaW50ZXJwcmV0ZWQgYXNcbiAgLy8gY2FsbCBleHByZXNzaW9ucy4gIFRvIHN1cHBvcnQgcmljaCB0ZXh0LCB3ZSBjb3VsZCBhZGQgYSAnc3RyaW5ncycgb3BlcmF0b3JcbiAgLy8gd2hlcmUgYWxsIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzIHdvdWxkIGJlIHN0cmluZyB2YWx1ZXMuXG4gIGNvbnN0IGV2YWx1YXRlVmFsdWUgPSBzdHJpbmdFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAndmFsdWUnLCBjb250ZXh0KTtcbiAgaWYgKCFldmFsdWF0ZVZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBldmFsdWF0ZUZpbGwgPSBidWlsZEZpbGwoZmxhdFN0eWxlLCBwcmVmaXgsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlQmFja2dyb3VuZEZpbGwgPSBidWlsZEZpbGwoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdiYWNrZ3JvdW5kLScsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVN0cm9rZSA9IGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUJhY2tncm91bmRTdHJva2UgPSBidWlsZFN0cm9rZShcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2JhY2tncm91bmQtJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlRm9udCA9IHN0cmluZ0V2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdmb250JywgY29udGV4dCk7XG5cbiAgY29uc3QgZXZhbHVhdGVNYXhBbmdsZSA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ21heC1hbmdsZScsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU9mZnNldFggPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdvZmZzZXQteCcsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU9mZnNldFkgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdvZmZzZXQteScsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU92ZXJmbG93ID0gYm9vbGVhbkV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ292ZXJmbG93JyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUGxhY2VtZW50ID0gc3RyaW5nRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncGxhY2VtZW50JyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUmVwZWF0ID0gbnVtYmVyRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JlcGVhdCcsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVJvdGF0aW9uID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRpb24nLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVBbGlnbiA9IHN0cmluZ0V2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdhbGlnbicsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlSnVzdGlmeSA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2p1c3RpZnknLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVCYXNlbGluZSA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2Jhc2VsaW5lJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUGFkZGluZyA9IG51bWJlckFycmF5RXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncGFkZGluZycsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICAvLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCBjdXJyZW50bHkgc2V0dGFibGVcbiAgY29uc3QgZGVjbHV0dGVyTW9kZSA9IG9wdGlvbmFsRGVjbHV0dGVyTW9kZShcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2RlY2x1dHRlci1tb2RlJyxcbiAgKTtcblxuICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoe2RlY2x1dHRlck1vZGV9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB0ZXh0LnNldFRleHQoZXZhbHVhdGVWYWx1ZShjb250ZXh0KSk7XG5cbiAgICBpZiAoZXZhbHVhdGVGaWxsKSB7XG4gICAgICB0ZXh0LnNldEZpbGwoZXZhbHVhdGVGaWxsKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVCYWNrZ3JvdW5kRmlsbCkge1xuICAgICAgdGV4dC5zZXRCYWNrZ3JvdW5kRmlsbChldmFsdWF0ZUJhY2tncm91bmRGaWxsKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVTdHJva2UpIHtcbiAgICAgIHRleHQuc2V0U3Ryb2tlKGV2YWx1YXRlU3Ryb2tlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVCYWNrZ3JvdW5kU3Ryb2tlKSB7XG4gICAgICB0ZXh0LnNldEJhY2tncm91bmRTdHJva2UoZXZhbHVhdGVCYWNrZ3JvdW5kU3Ryb2tlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVGb250KSB7XG4gICAgICB0ZXh0LnNldEZvbnQoZXZhbHVhdGVGb250KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVNYXhBbmdsZSkge1xuICAgICAgdGV4dC5zZXRNYXhBbmdsZShldmFsdWF0ZU1heEFuZ2xlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVPZmZzZXRYKSB7XG4gICAgICB0ZXh0LnNldE9mZnNldFgoZXZhbHVhdGVPZmZzZXRYKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVPZmZzZXRZKSB7XG4gICAgICB0ZXh0LnNldE9mZnNldFkoZXZhbHVhdGVPZmZzZXRZKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVPdmVyZmxvdykge1xuICAgICAgdGV4dC5zZXRPdmVyZmxvdyhldmFsdWF0ZU92ZXJmbG93KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVQbGFjZW1lbnQpIHtcbiAgICAgIGNvbnN0IHBsYWNlbWVudCA9IGV2YWx1YXRlUGxhY2VtZW50KGNvbnRleHQpO1xuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gJ3BvaW50JyAmJiBwbGFjZW1lbnQgIT09ICdsaW5lJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvaW50IG9yIGxpbmUgZm9yIHRleHQtcGxhY2VtZW50Jyk7XG4gICAgICB9XG4gICAgICB0ZXh0LnNldFBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZVJlcGVhdCkge1xuICAgICAgdGV4dC5zZXRSZXBlYXQoZXZhbHVhdGVSZXBlYXQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZVNjYWxlKSB7XG4gICAgICB0ZXh0LnNldFNjYWxlKGV2YWx1YXRlU2NhbGUoY29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgICB0ZXh0LnNldFJvdGF0ZVdpdGhWaWV3KGV2YWx1YXRlUm90YXRlV2l0aFZpZXcoY29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZVJvdGF0aW9uKSB7XG4gICAgICB0ZXh0LnNldFJvdGF0aW9uKGV2YWx1YXRlUm90YXRpb24oY29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUFsaWduKSB7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBldmFsdWF0ZUFsaWduKGNvbnRleHQpO1xuICAgICAgaWYgKFxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdsZWZ0JyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdjZW50ZXInICYmXG4gICAgICAgIHRleHRBbGlnbiAhPT0gJ3JpZ2h0JyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdlbmQnICYmXG4gICAgICAgIHRleHRBbGlnbiAhPT0gJ3N0YXJ0J1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXhwZWN0ZWQgbGVmdCwgcmlnaHQsIGNlbnRlciwgc3RhcnQsIG9yIGVuZCBmb3IgdGV4dC1hbGlnbicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0ZXh0LnNldFRleHRBbGlnbih0ZXh0QWxpZ24pO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUp1c3RpZnkpIHtcbiAgICAgIGNvbnN0IGp1c3RpZnkgPSBldmFsdWF0ZUp1c3RpZnkoY29udGV4dCk7XG4gICAgICBpZiAoanVzdGlmeSAhPT0gJ2xlZnQnICYmIGp1c3RpZnkgIT09ICdyaWdodCcgJiYganVzdGlmeSAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsZWZ0LCByaWdodCwgb3IgY2VudGVyIGZvciB0ZXh0LWp1c3RpZnknKTtcbiAgICAgIH1cbiAgICAgIHRleHQuc2V0SnVzdGlmeShqdXN0aWZ5KTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVCYXNlbGluZSkge1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gZXZhbHVhdGVCYXNlbGluZShjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnYm90dG9tJyAmJlxuICAgICAgICB0ZXh0QmFzZWxpbmUgIT09ICd0b3AnICYmXG4gICAgICAgIHRleHRCYXNlbGluZSAhPT0gJ21pZGRsZScgJiZcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnYWxwaGFiZXRpYycgJiZcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnaGFuZ2luZydcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGJvdHRvbSwgdG9wLCBtaWRkbGUsIGFscGhhYmV0aWMsIG9yIGhhbmdpbmcgZm9yIHRleHQtYmFzZWxpbmUnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGV4dC5zZXRUZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVQYWRkaW5nKSB7XG4gICAgICB0ZXh0LnNldFBhZGRpbmcoZXZhbHVhdGVQYWRkaW5nKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOmltcG9ydChcIi4uLy4uL3N0eWxlL0ltYWdlLmpzXCIpLmRlZmF1bHR9IEltYWdlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7SW1hZ2VFdmFsdWF0b3I/fSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGFuIGltYWdlIHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSW1hZ2UoZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGlmICgnaWNvbi1zcmMnIGluIGZsYXRTdHlsZSkge1xuICAgIHJldHVybiBidWlsZEljb24oZmxhdFN0eWxlLCBjb250ZXh0KTtcbiAgfVxuXG4gIGlmICgnc2hhcGUtcG9pbnRzJyBpbiBmbGF0U3R5bGUpIHtcbiAgICByZXR1cm4gYnVpbGRTaGFwZShmbGF0U3R5bGUsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKCdjaXJjbGUtcmFkaXVzJyBpbiBmbGF0U3R5bGUpIHtcbiAgICByZXR1cm4gYnVpbGRDaXJjbGUoZmxhdFN0eWxlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtJbWFnZUV2YWx1YXRvcn0gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBpbWFnZSBzeW1ib2xpemVyLlxuICovXG5mdW5jdGlvbiBidWlsZEljb24oZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHByZWZpeCA9ICdpY29uLSc7XG5cbiAgLy8gcmVxdWlyZWQgcHJvcGVydHlcbiAgY29uc3Qgc3JjTmFtZSA9IHByZWZpeCArICdzcmMnO1xuICBjb25zdCBzcmMgPSByZXF1aXJlU3RyaW5nKGZsYXRTdHlsZVtzcmNOYW1lXSwgc3JjTmFtZSk7XG5cbiAgLy8gc2V0dGFibGUgcHJvcGVydGllc1xuICBjb25zdCBldmFsdWF0ZUFuY2hvciA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdhbmNob3InLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVTY2FsZSA9IHNpemVMaWtlRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3NjYWxlJywgY29udGV4dCk7XG5cbiAgY29uc3QgZXZhbHVhdGVPcGFjaXR5ID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnb3BhY2l0eScsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZURpc3BsYWNlbWVudCA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkaXNwbGFjZW1lbnQnLFxuICAgIGNvbnRleHQsXG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVSb3RhdGlvbiA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0aW9uJyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dCxcbiAgKTtcblxuICAvLyB0aGUgcmVtYWluaW5nIHN5bWJvbGl6ZXIgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzZXR0YWJsZVxuICBjb25zdCBhbmNob3JPcmlnaW4gPSBvcHRpb25hbEljb25PcmlnaW4oZmxhdFN0eWxlLCBwcmVmaXggKyAnYW5jaG9yLW9yaWdpbicpO1xuICBjb25zdCBhbmNob3JYVW5pdHMgPSBvcHRpb25hbEljb25BbmNob3JVbml0cyhcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2FuY2hvci14LXVuaXRzJyxcbiAgKTtcbiAgY29uc3QgYW5jaG9yWVVuaXRzID0gb3B0aW9uYWxJY29uQW5jaG9yVW5pdHMoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdhbmNob3IteS11bml0cycsXG4gICk7XG4gIGNvbnN0IGNvbG9yID0gb3B0aW9uYWxDb2xvckxpa2UoZmxhdFN0eWxlLCBwcmVmaXggKyAnY29sb3InKTtcbiAgY29uc3QgY3Jvc3NPcmlnaW4gPSBvcHRpb25hbFN0cmluZyhmbGF0U3R5bGUsIHByZWZpeCArICdjcm9zcy1vcmlnaW4nKTtcbiAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9uYWxOdW1iZXJBcnJheShmbGF0U3R5bGUsIHByZWZpeCArICdvZmZzZXQnKTtcbiAgY29uc3Qgb2Zmc2V0T3JpZ2luID0gb3B0aW9uYWxJY29uT3JpZ2luKGZsYXRTdHlsZSwgcHJlZml4ICsgJ29mZnNldC1vcmlnaW4nKTtcbiAgY29uc3Qgd2lkdGggPSBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByZWZpeCArICd3aWR0aCcpO1xuICBjb25zdCBoZWlnaHQgPSBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByZWZpeCArICdoZWlnaHQnKTtcbiAgY29uc3Qgc2l6ZSA9IG9wdGlvbmFsU2l6ZShmbGF0U3R5bGUsIHByZWZpeCArICdzaXplJyk7XG4gIGNvbnN0IGRlY2x1dHRlck1vZGUgPSBvcHRpb25hbERlY2x1dHRlck1vZGUoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkZWNsdXR0ZXItbW9kZScsXG4gICk7XG5cbiAgY29uc3QgaWNvbiA9IG5ldyBJY29uKHtcbiAgICBzcmMsXG4gICAgYW5jaG9yT3JpZ2luLFxuICAgIGFuY2hvclhVbml0cyxcbiAgICBhbmNob3JZVW5pdHMsXG4gICAgY29sb3IsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgb2Zmc2V0LFxuICAgIG9mZnNldE9yaWdpbixcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgc2l6ZSxcbiAgICBkZWNsdXR0ZXJNb2RlLFxuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoZXZhbHVhdGVPcGFjaXR5KSB7XG4gICAgICBpY29uLnNldE9wYWNpdHkoZXZhbHVhdGVPcGFjaXR5KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVEaXNwbGFjZW1lbnQpIHtcbiAgICAgIGljb24uc2V0RGlzcGxhY2VtZW50KGV2YWx1YXRlRGlzcGxhY2VtZW50KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGlvbikge1xuICAgICAgaWNvbi5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGVXaXRoVmlldykge1xuICAgICAgaWNvbi5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVTY2FsZSkge1xuICAgICAgaWNvbi5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVBbmNob3IpIHtcbiAgICAgIGljb24uc2V0QW5jaG9yKGV2YWx1YXRlQW5jaG9yKGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGljb247XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0ltYWdlRXZhbHVhdG9yfSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGFuIGljb24gc3ltYm9saXplci5cbiAqL1xuZnVuY3Rpb24gYnVpbGRTaGFwZShmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZml4ID0gJ3NoYXBlLSc7XG5cbiAgLy8gcmVxdWlyZWQgcHJvcGVydHlcbiAgY29uc3QgcG9pbnRzTmFtZSA9IHByZWZpeCArICdwb2ludHMnO1xuICBjb25zdCByYWRpdXNOYW1lID0gcHJlZml4ICsgJ3JhZGl1cyc7XG4gIGNvbnN0IHBvaW50cyA9IHJlcXVpcmVOdW1iZXIoZmxhdFN0eWxlW3BvaW50c05hbWVdLCBwb2ludHNOYW1lKTtcbiAgY29uc3QgcmFkaXVzID0gcmVxdWlyZU51bWJlcihmbGF0U3R5bGVbcmFkaXVzTmFtZV0sIHJhZGl1c05hbWUpO1xuXG4gIC8vIHNldHRhYmxlIHByb3BlcnRpZXNcbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVTdHJva2UgPSBidWlsZFN0cm9rZShmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZURpc3BsYWNlbWVudCA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkaXNwbGFjZW1lbnQnLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIGNvbnN0IGV2YWx1YXRlUm90YXRpb24gPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGlvbicsXG4gICAgY29udGV4dCxcbiAgKTtcbiAgY29uc3QgZXZhbHVhdGVSb3RhdGVXaXRoVmlldyA9IGJvb2xlYW5FdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGUtd2l0aC12aWV3JyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIC8vIHRoZSByZW1haW5pbmcgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzZXR0YWJsZVxuICBjb25zdCByYWRpdXMyID0gb3B0aW9uYWxOdW1iZXIoZmxhdFN0eWxlLCBwcmVmaXggKyAncmFkaXVzMicpO1xuICBjb25zdCBhbmdsZSA9IG9wdGlvbmFsTnVtYmVyKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2FuZ2xlJyk7XG4gIGNvbnN0IGRlY2x1dHRlck1vZGUgPSBvcHRpb25hbERlY2x1dHRlck1vZGUoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkZWNsdXR0ZXItbW9kZScsXG4gICk7XG5cbiAgY29uc3Qgc2hhcGUgPSBuZXcgUmVndWxhclNoYXBlKHtcbiAgICBwb2ludHMsXG4gICAgcmFkaXVzLFxuICAgIHJhZGl1czIsXG4gICAgYW5nbGUsXG4gICAgZGVjbHV0dGVyTW9kZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgc2hhcGUuc2V0RmlsbChldmFsdWF0ZUZpbGwoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVTdHJva2UpIHtcbiAgICAgIHNoYXBlLnNldFN0cm9rZShldmFsdWF0ZVN0cm9rZShjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZURpc3BsYWNlbWVudCkge1xuICAgICAgc2hhcGUuc2V0RGlzcGxhY2VtZW50KGV2YWx1YXRlRGlzcGxhY2VtZW50KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRpb24pIHtcbiAgICAgIHNoYXBlLnNldFJvdGF0aW9uKGV2YWx1YXRlUm90YXRpb24oY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGVXaXRoVmlldykge1xuICAgICAgc2hhcGUuc2V0Um90YXRlV2l0aFZpZXcoZXZhbHVhdGVSb3RhdGVXaXRoVmlldyhjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVNjYWxlKSB7XG4gICAgICBzaGFwZS5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0ltYWdlRXZhbHVhdG9yfSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgY2lyY2xlIHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ2lyY2xlKGZsYXRTdHlsZSwgY29udGV4dCkge1xuICBjb25zdCBwcmVmaXggPSAnY2lyY2xlLSc7XG5cbiAgLy8gc2V0dGFibGUgcHJvcGVydGllc1xuICBjb25zdCBldmFsdWF0ZUZpbGwgPSBidWlsZEZpbGwoZmxhdFN0eWxlLCBwcmVmaXgsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVN0cm9rZSA9IGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVSYWRpdXMgPSBudW1iZXJFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAncmFkaXVzJywgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZURpc3BsYWNlbWVudCA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkaXNwbGFjZW1lbnQnLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIGNvbnN0IGV2YWx1YXRlUm90YXRpb24gPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGlvbicsXG4gICAgY29udGV4dCxcbiAgKTtcbiAgY29uc3QgZXZhbHVhdGVSb3RhdGVXaXRoVmlldyA9IGJvb2xlYW5FdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGUtd2l0aC12aWV3JyxcbiAgICBjb250ZXh0LFxuICApO1xuXG4gIC8vIHRoZSByZW1haW5pbmcgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzZXR0YWJsZVxuICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gb3B0aW9uYWxEZWNsdXR0ZXJNb2RlKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGVjbHV0dGVyLW1vZGUnLFxuICApO1xuXG4gIGNvbnN0IGNpcmNsZSA9IG5ldyBDaXJjbGUoe1xuICAgIHJhZGl1czogNSwgLy8gdGhpcyBpcyBhcmJpdHJhcnksIGJ1dCByZXF1aXJlZCAtIHRoZSBldmFsdWF0ZWQgcmFkaXVzIGlzIHVzZWQgYmVsb3dcbiAgICBkZWNsdXR0ZXJNb2RlLFxuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoZXZhbHVhdGVSYWRpdXMpIHtcbiAgICAgIGNpcmNsZS5zZXRSYWRpdXMoZXZhbHVhdGVSYWRpdXMoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVGaWxsKSB7XG4gICAgICBjaXJjbGUuc2V0RmlsbChldmFsdWF0ZUZpbGwoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVTdHJva2UpIHtcbiAgICAgIGNpcmNsZS5zZXRTdHJva2UoZXZhbHVhdGVTdHJva2UoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVEaXNwbGFjZW1lbnQpIHtcbiAgICAgIGNpcmNsZS5zZXREaXNwbGFjZW1lbnQoZXZhbHVhdGVEaXNwbGFjZW1lbnQoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGlvbikge1xuICAgICAgY2lyY2xlLnNldFJvdGF0aW9uKGV2YWx1YXRlUm90YXRpb24oY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGVXaXRoVmlldykge1xuICAgICAgY2lyY2xlLnNldFJvdGF0ZVdpdGhWaWV3KGV2YWx1YXRlUm90YXRlV2l0aFZpZXcoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVTY2FsZSkge1xuICAgICAgY2lyY2xlLnNldFNjYWxlKGV2YWx1YXRlU2NhbGUoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjaXJjbGU7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLk51bWJlckV2YWx1YXRvcnx1bmRlZmluZWR9IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvciBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG51bWJlckV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBOdW1iZXJUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVOdW1iZXIoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuU3RyaW5nRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBzdHJpbmdFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihmbGF0U3R5bGVbbmFtZV0sIFN0cmluZ1R5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVxdWlyZVN0cmluZyhldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXR0ZXJuRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KSB7XG4gIGNvbnN0IHNyY0V2YWx1YXRvciA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3BhdHRlcm4tc3JjJyxcbiAgICBjb250ZXh0LFxuICApO1xuICBjb25zdCBvZmZzZXRFdmFsdWF0b3IgPSBzaXplRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncGF0dGVybi1vZmZzZXQnLFxuICAgIGNvbnRleHQsXG4gICk7XG4gIGNvbnN0IHBhdHRlcm5TaXplRXZhbHVhdG9yID0gc2l6ZUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3BhdHRlcm4tc2l6ZScsXG4gICAgY29udGV4dCxcbiAgKTtcbiAgY29uc3QgY29sb3JFdmFsdWF0b3IgPSBjb2xvckxpa2VFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdjb2xvcicsXG4gICAgY29udGV4dCxcbiAgKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNyYzogc3JjRXZhbHVhdG9yKGNvbnRleHQpLFxuICAgICAgb2Zmc2V0OiBvZmZzZXRFdmFsdWF0b3IgJiYgb2Zmc2V0RXZhbHVhdG9yKGNvbnRleHQpLFxuICAgICAgc2l6ZTogcGF0dGVyblNpemVFdmFsdWF0b3IgJiYgcGF0dGVyblNpemVFdmFsdWF0b3IoY29udGV4dCksXG4gICAgICBjb2xvcjogY29sb3JFdmFsdWF0b3IgJiYgY29sb3JFdmFsdWF0b3IoY29udGV4dCksXG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuQm9vbGVhbkV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgQm9vbGVhblR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRvcihjb250ZXh0KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBib29sZWFuIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuQ29sb3JMaWtlRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBjb2xvckxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihmbGF0U3R5bGVbbmFtZV0sIENvbG9yVHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlQ29sb3JMaWtlKGV2YWx1YXRvcihjb250ZXh0KSwgbmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLk51bWJlckFycmF5RXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBudW1iZXJBcnJheUV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyQXJyYXlUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVOdW1iZXJBcnJheShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5Db29yZGluYXRlRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBjb29yZGluYXRlRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBOdW1iZXJBcnJheVR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCBhcnJheSA9IHJlcXVpcmVOdW1iZXJBcnJheShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdHdvIG51bWJlcnMgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5TaXplRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBzaXplRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBOdW1iZXJBcnJheVR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVxdWlyZVNpemUoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuU2l6ZUxpa2VFdmFsdWF0b3I/fSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3IuXG4gKi9cbmZ1bmN0aW9uIHNpemVMaWtlRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oXG4gICAgZmxhdFN0eWxlW25hbWVdLFxuICAgIE51bWJlckFycmF5VHlwZSB8IE51bWJlclR5cGUsXG4gICAgY29udGV4dCxcbiAgKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVTaXplTGlrZShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHN5bWJvbGl6ZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBBIG51bWJlciBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsTnVtYmVyKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgdmFsdWUgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gQSBzaXplIG9yIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWxTaXplKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdG9TaXplKGVuY29kZWQpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShlbmNvZGVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXIgb3Igc2l6ZSBhcnJheSBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICBpZiAoXG4gICAgZW5jb2RlZC5sZW5ndGggIT09IDIgfHxcbiAgICB0eXBlb2YgZW5jb2RlZFswXSAhPT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgZW5jb2RlZFsxXSAhPT0gJ251bWJlcidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBvciBzaXplIGFycmF5IGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHN5bWJvbGl6ZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBBIHN0cmluZyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsU3RyaW5nKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RlZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHN5bWJvbGl6ZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9JY29uLmpzXCIpLkljb25PcmlnaW58dW5kZWZpbmVkfSBBbiBpY29uIG9yaWdpbiBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsSWNvbk9yaWdpbihmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoXG4gICAgZW5jb2RlZCAhPT0gJ2JvdHRvbS1sZWZ0JyAmJlxuICAgIGVuY29kZWQgIT09ICdib3R0b20tcmlnaHQnICYmXG4gICAgZW5jb2RlZCAhPT0gJ3RvcC1sZWZ0JyAmJlxuICAgIGVuY29kZWQgIT09ICd0b3AtcmlnaHQnXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0LCB0b3AtbGVmdCwgb3IgdG9wLXJpZ2h0IGZvciAke3Byb3BlcnR5fWAsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uQW5jaG9yVW5pdHN8dW5kZWZpbmVkfSBJY29uIGFuY2hvciB1bml0cyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsSWNvbkFuY2hvclVuaXRzKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChlbmNvZGVkICE9PSAncGl4ZWxzJyAmJiBlbmNvZGVkICE9PSAnZnJhY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBwaXhlbHMgb3IgZnJhY3Rpb24gZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBBbiBhcnJheSBvZiBudW1iZXJzIG9yIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWxOdW1iZXJBcnJheShmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gcmVxdWlyZU51bWJlckFycmF5KGVuY29kZWQsIHByb3BlcnR5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9zdHlsZS9TdHlsZS5qcycpLkRlY2x1dHRlck1vZGV9IEljb24gZGVjbHV0dGVyIG1vZGUuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsRGVjbHV0dGVyTW9kZShmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kZWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0cmluZyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICBpZiAoZW5jb2RlZCAhPT0gJ2RlY2x1dHRlcicgJiYgZW5jb2RlZCAhPT0gJ29ic3RhY2xlJyAmJiBlbmNvZGVkICE9PSAnbm9uZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGRlY2x1dHRlciwgb2JzdGFjbGUsIG9yIG5vbmUgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge3N0cmluZ3xBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gQSBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgY29sb3IgdmFsdWVzIG9yIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWxDb2xvckxpa2UoZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHJlcXVpcmVDb2xvckxpa2UoZW5jb2RlZCwgcHJvcGVydHkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU51bWJlckFycmF5KHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSBvZiBudW1iZXJzIGZvciAke3Byb3BlcnR5fWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU3RyaW5nKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU51bWJlcih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58c3RyaW5nfSBBIGNvbG9yLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQ29sb3JMaWtlKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBhcnJheSA9IHJlcXVpcmVOdW1iZXJBcnJheSh2YWx1ZSwgcHJvcGVydHkpO1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGlmIChsZW5ndGggPCAzIHx8IGxlbmd0aCA+IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgY29sb3Igd2l0aCAzIG9yIDQgdmFsdWVzIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIHR3byBudW1iZXJzLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU2l6ZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2l6ZSA9IHJlcXVpcmVOdW1iZXJBcnJheSh2YWx1ZSwgcHJvcGVydHkpO1xuICBpZiAoc2l6ZS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIGFycmF5IG9mIHR3byBudW1iZXJzIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7bnVtYmVyfEFycmF5PG51bWJlcj59IEEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIHR3byBudW1iZXJzLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU2l6ZUxpa2UodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiByZXF1aXJlU2l6ZSh2YWx1ZSwgcHJvcGVydHkpO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlVmVjdG9yXG4gKi9cbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBSQnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQgU3R5bGUsIHtcbiAgY3JlYXRlRGVmYXVsdFN0eWxlLFxuICB0b0Z1bmN0aW9uIGFzIHRvU3R5bGVGdW5jdGlvbixcbn0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuaW1wb3J0IHtcbiAgZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbixcbiAgcnVsZXNUb1N0eWxlRnVuY3Rpb24sXG59IGZyb20gJy4uL3JlbmRlci9jYW52YXMvc3R5bGUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuLi9GZWF0dXJlJykuRmVhdHVyZUxpa2V9IEZlYXR1cmVUeXBlXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdDxGZWF0dXJlVHlwZT58aW1wb3J0KFwiLi4vc291cmNlL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdDxGZWF0dXJlVHlwZT59IFZlY3RvclNvdXJjZVR5cGU8RmVhdHVyZVR5cGU+XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbGF5ZXInXSBBIENTUyBjbGFzcyBuYW1lIHRvIHNldCB0byB0aGUgbGF5ZXIgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbn0gW3JlbmRlck9yZGVyXSBSZW5kZXIgb3JkZXIuIEZ1bmN0aW9uIHRvIGJlIHVzZWQgd2hlbiBzb3J0aW5nXG4gKiBmZWF0dXJlcyBiZWZvcmUgcmVuZGVyaW5nLiBCeSBkZWZhdWx0IGZlYXR1cmVzIGFyZSBkcmF3biBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFyZSBjcmVhdGVkLiBVc2VcbiAqIGBudWxsYCB0byBhdm9pZCB0aGUgc29ydCwgYnV0IGdldCBhbiB1bmRlZmluZWQgZHJhdyBvcmRlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVuZGVyQnVmZmVyPTEwMF0gVGhlIGJ1ZmZlciBpbiBwaXhlbHMgYXJvdW5kIHRoZSB2aWV3cG9ydCBleHRlbnQgdXNlZCBieSB0aGVcbiAqIHJlbmRlcmVyIHdoZW4gZ2V0dGluZyBmZWF0dXJlcyBmcm9tIHRoZSB2ZWN0b3Igc291cmNlIGZvciB0aGUgcmVuZGVyaW5nIG9yIGhpdC1kZXRlY3Rpb24uXG4gKiBSZWNvbW1lbmRlZCB2YWx1ZTogdGhlIHNpemUgb2YgdGhlIGxhcmdlc3Qgc3ltYm9sLCBsaW5lIHdpZHRoIG9yIGxhYmVsLlxuICogQHByb3BlcnR5IHtWZWN0b3JTb3VyY2VUeXBlfSBbc291cmNlXSBTb3VyY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBbbWFwXSBTZXRzIHRoZSBsYXllciBhcyBvdmVybGF5IG9uIGEgbWFwLiBUaGUgbWFwIHdpbGwgbm90IG1hbmFnZVxuICogdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24sIGFuZCB0aGUgbGF5ZXIgd2lsbCBiZSByZW5kZXJlZCBvbiB0b3AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICogdGVtcG9yYXJ5IGxheWVycy4gVGhlIHN0YW5kYXJkIHdheSB0byBhZGQgYSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAgaXMgdG9cbiAqIHVzZSBbbWFwLmFkZExheWVyKClde0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0I2FkZExheWVyfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxzdHJpbmd8bnVtYmVyfSBbZGVjbHV0dGVyPWZhbHNlXSBEZWNsdXR0ZXIgaW1hZ2VzIGFuZCB0ZXh0LiBBbnkgdHJ1dGh5IHZhbHVlIHdpbGwgZW5hYmxlXG4gKiBkZWNsdXR0ZXJpbmcuIFdpdGhpbiBhIGxheWVyLCBhIGZlYXR1cmUgcmVuZGVyZWQgYmVmb3JlIGFub3RoZXIgaGFzIGhpZ2hlciBwcmlvcml0eS4gQWxsIGxheWVycyB3aXRoIHRoZVxuICogc2FtZSBgZGVjbHV0dGVyYCB2YWx1ZSB3aWxsIGJlIGRlY2x1dHRlcmVkIHRvZ2V0aGVyLiBUaGUgcHJpb3JpdHkgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZHJhd2luZyBvcmRlciBvZiB0aGVcbiAqIGxheWVycyB3aXRoIHRoZSBzYW1lIGBkZWNsdXR0ZXJgIHZhbHVlLiBIaWdoZXIgaW4gdGhlIGxheWVyIHN0YWNrIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gVG8gZGVjbHV0dGVyIGRpc3RpbmN0XG4gKiBsYXllcnMgb3IgZ3JvdXBzIG9mIGxheWVycyBzZXBhcmF0ZWx5LCB1c2UgZGlmZmVyZW50IHRydXRoeSB2YWx1ZXMgZm9yIGBkZWNsdXR0ZXJgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGVMaWtlfG51bGx9IFtzdHlsZV0gTGF5ZXIgc3R5bGUuIFdoZW4gc2V0IHRvIGBudWxsYCwgb25seVxuICogZmVhdHVyZXMgdGhhdCBoYXZlIHRoZWlyIG93biBzdHlsZSB3aWxsIGJlIHJlbmRlcmVkLiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX0gZm9yIHRoZSBkZWZhdWx0IHN0eWxlXG4gKiB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBpcyBub3Qgc2V0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0Jhc2UuanNcIikuQmFja2dyb3VuZENvbG9yfSBbYmFja2dyb3VuZF0gQmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIGxheWVyLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBiYWNrZ3JvdW5kXG4gKiB3aWxsIGJlIHJlbmRlcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXBkYXRlV2hpbGVBbmltYXRpbmc9ZmFsc2VdIFdoZW4gc2V0IHRvIGB0cnVlYCwgZmVhdHVyZSBiYXRjaGVzIHdpbGxcbiAqIGJlIHJlY3JlYXRlZCBkdXJpbmcgYW5pbWF0aW9ucy4gVGhpcyBtZWFucyB0aGF0IG5vIHZlY3RvcnMgd2lsbCBiZSBzaG93biBjbGlwcGVkLCBidXQgdGhlXG4gKiBzZXR0aW5nIHdpbGwgaGF2ZSBhIHBlcmZvcm1hbmNlIGltcGFjdCBmb3IgbGFyZ2UgYW1vdW50cyBvZiB2ZWN0b3IgZGF0YS4gV2hlbiBzZXQgdG8gYGZhbHNlYCxcbiAqIGJhdGNoZXMgd2lsbCBiZSByZWNyZWF0ZWQgd2hlbiBubyBhbmltYXRpb24gaXMgYWN0aXZlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXBkYXRlV2hpbGVJbnRlcmFjdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLCBmZWF0dXJlIGJhdGNoZXMgd2lsbFxuICogYmUgcmVjcmVhdGVkIGR1cmluZyBpbnRlcmFjdGlvbnMuIFNlZSBhbHNvIGB1cGRhdGVXaGlsZUFuaW1hdGluZ2AuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSBbcHJvcGVydGllc10gQXJiaXRyYXJ5IG9ic2VydmFibGUgcHJvcGVydGllcy4gQ2FuIGJlIGFjY2Vzc2VkIHdpdGggYCNnZXQoKWAgYW5kIGAjc2V0KClgLlxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFByb3BlcnR5ID0ge1xuICBSRU5ERVJfT1JERVI6ICdyZW5kZXJPcmRlcicsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFZlY3RvciBkYXRhIHRoYXQgaXMgcmVuZGVyZWQgY2xpZW50LXNpZGUuXG4gKiBOb3RlIHRoYXQgYW55IHByb3BlcnR5IHNldCBpbiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fVxuICogcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdDsgZm9yIGV4YW1wbGUsIHNldHRpbmcgYHRpdGxlOiAnTXkgVGl0bGUnYCBpbiB0aGVcbiAqIG9wdGlvbnMgbWVhbnMgdGhhdCBgdGl0bGVgIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4uL0ZlYXR1cmUnKS5GZWF0dXJlTGlrZX0gRmVhdHVyZVR5cGVcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0PEZlYXR1cmVUeXBlPnxpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0PEZlYXR1cmVUeXBlPn0gVmVjdG9yU291cmNlVHlwZTxGZWF0dXJlVHlwZT5cbiAqIEBleHRlbmRzIHtMYXllcjxWZWN0b3JTb3VyY2VUeXBlLCBSZW5kZXJlclR5cGU+fVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXIuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXJlci9jYW52YXMvVmVjdG9yVGlsZUxheWVyLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyZXIvY2FudmFzL1ZlY3RvckltYWdlTGF5ZXIuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXJlci93ZWJnbC9Qb2ludHNMYXllci5qc1wiKS5kZWZhdWx0fSBSZW5kZXJlclR5cGVcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQmFzZVZlY3RvckxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zPEZlYXR1cmVUeXBlLCBWZWN0b3JTb3VyY2VUeXBlPn0gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBiYXNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnN0eWxlO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5yZW5kZXJCdWZmZXI7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlcl8gPSBvcHRpb25zLmRlY2x1dHRlciA/IFN0cmluZyhvcHRpb25zLmRlY2x1dHRlcikgOiB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJfID1cbiAgICAgIG9wdGlvbnMucmVuZGVyQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlckJ1ZmZlciA6IDEwMDtcblxuICAgIC8qKlxuICAgICAqIFVzZXIgcHJvdmlkZWQgc3R5bGUuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZXxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZUxpa2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTdHlsZSBmdW5jdGlvbiBmb3IgdXNlIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zZXRTdHlsZShvcHRpb25zLnN0eWxlKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVXaGlsZUFuaW1hdGluZ18gPVxuICAgICAgb3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZ1xuICAgICAgICA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdfID1cbiAgICAgIG9wdGlvbnMudXBkYXRlV2hpbGVJbnRlcmFjdGluZyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nXG4gICAgICAgIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBEZWNsdXR0ZXIgZ3JvdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0RGVjbHV0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2x1dHRlcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0b3Btb3N0IGZlYXR1cmUgdGhhdCBpbnRlcnNlY3RzIHRoZSBnaXZlbiBwaXhlbCBvbiB0aGUgdmlld3BvcnQuIFJldHVybnMgYSBwcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBmZWF0dXJlcy4gVGhlIGFycmF5IHdpbGwgZWl0aGVyIGNvbnRhaW4gdGhlIHRvcG1vc3QgZmVhdHVyZVxuICAgKiB3aGVuIGEgaGl0IHdhcyBkZXRlY3RlZCwgb3IgaXQgd2lsbCBiZSBlbXB0eS5cbiAgICpcbiAgICogVGhlIGhpdCBkZXRlY3Rpb24gYWxnb3JpdGhtIHVzZWQgZm9yIHRoaXMgbWV0aG9kIGlzIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2UsIGJ1dCBpcyBsZXNzXG4gICAqIGFjY3VyYXRlIHRoYW4gdGhlIG9uZSB1c2VkIGluIFttYXAuZ2V0RmVhdHVyZXNBdFBpeGVsKClde0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0I2dldEZlYXR1cmVzQXRQaXhlbH0uXG4gICAqIFRleHQgaXMgbm90IGNvbnNpZGVyZWQsIGFuZCBpY29ucyBhcmUgb25seSByZXByZXNlbnRlZCBieSB0aGVpciBib3VuZGluZyBib3ggaW5zdGVhZCBvZiB0aGUgZXhhY3RcbiAgICogaW1hZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGltcG9ydChcIi4uL0ZlYXR1cmVcIikuRmVhdHVyZUxpa2U+Pn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgZmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRGZWF0dXJlcyhwaXhlbCkge1xuICAgIHJldHVybiBzdXBlci5nZXRGZWF0dXJlcyhwaXhlbCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVuZGVyIGJ1ZmZlci5cbiAgICovXG4gIGdldFJlbmRlckJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJCdWZmZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogbnVtYmVyfG51bGx8dW5kZWZpbmVkfSBSZW5kZXJcbiAgICogICAgIG9yZGVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyT3JkZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLk9yZGVyRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9ICovIChcbiAgICAgIHRoaXMuZ2V0KFByb3BlcnR5LlJFTkRFUl9PUkRFUilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgZm9yIGZlYXR1cmVzLiAgVGhpcyByZXR1cm5zIHdoYXRldmVyIHdhcyBwYXNzZWQgdG8gdGhlIGBzdHlsZWBcbiAgICogb3B0aW9uIGF0IGNvbnN0cnVjdGlvbiBvciB0byB0aGUgYHNldFN0eWxlYCBtZXRob2QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZXxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZUxpa2V8bnVsbHx1bmRlZmluZWR9IExheWVyIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9IExheWVyIHN0eWxlIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHlsZUZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlRnVuY3Rpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlbmRlcmVkIGxheWVyIHNob3VsZCBiZSB1cGRhdGVkIHdoaWxlXG4gICAqICAgICBhbmltYXRpbmcuXG4gICAqL1xuICBnZXRVcGRhdGVXaGlsZUFuaW1hdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVXaGlsZUFuaW1hdGluZ187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyZWQgbGF5ZXIgc2hvdWxkIGJlIHVwZGF0ZWQgd2hpbGVcbiAgICogICAgIGludGVyYWN0aW5nLlxuICAgKi9cbiAgZ2V0VXBkYXRlV2hpbGVJbnRlcmFjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVXaGlsZUludGVyYWN0aW5nXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgZGVjbHV0dGVyIGl0ZW1zIGZvciB0aGlzIGxheWVyXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyRGVjbHV0dGVyKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICBjb25zdCBkZWNsdXR0ZXJHcm91cCA9IHRoaXMuZ2V0RGVjbHV0dGVyKCk7XG4gICAgaWYgKGRlY2x1dHRlckdyb3VwIGluIGZyYW1lU3RhdGUuZGVjbHV0dGVyID09PSBmYWxzZSkge1xuICAgICAgZnJhbWVTdGF0ZS5kZWNsdXR0ZXJbZGVjbHV0dGVyR3JvdXBdID0gbmV3IFJCdXNoKDkpO1xuICAgIH1cbiAgICB0aGlzLmdldFJlbmRlcmVyKCkucmVuZGVyRGVjbHV0dGVyKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLk9yZGVyRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9IHJlbmRlck9yZGVyXG4gICAqICAgICBSZW5kZXIgb3JkZXIuXG4gICAqL1xuICBzZXRSZW5kZXJPcmRlcihyZW5kZXJPcmRlcikge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LlJFTkRFUl9PUkRFUiwgcmVuZGVyT3JkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3R5bGUgZm9yIGZlYXR1cmVzLiAgVGhpcyBjYW4gYmUgYSBzaW5nbGUgc3R5bGUgb2JqZWN0LCBhbiBhcnJheVxuICAgKiBvZiBzdHlsZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGZlYXR1cmUgYW5kIHJlc29sdXRpb24gYW5kIHJldHVybnNcbiAgICogYW4gYXJyYXkgb2Ygc3R5bGVzLiBJZiBzZXQgdG8gYG51bGxgLCB0aGUgbGF5ZXIgaGFzIG5vIHN0eWxlIChhIGBudWxsYCBzdHlsZSksXG4gICAqIHNvIG9ubHkgZmVhdHVyZXMgdGhhdCBoYXZlIHRoZWlyIG93biBzdHlsZXMgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgbGF5ZXIuIENhbGxcbiAgICogYHNldFN0eWxlKClgIHdpdGhvdXQgYXJndW1lbnRzIHRvIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0eWxlLiBTZWVcbiAgICogW3RoZSBvbC9zdHlsZS9TdHlsZSBtb2R1bGVde0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSBkZWZhdWx0IHN0eWxlLlxuICAgKlxuICAgKiBJZiB5b3VyIGxheWVyIGhhcyBhIHN0YXRpYyBzdHlsZSwgeW91IGNhbiB1c2UgW2ZsYXQgc3R5bGVde0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9mbGF0fkZsYXRTdHlsZX0gb2JqZWN0XG4gICAqIGxpdGVyYWxzIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBTdHlsZWAgYW5kIHN5bWJvbGl6ZXIgY29uc3RydWN0b3JzIChgRmlsbGAsIGBTdHJva2VgLCBldGMuKTpcbiAgICogYGBganNcbiAgICogdmVjdG9yTGF5ZXIuc2V0U3R5bGUoe1xuICAgKiAgIFwiZmlsbC1jb2xvclwiOiBcInllbGxvd1wiLFxuICAgKiAgIFwic3Ryb2tlLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICogICBcInN0cm9rZS13aWR0aFwiOiA0XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZXxpbXBvcnQoXCIuLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZUxpa2V8bnVsbH0gW3N0eWxlXSBMYXllciBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlXyA9IHN0eWxlID09PSB1bmRlZmluZWQgPyBjcmVhdGVEZWZhdWx0U3R5bGUgOiBzdHlsZTtcbiAgICBjb25zdCBzdHlsZUxpa2UgPSB0b1N0eWxlTGlrZShzdHlsZSk7XG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9XG4gICAgICBzdHlsZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvU3R5bGVGdW5jdGlvbihzdHlsZUxpa2UpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbi8qKlxuICogQ29lcmNlIHRoZSBhbGxvd2VkIHN0eWxlIHR5cGVzIGludG8gYSBzaG9ydGVyIGxpc3Qgb2YgdHlwZXMuICBGbGF0IHN0eWxlcywgYXJyYXlzIG9mIGZsYXRcbiAqIHN0eWxlcywgYW5kIGFycmF5cyBvZiBydWxlcyBhcmUgY29udmVydGVkIGludG8gc3R5bGUgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfGltcG9ydChcIi4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlTGlrZXxudWxsfSBbc3R5bGVdIExheWVyIHN0eWxlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfG51bGx9IFRoZSBzdHlsZS5cbiAqL1xuZnVuY3Rpb24gdG9TdHlsZUxpa2Uoc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVmYXVsdFN0eWxlO1xuICB9XG4gIGlmICghc3R5bGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICByZXR1cm4gZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbihbc3R5bGVdKTtcbiAgfVxuICBpZiAoc3R5bGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gc3R5bGUubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IHN0eWxlWzBdO1xuXG4gIGlmIChmaXJzdCBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAgICAgKi9cbiAgICBjb25zdCBzdHlsZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBzdHlsZVtpXTtcbiAgICAgIGlmICghKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIFN0eWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgbGlzdCBvZiBzdHlsZSBpbnN0YW5jZXMnKTtcbiAgICAgIH1cbiAgICAgIHN0eWxlc1tpXSA9IGNhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuXG4gIGlmICgnc3R5bGUnIGluIGZpcnN0KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgQXJyYXk8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5SdWxlPlxuICAgICAqL1xuICAgIGNvbnN0IHJ1bGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gc3R5bGVbaV07XG4gICAgICBpZiAoISgnc3R5bGUnIGluIGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIGxpc3Qgb2YgcnVsZXMgd2l0aCBhIHN0eWxlIHByb3BlcnR5Jyk7XG4gICAgICB9XG4gICAgICBydWxlc1tpXSA9IGNhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzVG9TdHlsZUZ1bmN0aW9uKHJ1bGVzKTtcbiAgfVxuXG4gIGNvbnN0IGZsYXRTdHlsZXMgPVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGU+fSAqLyAoc3R5bGUpO1xuICByZXR1cm4gZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbihmbGF0U3R5bGVzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVZlY3RvckxheWVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9NYXBcbiAqL1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7Y29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLCBtYWtlSW52ZXJzZX0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Z2V0V2lkdGh9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge3NoYXJlZCBhcyBpY29uSW1hZ2VDYWNoZX0gZnJvbSAnLi4vc3R5bGUvSWNvbkltYWdlQ2FjaGUuanMnO1xuaW1wb3J0IHtpblZpZXd9IGZyb20gJy4uL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCB7d3JhcFh9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiBIaXRNYXRjaFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlU3EgU3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi92ZWN0b3IuanNcIikuRmVhdHVyZUNhbGxiYWNrPFQ+fSBjYWxsYmFjayBDYWxsYmFjay5cbiAqL1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBNYXBSZW5kZXJlciBleHRlbmRzIERpc3Bvc2FibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50KHR5cGUsIGZyYW1lU3RhdGUpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY2FsY3VsYXRlTWF0cmljZXMyRChmcmFtZVN0YXRlKSB7XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3QgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0gPSBmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtO1xuICAgIGNvbnN0IHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtID0gZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybTtcblxuICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSxcbiAgICAgIGZyYW1lU3RhdGUuc2l6ZVswXSAvIDIsXG4gICAgICBmcmFtZVN0YXRlLnNpemVbMV0gLyAyLFxuICAgICAgMSAvIHZpZXdTdGF0ZS5yZXNvbHV0aW9uLFxuICAgICAgLTEgLyB2aWV3U3RhdGUucmVzb2x1dGlvbixcbiAgICAgIC12aWV3U3RhdGUucm90YXRpb24sXG4gICAgICAtdmlld1N0YXRlLmNlbnRlclswXSxcbiAgICAgIC12aWV3U3RhdGUuY2VudGVyWzFdLFxuICAgICk7XG5cbiAgICBtYWtlSW52ZXJzZShwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja1dyYXBwZWQgQ2hlY2sgZm9yIHdyYXBwZWQgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3ZlY3Rvci5qc1wiKS5GZWF0dXJlQ2FsbGJhY2s8VD59IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICAgKiAgICAgZnVuY3Rpb24sIG9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvblxuICAgKiAgICAgcmV0dXJucyBgdHJ1ZWAgd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiAgQnkgZGVmYXVsdCwgYWxsIHZpc2libGVcbiAgICogICAgIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtVfSB0aGlzQXJnMiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBTLFQsVVxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgY29vcmRpbmF0ZSxcbiAgICBmcmFtZVN0YXRlLFxuICAgIGhpdFRvbGVyYW5jZSxcbiAgICBjaGVja1dyYXBwZWQsXG4gICAgY2FsbGJhY2ssXG4gICAgdGhpc0FyZyxcbiAgICBsYXllckZpbHRlcixcbiAgICB0aGlzQXJnMixcbiAgKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbWFuYWdlZCBNYW5hZ2VkIGxheWVyLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUobWFuYWdlZCwgZmVhdHVyZSwgbGF5ZXIsIGdlb21ldHJ5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBmZWF0dXJlLCBtYW5hZ2VkID8gbGF5ZXIgOiBudWxsLCBnZW9tZXRyeSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuXG4gICAgY29uc3QgdHJhbnNsYXRlZENvb3JkaW5hdGUgPSB3cmFwWChjb29yZGluYXRlLnNsaWNlKCksIHByb2plY3Rpb24pO1xuICAgIGNvbnN0IG9mZnNldHMgPSBbWzAsIDBdXTtcbiAgICBpZiAocHJvamVjdGlvbi5jYW5XcmFwWCgpICYmIGNoZWNrV3JhcHBlZCkge1xuICAgICAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gICAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgICBvZmZzZXRzLnB1c2goWy13b3JsZFdpZHRoLCAwXSwgW3dvcmxkV2lkdGgsIDBdKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllclN0YXRlcyA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheTtcbiAgICBjb25zdCBudW1MYXllcnMgPSBsYXllclN0YXRlcy5sZW5ndGg7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gLyoqIEB0eXBlIHtBcnJheTxIaXRNYXRjaDxUPj59ICovIChbXSk7XG4gICAgY29uc3QgdG1wQ29vcmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBudW1MYXllcnMgLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICBjb25zdCBsYXllclN0YXRlID0gbGF5ZXJTdGF0ZXNbal07XG4gICAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJTdGF0ZS5sYXllcjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGxheWVyLmhhc1JlbmRlcmVyKCkgJiZcbiAgICAgICAgICBpblZpZXcobGF5ZXJTdGF0ZSwgdmlld1N0YXRlKSAmJlxuICAgICAgICAgIGxheWVyRmlsdGVyLmNhbGwodGhpc0FyZzIsIGxheWVyKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBsYXllclJlbmRlcmVyID0gbGF5ZXIuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSBsYXllci5nZXRTb3VyY2UoKTtcbiAgICAgICAgICBpZiAobGF5ZXJSZW5kZXJlciAmJiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gc291cmNlLmdldFdyYXBYKClcbiAgICAgICAgICAgICAgPyB0cmFuc2xhdGVkQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICA6IGNvb3JkaW5hdGU7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlLmJpbmQoXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGxheWVyU3RhdGUubWFuYWdlZCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0bXBDb29yZFswXSA9IGNvb3JkaW5hdGVzWzBdICsgb2Zmc2V0c1tpXVswXTtcbiAgICAgICAgICAgIHRtcENvb3JkWzFdID0gY29vcmRpbmF0ZXNbMV0gKyBvZmZzZXRzW2ldWzFdO1xuICAgICAgICAgICAgcmVzdWx0ID0gbGF5ZXJSZW5kZXJlci5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgICAgICAgICAgdG1wQ29vcmQsXG4gICAgICAgICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgICAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyID0gMSAvIG1hdGNoZXMubGVuZ3RoO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobSwgaSkgPT4gKG0uZGlzdGFuY2VTcSArPSBpICogb3JkZXIpKTtcbiAgICBtYXRjaGVzLnNvcnQoKGEsIGIpID0+IGEuZGlzdGFuY2VTcSAtIGIuZGlzdGFuY2VTcSk7XG4gICAgbWF0Y2hlcy5zb21lKChtKSA9PiB7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9IG0uY2FsbGJhY2sobS5mZWF0dXJlLCBtLmxheWVyLCBtLmdlb21ldHJ5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tXcmFwcGVkIENoZWNrIGZvciB3cmFwcGVkIGdlb21ldHJpZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICAgKiAgICAgZnVuY3Rpb24sIG9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvblxuICAgKiAgICAgcmV0dXJucyBgdHJ1ZWAgd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiAgQnkgZGVmYXVsdCwgYWxsIHZpc2libGVcbiAgICogICAgIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtVfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlP1xuICAgKiBAdGVtcGxhdGUgVVxuICAgKi9cbiAgaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNoZWNrV3JhcHBlZCxcbiAgICBsYXllckZpbHRlcixcbiAgICB0aGlzQXJnLFxuICApIHtcbiAgICBjb25zdCBoYXNGZWF0dXJlID0gdGhpcy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsXG4gICAgICBmcmFtZVN0YXRlLFxuICAgICAgaGl0VG9sZXJhbmNlLFxuICAgICAgY2hlY2tXcmFwcGVkLFxuICAgICAgVFJVRSxcbiAgICAgIHRoaXMsXG4gICAgICBsYXllckZpbHRlcixcbiAgICAgIHRoaXNBcmcsXG4gICAgKTtcblxuICAgIHJldHVybiBoYXNGZWF0dXJlICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IE1hcC5cbiAgICovXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2NoZWR1bGVFeHBpcmVJY29uQ2FjaGUoZnJhbWVTdGF0ZSkge1xuICAgIGlmIChpY29uSW1hZ2VDYWNoZS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMucHVzaChleHBpcmVJY29uQ2FjaGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICovXG5mdW5jdGlvbiBleHBpcmVJY29uQ2FjaGUobWFwLCBmcmFtZVN0YXRlKSB7XG4gIGljb25JbWFnZUNhY2hlLmV4cGlyZSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBNYXBSZW5kZXJlcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50XG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5cbmNsYXNzIFJlbmRlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gW2ludmVyc2VQaXhlbFRyYW5zZm9ybV0gVHJhbnNmb3JtIGZvclxuICAgKiAgICAgQ1NTIHBpeGVscyB0byByZW5kZXJlZCBwaXhlbHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHs/KENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxXZWJHTFJlbmRlcmluZ0NvbnRleHQpfSBbY29udGV4dF0gQ29udGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGludmVyc2VQaXhlbFRyYW5zZm9ybSwgZnJhbWVTdGF0ZSwgY29udGV4dCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGZyb20gQ1NTIHBpeGVscyAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgbWFwIHZpZXdwb3J0KVxuICAgICAqIHRvIHJlbmRlcmVkIHBpeGVscyBvbiB0aGlzIGV2ZW50J3MgYGNvbnRleHRgLiBPbmx5IGF2YWlsYWJsZSB3aGVuIGEgQ2FudmFzIHJlbmRlcmVyIGlzIHVzZWQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0gPSBpbnZlcnNlUGl4ZWxUcmFuc2Zvcm07XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJlbmRlciBmcmFtZSBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIGNvbnRleHQuIE5vdCBhdmFpbGFibGUgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBieSB0aGUgbWFwLiBGb3IgQ2FudmFzIDJEIGxheWVycyxcbiAgICAgKiB0aGUgY29udGV4dCB3aWxsIGJlIHRoZSAyRCByZW5kZXJpbmcgY29udGV4dC4gIEZvciBXZWJHTCBsYXllcnMsIHRoZSBjb250ZXh0IHdpbGwgYmUgdGhlIFdlYkdMXG4gICAgICogY29udGV4dC5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFdlYkdMUmVuZGVyaW5nQ29udGV4dHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyRXZlbnQ7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL0NvbXBvc2l0ZVxuICovXG5pbXBvcnQgQmFzZVZlY3RvckxheWVyIGZyb20gJy4uL2xheWVyL0Jhc2VWZWN0b3IuanMnO1xuaW1wb3J0IE1hcFJlbmRlcmVyIGZyb20gJy4vTWFwLmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudCBmcm9tICcuLi9yZW5kZXIvRXZlbnQuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtjaGVja2VkRm9udHN9IGZyb20gJy4uL3JlbmRlci9jYW52YXMuanMnO1xuaW1wb3J0IHtpblZpZXd9IGZyb20gJy4uL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IHtyZXBsYWNlQ2hpbGRyZW59IGZyb20gJy4uL2RvbS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2FudmFzIG1hcCByZW5kZXJlci5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ29tcG9zaXRlTWFwUmVuZGVyZXIgZXh0ZW5kcyBNYXBSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFwKSB7XG4gICAgc3VwZXIobWFwKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5mb250Q2hhbmdlTGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgY2hlY2tlZEZvbnRzLFxuICAgICAgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgbWFwLnJlZHJhd1RleHQsXG4gICAgICBtYXAsXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZWxlbWVudF8uc3R5bGU7XG4gICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBzdHlsZS56SW5kZXggPSAnMCc7XG5cbiAgICB0aGlzLmVsZW1lbnRfLmNsYXNzTmFtZSA9IENMQVNTX1VOU0VMRUNUQUJMRSArICcgb2wtbGF5ZXJzJztcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5nZXRWaWV3cG9ydCgpO1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5lbGVtZW50XywgY29udGFpbmVyLmZpcnN0Q2hpbGQgfHwgbnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9FdmVudFR5cGUuanNcIikuZGVmYXVsdH0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3BhdGNoUmVuZGVyRXZlbnQodHlwZSwgZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcC5oYXNMaXN0ZW5lcih0eXBlKSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUmVuZGVyRXZlbnQodHlwZSwgdW5kZWZpbmVkLCBmcmFtZVN0YXRlKTtcbiAgICAgIG1hcC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdW5saXN0ZW5CeUtleSh0aGlzLmZvbnRDaGFuZ2VMaXN0ZW5lcktleV8pO1xuICAgIHRoaXMuZWxlbWVudF8ucmVtb3ZlKCk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyLlxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXJGcmFtZShmcmFtZVN0YXRlKSB7XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZFZpc2libGVfKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudF8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYWxjdWxhdGVNYXRyaWNlczJEKGZyYW1lU3RhdGUpO1xuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSwgZnJhbWVTdGF0ZSk7XG5cbiAgICBjb25zdCBsYXllclN0YXRlc0FycmF5ID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5LnNvcnQoXG4gICAgICAoYSwgYikgPT4gYS56SW5kZXggLSBiLnpJbmRleCxcbiAgICApO1xuICAgIGNvbnN0IGRlY2x1dHRlciA9IGxheWVyU3RhdGVzQXJyYXkuc29tZShcbiAgICAgIChsYXllclN0YXRlKSA9PlxuICAgICAgICBsYXllclN0YXRlLmxheWVyIGluc3RhbmNlb2YgQmFzZVZlY3RvckxheWVyICYmXG4gICAgICAgIGxheWVyU3RhdGUubGF5ZXIuZ2V0RGVjbHV0dGVyKCksXG4gICAgKTtcbiAgICBpZiAoZGVjbHV0dGVyKSB7XG4gICAgICAvLyBTb21lIGxheWVycyBuZWVkIGRlY2x1dHRlcmluZywgdHVybiBvbiBkZWZlcnJlZCByZW5kZXJpbmcgaGludFxuICAgICAgZnJhbWVTdGF0ZS5kZWNsdXR0ZXIgPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG5cbiAgICB0aGlzLmNoaWxkcmVuXy5sZW5ndGggPSAwO1xuXG4gICAgY29uc3QgcmVuZGVyZWRMYXllclN0YXRlcyA9IFtdO1xuICAgIGxldCBwcmV2aW91c0VsZW1lbnQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVyU3RhdGVzQXJyYXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGxheWVyU3RhdGVzQXJyYXlbaV07XG4gICAgICBmcmFtZVN0YXRlLmxheWVySW5kZXggPSBpO1xuXG4gICAgICBjb25zdCBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICBjb25zdCBzb3VyY2VTdGF0ZSA9IGxheWVyLmdldFNvdXJjZVN0YXRlKCk7XG4gICAgICBpZiAoXG4gICAgICAgICFpblZpZXcobGF5ZXJTdGF0ZSwgdmlld1N0YXRlKSB8fFxuICAgICAgICAoc291cmNlU3RhdGUgIT0gJ3JlYWR5JyAmJiBzb3VyY2VTdGF0ZSAhPSAndW5kZWZpbmVkJylcbiAgICAgICkge1xuICAgICAgICBsYXllci51bnJlbmRlcigpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnJlbmRlcihmcmFtZVN0YXRlLCBwcmV2aW91c0VsZW1lbnQpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQgIT09IHByZXZpb3VzRWxlbWVudCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICByZW5kZXJlZExheWVyU3RhdGVzLnB1c2gobGF5ZXJTdGF0ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWNsdXR0ZXIoZnJhbWVTdGF0ZSwgcmVuZGVyZWRMYXllclN0YXRlcyk7XG5cbiAgICByZXBsYWNlQ2hpbGRyZW4odGhpcy5lbGVtZW50XywgdGhpcy5jaGlsZHJlbl8pO1xuXG4gICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50KFJlbmRlckV2ZW50VHlwZS5QT1NUQ09NUE9TRSwgZnJhbWVTdGF0ZSk7XG5cbiAgICBpZiAoIXRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVFeHBpcmVJY29uQ2FjaGUoZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2xheWVyL0xheWVyLmpzJykuU3RhdGU+fSBsYXllclN0YXRlcyBMYXllcnMuXG4gICAqL1xuICBkZWNsdXR0ZXIoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZXMpIHtcbiAgICBpZiAoIWZyYW1lU3RhdGUuZGVjbHV0dGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBsYXllclN0YXRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGxheWVyU3RhdGVzW2ldO1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgaWYgKGxheWVyLmdldERlY2x1dHRlcigpKSB7XG4gICAgICAgIGxheWVyLnJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlLCBsYXllclN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGF5ZXJTdGF0ZXMuZm9yRWFjaCgobGF5ZXJTdGF0ZSkgPT5cbiAgICAgIGxheWVyU3RhdGUubGF5ZXIucmVuZGVyRGVmZXJyZWQoZnJhbWVTdGF0ZSksXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb3NpdGVNYXBSZW5kZXJlcjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvR3JvdXBcbiAqL1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuL0Jhc2UuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQge2dldEludGVyc2VjdGlvbn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnYWRkbGF5ZXInfCdyZW1vdmVsYXllcid9IEdyb3VwRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGxheWVyIGdyb3VwIHRyaWdnZXJzICdhZGRsYXllcicgYW5kICdyZW1vdmVsYXllcicgZXZlbnRzIHdoZW4gbGF5ZXJzIGFyZSBhZGRlZCB0byBvciByZW1vdmVkIGZyb21cbiAqIHRoZSBncm91cCBvciBvbmUgb2YgaXRzIGNoaWxkIGdyb3Vwcy4gIFdoZW4gYSBsYXllciBncm91cCBpcyBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gYW5vdGhlciBsYXllciBncm91cCxcbiAqIGEgc2luZ2xlIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIChpbnN0ZWFkIG9mIG9uZSBwZXIgbGF5ZXIgaW4gdGhlIGdyb3VwIGFkZGVkIG9yIHJlbW92ZWQpLlxuICovXG5leHBvcnQgY2xhc3MgR3JvdXBFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7R3JvdXBFdmVudFR5cGV9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7QmFzZUxheWVyfSBsYXllciBUaGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBsYXllcikge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFkZGVkIG9yIHJlbW92ZWQgbGF5ZXIuXG4gICAgICogQHR5cGUge0Jhc2VMYXllcn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfFxuICogICAgICdjaGFuZ2U6bGF5ZXJzJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3wnY2hhbmdlOmxheWVycycsIFJldHVybj59IEdyb3VwT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IFtsYXllcnNdIENoaWxkIGxheWVycy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgUHJvcGVydHkgPSB7XG4gIExBWUVSUzogJ2xheWVycycsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IG9mIGxheWVycyB0aGF0IGFyZSBoYW5kbGVkIHRvZ2V0aGVyLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgZ3JvdXAvQ29sbGVjdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTGF5ZXJHcm91cCBleHRlbmRzIEJhc2VMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBMYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gLyoqIEB0eXBlIHtPcHRpb25zfSAqLyAoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5sYXllcnM7XG5cbiAgICBsZXQgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG5cbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0dyb3VwT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7R3JvdXBPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0dyb3VwT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT4+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJLZXlzXyA9IHt9O1xuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihQcm9wZXJ0eS5MQVlFUlMsIHRoaXMuaGFuZGxlTGF5ZXJzQ2hhbmdlZF8pO1xuXG4gICAgaWYgKGxheWVycykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGF5ZXJzKSkge1xuICAgICAgICBsYXllcnMgPSBuZXcgQ29sbGVjdGlvbihsYXllcnMuc2xpY2UoKSwge3VuaXF1ZTogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAobGF5ZXJzKS5nZXRBcnJheSkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICAgJ0V4cGVjdGVkIGBsYXllcnNgIHRvIGJlIGFuIGFycmF5IG9yIGEgYENvbGxlY3Rpb25gJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJzID0gbmV3IENvbGxlY3Rpb24odW5kZWZpbmVkLCB7dW5pcXVlOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRMYXllcnMobGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJDaGFuZ2VfKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllcnNDaGFuZ2VkXygpIHtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcblxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICBsaXN0ZW4obGF5ZXJzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgdGhpcy5oYW5kbGVMYXllcnNBZGRfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgICAgdGhpcy5oYW5kbGVMYXllcnNSZW1vdmVfLFxuICAgICAgICB0aGlzLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmxpc3RlbmVyS2V5c18pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJLZXlzX1tpZF0uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB9XG4gICAgY2xlYXIodGhpcy5saXN0ZW5lcktleXNfKTtcblxuICAgIGNvbnN0IGxheWVyc0FycmF5ID0gbGF5ZXJzLmdldEFycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNBcnJheVtpXTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMYXllckxpc3RlbmVyc18obGF5ZXIpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdhZGRsYXllcicsIGxheWVyKSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZUxheWVyfSBsYXllciBUaGUgbGF5ZXIuXG4gICAqL1xuICByZWdpc3RlckxheWVyTGlzdGVuZXJzXyhsYXllcikge1xuICAgIGNvbnN0IGxpc3RlbmVyS2V5cyA9IFtcbiAgICAgIGxpc3RlbihcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sXG4gICAgICAgIHRoaXMsXG4gICAgICApLFxuICAgICAgbGlzdGVuKGxheWVyLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyQ2hhbmdlXywgdGhpcyksXG4gICAgXTtcblxuICAgIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgIGxpc3RlbmVyS2V5cy5wdXNoKFxuICAgICAgICBsaXN0ZW4obGF5ZXIsICdhZGRsYXllcicsIHRoaXMuaGFuZGxlTGF5ZXJHcm91cEFkZF8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXIsICdyZW1vdmVsYXllcicsIHRoaXMuaGFuZGxlTGF5ZXJHcm91cFJlbW92ZV8sIHRoaXMpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyS2V5c19bZ2V0VWlkKGxheWVyKV0gPSBsaXN0ZW5lcktleXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtHcm91cEV2ZW50fSBldmVudCBUaGUgbGF5ZXIgZ3JvdXAgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVMYXllckdyb3VwQWRkXyhldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBFdmVudCgnYWRkbGF5ZXInLCBldmVudC5sYXllcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R3JvdXBFdmVudH0gZXZlbnQgVGhlIGxheWVyIGdyb3VwIGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlTGF5ZXJHcm91cFJlbW92ZV8oZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ3JlbW92ZWxheWVyJywgZXZlbnQubGF5ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc0FkZF8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSBjb2xsZWN0aW9uRXZlbnQuZWxlbWVudDtcbiAgICB0aGlzLnJlZ2lzdGVyTGF5ZXJMaXN0ZW5lcnNfKGxheWVyKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ2FkZGxheWVyJywgbGF5ZXIpKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc1JlbW92ZV8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSBjb2xsZWN0aW9uRXZlbnQuZWxlbWVudDtcbiAgICBjb25zdCBrZXkgPSBnZXRVaWQobGF5ZXIpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1trZXldLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgZGVsZXRlIHRoaXMubGlzdGVuZXJLZXlzX1trZXldO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBFdmVudCgncmVtb3ZlbGF5ZXInLCBsYXllcikpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcmV0dXJuIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXllcnMoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSAqLyAoXG4gICAgICB0aGlzLmdldChQcm9wZXJ0eS5MQVlFUlMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcGFyYW0geyFDb2xsZWN0aW9uPGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllcnMobGF5ZXJzKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMYXllcnMgPSBjb2xsZWN0aW9uLmdldEFycmF5KCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjdXJyZW50TGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdyZW1vdmVsYXllcicsIGN1cnJlbnRMYXllcnNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldChQcm9wZXJ0eS5MQVlFUlMsIGxheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBbYXJyYXldIEFycmF5IG9mIGxheWVycyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBBcnJheSBvZiBsYXllcnMuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheSA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheSA6IFtdO1xuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmdldExheWVyc0FycmF5KGFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciBzdGF0ZXMgbGlzdCBhbmQgdXNlIHRoaXMgZ3JvdXBzIHotaW5kZXggYXMgdGhlIGRlZmF1bHRcbiAgICogZm9yIGFsbCBsYXllcnMgaW4gdGhpcyBhbmQgbmVzdGVkIGdyb3VwcywgaWYgaXQgaXMgdW5zZXQgYXQgdGhpcyBwb2ludC5cbiAgICogSWYgZGVzdCBpcyBub3QgcHJvdmlkZWQgYW5kIHRoaXMgZ3JvdXAncyB6LWluZGV4IGlzIHVuZGVmaW5lZFxuICAgKiAwIGlzIHVzZWQgYSB0aGUgZGVmYXVsdCB6LWluZGV4LlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+fSBbZGVzdF0gT3B0aW9uYWwgbGlzdFxuICAgKiBvZiBsYXllciBzdGF0ZXMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IExpc3Qgb2YgbGF5ZXIgc3RhdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldExheWVyU3RhdGVzQXJyYXkoZGVzdCkge1xuICAgIGNvbnN0IHN0YXRlcyA9IGRlc3QgIT09IHVuZGVmaW5lZCA/IGRlc3QgOiBbXTtcbiAgICBjb25zdCBwb3MgPSBzdGF0ZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgbGF5ZXIuZ2V0TGF5ZXJTdGF0ZXNBcnJheShzdGF0ZXMpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb3duTGF5ZXJTdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZSgpO1xuICAgIGxldCBkZWZhdWx0WkluZGV4ID0gb3duTGF5ZXJTdGF0ZS56SW5kZXg7XG4gICAgaWYgKCFkZXN0ICYmIG93bkxheWVyU3RhdGUuekluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmF1bHRaSW5kZXggPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcG9zLCBpaSA9IHN0YXRlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllclN0YXRlID0gc3RhdGVzW2ldO1xuICAgICAgbGF5ZXJTdGF0ZS5vcGFjaXR5ICo9IG93bkxheWVyU3RhdGUub3BhY2l0eTtcbiAgICAgIGxheWVyU3RhdGUudmlzaWJsZSA9IGxheWVyU3RhdGUudmlzaWJsZSAmJiBvd25MYXllclN0YXRlLnZpc2libGU7XG4gICAgICBsYXllclN0YXRlLm1heFJlc29sdXRpb24gPSBNYXRoLm1pbihcbiAgICAgICAgbGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uLFxuICAgICAgICBvd25MYXllclN0YXRlLm1heFJlc29sdXRpb24sXG4gICAgICApO1xuICAgICAgbGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgIGxheWVyU3RhdGUubWluUmVzb2x1dGlvbixcbiAgICAgICAgb3duTGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uLFxuICAgICAgKTtcbiAgICAgIGxheWVyU3RhdGUubWluWm9vbSA9IE1hdGgubWF4KGxheWVyU3RhdGUubWluWm9vbSwgb3duTGF5ZXJTdGF0ZS5taW5ab29tKTtcbiAgICAgIGxheWVyU3RhdGUubWF4Wm9vbSA9IE1hdGgubWluKGxheWVyU3RhdGUubWF4Wm9vbSwgb3duTGF5ZXJTdGF0ZS5tYXhab29tKTtcbiAgICAgIGlmIChvd25MYXllclN0YXRlLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChsYXllclN0YXRlLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oXG4gICAgICAgICAgICBsYXllclN0YXRlLmV4dGVudCxcbiAgICAgICAgICAgIG93bkxheWVyU3RhdGUuZXh0ZW50LFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgPSBvd25MYXllclN0YXRlLmV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxheWVyU3RhdGUuekluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGF5ZXJTdGF0ZS56SW5kZXggPSBkZWZhdWx0WkluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5TdGF0ZX0gU291cmNlIHN0YXRlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNvdXJjZVN0YXRlKCkge1xuICAgIHJldHVybiAncmVhZHknO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyR3JvdXA7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50XG4gKi9cbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYXMgbWFwIGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGZvciB3aGljaCBldmVudHMgdHJpZ2dlciBhIG1hcCBldmVudC5cbiAqL1xuY2xhc3MgTWFwRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgZnJhbWVTdGF0ZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIHN0YXRlIGF0IHRoZSB0aW1lIG9mIHRoZSBldmVudC5cbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IGZyYW1lU3RhdGUgIT09IHVuZGVmaW5lZCA/IGZyYW1lU3RhdGUgOiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEV2ZW50O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRcbiAqL1xuaW1wb3J0IE1hcEV2ZW50IGZyb20gJy4vTWFwRXZlbnQuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGFzIG1hcCBicm93c2VyIGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGZvciB3aGljaCBldmVudHMgdHJpZ2dlciBhIG1hcCBicm93c2VyIGV2ZW50LlxuICogQHRlbXBsYXRlIHtVSUV2ZW50fSBFVkVOVFxuICovXG5jbGFzcyBNYXBCcm93c2VyRXZlbnQgZXh0ZW5kcyBNYXBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7RVZFTlR9IG9yaWdpbmFsRXZlbnQgT3JpZ2luYWwgZXZlbnQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RyYWdnaW5nXSBJcyB0aGUgbWFwIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkP1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtBcnJheTxQb2ludGVyRXZlbnQ+fSBbYWN0aXZlUG9pbnRlcnNdIEFjdGl2ZSBwb2ludGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgb3JpZ2luYWxFdmVudCwgZHJhZ2dpbmcsIGZyYW1lU3RhdGUsIGFjdGl2ZVBvaW50ZXJzKSB7XG4gICAgc3VwZXIodHlwZSwgbWFwLCBmcmFtZVN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtFVkVOVH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgcGl4ZWwgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yaWdpbmFsIGJyb3dzZXIgZXZlbnQuXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5waXhlbF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgaW4gdGhlIHVzZXIgcHJvamVjdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgbWFwIGlzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLiBPbmx5IHNldCBmb3JcbiAgICAgKiBgUE9JTlRFUkRSQUdgIGFuZCBgUE9JTlRFUk1PVkVgIGV2ZW50cy4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBkcmFnZ2luZyAhPT0gdW5kZWZpbmVkID8gZHJhZ2dpbmcgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxQb2ludGVyRXZlbnQ+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzID0gYWN0aXZlUG9pbnRlcnM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1hcCBwaXhlbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXQgcGl4ZWwoKSB7XG4gICAgaWYgKCF0aGlzLnBpeGVsXykge1xuICAgICAgdGhpcy5waXhlbF8gPSB0aGlzLm1hcC5nZXRFdmVudFBpeGVsKHRoaXMub3JpZ2luYWxFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBpeGVsXztcbiAgfVxuICBzZXQgcGl4ZWwocGl4ZWwpIHtcbiAgICB0aGlzLnBpeGVsXyA9IHBpeGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb29yZGluYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yaWdpbmFsIGJyb3dzZXIgZXZlbnQuICBUaGlzIHdpbGwgYmUgaW4gdGhlIHVzZXJcbiAgICogcHJvamVjdGlvbiBpZiBvbmUgaXMgc2V0LiAgT3RoZXJ3aXNlIGl0IHdpbGwgYmUgaW4gdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXQgY29vcmRpbmF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuY29vcmRpbmF0ZV8pIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZV8gPSB0aGlzLm1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMucGl4ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlXztcbiAgfVxuICBzZXQgY29vcmRpbmF0ZShjb29yZGluYXRlKSB7XG4gICAgdGhpcy5jb29yZGluYXRlXyA9IGNvb3JkaW5hdGU7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb24uXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZXZlbnQucHJldmVudERlZmF1bHQuXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICBzdXBlci5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICgncHJldmVudERlZmF1bHQnIGluIHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgLyoqIEB0eXBlIHtVSUV2ZW50fSAqLyAodGhpcy5vcmlnaW5hbEV2ZW50KS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBmdXJ0aGVyIHByb3BhZ2F0aW9uIG9mIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LnN0b3BQcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICBzdXBlci5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoJ3N0b3BQcm9wYWdhdGlvbicgaW4gdGhpcy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAvKiogQHR5cGUge1VJRXZlbnR9ICovICh0aGlzLm9yaWdpbmFsRXZlbnQpLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXBCcm93c2VyRXZlbnQ7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudFR5cGVcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgZXZlbnQgbmFtZXMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBBIHRydWUgc2luZ2xlIGNsaWNrIHdpdGggbm8gZHJhZ2dpbmcgYW5kIG5vIGRvdWJsZSBjbGljay4gTm90ZSB0aGF0IHRoaXNcbiAgICogZXZlbnQgaXMgZGVsYXllZCBieSAyNTAgbXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgbm90IGEgZG91YmxlIGNsaWNrLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjc2luZ2xlY2xpY2tcbiAgICogQGFwaVxuICAgKi9cbiAgU0lOR0xFQ0xJQ0s6ICdzaW5nbGVjbGljaycsXG5cbiAgLyoqXG4gICAqIEEgY2xpY2sgd2l0aCBubyBkcmFnZ2luZy4gQSBkb3VibGUgY2xpY2sgd2lsbCBmaXJlIHR3byBvZiB0aGlzLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjY2xpY2tcbiAgICogQGFwaVxuICAgKi9cbiAgQ0xJQ0s6IEV2ZW50VHlwZS5DTElDSyxcblxuICAvKipcbiAgICogQSB0cnVlIGRvdWJsZSBjbGljaywgd2l0aCBubyBkcmFnZ2luZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I2RibGNsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIERCTENMSUNLOiBFdmVudFR5cGUuREJMQ0xJQ0ssXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgcG9pbnRlciBpcyBkcmFnZ2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjcG9pbnRlcmRyYWdcbiAgICogQGFwaVxuICAgKi9cbiAgUE9JTlRFUkRSQUc6ICdwb2ludGVyZHJhZycsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgcG9pbnRlciBpcyBtb3ZlZC4gTm90ZSB0aGF0IG9uIHRvdWNoIGRldmljZXMgdGhpcyBpc1xuICAgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgbWFwIGlzIHBhbm5lZCwgc28gaXMgbm90IHRoZSBzYW1lIGFzIG1vdXNlbW92ZS5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3BvaW50ZXJtb3ZlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPSU5URVJNT1ZFOiAncG9pbnRlcm1vdmUnLFxuXG4gIFBPSU5URVJET1dOOiAncG9pbnRlcmRvd24nLFxuICBQT0lOVEVSVVA6ICdwb2ludGVydXAnLFxuICBQT0lOVEVST1ZFUjogJ3BvaW50ZXJvdmVyJyxcbiAgUE9JTlRFUk9VVDogJ3BvaW50ZXJvdXQnLFxuICBQT0lOVEVSRU5URVI6ICdwb2ludGVyZW50ZXInLFxuICBQT0lOVEVSTEVBVkU6ICdwb2ludGVybGVhdmUnLFxuICBQT0lOVEVSQ0FOQ0VMOiAncG9pbnRlcmNhbmNlbCcsXG59O1xuXG4vKioqXG4gKiBAdHlwZWRlZiB7J3NpbmdsZWNsaWNrJ3wnY2xpY2snfCdkYmxjbGljayd8J3BvaW50ZXJkcmFnJ3wncG9pbnRlcm1vdmUnfSBUeXBlc1xuICovXG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGV2ZW50IG5hbWVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQT0lOVEVSTU9WRTogJ3BvaW50ZXJtb3ZlJyxcbiAgUE9JTlRFUkRPV046ICdwb2ludGVyZG93bicsXG4gIFBPSU5URVJVUDogJ3BvaW50ZXJ1cCcsXG4gIFBPSU5URVJPVkVSOiAncG9pbnRlcm92ZXInLFxuICBQT0lOVEVST1VUOiAncG9pbnRlcm91dCcsXG4gIFBPSU5URVJFTlRFUjogJ3BvaW50ZXJlbnRlcicsXG4gIFBPSU5URVJMRUFWRTogJ3BvaW50ZXJsZWF2ZScsXG4gIFBPSU5URVJDQU5DRUw6ICdwb2ludGVyY2FuY2VsJyxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudEhhbmRsZXJcbiAqL1xuXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlckV2ZW50LmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCB7UEFTU0lWRV9FVkVOVF9MSVNURU5FUlN9IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5cbmNsYXNzIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIgZXh0ZW5kcyBUYXJnZXQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgVGhlIG1hcCB3aXRoIHRoZSB2aWV3cG9ydCB0byBsaXN0ZW4gdG8gZXZlbnRzIG9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vdmVUb2xlcmFuY2VdIFRoZSBtaW5pbWFsIGRpc3RhbmNlIHRoZSBwb2ludGVyIG11c3QgdHJhdmVsIHRvIHRyaWdnZXIgYSBtb3ZlLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFwLCBtb3ZlVG9sZXJhbmNlKSB7XG4gICAgc3VwZXIobWFwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGxpc3RlbiB0byB0aGUgcmVhbCBldmVudHMgb24uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNsaWNrVGltZW91dElkXztcblxuICAgIC8qKlxuICAgICAqIEVtdWxhdGUgZGJsY2xpY2sgYW5kIHNpbmdsZWNsaWNrLiBXaWxsIGJlIHRydWUgd2hlbiBvbmx5IG9uZSBwb2ludGVyIGlzIGFjdGl2ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVtdWxhdGVDbGlja3NfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tb3ZlVG9sZXJhbmNlXyA9IG1vdmVUb2xlcmFuY2UgPT09IHVuZGVmaW5lZCA/IDEgOiBtb3ZlVG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IFwiZG93blwiIHR5cGUgZXZlbnQgKG9yIG51bGwgaWYgbm9uZSBoYXZlIG9jY3VycmVkKS5cbiAgICAgKiBTZXQgb24gcG9pbnRlcmRvd24uXG4gICAgICogQHR5cGUge1BvaW50ZXJFdmVudHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kb3duXyA9IG51bGw7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5tYXBfLmdldFZpZXdwb3J0KCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9pbnRlckV2ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxudW1iZXIsIEV2ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSBlbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgZWxlbWVudCxcbiAgICAgIFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sXG4gICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duXyxcbiAgICAgIHRoaXMsXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQb2ludGVyRXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVsYXllZExpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgIGVsZW1lbnQsXG4gICAgICBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgdGhpcy5yZWxheU1vdmVFdmVudF8sXG4gICAgICB0aGlzLFxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRIYW5kbGVUb3VjaE1vdmVfID0gdGhpcy5oYW5kbGVUb3VjaE1vdmVfLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmVsZW1lbnRfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuVE9VQ0hNT1ZFLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVRvdWNoTW92ZV8sXG4gICAgICBQQVNTSVZFX0VWRU5UX0xJU1RFTkVSUyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtdWxhdGVDbGlja18ocG9pbnRlckV2ZW50KSB7XG4gICAgbGV0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICB0aGlzLm1hcF8sXG4gICAgICBwb2ludGVyRXZlbnQsXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIGlmICh0aGlzLmNsaWNrVGltZW91dElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkb3VibGUtY2xpY2tcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZW91dElkXyk7XG4gICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgICAgIG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSyxcbiAgICAgICAgdGhpcy5tYXBfLFxuICAgICAgICBwb2ludGVyRXZlbnQsXG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2xpY2tcbiAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQoXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSyxcbiAgICAgICAgICB0aGlzLm1hcF8sXG4gICAgICAgICAgcG9pbnRlckV2ZW50LFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgICAgfSwgMjUwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb24gaG93IG1hbnkgcG9pbnRlcnMgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IHBvaW50ZXJFdmVudDtcbiAgICBjb25zdCBpZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuICAgIGlmIChcbiAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVAgfHxcbiAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSQ0FOQ0VMXG4gICAgKSB7XG4gICAgICBkZWxldGUgdGhpcy50cmFja2VkVG91Y2hlc19baWRdO1xuICAgICAgZm9yIChjb25zdCBwb2ludGVySWQgaW4gdGhpcy50cmFja2VkVG91Y2hlc18pIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZFRvdWNoZXNfW3BvaW50ZXJJZF0udGFyZ2V0ICE9PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAvLyBTb21lIHBsYXRmb3JtcyBhc3NpZ24gYSBuZXcgcG9pbnRlcklkIHdoZW4gdGhlIHRhcmdldCBjaGFuZ2VzLlxuICAgICAgICAgIC8vIElmIHRoaXMgaGFwcGVucywgZGVsZXRlIG9uZSB0cmFja2VkIHBvaW50ZXIuIElmIHRoZXJlIGlzIG1vcmVcbiAgICAgICAgICAvLyB0aGFuIG9uZSB0cmFja2VkIHBvaW50ZXIgZm9yIHRoZSBvbGQgdGFyZ2V0LCBpdCB3aWxsIGJlIGNsZWFyZWRcbiAgICAgICAgICAvLyBieSBzdWJzZXF1ZW50IFBPSU5URVJVUCBldmVudHMgZnJvbSBvdGhlciBwb2ludGVycy5cbiAgICAgICAgICBkZWxldGUgdGhpcy50cmFja2VkVG91Y2hlc19bcG9pbnRlcklkXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04gfHxcbiAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRVxuICAgICkge1xuICAgICAgdGhpcy50cmFja2VkVG91Y2hlc19baWRdID0gZXZlbnQ7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gT2JqZWN0LnZhbHVlcyh0aGlzLnRyYWNrZWRUb3VjaGVzXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUG9pbnRlclVwXyhwb2ludGVyRXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQLFxuICAgICAgdGhpcy5tYXBfLFxuICAgICAgcG9pbnRlckV2ZW50LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5hY3RpdmVQb2ludGVyc18sXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgLy8gV2UgZW11bGF0ZSBjbGljayBldmVudHMgb24gbGVmdCBtb3VzZSBidXR0b24gY2xpY2ssIHRvdWNoIGNvbnRhY3QsIGFuZCBwZW5cbiAgICAvLyBjb250YWN0LiBpc01vdXNlQWN0aW9uQnV0dG9uIHJldHVybnMgdHJ1ZSBpbiB0aGVzZSBjYXNlcyAoZXZ0LmJ1dHRvbiBpcyBzZXRcbiAgICAvLyB0byAwKS5cbiAgICAvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jYnV0dG9uLXN0YXRlc1xuICAgIC8vIFdlIG9ubHkgZmlyZSBjbGljaywgc2luZ2xlY2xpY2ssIGFuZCBkb3VibGVjbGljayBpZiBub2JvZHkgaGFzIGNhbGxlZFxuICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gICAgaWYgKFxuICAgICAgdGhpcy5lbXVsYXRlQ2xpY2tzXyAmJlxuICAgICAgIW5ld0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiZcbiAgICAgICF0aGlzLmRyYWdnaW5nXyAmJlxuICAgICAgdGhpcy5pc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpXG4gICAgKSB7XG4gICAgICB0aGlzLmVtdWxhdGVDbGlja18odGhpcy5kb3duXyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlUG9pbnRlcnNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5kcmFnZ2luZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMuZG93bl8gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiB3YXMgcHJlc3NlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW91c2VBY3Rpb25CdXR0b25fKHBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVBvaW50ZXJEb3duXyhwb2ludGVyRXZlbnQpIHtcbiAgICB0aGlzLmVtdWxhdGVDbGlja3NfID0gdGhpcy5hY3RpdmVQb2ludGVyc18ubGVuZ3RoID09PSAwO1xuICAgIHRoaXMudXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCk7XG4gICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTixcbiAgICAgIHRoaXMubWFwXyxcbiAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfLFxuICAgICk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblxuICAgIHRoaXMuZG93bl8gPSBuZXcgUG9pbnRlckV2ZW50KHBvaW50ZXJFdmVudC50eXBlLCBwb2ludGVyRXZlbnQpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmRvd25fLCAndGFyZ2V0Jywge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHBvaW50ZXJFdmVudC50YXJnZXQsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMubWFwXy5nZXRPd25lckRvY3VtZW50KCk7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBkb2MsXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICApLFxuICAgICAgICBsaXN0ZW4oZG9jLCBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCwgdGhpcy5oYW5kbGVQb2ludGVyVXBfLCB0aGlzKSxcbiAgICAgICAgLyogTm90ZSB0aGF0IHRoZSBsaXN0ZW5lciBmb3IgYHBvaW50ZXJjYW5jZWwgaXMgc2V0IHVwIG9uXG4gICAgICAgICAqIGBwb2ludGVyRXZlbnRIYW5kbGVyX2AgYW5kIG5vdCBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgbGlrZVxuICAgICAgICAgKiB0aGUgYHBvaW50ZXJ1cGAgYW5kIGBwb2ludGVybW92ZWAgbGlzdGVuZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoZSBmb2xsb3dpbmc6IGBUb3VjaFNvdXJjZS52YWN1dW1Ub3VjaGVzXygpYFxuICAgICAgICAgKiBpc3N1ZXMgYHBvaW50ZXJjYW5jZWxgIGV2ZW50cywgd2hlbiB0aGVyZSB3YXMgbm8gYHRvdWNoZW5kYCBmb3IgYVxuICAgICAgICAgKiBgdG91Y2hzdGFydGAuIE5vdywgbGV0J3Mgc2F5IGEgZmlyc3QgYHRvdWNoc3RhcnRgIGlzIHJlZ2lzdGVyZWQgb25cbiAgICAgICAgICogYHBvaW50ZXJFdmVudEhhbmRsZXJfYC4gVGhlIGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBpcyBzZXQgdXAuXG4gICAgICAgICAqIEJ1dCBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgZG9lc24ndCBrbm93IGFib3V0IHRoZSBmaXJzdFxuICAgICAgICAgKiBgdG91Y2hzdGFydGAuIElmIHRoZXJlIGlzIG5vIGB0b3VjaGVuZGAgZm9yIHRoZSBgdG91Y2hzdGFydGAsIHdlIGNhblxuICAgICAgICAgKiBvbmx5IHJlY2VpdmUgYSBgdG91Y2hjYW5jZWxgIGZyb20gYHBvaW50ZXJFdmVudEhhbmRsZXJfYCwgYmVjYXVzZSBpdCBpc1xuICAgICAgICAgKiBvbmx5IHJlZ2lzdGVyZWQgdGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAgdGhpcy5lbGVtZW50XyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJDQU5DRUwsXG4gICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXBfLFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudF8uZ2V0Um9vdE5vZGUgJiYgdGhpcy5lbGVtZW50Xy5nZXRSb290Tm9kZSgpICE9PSBkb2MpIHtcbiAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5wdXNoKFxuICAgICAgICAgIGxpc3RlbihcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudF8uZ2V0Um9vdE5vZGUoKSxcbiAgICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXBfLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyTW92ZV8ocG9pbnRlckV2ZW50KSB7XG4gICAgLy8gQmV0d2VlbiBwb2ludGVyZG93biBhbmQgcG9pbnRlcnVwLCBwb2ludGVybW92ZSBldmVudHMgYXJlIHRyaWdnZXJlZC5cbiAgICAvLyBUbyBhdm9pZCBhICdmYWxzZScgdG91Y2htb3ZlIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQsIHdlIHRlc3QgaWYgdGhlIHBvaW50ZXJcbiAgICAvLyBtb3ZlZCBhIHNpZ25pZmljYW50IGRpc3RhbmNlLlxuICAgIGlmICh0aGlzLmlzTW92aW5nXyhwb2ludGVyRXZlbnQpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgICAgdGhpcy5kcmFnZ2luZ18gPSB0cnVlO1xuICAgICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHLFxuICAgICAgICB0aGlzLm1hcF8sXG4gICAgICAgIHBvaW50ZXJFdmVudCxcbiAgICAgICAgdGhpcy5kcmFnZ2luZ18sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5hY3RpdmVQb2ludGVyc18sXG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbmQgcmVsYXkgYSBwb2ludGVybW92ZSBldmVudC5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVsYXlNb3ZlRXZlbnRfKHBvaW50ZXJFdmVudCkge1xuICAgIHRoaXMub3JpZ2luYWxQb2ludGVyTW92ZUV2ZW50XyA9IHBvaW50ZXJFdmVudDtcbiAgICBjb25zdCBkcmFnZ2luZyA9ICEhKHRoaXMuZG93bl8gJiYgdGhpcy5pc01vdmluZ18ocG9pbnRlckV2ZW50KSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgICAgdGhpcy5tYXBfLFxuICAgICAgICBwb2ludGVyRXZlbnQsXG4gICAgICAgIGRyYWdnaW5nLFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsZXhpYmxlIGhhbmRsaW5nIG9mIGEgYHRvdWNoLWFjdGlvbjogbm9uZWAgY3NzIGVxdWl2YWxlbnQ6IGJlY2F1c2UgY2FsbGluZ1xuICAgKiBgcHJldmVudERlZmF1bHQoKWAgb24gYSBgcG9pbnRlcm1vdmVgIGV2ZW50IGRvZXMgbm90IHN0b3AgbmF0aXZlIHBhZ2Ugc2Nyb2xsaW5nXG4gICAqIGFuZCB6b29taW5nLCB3ZSBhbHNvIGxpc3RlbiBmb3IgYHRvdWNobW92ZWAgYW5kIGNhbGwgYHByZXZlbnREZWZhdWx0KClgIG9uIGl0XG4gICAqIHdoZW4gYW4gaW50ZXJhY3Rpb24gKGN1cnJlbnRseSBgRHJhZ1BhbmAgaGFuZGxlcyB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUb3VjaE1vdmVfKGV2ZW50KSB7XG4gICAgLy8gRHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tcGl6ZW5iZXJnL2VsbS1wZXAvaXNzdWVzLzIsIGB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF9gXG4gICAgLy8gbWF5IG5vdCBiZSBpbml0aWFsaXplZCB5ZXQgd2hlbiB3ZSBnZXQgaGVyZSBvbiBhIHBsYXRmb3JtIHdpdGhvdXQgbmF0aXZlIHBvaW50ZXIgZXZlbnRzLFxuICAgIC8vIHdoZW4gZWxtLXBlcCBpcyB1c2VkIGFzIHBvaW50ZXIgZXZlbnRzIHBvbHlmaWxsLlxuICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSB0aGlzLm9yaWdpbmFsUG9pbnRlck1vdmVFdmVudF87XG4gICAgaWYgKFxuICAgICAgKCFvcmlnaW5hbEV2ZW50IHx8IG9yaWdpbmFsRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiZcbiAgICAgICh0eXBlb2YgZXZlbnQuY2FuY2VsYWJsZSAhPT0gJ2Jvb2xlYW4nIHx8IGV2ZW50LmNhbmNlbGFibGUgPT09IHRydWUpXG4gICAgKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIG1vdmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW92aW5nXyhwb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5kcmFnZ2luZ18gfHxcbiAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRYIC0gdGhpcy5kb3duXy5jbGllbnRYKSA+XG4gICAgICAgIHRoaXMubW92ZVRvbGVyYW5jZV8gfHxcbiAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRZIC0gdGhpcy5kb3duXy5jbGllbnRZKSA+IHRoaXMubW92ZVRvbGVyYW5jZV9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucmVsYXllZExpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRfLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuVE9VQ0hNT1ZFLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVRvdWNoTW92ZV8sXG4gICAgKTtcblxuICAgIGlmICh0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuZWxlbWVudF8gPSBudWxsO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbWFwIGZyYW1lIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBtb3ZpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbW92ZXN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIE1PVkVTVEFSVDogJ21vdmVzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWFwIGlzIG1vdmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I21vdmVlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTU9WRUVORDogJ21vdmVlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBsb2FkaW5nIG9mIGFkZGl0aW9uYWwgbWFwIGRhdGEgKHRpbGVzLCBpbWFnZXMsIGZlYXR1cmVzKSBzdGFydHMuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbG9hZHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIExPQURTVEFSVDogJ2xvYWRzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGxvYWRpbmcgb2YgYWRkaXRpb25hbCBtYXAgZGF0YSBoYXMgY29tcGxldGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I2xvYWRlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTE9BREVORDogJ2xvYWRlbmQnLFxufTtcblxuLyoqKlxuICogQHR5cGVkZWYgeydwb3N0cmVuZGVyJ3wnbW92ZXN0YXJ0J3wnbW92ZWVuZCd8J2xvYWRzdGFydCd8J2xvYWRlbmQnfSBUeXBlc1xuICovXG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL01hcFByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIExBWUVSR1JPVVA6ICdsYXllcmdyb3VwJyxcbiAgU0laRTogJ3NpemUnLFxuICBUQVJHRVQ6ICd0YXJnZXQnLFxuICBWSUVXOiAndmlldycsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWVcbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRFJPUCA9IEluZmluaXR5O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByaW9yaXR5IHF1ZXVlLlxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBpbnNwaXJlZCBmcm9tIHRoZSBDbG9zdXJlIExpYnJhcnkncyBIZWFwIGNsYXNzIGFuZFxuICogUHl0aG9uJ3MgaGVhcHEgbW9kdWxlLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvc3RydWN0cy9oZWFwLmpzXG4gKiBhbmQgaHR0cHM6Ly9oZy5weXRob24ub3JnL2NweXRob24vZmlsZS8yLjcvTGliL2hlYXBxLnB5LlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIFByaW9yaXR5UXVldWUge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUKTogbnVtYmVyfSBwcmlvcml0eUZ1bmN0aW9uIFByaW9yaXR5IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiBzdHJpbmd9IGtleUZ1bmN0aW9uIEtleSBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaW9yaXR5RnVuY3Rpb24sIGtleUZ1bmN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFQpOiBudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnByaW9yaXR5RnVuY3Rpb25fID0gcHJpb3JpdHlGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihUKTogc3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5rZXlGdW5jdGlvbl8gPSBrZXlGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxUPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucHJpb3JpdGllc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnF1ZXVlZEVsZW1lbnRzXyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5lbGVtZW50c18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLnByaW9yaXRpZXNfLmxlbmd0aCA9IDA7XG4gICAgY2xlYXIodGhpcy5xdWV1ZWRFbGVtZW50c18pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBoaWdoZXN0LXByaW9yaXR5IGVsZW1lbnQuIE8obG9nIE4pLlxuICAgKiBAcmV0dXJuIHtUfSBFbGVtZW50LlxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICAgIGNvbnN0IHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgIGVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICBwcmlvcml0aWVzLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRzWzBdID0gLyoqIEB0eXBlIHtUfSAqLyAoZWxlbWVudHMucG9wKCkpO1xuICAgICAgcHJpb3JpdGllc1swXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocHJpb3JpdGllcy5wb3AoKSk7XG4gICAgICB0aGlzLnNpZnRVcF8oMCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRLZXkgPSB0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KTtcbiAgICBkZWxldGUgdGhpcy5xdWV1ZWRFbGVtZW50c19bZWxlbWVudEtleV07XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZSBhbiBlbGVtZW50LiBPKGxvZyBOKS5cbiAgICogQHBhcmFtIHtUfSBlbGVtZW50IEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbGVtZW50IHdhcyBhZGRlZCB0byB0aGUgcXVldWUuXG4gICAqL1xuICBlbnF1ZXVlKGVsZW1lbnQpIHtcbiAgICBhc3NlcnQoXG4gICAgICAhKHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpIGluIHRoaXMucXVldWVkRWxlbWVudHNfKSxcbiAgICAgICdUcmllZCB0byBlbnF1ZXVlIGFuIGBlbGVtZW50YCB0aGF0IHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBxdWV1ZScsXG4gICAgKTtcbiAgICBjb25zdCBwcmlvcml0eSA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl8oZWxlbWVudCk7XG4gICAgaWYgKHByaW9yaXR5ICE9IERST1ApIHtcbiAgICAgIHRoaXMuZWxlbWVudHNfLnB1c2goZWxlbWVudCk7XG4gICAgICB0aGlzLnByaW9yaXRpZXNfLnB1c2gocHJpb3JpdHkpO1xuICAgICAgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2lmdERvd25fKDAsIHRoaXMuZWxlbWVudHNfLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvdW50LlxuICAgKi9cbiAgZ2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBsZWZ0IGNoaWxkIGZvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRMZWZ0Q2hpbGRJbmRleF8oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggKiAyICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgcmlnaHQgY2hpbGQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICogMiArIDI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBhcmVudCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBwYXJlbnQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcGFyZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFyZW50SW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIChpbmRleCAtIDEpID4+IDE7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIGEgaGVhcC4gTyhOKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhlYXBpZnlfKCkge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9ICh0aGlzLmVsZW1lbnRzXy5sZW5ndGggPj4gMSkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5zaWZ0VXBfKGkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMga2V5IHF1ZXVlZC5cbiAgICovXG4gIGlzS2V5UXVldWVkKGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gdGhpcy5xdWV1ZWRFbGVtZW50c187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSBlbGVtZW50IEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHF1ZXVlZC5cbiAgICovXG4gIGlzUXVldWVkKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0tleVF1ZXVlZCh0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIGRvd24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaWZ0VXBfKGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBjb3VudCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuXG4gICAgd2hpbGUgKGluZGV4IDwgY291bnQgPj4gMSkge1xuICAgICAgY29uc3QgbEluZGV4ID0gdGhpcy5nZXRMZWZ0Q2hpbGRJbmRleF8oaW5kZXgpO1xuICAgICAgY29uc3QgckluZGV4ID0gdGhpcy5nZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KTtcblxuICAgICAgY29uc3Qgc21hbGxlckNoaWxkSW5kZXggPVxuICAgICAgICBySW5kZXggPCBjb3VudCAmJiBwcmlvcml0aWVzW3JJbmRleF0gPCBwcmlvcml0aWVzW2xJbmRleF1cbiAgICAgICAgICA/IHJJbmRleFxuICAgICAgICAgIDogbEluZGV4O1xuXG4gICAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50c1tzbWFsbGVyQ2hpbGRJbmRleF07XG4gICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbc21hbGxlckNoaWxkSW5kZXhdO1xuICAgICAgaW5kZXggPSBzbWFsbGVyQ2hpbGRJbmRleDtcbiAgICB9XG5cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gICAgdGhpcy5zaWZ0RG93bl8oc3RhcnRJbmRleCwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFRoZSBpbmRleCBvZiB0aGUgcm9vdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIHVwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2lmdERvd25fKHN0YXJ0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG5cbiAgICB3aGlsZSAoaW5kZXggPiBzdGFydEluZGV4KSB7XG4gICAgICBjb25zdCBwYXJlbnRJbmRleCA9IHRoaXMuZ2V0UGFyZW50SW5kZXhfKGluZGV4KTtcbiAgICAgIGlmIChwcmlvcml0aWVzW3BhcmVudEluZGV4XSA+IHByaW9yaXR5KSB7XG4gICAgICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3BhcmVudEluZGV4XTtcbiAgICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0aWVzW3BhcmVudEluZGV4XTtcbiAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICByZXByaW9yaXRpemUoKSB7XG4gICAgY29uc3QgcHJpb3JpdHlGdW5jdGlvbiA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl87XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IG4gPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgbGV0IGVsZW1lbnQsIGksIHByaW9yaXR5O1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHlGdW5jdGlvbihlbGVtZW50KTtcbiAgICAgIGlmIChwcmlvcml0eSA9PSBEUk9QKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZEVsZW1lbnRzX1t0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICAgICAgICBlbGVtZW50c1tpbmRleCsrXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzLmxlbmd0aCA9IGluZGV4O1xuICAgIHByaW9yaXRpZXMubGVuZ3RoID0gaW5kZXg7XG4gICAgdGhpcy5oZWFwaWZ5XygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByaW9yaXR5UXVldWU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aWxlIGxvYWRpbmcgZmFpbGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlUXVldWVcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFByaW9yaXR5UXVldWUsIHtEUk9QfSBmcm9tICcuL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHQsIHN0cmluZywgaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUsIG51bWJlcik6IG51bWJlcn0gUHJpb3JpdHlGdW5jdGlvblxuICovXG5cbmNsYXNzIFRpbGVRdWV1ZSBleHRlbmRzIFByaW9yaXR5UXVldWUge1xuICAvKipcbiAgICogQHBhcmFtIHtQcmlvcml0eUZ1bmN0aW9ufSB0aWxlUHJpb3JpdHlGdW5jdGlvbiBUaWxlIHByaW9yaXR5IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6ID99IHRpbGVDaGFuZ2VDYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgb24gZWFjaCB0aWxlIGNoYW5nZSBldmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbGVQcmlvcml0eUZ1bmN0aW9uLCB0aWxlQ2hhbmdlQ2FsbGJhY2spIHtcbiAgICBzdXBlcihcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudCBFbGVtZW50LlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBQcmlvcml0eS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRpbGVQcmlvcml0eUZ1bmN0aW9uLmFwcGx5KG51bGwsIGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudCBFbGVtZW50LlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAoZWxlbWVudFswXSkuZ2V0S2V5KCk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmJvdW5kSGFuZGxlVGlsZUNoYW5nZV8gPSB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKCk6ID99XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfID0gdGlsZUNoYW5nZUNhbGxiYWNrO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZXNMb2FkaW5nXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZyxib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVzTG9hZGluZ0tleXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudCBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGVucXVldWUoZWxlbWVudCkge1xuICAgIGNvbnN0IGFkZGVkID0gc3VwZXIuZW5xdWV1ZShlbGVtZW50KTtcbiAgICBpZiAoYWRkZWQpIHtcbiAgICAgIGNvbnN0IHRpbGUgPSBlbGVtZW50WzBdO1xuICAgICAgdGlsZS5hZGRFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuYm91bmRIYW5kbGVUaWxlQ2hhbmdlXyk7XG4gICAgfVxuICAgIHJldHVybiBhZGRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiB0aWxlcyBsb2FkaW5nLlxuICAgKi9cbiAgZ2V0VGlsZXNMb2FkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVzTG9hZGluZ187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlVGlsZUNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZSA9PT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgc3RhdGUgPT09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgc3RhdGUgPT09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICkge1xuICAgICAgaWYgKHN0YXRlICE9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgICAgdGlsZS5yZW1vdmVFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuYm91bmRIYW5kbGVUaWxlQ2hhbmdlXyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aWxlS2V5ID0gdGlsZS5nZXRLZXkoKTtcbiAgICAgIGlmICh0aWxlS2V5IGluIHRoaXMudGlsZXNMb2FkaW5nS2V5c18pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGlsZXNMb2FkaW5nS2V5c19bdGlsZUtleV07XG4gICAgICAgIC0tdGhpcy50aWxlc0xvYWRpbmdfO1xuICAgICAgfVxuICAgICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhUb3RhbExvYWRpbmcgTWF4aW11bSBudW1iZXIgdGlsZXMgdG8gbG9hZCBzaW11bHRhbmVvdXNseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heE5ld0xvYWRzIE1heGltdW0gbnVtYmVyIG9mIG5ldyB0aWxlcyB0byBsb2FkLlxuICAgKi9cbiAgbG9hZE1vcmVUaWxlcyhtYXhUb3RhbExvYWRpbmcsIG1heE5ld0xvYWRzKSB7XG4gICAgbGV0IG5ld0xvYWRzID0gMDtcbiAgICB3aGlsZSAoXG4gICAgICB0aGlzLnRpbGVzTG9hZGluZ18gPCBtYXhUb3RhbExvYWRpbmcgJiZcbiAgICAgIG5ld0xvYWRzIDwgbWF4TmV3TG9hZHMgJiZcbiAgICAgIHRoaXMuZ2V0Q291bnQoKSA+IDBcbiAgICApIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fVxuICAgICAgICovXG4gICAgICBjb25zdCB0aWxlID0gdGhpcy5kZXF1ZXVlKClbMF07XG4gICAgICBjb25zdCB0aWxlS2V5ID0gdGlsZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXRlID09PSBUaWxlU3RhdGUuSURMRSAmJiAhKHRpbGVLZXkgaW4gdGhpcy50aWxlc0xvYWRpbmdLZXlzXykpIHtcbiAgICAgICAgdGhpcy50aWxlc0xvYWRpbmdLZXlzX1t0aWxlS2V5XSA9IHRydWU7XG4gICAgICAgICsrdGhpcy50aWxlc0xvYWRpbmdfO1xuICAgICAgICArK25ld0xvYWRzO1xuICAgICAgICB0aWxlLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVF1ZXVlO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL01hcC5qcycpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGlsZVNvdXJjZUtleSBUaWxlIHNvdXJjZSBrZXkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSB0aWxlQ2VudGVyIFRpbGUgY2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbGVSZXNvbHV0aW9uIFRpbGUgcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwcmlvcml0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbGVQcmlvcml0eShcbiAgZnJhbWVTdGF0ZSxcbiAgdGlsZSxcbiAgdGlsZVNvdXJjZUtleSxcbiAgdGlsZUNlbnRlcixcbiAgdGlsZVJlc29sdXRpb24sXG4pIHtcbiAgLy8gRmlsdGVyIG91dCB0aWxlcyBhdCBoaWdoZXIgem9vbSBsZXZlbHMgdGhhbiB0aGUgY3VycmVudCB6b29tIGxldmVsLCBvciB0aGF0XG4gIC8vIGFyZSBvdXRzaWRlIHRoZSB2aXNpYmxlIGV4dGVudC5cbiAgaWYgKCFmcmFtZVN0YXRlIHx8ICEodGlsZVNvdXJjZUtleSBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzKSkge1xuICAgIHJldHVybiBEUk9QO1xuICB9XG4gIGlmICghZnJhbWVTdGF0ZS53YW50ZWRUaWxlc1t0aWxlU291cmNlS2V5XVt0aWxlLmdldEtleSgpXSkge1xuICAgIHJldHVybiBEUk9QO1xuICB9XG4gIC8vIFByaW9yaXRpemUgdGhlIGhpZ2hlc3Qgem9vbSBsZXZlbCB0aWxlcyBjbG9zZXN0IHRvIHRoZSBmb2N1cy5cbiAgLy8gVGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIGFyZSBwcmlvcml0aXplZCB1c2luZyBNYXRoLmxvZyh0aWxlUmVzb2x1dGlvbikuXG4gIC8vIFdpdGhpbiBhIHpvb20gbGV2ZWwsIHRpbGVzIGFyZSBwcmlvcml0aXplZCBieSB0aGUgZGlzdGFuY2UgaW4gcGl4ZWxzIGJldHdlZW5cbiAgLy8gdGhlIGNlbnRlciBvZiB0aGUgdGlsZSBhbmQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQuICBUaGUgZmFjdG9yIG9mIDY1NTM2XG4gIC8vIG1lYW5zIHRoYXQgdGhlIHByaW9yaXRpemF0aW9uIHNob3VsZCBiZWhhdmUgYXMgZGVzaXJlZCBmb3IgdGlsZXMgdXAgdG9cbiAgLy8gNjU1MzYgKiBNYXRoLmxvZygyKSA9IDQ1NDI2IHBpeGVscyBmcm9tIHRoZSBmb2N1cy5cbiAgY29uc3QgY2VudGVyID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUuY2VudGVyO1xuICBjb25zdCBkZWx0YVggPSB0aWxlQ2VudGVyWzBdIC0gY2VudGVyWzBdO1xuICBjb25zdCBkZWx0YVkgPSB0aWxlQ2VudGVyWzFdIC0gY2VudGVyWzFdO1xuICByZXR1cm4gKFxuICAgIDY1NTM2ICogTWF0aC5sb2codGlsZVJlc29sdXRpb24pICtcbiAgICBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSAvIHRpbGVSZXNvbHV0aW9uXG4gICk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvQ29udHJvbFxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IE1hcEV2ZW50VHlwZSBmcm9tICcuLi9NYXBFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtWT0lEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW2VsZW1lbnRdIFRoZSBlbGVtZW50IGlzIHRoZSBjb250cm9sJ3NcbiAqIGNvbnRhaW5lciBlbGVtZW50LiBUaGlzIG9ubHkgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIGlmIHlvdSdyZSBkZXZlbG9waW5nXG4gKiBhIGN1c3RvbSBjb250cm9sLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbcmVuZGVyXSBGdW5jdGlvbiBjYWxsZWQgd2hlblxuICogdGhlIGNvbnRyb2wgc2hvdWxkIGJlIHJlLXJlbmRlcmVkLiBUaGlzIGlzIGNhbGxlZCBpbiBhIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gKiBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50XG4gKiB0aGUgY29udHJvbCB0byBiZSByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29udHJvbCBpcyBhIHZpc2libGUgd2lkZ2V0IHdpdGggYSBET00gZWxlbWVudCBpbiBhIGZpeGVkIHBvc2l0aW9uIG9uIHRoZVxuICogc2NyZWVuLiBUaGV5IGNhbiBpbnZvbHZlIHVzZXIgaW5wdXQgKGJ1dHRvbnMpLCBvciBiZSBpbmZvcm1hdGlvbmFsIG9ubHk7XG4gKiB0aGUgcG9zaXRpb24gaXMgZGV0ZXJtaW5lZCB1c2luZyBDU1MuIEJ5IGRlZmF1bHQgdGhlc2UgYXJlIHBsYWNlZCBpbiB0aGVcbiAqIGNvbnRhaW5lciB3aXRoIENTUyBjbGFzcyBuYW1lIGBvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudGAsIGJ1dCBjYW4gdXNlXG4gKiBhbnkgb3V0c2lkZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBjb250cm9scy4gWW91IGNhbiB1c2UgaXQgZm9yIHNpbXBsZSBjdXN0b21cbiAqIGNvbnRyb2xzIGJ5IGNyZWF0aW5nIHRoZSBlbGVtZW50IHdpdGggbGlzdGVuZXJzLCBjcmVhdGluZyBhbiBpbnN0YW5jZTpcbiAqIGBgYGpzXG4gKiBjb25zdCBteUNvbnRyb2wgPSBuZXcgQ29udHJvbCh7ZWxlbWVudDogbXlFbGVtZW50fSk7XG4gKiBgYGBcbiAqIGFuZCB0aGVuIGFkZGluZyB0aGlzIHRvIHRoZSBtYXAuXG4gKlxuICogVGhlIG1haW4gYWR2YW50YWdlIG9mIGhhdmluZyB0aGlzIGFzIGEgY29udHJvbCByYXRoZXIgdGhhbiBhIHNpbXBsZSBzZXBhcmF0ZVxuICogRE9NIGVsZW1lbnQgaXMgdGhhdCBwcmV2ZW50aW5nIHByb3BhZ2F0aW9uIGlzIGhhbmRsZWQgZm9yIHlvdS4gQ29udHJvbHNcbiAqIHdpbGwgYWxzbyBiZSBvYmplY3RzIGluIGEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259LCBzbyB5b3UgY2FuIHVzZSB0aGVpciBtZXRob2RzLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBleHRlbmQgdGhpcyBiYXNlIGZvciB5b3VyIG93biBjb250cm9sIGNsYXNzLiBTZWVcbiAqIGV4YW1wbGVzL2N1c3RvbS1jb250cm9scyBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gZG8gdGhpcy5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENvbnRyb2wgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBDb250cm9sIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnQgJiYgIW9wdGlvbnMudGFyZ2V0ICYmICFlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQgPyBlbGVtZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyS2V5cyA9IFtdO1xuXG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICB0aGlzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgdGhpcy5zZXRUYXJnZXQob3B0aW9ucy50YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy5lbGVtZW50Py5yZW1vdmUoKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250cm9sLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY29udHJvbCBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBQYXNzIGBudWxsYCB0byBqdXN0IHJlbW92ZSB0aGUgY29udHJvbCBmcm9tIHRoZSBjdXJyZW50IG1hcC5cbiAgICogU3ViY2xhc3NlcyBtYXkgc2V0IHVwIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvXG4gICAqIHRoZSBtYXAgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBtYXAgTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgdGhpcy5lbGVtZW50Py5yZW1vdmUoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5saXN0ZW5lcktleXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLmxpc3RlbmVyS2V5c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJLZXlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICAgIGlmIChtYXApIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0XyA/PyBtYXAuZ2V0T3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudCgpO1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy5yZW5kZXIgIT09IFZPSUQpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcktleXMucHVzaChcbiAgICAgICAgICBsaXN0ZW4obWFwLCBNYXBFdmVudFR5cGUuUE9TVFJFTkRFUiwgdGhpcy5yZW5kZXIsIHRoaXMpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWFwLnJlbmRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9sLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVuZGVyKG1hcEV2ZW50KSB7fVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gc2V0IGEgdGFyZ2V0IGVsZW1lbnQgZm9yIHRoZSBjb250cm9sLiBJdCBoYXMgbm9cbiAgICogZWZmZWN0IGlmIGl0IGlzIGNhbGxlZCBhZnRlciB0aGUgY29udHJvbCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgbWFwIChpLmUuXG4gICAqIGFmdGVyIGBzZXRNYXBgIGlzIGNhbGxlZCBvbiB0aGUgY29udHJvbCkuIElmIG5vIGB0YXJnZXRgIGlzIHNldCBpbiB0aGVcbiAgICogb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbnRyb2wgY29uc3RydWN0b3IgYW5kIGlmIGBzZXRUYXJnZXRgIGlzIG5vdCBjYWxsZWRcbiAgICogdGhlbiB0aGUgY29udHJvbCBpcyBhZGRlZCB0byB0aGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGFyZ2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXRfID1cbiAgICAgIHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KSA6IHRhcmdldDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL0F0dHJpYnV0aW9uXG4gKi9cbmltcG9ydCBDb250cm9sIGZyb20gJy4vQ29udHJvbC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtDTEFTU19DT0xMQVBTRUQsIENMQVNTX0NPTlRST0wsIENMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge3JlbW92ZUNoaWxkcmVuLCByZXBsYWNlTm9kZX0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7dG9Qcm9taXNlfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1hdHRyaWJ1dGlvbiddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91XG4gKiB3YW50IHRoZSBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzXG4gKiB2aWV3cG9ydC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxhcHNpYmxlXSBTcGVjaWZ5IGlmIGF0dHJpYnV0aW9ucyBjYW5cbiAqIGJlIGNvbGxhcHNlZC4gSWYgbm90IHNwZWNpZmllZCwgc291cmNlcyBjb250cm9sIHRoaXMgYmVoYXZpb3Igd2l0aCB0aGVpclxuICogYGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlYCBzZXR0aW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29sbGFwc2VkPXRydWVdIFNwZWNpZnkgaWYgYXR0cmlidXRpb25zIHNob3VsZFxuICogYmUgY29sbGFwc2VkIGF0IHN0YXJ0dXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpcExhYmVsPSdBdHRyaWJ1dGlvbnMnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2xhYmVsPSdpJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZVxuICogY29sbGFwc2VkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXhwYW5kQ2xhc3NOYW1lPWNsYXNzTmFtZSArICctZXhwYW5kJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZVxuICogY29sbGFwc2VkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2NvbGxhcHNlTGFiZWw9J1x1MjAzQSddIFRleHQgbGFiZWwgdG8gdXNlXG4gKiBmb3IgdGhlIGV4cGFuZGVkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sbGFwc2VDbGFzc05hbWU9Y2xhc3NOYW1lICsgJy1jb2xsYXBzZSddIENTUyBjbGFzcyBuYW1lIGZvciB0aGVcbiAqIGV4cGFuZGVkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuXG4gKiB0aGUgY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICogQHByb3BlcnR5IHtzdHJpbmd8QXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IFthdHRyaWJ1dGlvbnNdIE9wdGlvbmFsIGF0dHJpYnV0aW9uKHMpIHRoYXQgd2lsbCBhbHdheXMgYmVcbiAqIGRpc3BsYXllZCByZWdhcmRsZXNzIG9mIHRoZSBsYXllcnMgcmVuZGVyZWRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRyb2wgdG8gc2hvdyBhbGwgdGhlIGF0dHJpYnV0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGxheWVyIHNvdXJjZXNcbiAqIGluIHRoZSBtYXAuIFRoaXMgY29udHJvbCBpcyBvbmUgb2YgdGhlIGRlZmF1bHQgY29udHJvbHMgaW5jbHVkZWQgaW4gbWFwcy5cbiAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBzaG93IGluIHRoZSBib3R0b20gcmlnaHQgcG9ydGlvbiBvZiB0aGUgbWFwLCBidXQgdGhpcyBjYW5cbiAqIGJlIGNoYW5nZWQgYnkgdXNpbmcgYSBjc3Mgc2VsZWN0b3IgZm9yIGAub2wtYXR0cmlidXRpb25gLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQXR0cmlidXRpb24gZXh0ZW5kcyBDb250cm9sIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIEF0dHJpYnV0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHJlbmRlcjogb3B0aW9ucy5yZW5kZXIsXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy51bEVsZW1lbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb2xsYXBzZWRfID1cbiAgICAgIG9wdGlvbnMuY29sbGFwc2VkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxhcHNlZCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlckNvbGxhcHNlZF8gPSB0aGlzLmNvbGxhcHNlZF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcnJpZGVDb2xsYXBzaWJsZV8gPSBvcHRpb25zLmNvbGxhcHNpYmxlICE9PSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2libGVfID1cbiAgICAgIG9wdGlvbnMuY29sbGFwc2libGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGFwc2libGUgOiB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlXykge1xuICAgICAgdGhpcy5jb2xsYXBzZWRfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0aW9uc18gPSBvcHRpb25zLmF0dHJpYnV0aW9ucztcblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbGFzc05hbWUgOiAnb2wtYXR0cmlidXRpb24nO1xuXG4gICAgY29uc3QgdGlwTGFiZWwgPVxuICAgICAgb3B0aW9ucy50aXBMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aXBMYWJlbCA6ICdBdHRyaWJ1dGlvbnMnO1xuXG4gICAgY29uc3QgZXhwYW5kQ2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuZXhwYW5kQ2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmV4cGFuZENsYXNzTmFtZVxuICAgICAgICA6IGNsYXNzTmFtZSArICctZXhwYW5kJztcblxuICAgIGNvbnN0IGNvbGxhcHNlTGFiZWwgPVxuICAgICAgb3B0aW9ucy5jb2xsYXBzZUxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxhcHNlTGFiZWwgOiAnXFx1MjAzQSc7XG5cbiAgICBjb25zdCBjb2xsYXBzZUNsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNvbGxhcHNlQ2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmNvbGxhcHNlQ2xhc3NOYW1lXG4gICAgICAgIDogY2xhc3NOYW1lICsgJy1jb2xsYXBzZSc7XG5cbiAgICBpZiAodHlwZW9mIGNvbGxhcHNlTGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfLnRleHRDb250ZW50ID0gY29sbGFwc2VMYWJlbDtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8uY2xhc3NOYW1lID0gY29sbGFwc2VDbGFzc05hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gPSBjb2xsYXBzZUxhYmVsO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsID0gb3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYWJlbCA6ICdpJztcblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMubGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5sYWJlbF8udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICAgIHRoaXMubGFiZWxfLmNsYXNzTmFtZSA9IGV4cGFuZENsYXNzTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbF8gPSBsYWJlbDtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVMYWJlbCA9XG4gICAgICB0aGlzLmNvbGxhcHNpYmxlXyAmJiAhdGhpcy5jb2xsYXBzZWRfID8gdGhpcy5jb2xsYXBzZUxhYmVsXyA6IHRoaXMubGFiZWxfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy50b2dnbGVCdXR0b25fID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgdGhpcy50b2dnbGVCdXR0b25fLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgU3RyaW5nKCF0aGlzLmNvbGxhcHNlZF8pKTtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8udGl0bGUgPSB0aXBMYWJlbDtcbiAgICB0aGlzLnRvZ2dsZUJ1dHRvbl8uYXBwZW5kQ2hpbGQoYWN0aXZlTGFiZWwpO1xuXG4gICAgdGhpcy50b2dnbGVCdXR0b25fLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICB0aGlzLmhhbmRsZUNsaWNrXy5iaW5kKHRoaXMpLFxuICAgICAgZmFsc2UsXG4gICAgKTtcblxuICAgIGNvbnN0IGNzc0NsYXNzZXMgPVxuICAgICAgY2xhc3NOYW1lICtcbiAgICAgICcgJyArXG4gICAgICBDTEFTU19VTlNFTEVDVEFCTEUgK1xuICAgICAgJyAnICtcbiAgICAgIENMQVNTX0NPTlRST0wgK1xuICAgICAgKHRoaXMuY29sbGFwc2VkXyAmJiB0aGlzLmNvbGxhcHNpYmxlXyA/ICcgJyArIENMQVNTX0NPTExBUFNFRCA6ICcnKSArXG4gICAgICAodGhpcy5jb2xsYXBzaWJsZV8gPyAnJyA6ICcgb2wtdW5jb2xsYXBzaWJsZScpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50b2dnbGVCdXR0b25fKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudWxFbGVtZW50Xyk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgY3VycmVudGx5IHJlbmRlcmVkIHJlc29sdXRpb25zLlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEF0dHJpYnV0aW9uc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0IGEgbGlzdCBvZiB2aXNpYmxlIGF0dHJpYnV0aW9ucyBhbmQgc2V0IHRoZSBjb2xsYXBzaWJsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXR0cmlidXRpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29sbGVjdFNvdXJjZUF0dHJpYnV0aW9uc18oZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TWFwKCkuZ2V0QWxsTGF5ZXJzKCk7XG4gICAgY29uc3QgdmlzaWJsZUF0dHJpYnV0aW9ucyA9IG5ldyBTZXQoXG4gICAgICBsYXllcnMuZmxhdE1hcCgobGF5ZXIpID0+IGxheWVyLmdldEF0dHJpYnV0aW9ucyhmcmFtZVN0YXRlKSksXG4gICAgKTtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGlvbnNfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5hdHRyaWJ1dGlvbnNfKVxuICAgICAgICA/IHRoaXMuYXR0cmlidXRpb25zXy5mb3JFYWNoKChpdGVtKSA9PiB2aXNpYmxlQXR0cmlidXRpb25zLmFkZChpdGVtKSlcbiAgICAgICAgOiB2aXNpYmxlQXR0cmlidXRpb25zLmFkZCh0aGlzLmF0dHJpYnV0aW9uc18pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5vdmVycmlkZUNvbGxhcHNpYmxlXykge1xuICAgICAgY29uc3QgY29sbGFwc2libGUgPSAhbGF5ZXJzLnNvbWUoXG4gICAgICAgIChsYXllcikgPT4gbGF5ZXIuZ2V0U291cmNlKCk/LmdldEF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlKCkgPT09IGZhbHNlLFxuICAgICAgKTtcbiAgICAgIHRoaXMuc2V0Q29sbGFwc2libGUoY29sbGFwc2libGUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2aXNpYmxlQXR0cmlidXRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZUVsZW1lbnRfKGZyYW1lU3RhdGUpIHtcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5jb2xsZWN0U291cmNlQXR0cmlidXRpb25zXyhmcmFtZVN0YXRlKS5tYXAoKGF0dHJpYnV0aW9uKSA9PlxuICAgICAgICB0b1Byb21pc2UoKCkgPT4gYXR0cmlidXRpb24pLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgY29uc3QgdmlzaWJsZSA9IGF0dHJpYnV0aW9ucy5sZW5ndGggPiAwO1xuICAgIGlmICh0aGlzLnJlbmRlcmVkVmlzaWJsZV8gIT0gdmlzaWJsZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB2aXNpYmxlO1xuICAgIH1cblxuICAgIGlmIChlcXVhbHMoYXR0cmlidXRpb25zLCB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW1vdmVDaGlsZHJlbih0aGlzLnVsRWxlbWVudF8pO1xuXG4gICAgLy8gYXBwZW5kIHRoZSBhdHRyaWJ1dGlvbnNcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhdHRyaWJ1dGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGF0dHJpYnV0aW9uc1tpXTtcbiAgICAgIHRoaXMudWxFbGVtZW50Xy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXyA9IGF0dHJpYnV0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNsaWNrXyhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gICAgdGhpcy51c2VyQ29sbGFwc2VkXyA9IHRoaXMuY29sbGFwc2VkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVG9nZ2xlXygpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19DT0xMQVBTRUQpO1xuICAgIGlmICh0aGlzLmNvbGxhcHNlZF8pIHtcbiAgICAgIHJlcGxhY2VOb2RlKHRoaXMuY29sbGFwc2VMYWJlbF8sIHRoaXMubGFiZWxfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZU5vZGUodGhpcy5sYWJlbF8sIHRoaXMuY29sbGFwc2VMYWJlbF8pO1xuICAgIH1cbiAgICB0aGlzLmNvbGxhcHNlZF8gPSAhdGhpcy5jb2xsYXBzZWRfO1xuICAgIHRoaXMudG9nZ2xlQnV0dG9uXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBTdHJpbmcoIXRoaXMuY29sbGFwc2VkXykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGF0dHJpYnV0aW9uIGlzIGNvbGxhcHNpYmxlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNpYmxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xsYXBzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsYXBzaWJsZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIGF0dHJpYnV0aW9uIHNob3VsZCBiZSBjb2xsYXBzaWJsZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzaWJsZSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2libGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvbGxhcHNpYmxlKGNvbGxhcHNpYmxlKSB7XG4gICAgaWYgKHRoaXMuY29sbGFwc2libGVfID09PSBjb2xsYXBzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbGxhcHNpYmxlXyA9IGNvbGxhcHNpYmxlO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdvbC11bmNvbGxhcHNpYmxlJyk7XG4gICAgaWYgKHRoaXMudXNlckNvbGxhcHNlZF8pIHtcbiAgICAgIHRoaXMuaGFuZGxlVG9nZ2xlXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsYXBzZSBvciBleHBhbmQgdGhlIGF0dHJpYnV0aW9uIGFjY29yZGluZyB0byB0aGUgcGFzc2VkIHBhcmFtZXRlci4gV2lsbFxuICAgKiBub3QgZG8gYW55dGhpbmcgaWYgdGhlIGF0dHJpYnV0aW9uIGlzbid0IGNvbGxhcHNpYmxlIG9yIGlmIHRoZSBjdXJyZW50XG4gICAqIGNvbGxhcHNlZCBzdGF0ZSBpcyBhbHJlYWR5IHRoZSBvbmUgcmVxdWVzdGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNlZCBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2VkLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb2xsYXBzZWQoY29sbGFwc2VkKSB7XG4gICAgdGhpcy51c2VyQ29sbGFwc2VkXyA9IGNvbGxhcHNlZDtcbiAgICBpZiAoIXRoaXMuY29sbGFwc2libGVfIHx8IHRoaXMuY29sbGFwc2VkXyA9PT0gY29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVG9nZ2xlXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgd2hlbiB0aGUgYXR0cmlidXRpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCBvciBgZmFsc2VgXG4gICAqIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29sbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhcHNlZF87XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGlvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXIobWFwRXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRfKG1hcEV2ZW50LmZyYW1lU3RhdGUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJpYnV0aW9uO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL1JvdGF0ZVxuICovXG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfSElEREVOLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLXJvdGF0ZSddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtsYWJlbD0nXHUyMUU3J10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSByb3RhdGUgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpcExhYmVsPSdSZXNldCByb3RhdGlvbiddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgcm90YXRlIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29tcGFzc0NsYXNzTmFtZT0nb2wtY29tcGFzcyddIENTUyBjbGFzcyBuYW1lIGZvciB0aGUgY29tcGFzcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b0hpZGU9dHJ1ZV0gSGlkZSB0aGUgY29udHJvbCB3aGVuIHJvdGF0aW9uIGlzIDAuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIHNob3VsZFxuICogYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6dm9pZH0gW3Jlc2V0Tm9ydGhdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIGlzIGNsaWNrZWQuXG4gKiBUaGlzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYHJlc2V0Tm9ydGhgLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBidXR0b24gY29udHJvbCB0byByZXNldCByb3RhdGlvbiB0byAwLlxuICogVG8gc3R5bGUgdGhpcyBjb250cm9sIHVzZSBjc3Mgc2VsZWN0b3IgYC5vbC1yb3RhdGVgLiBBIGAub2wtaGlkZGVuYCBjc3NcbiAqIHNlbGVjdG9yIGlzIGFkZGVkIHRvIHRoZSBidXR0b24gd2hlbiB0aGUgcm90YXRpb24gaXMgMC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFJvdGF0ZSBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gUm90YXRlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHJlbmRlcjogb3B0aW9ucy5yZW5kZXIsXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1yb3RhdGUnO1xuXG4gICAgY29uc3QgbGFiZWwgPSBvcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxhYmVsIDogJ1xcdTIxRTcnO1xuXG4gICAgY29uc3QgY29tcGFzc0NsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmNvbXBhc3NDbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuY29tcGFzc0NsYXNzTmFtZVxuICAgICAgICA6ICdvbC1jb21wYXNzJztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxfID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMubGFiZWxfLmNsYXNzTmFtZSA9IGNvbXBhc3NDbGFzc05hbWU7XG4gICAgICB0aGlzLmxhYmVsXy50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGxhYmVsO1xuICAgICAgdGhpcy5sYWJlbF8uY2xhc3NMaXN0LmFkZChjb21wYXNzQ2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aXBMYWJlbCA9IG9wdGlvbnMudGlwTGFiZWwgPyBvcHRpb25zLnRpcExhYmVsIDogJ1Jlc2V0IHJvdGF0aW9uJztcblxuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLXJlc2V0JztcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi50aXRsZSA9IHRpcExhYmVsO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsXyk7XG5cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcyksXG4gICAgICBmYWxzZSxcbiAgICApO1xuXG4gICAgY29uc3QgY3NzQ2xhc3NlcyA9XG4gICAgICBjbGFzc05hbWUgKyAnICcgKyBDTEFTU19VTlNFTEVDVEFCTEUgKyAnICcgKyBDTEFTU19DT05UUk9MO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYWxsUmVzZXROb3J0aF8gPSBvcHRpb25zLnJlc2V0Tm9ydGggPyBvcHRpb25zLnJlc2V0Tm9ydGggOiB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmF1dG9IaWRlXyA9IG9wdGlvbnMuYXV0b0hpZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0b0hpZGUgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmF1dG9IaWRlXykge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfSElEREVOKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGlja18oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLmNhbGxSZXNldE5vcnRoXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGxSZXNldE5vcnRoXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0Tm9ydGhfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldE5vcnRoXygpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICghdmlldykge1xuICAgICAgLy8gdGhlIG1hcCBkb2VzIG5vdCBoYXZlIGEgdmlldywgc28gd2UgY2FuJ3QgYWN0XG4gICAgICAvLyB1cG9uIGl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwICYmIHJvdGF0aW9uICUgKDIgKiBNYXRoLlBJKSAhPT0gMCkge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRSb3RhdGlvbigwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSByb3RhdGUgY29udHJvbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXIobWFwRXZlbnQpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gbWFwRXZlbnQuZnJhbWVTdGF0ZTtcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT0gdGhpcy5yb3RhdGlvbl8pIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ3JhZCknO1xuICAgICAgaWYgKHRoaXMuYXV0b0hpZGVfKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19ISURERU4pO1xuICAgICAgICBpZiAoIWNvbnRhaW5zICYmIHJvdGF0aW9uID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfSElEREVOKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWlucyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX0hJRERFTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxfLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSb3RhdGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvWm9vbVxuICovXG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLXpvb20nXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbUluQ2xhc3NOYW1lPWNsYXNzTmFtZSArICctaW4nXSBDU1MgY2xhc3MgbmFtZSBmb3IgdGhlIHpvb20taW4gYnV0dG9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tT3V0Q2xhc3NOYW1lPWNsYXNzTmFtZSArICctb3V0J10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZSB6b29tLW91dCBidXR0b24uXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW3pvb21JbkxhYmVsPScrJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSB6b29tLWluXG4gKiBidXR0b24uIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFt6b29tT3V0TGFiZWw9J1x1MjAxMyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgem9vbS1vdXQgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb21JblRpcExhYmVsPSdab29tIGluJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSBidXR0b24gdGlwLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tT3V0VGlwTGFiZWw9J1pvb20gb3V0J10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSBidXR0b24gdGlwLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBkZWx0YSBhcHBsaWVkIG9uIGVhY2ggY2xpY2suXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gU3BlY2lmeSBhIHRhcmdldCBpZiB5b3Ugd2FudCB0aGUgY29udHJvbCB0byBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgbWFwJ3Mgdmlld3BvcnQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNvbnRyb2wgd2l0aCAyIGJ1dHRvbnMsIG9uZSBmb3Igem9vbSBpbiBhbmQgb25lIGZvciB6b29tIG91dC5cbiAqIFRoaXMgY29udHJvbCBpcyBvbmUgb2YgdGhlIGRlZmF1bHQgY29udHJvbHMgb2YgYSBtYXAuIFRvIHN0eWxlIHRoaXMgY29udHJvbFxuICogdXNlIGNzcyBzZWxlY3RvcnMgYC5vbC16b29tLWluYCBhbmQgYC5vbC16b29tLW91dGAuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBab29tIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBab29tIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcih7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLXpvb20nO1xuXG4gICAgY29uc3QgZGVsdGEgPSBvcHRpb25zLmRlbHRhICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbHRhIDogMTtcblxuICAgIGNvbnN0IHpvb21JbkNsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLnpvb21JbkNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy56b29tSW5DbGFzc05hbWVcbiAgICAgICAgOiBjbGFzc05hbWUgKyAnLWluJztcblxuICAgIGNvbnN0IHpvb21PdXRDbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy56b29tT3V0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnpvb21PdXRDbGFzc05hbWVcbiAgICAgICAgOiBjbGFzc05hbWUgKyAnLW91dCc7XG5cbiAgICBjb25zdCB6b29tSW5MYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21JbkxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21JbkxhYmVsIDogJysnO1xuICAgIGNvbnN0IHpvb21PdXRMYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21PdXRMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tT3V0TGFiZWwgOiAnXFx1MjAxMyc7XG5cbiAgICBjb25zdCB6b29tSW5UaXBMYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21JblRpcExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21JblRpcExhYmVsIDogJ1pvb20gaW4nO1xuICAgIGNvbnN0IHpvb21PdXRUaXBMYWJlbCA9XG4gICAgICBvcHRpb25zLnpvb21PdXRUaXBMYWJlbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy56b29tT3V0VGlwTGFiZWxcbiAgICAgICAgOiAnWm9vbSBvdXQnO1xuXG4gICAgY29uc3QgaW5FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgaW5FbGVtZW50LmNsYXNzTmFtZSA9IHpvb21JbkNsYXNzTmFtZTtcbiAgICBpbkVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGluRWxlbWVudC50aXRsZSA9IHpvb21JblRpcExhYmVsO1xuICAgIGluRWxlbWVudC5hcHBlbmRDaGlsZChcbiAgICAgIHR5cGVvZiB6b29tSW5MYWJlbCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh6b29tSW5MYWJlbClcbiAgICAgICAgOiB6b29tSW5MYWJlbCxcbiAgICApO1xuXG4gICAgaW5FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICB0aGlzLmhhbmRsZUNsaWNrXy5iaW5kKHRoaXMsIGRlbHRhKSxcbiAgICAgIGZhbHNlLFxuICAgICk7XG5cbiAgICBjb25zdCBvdXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgb3V0RWxlbWVudC5jbGFzc05hbWUgPSB6b29tT3V0Q2xhc3NOYW1lO1xuICAgIG91dEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIG91dEVsZW1lbnQudGl0bGUgPSB6b29tT3V0VGlwTGFiZWw7XG4gICAgb3V0RWxlbWVudC5hcHBlbmRDaGlsZChcbiAgICAgIHR5cGVvZiB6b29tT3V0TGFiZWwgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoem9vbU91dExhYmVsKVxuICAgICAgICA6IHpvb21PdXRMYWJlbCxcbiAgICApO1xuXG4gICAgb3V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzLCAtZGVsdGEpLFxuICAgICAgZmFsc2UsXG4gICAgKTtcblxuICAgIGNvbnN0IGNzc0NsYXNzZXMgPVxuICAgICAgY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTDtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3NlcztcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGluRWxlbWVudCk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChvdXRFbGVtZW50KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFpvb20gZGVsdGEuXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2xpY2tfKGRlbHRhLCBldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy56b29tQnlEZWx0YV8oZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBab29tIGRlbHRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgem9vbUJ5RGVsdGFfKGRlbHRhKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIC8vIHRoZSBtYXAgZG9lcyBub3QgaGF2ZSBhIHZpZXcsIHNvIHdlIGNhbid0IGFjdFxuICAgICAgLy8gdXBvbiBpdFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHZpZXcuZ2V0Wm9vbSgpO1xuICAgIGlmIChjdXJyZW50Wm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXdab29tID0gdmlldy5nZXRDb25zdHJhaW5lZFpvb20oY3VycmVudFpvb20gKyBkZWx0YSk7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwKSB7XG4gICAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICB6b29tOiBuZXdab29tLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRab29tKG5ld1pvb20pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBab29tO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL2RlZmF1bHRzXG4gKi9cbmltcG9ydCBBdHRyaWJ1dGlvbiBmcm9tICcuL0F0dHJpYnV0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IFJvdGF0ZSBmcm9tICcuL1JvdGF0ZS5qcyc7XG5pbXBvcnQgWm9vbSBmcm9tICcuL1pvb20uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRzT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb249dHJ1ZV0gSW5jbHVkZVxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9BdHRyaWJ1dGlvbi5qc1wiKS5PcHRpb25zfSBbYXR0cmlidXRpb25PcHRpb25zXVxuICogT3B0aW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZT10cnVlXSBJbmNsdWRlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vUm90YXRlLmpzXCIpLk9wdGlvbnN9IFtyb3RhdGVPcHRpb25zXSBPcHRpb25zXG4gKiBmb3Ige0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX5Sb3RhdGV9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbem9vbV0gSW5jbHVkZSB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9ab29tLmpzXCIpLk9wdGlvbnN9IFt6b29tT3B0aW9uc10gT3B0aW9ucyBmb3JcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219LlxuICovXG5cbi8qKlxuICogU2V0IG9mIGNvbnRyb2xzIGluY2x1ZGVkIGluIG1hcHMgYnkgZGVmYXVsdC4gVW5sZXNzIGNvbmZpZ3VyZWQgb3RoZXJ3aXNlLFxuICogdGhpcyByZXR1cm5zIGEgY29sbGVjdGlvbiBjb250YWluaW5nIGFuIGluc3RhbmNlIG9mIGVhY2ggb2YgdGhlIGZvbGxvd2luZ1xuICogY29udHJvbHM6XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Sb3RhdGV+Um90YXRlfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvQXR0cmlidXRpb25+QXR0cmlidXRpb259XG4gKlxuICogQHBhcmFtIHtEZWZhdWx0c09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgZGVmYXVsdCBjb250cm9scy5cbiAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBBIGNvbGxlY3Rpb24gb2YgY29udHJvbHNcbiAqIHRvIGJlIHVzZWQgd2l0aCB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfSBjb25zdHJ1Y3RvcidzIGBjb250cm9sc2Agb3B0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdHMob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICBjb25zdCBjb250cm9scyA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgY29uc3Qgem9vbUNvbnRyb2wgPSBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuem9vbSA6IHRydWU7XG4gIGlmICh6b29tQ29udHJvbCkge1xuICAgIGNvbnRyb2xzLnB1c2gobmV3IFpvb20ob3B0aW9ucy56b29tT3B0aW9ucykpO1xuICB9XG5cbiAgY29uc3Qgcm90YXRlQ29udHJvbCA9IG9wdGlvbnMucm90YXRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0ZSA6IHRydWU7XG4gIGlmIChyb3RhdGVDb250cm9sKSB7XG4gICAgY29udHJvbHMucHVzaChuZXcgUm90YXRlKG9wdGlvbnMucm90YXRlT3B0aW9ucykpO1xuICB9XG5cbiAgY29uc3QgYXR0cmlidXRpb25Db250cm9sID1cbiAgICBvcHRpb25zLmF0dHJpYnV0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF0dHJpYnV0aW9uIDogdHJ1ZTtcbiAgaWYgKGF0dHJpYnV0aW9uQ29udHJvbCkge1xuICAgIGNvbnRyb2xzLnB1c2gobmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMuYXR0cmlidXRpb25PcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gY29udHJvbHM7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFDVElWRTogJ2FjdGl2ZScsXG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvblxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2Vhc2VPdXQsIGxpbmVhcn0gZnJvbSAnLi4vZWFzaW5nLmpzJztcblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBSZXR1cm4+fSBJbnRlcmFjdGlvbk9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIGNvbmZpZyBvcHRpb25zIGZvciBpbnRlcmFjdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbnRlcmFjdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IFtoYW5kbGVFdmVudF1cbiAqIE1ldGhvZCBjYWxsZWQgYnkgdGhlIG1hcCB0byBub3RpZnkgdGhlIGludGVyYWN0aW9uIHRoYXQgYSBicm93c2VyIGV2ZW50IHdhc1xuICogZGlzcGF0Y2hlZCB0byB0aGUgbWFwLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBwcm9wYWdhdGlvbiBvZlxuICogdGhlIGV2ZW50IHRvIG90aGVyIGludGVyYWN0aW9ucyBpbiB0aGUgbWFwJ3MgaW50ZXJhY3Rpb25zIGNoYWluIHdpbGwgYmVcbiAqIHByZXZlbnRlZCAodGhpcyBpbmNsdWRlcyBmdW5jdGlvbnMgd2l0aCBubyBleHBsaWNpdCByZXR1cm4pLiBUaGUgaW50ZXJhY3Rpb25zXG4gKiBhcmUgdHJhdmVyc2VkIGluIHJldmVyc2Ugb3JkZXIgb2YgdGhlIGludGVyYWN0aW9ucyBjb2xsZWN0aW9uIG9mIHRoZSBtYXAuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBVc2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBtYXAuIFNvbWUgYXJlIHNpbWlsYXIgdG8gY29udHJvbHMsXG4gKiBidXQgYXJlIG5vdCBhc3NvY2lhdGVkIHdpdGggYSBET00gZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbX5LZXlib2FyZFpvb219IGlzXG4gKiBmdW5jdGlvbmFsbHkgdGhlIHNhbWUgYXMge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0sIGJ1dCB0cmlnZ2VyZWRcbiAqIGJ5IGEga2V5Ym9hcmQgZXZlbnQgbm90IGEgYnV0dG9uIGVsZW1lbnQgZXZlbnQuXG4gKiBBbHRob3VnaCBpbnRlcmFjdGlvbnMgZG8gbm90IGhhdmUgYSBET00gZWxlbWVudCwgc29tZSBvZiB0aGVtIGRvIHJlbmRlclxuICogdmVjdG9ycyBhbmQgc28gYXJlIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgSW50ZXJhY3Rpb24gZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtJbnRlcmFjdGlvbk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0ludGVyYWN0aW9uT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtJbnRlcmFjdGlvbk9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZUV2ZW50ID0gb3B0aW9ucy5oYW5kbGVFdmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG51bGw7XG5cbiAgICB0aGlzLnNldEFjdGl2ZSh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgaW50ZXJhY3Rpb24gaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHRoaXMuZ2V0KEludGVyYWN0aW9uUHJvcGVydHkuQUNUSVZFKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW50ZXJhY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBBY3RpdmUuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICB0aGlzLnNldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSwgYWN0aXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRlbHRhIERlbHRhLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYW4odmlldywgZGVsdGEsIGR1cmF0aW9uKSB7XG4gIGNvbnN0IGN1cnJlbnRDZW50ZXIgPSB2aWV3LmdldENlbnRlckludGVybmFsKCk7XG4gIGlmIChjdXJyZW50Q2VudGVyKSB7XG4gICAgY29uc3QgY2VudGVyID0gW2N1cnJlbnRDZW50ZXJbMF0gKyBkZWx0YVswXSwgY3VycmVudENlbnRlclsxXSArIGRlbHRhWzFdXTtcbiAgICB2aWV3LmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGR1cmF0aW9uIDogMjUwLFxuICAgICAgZWFzaW5nOiBsaW5lYXIsXG4gICAgICBjZW50ZXI6IHZpZXcuZ2V0Q29uc3RyYWluZWRDZW50ZXIoY2VudGVyKSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEgZnJvbSBwcmV2aW91cyB6b29tIGxldmVsLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIEFuY2hvciBjb29yZGluYXRlIGluIHRoZSB1c2VyIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCBhbmNob3IsIGR1cmF0aW9uKSB7XG4gIGNvbnN0IGN1cnJlbnRab29tID0gdmlldy5nZXRab29tKCk7XG5cbiAgaWYgKGN1cnJlbnRab29tID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBuZXdab29tID0gdmlldy5nZXRDb25zdHJhaW5lZFpvb20oY3VycmVudFpvb20gKyBkZWx0YSk7XG4gIGNvbnN0IG5ld1Jlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb25Gb3Jab29tKG5ld1pvb20pO1xuXG4gIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gIH1cbiAgdmlldy5hbmltYXRlKHtcbiAgICByZXNvbHV0aW9uOiBuZXdSZXNvbHV0aW9uLFxuICAgIGFuY2hvcjogYW5jaG9yLFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiAyNTAsXG4gICAgZWFzaW5nOiBlYXNlT3V0LFxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJhY3Rpb247XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbVxuICovXG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsdGE9MV0gVGhlIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGRvdWJsZSBjbGljay5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIGJ5IGRvdWJsZS1jbGlja2luZyBvbiB0aGUgbWFwLlxuICogQGFwaVxuICovXG5jbGFzcyBEb3VibGVDbGlja1pvb20gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhXyA9IG9wdGlvbnMuZGVsdGEgPyBvcHRpb25zLmRlbHRhIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSAoaWYgaXQgd2FzIGFcbiAgICogZG91YmxlY2xpY2spIGFuZCBldmVudHVhbGx5IHpvb21zIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGxldCBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSykge1xuICAgICAgY29uc3QgYnJvd3NlckV2ZW50ID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAoXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICApO1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIGNvbnN0IGFuY2hvciA9IG1hcEJyb3dzZXJFdmVudC5jb29yZGluYXRlO1xuICAgICAgY29uc3QgZGVsdGEgPSBicm93c2VyRXZlbnQuc2hpZnRLZXkgPyAtdGhpcy5kZWx0YV8gOiB0aGlzLmRlbHRhXztcbiAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIGFuY2hvciwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgYnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEb3VibGVDbGlja1pvb207XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BvaW50ZXJcbiAqL1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZURvd25FdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZG93blwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIHRoZW4gYSBkcmFnXG4gKiBzZXF1ZW5jZSBpcyBzdGFydGVkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW2hhbmRsZURyYWdFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZHJhZ1wiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzXG4gKiBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZUV2ZW50XVxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIFRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCB0aGVcbiAqIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9uc1xuICogY2hhaW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbaGFuZGxlTW92ZUV2ZW50XVxuICogRnVuY3Rpb24gaGFuZGxpbmcgXCJtb3ZlXCIgZXZlbnRzLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBcIm1vdmVcIiBldmVudHMuXG4gKiBUaGlzIGZ1bmN0aW9ucyBpcyBhbHNvIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLCBzbyBkdXJpbmcgYSBkcmFnXG4gKiBzZXF1ZW5jZSBib3RoIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCBmdW5jdGlvbiBhbmQgdGhpcyBmdW5jdGlvbiBhcmUgY2FsbGVkLlxuICogSWYgYGhhbmRsZURvd25FdmVudGAgaXMgZGVmaW5lZCBhbmQgaXQgcmV0dXJucyB0cnVlIHRoaXMgZnVuY3Rpb24gd2lsbCBub3RcbiAqIGJlIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZVVwRXZlbnRdXG4gKiAgRnVuY3Rpb24gaGFuZGxpbmcgXCJ1cFwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGVuIHRoZVxuICogY3VycmVudCBkcmFnIHNlcXVlbmNlIGlzIHN0b3BwZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOmJvb2xlYW59IFtzdG9wRG93bl1cbiAqIFNob3VsZCB0aGUgZG93biBldmVudCBiZSBwcm9wYWdhdGVkIHRvIG90aGVyIGludGVyYWN0aW9ucywgb3Igc2hvdWxkIGJlXG4gKiBzdG9wcGVkP1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyB0aGF0IGNhbGxzIHVzZXItZGVmaW5lZCBmdW5jdGlvbnMgb24gYGRvd25gLCBgbW92ZWAgYW5kIGB1cGBcbiAqIGV2ZW50cy4gVGhpcyBjbGFzcyBhbHNvIG1hbmFnZXMgXCJkcmFnIHNlcXVlbmNlc1wiLlxuICpcbiAqIFdoZW4gdGhlIGBoYW5kbGVEb3duRXZlbnRgIHVzZXIgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgYSBkcmFnIHNlcXVlbmNlIGlzXG4gKiBzdGFydGVkLiBEdXJpbmcgYSBkcmFnIHNlcXVlbmNlIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCB1c2VyIGZ1bmN0aW9uIGlzXG4gKiBjYWxsZWQgb24gYG1vdmVgIGV2ZW50cy4gVGhlIGRyYWcgc2VxdWVuY2UgZW5kcyB3aGVuIHRoZSBgaGFuZGxlVXBFdmVudGBcbiAqIHVzZXIgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBvaW50ZXJJbnRlcmFjdGlvbiBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIChvcHRpb25zKSxcbiAgICApO1xuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRG93bkV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZURvd25FdmVudCA9IG9wdGlvbnMuaGFuZGxlRG93bkV2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZURyYWdFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVEcmFnRXZlbnQgPSBvcHRpb25zLmhhbmRsZURyYWdFdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVNb3ZlRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50ID0gb3B0aW9ucy5oYW5kbGVNb3ZlRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlVXBFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVVcEV2ZW50ID0gb3B0aW9ucy5oYW5kbGVVcEV2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICB0aGlzLnN0b3BEb3duID0gb3B0aW9ucy5zdG9wRG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9pbnRlckV2ZW50Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQb2ludGVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBvaW50ZXJzIGludm9sdmVkIGluIHRoZSBpbnRlcmFjdGlvbixcbiAgICogZS5nLiBgMmAgd2hlbiB0d28gZmluZ2VycyBhcmUgdXNlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBvaW50ZXJzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQb2ludGVyQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge31cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IGNhbGwgaW50b1xuICAgKiBvdGhlciBmdW5jdGlvbnMsIGlmIGV2ZW50IHNlcXVlbmNlcyBsaWtlIGUuZy4gJ2RyYWcnIG9yICdkb3duLXVwJyBldGMuIGFyZVxuICAgKiBkZXRlY3RlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVUcmFja2VkUG9pbnRlcnNfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgaWYgKHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgICAgLy8gcHJldmVudCBwYWdlIHNjcm9sbGluZyBkdXJpbmcgZHJhZ2dpbmdcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVApIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZFVwID0gdGhpcy5oYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSA9XG4gICAgICAgICAgaGFuZGxlZFVwICYmIHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04pIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZCA9IHRoaXMuaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSA9IGhhbmRsZWQ7XG4gICAgICAgIHN0b3BFdmVudCA9IHRoaXMuc3RvcERvd24oaGFuZGxlZCk7XG4gICAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgbW92ZSBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlTW92ZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge31cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgXCJkb3duXCIgZXZlbnRzIHNob3VsZCBiZSBwcm9wYWdhdGVkXG4gICAqIHRvIG90aGVyIGludGVyYWN0aW9ucyBvciBzaG91bGQgYmUgc3RvcHBlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBoYW5kbGVkIFdhcyB0aGUgZXZlbnQgaGFuZGxlZCBieSB0aGUgaW50ZXJhY3Rpb24/XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFNob3VsZCB0aGUgYGRvd25gIGV2ZW50IGJlIHN0b3BwZWQ/XG4gICAqL1xuICBzdG9wRG93bihoYW5kbGVkKSB7XG4gICAgcmV0dXJuIGhhbmRsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlVHJhY2tlZFBvaW50ZXJzXyhtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAobWFwQnJvd3NlckV2ZW50LmFjdGl2ZVBvaW50ZXJzKSB7XG4gICAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gbWFwQnJvd3NlckV2ZW50LmFjdGl2ZVBvaW50ZXJzO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnRlckV2ZW50Pn0gcG9pbnRlckV2ZW50cyBMaXN0IG9mIGV2ZW50cy5cbiAqIEByZXR1cm4ge3tjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn19IENlbnRyb2lkIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VudHJvaWQocG9pbnRlckV2ZW50cykge1xuICBjb25zdCBsZW5ndGggPSBwb2ludGVyRXZlbnRzLmxlbmd0aDtcbiAgbGV0IGNsaWVudFggPSAwO1xuICBsZXQgY2xpZW50WSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjbGllbnRYICs9IHBvaW50ZXJFdmVudHNbaV0uY2xpZW50WDtcbiAgICBjbGllbnRZICs9IHBvaW50ZXJFdmVudHNbaV0uY2xpZW50WTtcbiAgfVxuICByZXR1cm4ge2NsaWVudFg6IGNsaWVudFggLyBsZW5ndGgsIGNsaWVudFk6IGNsaWVudFkgLyBsZW5ndGh9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBQb2ludGVySW50ZXJhY3Rpb247XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9jb25kaXRpb25cbiAqL1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0ZBTFNFLCBUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtNQUMsIFdFQktJVH0gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGB7Ym9vbGVhbn1gLiBJZiB0aGUgY29uZGl0aW9uIGlzIG1ldCwgdHJ1ZSBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKHRoaXM6ID8sIGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gQ29uZGl0aW9uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIHdoZW4gYWxsIHByb3ZpZGVkIGNvbmRpdGlvbnMgcGFzcy5cbiAqIEBwYXJhbSB7Li4uQ29uZGl0aW9ufSB2YXJfYXJncyBDb25kaXRpb25zIHRvIGNoZWNrLlxuICogQHJldHVybiB7Q29uZGl0aW9ufSBDb25kaXRpb24gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGwodmFyX2FyZ3MpIHtcbiAgY29uc3QgY29uZGl0aW9ucyA9IGFyZ3VtZW50cztcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBBbGwgY29uZGl0aW9ucyBwYXNzZWQuXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbGV0IHBhc3MgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcGFzcyA9IHBhc3MgJiYgY29uZGl0aW9uc1tpXShldmVudCk7XG4gICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXNzO1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgYWx0LWtleSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZSAoZS5nLiB3aGVuXG4gKiBhZGRpdGlvbmFsbHkgdGhlIHNoaWZ0LWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIGFsdCBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGFsdEtleU9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgcmV0dXJuIChcbiAgICBvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIGFsdC1rZXkgYW5kIHNoaWZ0LWtleSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICogKGUuZy4gd2hlbiBhZGRpdGlvbmFsbHkgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIGFsdCBhbmQgc2hpZnQga2V5cyBhcmUgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGFsdFNoaWZ0S2V5c09ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgcmV0dXJuIChcbiAgICBvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5XG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIG1hcCBoYXMgdGhlIGZvY3VzLiBUaGlzIGNvbmRpdGlvbiByZXF1aXJlcyBhIG1hcCB0YXJnZXRcbiAqIGVsZW1lbnQgd2l0aCBhIGB0YWJpbmRleGAgYXR0cmlidXRlLCBlLmcuIGA8ZGl2IGlkPVwibWFwXCIgdGFiaW5kZXg9XCIxXCI+YC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBtYXAgaGFzIHRoZSBmb2N1cy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBldmVudC5tYXAuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuICBjb25zdCByb290Tm9kZSA9IHRhcmdldEVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGV2ZW50Lm1hcC5nZXRPd25lckRvY3VtZW50KCkuYWN0aXZlRWxlbWVudDtcblxuICByZXR1cm4gcm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290XG4gICAgPyByb290Tm9kZS5ob3N0LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpXG4gICAgOiB0YXJnZXRFbGVtZW50LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBtYXAgaGFzIHRoZSBmb2N1cyBvciBubyAndGFiaW5kZXgnIGF0dHJpYnV0ZSBzZXQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbWFwIGNvbnRhaW5lciBoYXMgdGhlIGZvY3VzIG9yIG5vICd0YWJpbmRleCcgYXR0cmlidXRlLlxuICovXG5leHBvcnQgY29uc3QgZm9jdXNXaXRoVGFiaW5kZXggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGV2ZW50Lm1hcC5nZXRUYXJnZXRFbGVtZW50KCk7XG4gIGNvbnN0IHJvb3ROb2RlID0gdGFyZ2V0RWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICBjb25zdCB0YWJJbmRleENhbmRpZGF0ZSA9XG4gICAgcm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gcm9vdE5vZGUuaG9zdCA6IHRhcmdldEVsZW1lbnQ7XG5cbiAgcmV0dXJuIHRhYkluZGV4Q2FuZGlkYXRlLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSA/IGZvY3VzKGV2ZW50KSA6IHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbHdheXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgYWx3YXlzID0gVFJVRTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIGBjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBjbGljayA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuQ0xJQ0s7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhcyBhbiBcImFjdGlvblwiLXByb2R1Y2luZyBtb3VzZSBidXR0b24uXG4gKlxuICogQnkgZGVmaW5pdGlvbiwgdGhpcyBpbmNsdWRlcyBsZWZ0LWNsaWNrIG9uIHdpbmRvd3MvbGludXgsIGFuZCBsZWZ0LWNsaWNrXG4gKiB3aXRob3V0IHRoZSBjdHJsIGtleSBvbiBNYWNzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZXN1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCBtb3VzZUFjdGlvbkJ1dHRvbiA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiBvcmlnaW5hbEV2ZW50LmJ1dHRvbiA9PSAwICYmICEoV0VCS0lUICYmIE1BQyAmJiBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYWx3YXlzIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEZhbHNlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgbmV2ZXIgPSBGQUxTRTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBicm93c2VyIGV2ZW50IGlzIGEgYHBvaW50ZXJtb3ZlYCBldmVudCwgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJyb3dzZXIgZXZlbnQgaXMgYSBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgcG9pbnRlck1vdmUgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSAncG9pbnRlcm1vdmUnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgc2luZ2xlY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgc2luZ2xlY2xpY2tgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgc2luZ2xlQ2xpY2sgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgZGJsY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgZGJsY2xpY2tgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgZG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG5vIG1vZGlmaWVyIGtleSAoYWx0LSwgc2hpZnQtIG9yIHBsYXRmb3JtLW1vZGlmaWVyLWtleSkgaXNcbiAqIHByZXNzZWQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvbmx5IGlmIHRoZXJlIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBub01vZGlmaWVyS2V5cyA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICApO1xuICByZXR1cm4gKFxuICAgICFvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSAodGhlIG1ldGEta2V5IG9uIE1hYyxcbiAqIGN0cmwta2V5IG90aGVyd2lzZSkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlbiBhZGRpdGlvbmFsbHlcbiAqIHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXRmb3JtTW9kaWZpZXJLZXlPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgKE1BQyA/IG9yaWdpbmFsRXZlbnQubWV0YUtleSA6IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgKHRoZSBtZXRhLWtleSBvbiBNYWMsXG4gKiBjdHJsLWtleSBvdGhlcndpc2UpIGlzIHByZXNzZWQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxhdGZvcm0gbW9kaWZpZXIga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBwbGF0Zm9ybU1vZGlmaWVyS2V5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiBNQUMgPyBvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgOiBvcmlnaW5hbEV2ZW50LmN0cmxLZXk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW5cbiAqIGFkZGl0aW9uYWxseSB0aGUgYWx0LWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgc2hpZnRLZXlPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgIG9yaWdpbmFsRXZlbnQuc2hpZnRLZXlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGVkaXRhYmxlLCBpLmUuIG5vdCBhbiBgaW5wdXRgLFxuICogYHNlbGVjdGAsIG9yIGB0ZXh0YXJlYWAgZWxlbWVudCBhbmQgbm8gYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIGlzXG4gKiBzZXQgb3IgaW5oZXJpdGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9ubHkgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBlZGl0YWJsZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHRhcmdldE5vdEVkaXRhYmxlID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIGNvbnN0IHRhZ05hbWUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChvcmlnaW5hbEV2ZW50LnRhcmdldCkudGFnTmFtZTtcbiAgcmV0dXJuIChcbiAgICB0YWdOYW1lICE9PSAnSU5QVVQnICYmXG4gICAgdGFnTmFtZSAhPT0gJ1NFTEVDVCcgJiZcbiAgICB0YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmXG4gICAgLy8gYGlzQ29udGVudEVkaXRhYmxlYCBpcyBvbmx5IGF2YWlsYWJsZSBvbiBgSFRNTEVsZW1lbnRgLCBidXQgaXQgbWF5IGFsc28gYmUgYVxuICAgIC8vIGRpZmZlcmVudCB0eXBlIGxpa2UgYFNWR0VsZW1lbnRgLlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAhb3JpZ2luYWxFdmVudC50YXJnZXQuaXNDb250ZW50RWRpdGFibGVcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgbW91c2UgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIG1vdXNlIGRldmljZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IG1vdXNlT25seSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3QgcG9pbnRlckV2ZW50ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnRcIikuZGVmYXVsdH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudFxuICApLm9yaWdpbmFsRXZlbnQ7XG4gIGFzc2VydChcbiAgICBwb2ludGVyRXZlbnQgIT09IHVuZGVmaW5lZCxcbiAgICAnbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50JyxcbiAgKTtcbiAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN3aWRsLVBvaW50ZXJFdmVudC1wb2ludGVyVHlwZVxuICByZXR1cm4gcG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09ICdtb3VzZSc7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHRvdWNoYWJsZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgdG91Y2hhYmxlIGRldmljZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHRvdWNoT25seSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3QgcG9pbnRlckV2dCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50XCIpLmRlZmF1bHR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnRcbiAgKS5vcmlnaW5hbEV2ZW50O1xuICBhc3NlcnQoXG4gICAgcG9pbnRlckV2dCAhPT0gdW5kZWZpbmVkLFxuICAgICdtYXBCcm93c2VyRXZlbnQgbXVzdCBvcmlnaW5hdGUgZnJvbSBhIHBvaW50ZXIgZXZlbnQnLFxuICApO1xuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI3dpZGwtUG9pbnRlckV2ZW50LXBvaW50ZXJUeXBlXG4gIHJldHVybiBwb2ludGVyRXZ0LnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBkaWdpdGFsIHBlbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBkaWdpdGFsIHBlbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHBlbk9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50XG4gICkub3JpZ2luYWxFdmVudDtcbiAgYXNzZXJ0KFxuICAgIHBvaW50ZXJFdnQgIT09IHVuZGVmaW5lZCxcbiAgICAnbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50JyxcbiAgKTtcbiAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN3aWRsLVBvaW50ZXJFdmVudC1wb2ludGVyVHlwZVxuICByZXR1cm4gcG9pbnRlckV2dC5wb2ludGVyVHlwZSA9PT0gJ3Blbic7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHByaW1hcnkgcG9pbnRlciBpblxuICogY29udGFjdCB3aXRoIHRoZSBzdXJmYWNlIG9yIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHByaW1hcnkgcG9pbnRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW1hcnlBY3Rpb24gPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdmVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50XCIpLmRlZmF1bHR9ICovIChcbiAgICBtYXBCcm93c2VyRXZlbnRcbiAgKS5vcmlnaW5hbEV2ZW50O1xuICBhc3NlcnQoXG4gICAgcG9pbnRlckV2ZW50ICE9PSB1bmRlZmluZWQsXG4gICAgJ21hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudCcsXG4gICk7XG4gIHJldHVybiBwb2ludGVyRXZlbnQuaXNQcmltYXJ5ICYmIHBvaW50ZXJFdmVudC5idXR0b24gPT09IDA7XG59O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnUGFuXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtcbiAgY2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnMsXG59IGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYWxsLFxuICBmb2N1c1dpdGhUYWJpbmRleCxcbiAgbm9Nb2RpZmllcktleXMsXG4gIHByaW1hcnlBY3Rpb24sXG59IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtcbiAgcm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGUsXG4gIHNjYWxlIGFzIHNjYWxlQ29vcmRpbmF0ZSxcbn0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLm5vTW9kaWZpZXJLZXlzfSBhbmQge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLnByaW1hcnlBY3Rpb259LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25Gb2N1c09ubHk9ZmFsc2VdIFdoZW4gdGhlIG1hcCdzIHRhcmdldCBoYXMgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBzZXQsXG4gKiB0aGUgaW50ZXJhY3Rpb24gd2lsbCBvbmx5IGhhbmRsZSBldmVudHMgd2hlbiB0aGUgbWFwIGhhcyB0aGUgZm9jdXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0tpbmV0aWMuanNcIikuZGVmYXVsdH0gW2tpbmV0aWNdIEtpbmV0aWMgaW5lcnRpYSB0byBhcHBseSB0byB0aGUgcGFuLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHBhbiB0aGUgbWFwIGJ5IGRyYWdnaW5nIHRoZSBtYXAuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIERyYWdQYW4gZXh0ZW5kcyBQb2ludGVySW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBzdG9wRG93bjogRkFMU0UsXG4gICAgfSk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0tpbmV0aWMuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5raW5ldGljXyA9IG9wdGlvbnMua2luZXRpYztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYXN0UG9pbnRlcnNDb3VudF87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGFubmluZ18gPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbmRpdGlvbiA9IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICA/IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICA6IGFsbChub01vZGlmaWVyS2V5cywgcHJpbWFyeUFjdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLm9uRm9jdXNPbmx5XG4gICAgICA/IGFsbChmb2N1c1dpdGhUYWJpbmRleCwgY29uZGl0aW9uKVxuICAgICAgOiBjb25kaXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubm9LaW5ldGljXyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgaWYgKCF0aGlzLnBhbm5pbmdfKSB7XG4gICAgICB0aGlzLnBhbm5pbmdfID0gdHJ1ZTtcbiAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRQb2ludGVycyA9IHRoaXMudGFyZ2V0UG9pbnRlcnM7XG4gICAgY29uc3QgY2VudHJvaWQgPSBtYXAuZ2V0RXZlbnRQaXhlbChjZW50cm9pZEZyb21Qb2ludGVycyh0YXJnZXRQb2ludGVycykpO1xuICAgIGlmICh0YXJnZXRQb2ludGVycy5sZW5ndGggPT0gdGhpcy5sYXN0UG9pbnRlcnNDb3VudF8pIHtcbiAgICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAgIHRoaXMua2luZXRpY18udXBkYXRlKGNlbnRyb2lkWzBdLCBjZW50cm9pZFsxXSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYXN0Q2VudHJvaWQpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgdGhpcy5sYXN0Q2VudHJvaWRbMF0gLSBjZW50cm9pZFswXSxcbiAgICAgICAgICBjZW50cm9pZFsxXSAtIHRoaXMubGFzdENlbnRyb2lkWzFdLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgc2NhbGVDb29yZGluYXRlKGRlbHRhLCB2aWV3LmdldFJlc29sdXRpb24oKSk7XG4gICAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIHZpZXcuYWRqdXN0Q2VudGVySW50ZXJuYWwoZGVsdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgLy8gcmVzZXQgc28gd2UgZG9uJ3Qgb3ZlcmVzdGltYXRlIHRoZSBraW5ldGljIGVuZXJneSBhZnRlclxuICAgICAgLy8gYWZ0ZXIgb25lIGZpbmdlciBkb3duLCB0aW55IGRyYWcsIHNlY29uZCBmaW5nZXIgZG93blxuICAgICAgdGhpcy5raW5ldGljXy5iZWdpbigpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IGNlbnRyb2lkO1xuICAgIHRoaXMubGFzdFBvaW50ZXJzQ291bnRfID0gdGFyZ2V0UG9pbnRlcnMubGVuZ3RoO1xuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLm5vS2luZXRpY18gJiYgdGhpcy5raW5ldGljXyAmJiB0aGlzLmtpbmV0aWNfLmVuZCgpKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5raW5ldGljXy5nZXREaXN0YW5jZSgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMua2luZXRpY18uZ2V0QW5nbGUoKTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdmlldy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICAgICAgICBjb25zdCBjZW50ZXJweCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlSW50ZXJuYWwoY2VudGVyKTtcbiAgICAgICAgY29uc3QgZGVzdCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwoW1xuICAgICAgICAgIGNlbnRlcnB4WzBdIC0gZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgY2VudGVycHhbMV0gLSBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHZpZXcuYW5pbWF0ZUludGVybmFsKHtcbiAgICAgICAgICBjZW50ZXI6IHZpZXcuZ2V0Q29uc3RyYWluZWRDZW50ZXIoZGVzdCksXG4gICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFubmluZ18pIHtcbiAgICAgICAgdGhpcy5wYW5uaW5nXyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmVuZEludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAvLyByZXNldCBzbyB3ZSBkb24ndCBvdmVyZXN0aW1hdGUgdGhlIGtpbmV0aWMgZW5lcmd5IGFmdGVyXG4gICAgICAvLyBhZnRlciBvbmUgZmluZ2VyIHVwLCB0aW55IGRyYWcsIHNlY29uZCBmaW5nZXIgdXBcbiAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q2VudHJvaWQgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICAgIC8vIHN0b3AgYW55IGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vIGtpbmV0aWMgYXMgc29vbiBhcyBtb3JlIHRoYW4gb25lIHBvaW50ZXIgb24gdGhlIHNjcmVlbiBpc1xuICAgICAgLy8gZGV0ZWN0ZWQuIFRoaXMgaXMgdG8gcHJldmVudCBuYXN0eSBwYW5zIGFmdGVyIHBpbmNoLlxuICAgICAgdGhpcy5ub0tpbmV0aWNfID0gdGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnUGFuO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge1xuICBhbHRTaGlmdEtleXNPbmx5LFxuICBtb3VzZUFjdGlvbkJ1dHRvbixcbiAgbW91c2VPbmx5LFxufSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7ZGlzYWJsZX0gZnJvbSAnLi4vcm90YXRpb25jb25zdHJhaW50LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYVxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLmFsdFNoaWZ0S2V5c09ubHl9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcm90YXRlIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAsXG4gKiBub3JtYWxseSBjb21iaW5lZCB3aXRoIGEge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiB0aGUgYWx0IGFuZCBzaGlmdCBrZXlzIGFyZSBoZWxkIGRvd24uXG4gKlxuICogVGhpcyBpbnRlcmFjdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbW91c2UgZGV2aWNlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ1JvdGF0ZSBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgc3VwZXIoe1xuICAgICAgc3RvcERvd246IEZBTFNFLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsdFNoaWZ0S2V5c09ubHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0Q29uc3RyYWludHMoKS5yb3RhdGlvbiA9PT0gZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gbWFwLmdldFNpemUoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgY29uc3QgdGhldGEgPSBNYXRoLmF0YW4yKHNpemVbMV0gLyAyIC0gb2Zmc2V0WzFdLCBvZmZzZXRbMF0gLSBzaXplWzBdIC8gMik7XG4gICAgaWYgKHRoaXMubGFzdEFuZ2xlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHRoZXRhIC0gdGhpcy5sYXN0QW5nbGVfO1xuICAgICAgdmlldy5hZGp1c3RSb3RhdGlvbkludGVybmFsKC1kZWx0YSk7XG4gICAgfVxuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHRoZXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB2aWV3LmVuZEludGVyYWN0aW9uKHRoaXMuZHVyYXRpb25fKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG1vdXNlQWN0aW9uQnV0dG9uKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpXG4gICAgKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgbWFwLmdldFZpZXcoKS5iZWdpbkludGVyYWN0aW9uKCk7XG4gICAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdSb3RhdGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9Cb3hcbiAqL1xuXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5cbmNsYXNzIFJlbmRlckJveCBleHRlbmRzIERpc3Bvc2FibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBDU1MgY2xhc3MgbmFtZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgIHRoaXMuZWxlbWVudF8uY2xhc3NOYW1lID0gJ29sLWJveCAnICsgY2xhc3NOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmVuZFBpeGVsXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMuc2V0TWFwKG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW5kZXJfKCkge1xuICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB0aGlzLnN0YXJ0UGl4ZWxfO1xuICAgIGNvbnN0IGVuZFBpeGVsID0gdGhpcy5lbmRQaXhlbF87XG4gICAgY29uc3QgcHggPSAncHgnO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5lbGVtZW50Xy5zdHlsZTtcbiAgICBzdHlsZS5sZWZ0ID0gTWF0aC5taW4oc3RhcnRQaXhlbFswXSwgZW5kUGl4ZWxbMF0pICsgcHg7XG4gICAgc3R5bGUudG9wID0gTWF0aC5taW4oc3RhcnRQaXhlbFsxXSwgZW5kUGl4ZWxbMV0pICsgcHg7XG4gICAgc3R5bGUud2lkdGggPSBNYXRoLmFicyhlbmRQaXhlbFswXSAtIHN0YXJ0UGl4ZWxbMF0pICsgcHg7XG4gICAgc3R5bGUuaGVpZ2h0ID0gTWF0aC5hYnMoZW5kUGl4ZWxbMV0gLSBzdGFydFBpeGVsWzFdKSArIHB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICB0aGlzLm1hcF8uZ2V0T3ZlcmxheUNvbnRhaW5lcigpLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudF8pO1xuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsZW1lbnRfLnN0eWxlO1xuICAgICAgc3R5bGUubGVmdCA9ICdpbmhlcml0JztcbiAgICAgIHN0eWxlLnRvcCA9ICdpbmhlcml0JztcbiAgICAgIHN0eWxlLndpZHRoID0gJ2luaGVyaXQnO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gJ2luaGVyaXQnO1xuICAgIH1cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgdGhpcy5tYXBfLmdldE92ZXJsYXlDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnRfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gc3RhcnRQaXhlbCBTdGFydCBwaXhlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gZW5kUGl4ZWwgRW5kIHBpeGVsLlxuICAgKi9cbiAgc2V0UGl4ZWxzKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKSB7XG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5lbmRQaXhlbF8gPSBlbmRQaXhlbDtcbiAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlR2VvbWV0cnkoKTtcbiAgICB0aGlzLnJlbmRlcl8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG9yIHVwZGF0ZXMgdGhlIGNhY2hlZCBnZW9tZXRyeS5cbiAgICovXG4gIGNyZWF0ZU9yVXBkYXRlR2VvbWV0cnkoKSB7XG4gICAgaWYgKCF0aGlzLm1hcF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFBpeGVsID0gdGhpcy5zdGFydFBpeGVsXztcbiAgICBjb25zdCBlbmRQaXhlbCA9IHRoaXMuZW5kUGl4ZWxfO1xuICAgIGNvbnN0IHBpeGVscyA9IFtcbiAgICAgIHN0YXJ0UGl4ZWwsXG4gICAgICBbc3RhcnRQaXhlbFswXSwgZW5kUGl4ZWxbMV1dLFxuICAgICAgZW5kUGl4ZWwsXG4gICAgICBbZW5kUGl4ZWxbMF0sIHN0YXJ0UGl4ZWxbMV1dLFxuICAgIF07XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBwaXhlbHMubWFwKFxuICAgICAgdGhpcy5tYXBfLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbCxcbiAgICAgIHRoaXMubWFwXyxcbiAgICApO1xuICAgIC8vIGNsb3NlIHRoZSBwb2x5Z29uXG4gICAgY29vcmRpbmF0ZXNbNF0gPSBjb29yZGluYXRlc1swXS5zbGljZSgpO1xuICAgIGlmICghdGhpcy5nZW9tZXRyeV8pIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlfID0gbmV3IFBvbHlnb24oW2Nvb3JkaW5hdGVzXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlfLnNldENvb3JkaW5hdGVzKFtjb29yZGluYXRlc10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqL1xuICBnZXRHZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeV87XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQm94O1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnQm94XG4gKi9cbi8vIEZJWE1FIGRyYXcgZHJhZyBib3hcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IFJlbmRlckJveCBmcm9tICcuLi9yZW5kZXIvQm94LmpzJztcbmltcG9ydCB7bW91c2VBY3Rpb25CdXR0b259IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHR3b1xuICoge0BsaW5rIG1vZHVsZTpvbC9waXhlbH5QaXhlbH1zIGFuZCByZXR1cm5zIGEgYHtib29sZWFufWAuIElmIHRoZSBjb25kaXRpb24gaXMgbWV0LFxuICogdHJ1ZSBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczogPywgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsLCBpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbCk6Ym9vbGVhbn0gRW5kQ29uZGl0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtZHJhZ2JveCddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZSBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGEgYm9vbGVhblxuICogdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgb2wvZXZlbnRzL2NvbmRpdGlvbn5tb3VzZUFjdGlvbkJ1dHRvbn0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbkFyZWE9NjRdIFRoZSBtaW5pbXVtIGFyZWEgb2YgdGhlIGJveCBpbiBwaXhlbCwgdGhpcyB2YWx1ZSBpcyB1c2VkIGJ5IHRoZSBkZWZhdWx0XG4gKiBgYm94RW5kQ29uZGl0aW9uYCBmdW5jdGlvbi5cbiAqIEBwcm9wZXJ0eSB7RW5kQ29uZGl0aW9ufSBbYm94RW5kQ29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCB0d29cbiAqIHtAbGluayBtb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9cyB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgYGJveGVuZGAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLlxuICogRGVmYXVsdCBpcyBgdHJ1ZWAgaWYgdGhlIGFyZWEgb2YgdGhlIGJveCBpcyBiaWdnZXIgdGhhbiB0aGUgYG1pbkFyZWFgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24odGhpczpEcmFnQm94LCBpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW29uQm94RW5kXSBDb2RlIHRvIGV4ZWN1dGUganVzdFxuICogYmVmb3JlIGBib3hlbmRgIGlzIGZpcmVkLlxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgRHJhZ0JveEV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IHN0YXJ0LlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIEJPWFNUQVJUOiAnYm94c3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgb24gZHJhZyB3aGVuIGJveCBpcyBhY3RpdmUuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94ZHJhZ1xuICAgKiBAYXBpXG4gICAqL1xuICBCT1hEUkFHOiAnYm94ZHJhZycsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IGVuZC5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YRU5EOiAnYm94ZW5kJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZHJhZyBib3ggY2FuY2VsZWQuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94Y2FuY2VsXG4gICAqIEBhcGlcbiAgICovXG4gIEJPWENBTkNFTDogJ2JveGNhbmNlbCcsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH5EcmFnQm94fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgRHJhZ0JveEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBldmVudCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgT3JpZ2luYXRpbmcgZXZlbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjb29yZGluYXRlLCBtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBkcmFnIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGU7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50ID0gbWFwQnJvd3NlckV2ZW50O1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZScsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8J2JveGNhbmNlbCd8J2JveGRyYWcnfCdib3hlbmQnfCdib3hzdGFydCcsIERyYWdCb3hFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJ3wnYm94Y2FuY2VsJ3wnYm94ZHJhZyd8J2JveGVuZCcsIFJldHVybj59IERyYWdCb3hPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYXcgYSB2ZWN0b3IgYm94IGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLFxuICogbm9ybWFsbHkgY29tYmluZWQgd2l0aCBhIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn0gdGhhdCBsaW1pdHNcbiAqIGl0IHRvIHdoZW4gdGhlIHNoaWZ0IG9yIG90aGVyIGtleSBpcyBoZWxkIGRvd24uIFRoaXMgaXMgdXNlZCwgZm9yIGV4YW1wbGUsXG4gKiBmb3Igem9vbWluZyB0byBhIHNwZWNpZmljIGFyZWEgb2YgdGhlIG1hcFxuICogKHNlZSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdab29tfkRyYWdab29tfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZUFuZFpvb21+RHJhZ1JvdGF0ZUFuZFpvb219KS5cbiAqXG4gKiBAZmlyZXMgRHJhZ0JveEV2ZW50XG4gKiBAYXBpXG4gKi9cbmNsYXNzIERyYWdCb3ggZXh0ZW5kcyBQb2ludGVySW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQm94T25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7RHJhZ0JveE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7RHJhZ0JveE9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIvQm94LmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJveF8gPSBuZXcgUmVuZGVyQm94KG9wdGlvbnMuY2xhc3NOYW1lIHx8ICdvbC1kcmFnYm94Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5taW5BcmVhXyA9IG9wdGlvbnMubWluQXJlYSA/PyA2NDtcblxuICAgIGlmIChvcHRpb25zLm9uQm94RW5kKSB7XG4gICAgICB0aGlzLm9uQm94RW5kID0gb3B0aW9ucy5vbkJveEVuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8/IG1vdXNlQWN0aW9uQnV0dG9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RW5kQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYm94RW5kQ29uZGl0aW9uXyA9XG4gICAgICBvcHRpb25zLmJveEVuZENvbmRpdGlvbiA/PyB0aGlzLmRlZmF1bHRCb3hFbmRDb25kaXRpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29uZGl0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBib3hlbmQgZXZlbnRcbiAgICogc2hvdWxkIGZpcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBUaGUgb3JpZ2luYXRpbmcgTWFwQnJvd3NlckV2ZW50XG4gICAqICAgICBsZWFkaW5nIHRvIHRoZSBib3ggZW5kLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFRoZSBzdGFydGluZyBwaXhlbCBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBUaGUgZW5kIHBpeGVsIG9mIHRoZSBib3guXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBib3hlbmQgY29uZGl0aW9uIHNob3VsZCBiZSBmaXJlZC5cbiAgICovXG4gIGRlZmF1bHRCb3hFbmRDb25kaXRpb24obWFwQnJvd3NlckV2ZW50LCBzdGFydFBpeGVsLCBlbmRQaXhlbCkge1xuICAgIGNvbnN0IHdpZHRoID0gZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGVuZFBpeGVsWzFdIC0gc3RhcnRQaXhlbFsxXTtcbiAgICByZXR1cm4gd2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCA+PSB0aGlzLm1pbkFyZWFfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZ2VvbWV0cnkgb2YgbGFzdCBkcmF3biBib3guXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94Xy5nZXRHZW9tZXRyeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghdGhpcy5zdGFydFBpeGVsXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYm94Xy5zZXRQaXhlbHModGhpcy5zdGFydFBpeGVsXywgbWFwQnJvd3NlckV2ZW50LnBpeGVsKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBEcmFnQm94RXZlbnQoXG4gICAgICAgIERyYWdCb3hFdmVudFR5cGUuQk9YRFJBRyxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudCxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghdGhpcy5zdGFydFBpeGVsXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlQm94ID0gdGhpcy5ib3hFbmRDb25kaXRpb25fKFxuICAgICAgbWFwQnJvd3NlckV2ZW50LFxuICAgICAgdGhpcy5zdGFydFBpeGVsXyxcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5waXhlbCxcbiAgICApO1xuICAgIGlmIChjb21wbGV0ZUJveCkge1xuICAgICAgdGhpcy5vbkJveEVuZChtYXBCcm93c2VyRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgRHJhZ0JveEV2ZW50KFxuICAgICAgICBjb21wbGV0ZUJveCA/IERyYWdCb3hFdmVudFR5cGUuQk9YRU5EIDogRHJhZ0JveEV2ZW50VHlwZS5CT1hDQU5DRUwsXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5jb29yZGluYXRlLFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQsXG4gICAgICApLFxuICAgICk7XG5cbiAgICB0aGlzLmJveF8uc2V0TWFwKG51bGwpO1xuICAgIHRoaXMuc3RhcnRQaXhlbF8gPSBudWxsO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgdGhpcy5zdGFydFBpeGVsXyA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICAgIHRoaXMuYm94Xy5zZXRNYXAobWFwQnJvd3NlckV2ZW50Lm1hcCk7XG4gICAgICB0aGlzLmJveF8uc2V0UGl4ZWxzKHRoaXMuc3RhcnRQaXhlbF8sIHRoaXMuc3RhcnRQaXhlbF8pO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgRHJhZ0JveEV2ZW50KFxuICAgICAgICAgIERyYWdCb3hFdmVudFR5cGUuQk9YU1RBUlQsXG4gICAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsXG4gICAgICAgICAgbWFwQnJvd3NlckV2ZW50LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gZXhlY3V0ZSBqdXN0IGJlZm9yZSBgb25ib3hlbmRgIGlzIGZpcmVkXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgb25Cb3hFbmQoZXZlbnQpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBBY3RpdmUuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRBY3RpdmUoYWN0aXZlKSB7XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgIHRoaXMuYm94Xy5zZXRNYXAobnVsbCk7XG4gICAgICBpZiAodGhpcy5zdGFydFBpeGVsXykge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IERyYWdCb3hFdmVudChEcmFnQm94RXZlbnRUeXBlLkJPWENBTkNFTCwgdGhpcy5zdGFydFBpeGVsXywgbnVsbCksXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc3RhcnRQaXhlbF8gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyLnNldEFjdGl2ZShhY3RpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgY29uc3Qgb2xkTWFwID0gdGhpcy5nZXRNYXAoKTtcblxuICAgIGlmIChvbGRNYXApIHtcbiAgICAgIHRoaXMuYm94Xy5zZXRNYXAobnVsbCk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0UGl4ZWxfKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgRHJhZ0JveEV2ZW50KERyYWdCb3hFdmVudFR5cGUuQk9YQ0FOQ0VMLCB0aGlzLnN0YXJ0UGl4ZWxfLCBudWxsKSxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXIuc2V0TWFwKG1hcCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ0JveDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21cbiAqL1xuaW1wb3J0IERyYWdCb3ggZnJvbSAnLi9EcmFnQm94LmpzJztcbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcbmltcG9ydCB7c2hpZnRLZXlPbmx5fSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtZHJhZ3pvb20nXSBDU1MgY2xhc3MgbmFtZSBmb3Igc3R5bGluZyB0aGVcbiAqIGJveC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24uc2hpZnRLZXlPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0PWZhbHNlXSBVc2UgaW50ZXJhY3Rpb24gZm9yIHpvb21pbmcgb3V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5BcmVhPTY0XSBUaGUgbWluaW11bSBhcmVhIG9mIHRoZSBib3ggaW4gcGl4ZWwsIHRoaXMgdmFsdWUgaXMgdXNlZCBieSB0aGUgcGFyZW50IGRlZmF1bHRcbiAqIGBib3hFbmRDb25kaXRpb25gIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYSB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb259IHRoYXQgbGltaXRzXG4gKiBpdCB0byB3aGVuIGEga2V5LCBzaGlmdCBieSBkZWZhdWx0LCBpcyBoZWxkIGRvd24uXG4gKlxuICogVG8gY2hhbmdlIHRoZSBzdHlsZSBvZiB0aGUgYm94LCB1c2UgQ1NTIGFuZCB0aGUgYC5vbC1kcmFnem9vbWAgc2VsZWN0b3IsIG9yXG4gKiB5b3VyIGN1c3RvbSBvbmUgY29uZmlndXJlZCB3aXRoIGBjbGFzc05hbWVgLlxuICogQGFwaVxuICovXG5jbGFzcyBEcmFnWm9vbSBleHRlbmRzIERyYWdCb3gge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIGNvbnN0IGNvbmRpdGlvbiA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBzaGlmdEtleU9ubHk7XG5cbiAgICBzdXBlcih7XG4gICAgICBjb25kaXRpb246IGNvbmRpdGlvbixcbiAgICAgIGNsYXNzTmFtZTogb3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWd6b29tJyxcbiAgICAgIG1pbkFyZWE6IG9wdGlvbnMubWluQXJlYSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyMDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3V0XyA9IG9wdGlvbnMub3V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm91dCA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGUganVzdCBiZWZvcmUgYG9uYm94ZW5kYCBpcyBmaXJlZFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvbkJveEVuZChldmVudCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgY29uc3QgdmlldyA9IC8qKiBAdHlwZSB7IWltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gKi8gKG1hcC5nZXRWaWV3KCkpO1xuICAgIGxldCBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcblxuICAgIGlmICh0aGlzLm91dF8pIHtcbiAgICAgIGNvbnN0IHJvdGF0ZWRFeHRlbnQgPSB2aWV3LnJvdGF0ZWRFeHRlbnRGb3JHZW9tZXRyeShnZW9tZXRyeSk7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwocm90YXRlZEV4dGVudCk7XG4gICAgICBjb25zdCBmYWN0b3IgPSB2aWV3LmdldFJlc29sdXRpb24oKSAvIHJlc29sdXRpb247XG4gICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgICBnZW9tZXRyeS5zY2FsZShmYWN0b3IgKiBmYWN0b3IpO1xuICAgIH1cblxuICAgIHZpZXcuZml0SW50ZXJuYWwoZ2VvbWV0cnksIHtcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnWm9vbTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0tleVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIExFRlQ6ICdBcnJvd0xlZnQnLFxuICBVUDogJ0Fycm93VXAnLFxuICBSSUdIVDogJ0Fycm93UmlnaHQnLFxuICBET1dOOiAnQXJyb3dEb3duJyxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHtwYW59IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IEtleSBmcm9tICcuLi9ldmVudHMvS2V5LmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXMsIHRhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7cm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBEZWZhdWx0IGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ubm9Nb2RpZmllcktleXN9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLnRhcmdldE5vdEVkaXRhYmxlfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbERlbHRhPTEyOF0gVGhlIGFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIG9uIGVhY2gga2V5XG4gKiBwcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBwYW4gdGhlIG1hcCB1c2luZyBrZXlib2FyZCBhcnJvd3MuXG4gKiBOb3RlIHRoYXQsIGFsdGhvdWdoIHRoaXMgaW50ZXJhY3Rpb24gaXMgYnkgZGVmYXVsdCBpbmNsdWRlZCBpbiBtYXBzLFxuICogdGhlIGtleXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGJyb3dzZXIgZm9jdXMgaXMgb24gdGhlIGVsZW1lbnQgdG8gd2hpY2hcbiAqIHRoZSBrZXlib2FyZCBldmVudHMgYXJlIGF0dGFjaGVkLiBCeSBkZWZhdWx0LCB0aGlzIGlzIHRoZSBtYXAgZGl2LFxuICogdGhvdWdoIHlvdSBjYW4gY2hhbmdlIHRoaXMgd2l0aCB0aGUgYGtleWJvYXJkRXZlbnRUYXJnZXRgIGluXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9LiBgZG9jdW1lbnRgIG5ldmVyIGxvc2VzIGZvY3VzIGJ1dCwgZm9yIGFueSBvdGhlclxuICogZWxlbWVudCwgZm9jdXMgd2lsbCBoYXZlIHRvIGJlIG9uLCBhbmQgcmV0dXJuZWQgdG8sIHRoaXMgZWxlbWVudCBpZiB0aGUga2V5c1xuICogYXJlIHRvIGZ1bmN0aW9uLlxuICogU2VlIGFsc28ge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgS2V5Ym9hcmRQYW4gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb25kaXRpb25fID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgbm9Nb2RpZmllcktleXMobWFwQnJvd3NlckV2ZW50KSAmJiB0YXJnZXROb3RFZGl0YWJsZShtYXBCcm93c2VyRXZlbnQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPVxuICAgICAgb3B0aW9ucy5jb25kaXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuY29uZGl0aW9uXG4gICAgICAgIDogdGhpcy5kZWZhdWx0Q29uZGl0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbERlbHRhXyA9XG4gICAgICBvcHRpb25zLnBpeGVsRGVsdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGl4ZWxEZWx0YSA6IDEyODtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGlmIGl0IHdhcyBhXG4gICAqIGBLZXlFdmVudGAsIGFuZCBkZWNpZGVzIHRoZSBkaXJlY3Rpb24gdG8gcGFuIHRvIChpZiBhbiBhcnJvdyBrZXkgd2FzXG4gICAqIHByZXNzZWQpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOKSB7XG4gICAgICBjb25zdCBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGtleSA9IGtleUV2ZW50LmtleTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgKGtleSA9PSBLZXkuRE9XTiB8fFxuICAgICAgICAgIGtleSA9PSBLZXkuTEVGVCB8fFxuICAgICAgICAgIGtleSA9PSBLZXkuUklHSFQgfHxcbiAgICAgICAgICBrZXkgPT0gS2V5LlVQKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgICBjb25zdCBtYXBVbml0c0RlbHRhID0gdmlldy5nZXRSZXNvbHV0aW9uKCkgKiB0aGlzLnBpeGVsRGVsdGFfO1xuICAgICAgICBsZXQgZGVsdGFYID0gMCxcbiAgICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBpZiAoa2V5ID09IEtleS5ET1dOKSB7XG4gICAgICAgICAgZGVsdGFZID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09IEtleS5MRUZUKSB7XG4gICAgICAgICAgZGVsdGFYID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09IEtleS5SSUdIVCkge1xuICAgICAgICAgIGRlbHRhWCA9IG1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFZID0gbWFwVW5pdHNEZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IFtkZWx0YVgsIGRlbHRhWV07XG4gICAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIHBhbih2aWV3LCBkZWx0YSwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgICBrZXlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFBhbjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQge3BsYXRmb3JtTW9kaWZpZXJLZXksIHRhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGUgZGVmYXVsdCBjb25kaXRpb24gaXNcbiAqIHRoYXQge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLnRhcmdldE5vdEVkaXRhYmxlfSBpcyBmdWxmaWxsZWQgYW5kIHRoYXRcbiAqIHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXNuJ3QgcHJlc3NlZFxuICogKCF7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ucGxhdGZvcm1Nb2RpZmllcktleX0pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBsZXZlbCBkZWx0YSBvbiBlYWNoIGtleSBwcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgKyBhbmQgLS5cbiAqIE5vdGUgdGhhdCwgYWx0aG91Z2ggdGhpcyBpbnRlcmFjdGlvbiBpcyBieSBkZWZhdWx0IGluY2x1ZGVkIGluIG1hcHMsXG4gKiB0aGUga2V5cyBjYW4gb25seSBiZSB1c2VkIHdoZW4gYnJvd3NlciBmb2N1cyBpcyBvbiB0aGUgZWxlbWVudCB0byB3aGljaFxuICogdGhlIGtleWJvYXJkIGV2ZW50cyBhcmUgYXR0YWNoZWQuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIG1hcCBkaXYsXG4gKiB0aG91Z2ggeW91IGNhbiBjaGFuZ2UgdGhpcyB3aXRoIHRoZSBga2V5Ym9hcmRFdmVudFRhcmdldGAgaW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0uIGBkb2N1bWVudGAgbmV2ZXIgbG9zZXMgZm9jdXMgYnV0LCBmb3IgYW55IG90aGVyXG4gKiBlbGVtZW50LCBmb2N1cyB3aWxsIGhhdmUgdG8gYmUgb24sIGFuZCByZXR1cm5lZCB0bywgdGhpcyBlbGVtZW50IGlmIHRoZSBrZXlzXG4gKiBhcmUgdG8gZnVuY3Rpb24uXG4gKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFufktleWJvYXJkUGFufS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgS2V5Ym9hcmRab29tIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgPyBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgOiBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICFwbGF0Zm9ybU1vZGlmaWVyS2V5KG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIHRhcmdldE5vdEVkaXRhYmxlKG1hcEJyb3dzZXJFdmVudClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gb3B0aW9ucy5kZWx0YSA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGlmIGl0IHdhcyBhXG4gICAqIGBLZXlFdmVudGAsIGFuZCBkZWNpZGVzIHdoZXRoZXIgdG8gem9vbSBpbiBvciBvdXQgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICAgKiBrZXkgcHJlc3NlZCB3YXMgJysnIG9yICctJykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGxldCBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgICBpZiAoXG4gICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZRE9XTiB8fFxuICAgICAgbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLktFWVBSRVNTXG4gICAgKSB7XG4gICAgICBjb25zdCBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGtleSA9IGtleUV2ZW50LmtleTtcbiAgICAgIGlmICh0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSAmJiAoa2V5ID09PSAnKycgfHwga2V5ID09PSAnLScpKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICAgIGNvbnN0IGRlbHRhID0ga2V5ID09PSAnKycgPyB0aGlzLmRlbHRhXyA6IC10aGlzLmRlbHRhXztcbiAgICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICAgIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCB1bmRlZmluZWQsIHRoaXMuZHVyYXRpb25fKTtcbiAgICAgICAga2V5RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc3RvcEV2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgS2V5Ym9hcmRab29tO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9LaW5ldGljXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBpbmVydGlhbCBkZWNlbGVyYXRpb24gZm9yIG1hcCBtb3ZlbWVudC5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEtpbmV0aWMge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlY2F5IFJhdGUgb2YgZGVjYXkgKG11c3QgYmUgbmVnYXRpdmUpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluVmVsb2NpdHkgTWluaW11bSB2ZWxvY2l0eSAocGl4ZWxzL21pbGxpc2Vjb25kKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IERlbGF5IHRvIGNvbnNpZGVyIHRvIGNhbGN1bGF0ZSB0aGUga2luZXRpY1xuICAgKiAgICAgaW5pdGlhbCB2YWx1ZXMgKG1pbGxpc2Vjb25kcykuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZWNheSwgbWluVmVsb2NpdHksIGRlbGF5KSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVjYXlfID0gZGVjYXk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5WZWxvY2l0eV8gPSBtaW5WZWxvY2l0eTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGF5XyA9IGRlbGF5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbml0aWFsVmVsb2NpdHlfID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIGJlZ2luKCkge1xuICAgIHRoaXMucG9pbnRzXy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYW5nbGVfID0gMDtcbiAgICB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqL1xuICB1cGRhdGUoeCwgeSkge1xuICAgIHRoaXMucG9pbnRzXy5wdXNoKHgsIHksIERhdGUubm93KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgd2Ugc2hvdWxkIGRvIGtpbmV0aWMgYW5pbWF0aW9uLlxuICAgKi9cbiAgZW5kKCkge1xuICAgIGlmICh0aGlzLnBvaW50c18ubGVuZ3RoIDwgNikge1xuICAgICAgLy8gYXQgbGVhc3QgMiBwb2ludHMgYXJlIHJlcXVpcmVkIChpLmUuIHRoZXJlIG11c3QgYmUgYXQgbGVhc3QgNiBlbGVtZW50c1xuICAgICAgLy8gaW4gdGhlIGFycmF5KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IERhdGUubm93KCkgLSB0aGlzLmRlbGF5XztcbiAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLnBvaW50c18ubGVuZ3RoIC0gMztcbiAgICBpZiAodGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDJdIDwgZGVsYXkpIHtcbiAgICAgIC8vIHRoZSBsYXN0IHRyYWNrZWQgcG9pbnQgaXMgdG9vIG9sZCwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgdXNlciBzdG9wcGVkXG4gICAgICAvLyBwYW5uaW5nIGJlZm9yZSByZWxlYXNpbmcgdGhlIG1hcFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggc3RpbGwgZmFsbHMgaW50byB0aGUgZGVsYXkgdGltZVxuICAgIGxldCBmaXJzdEluZGV4ID0gbGFzdEluZGV4IC0gMztcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA+IDAgJiYgdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAyXSA+IGRlbGF5KSB7XG4gICAgICBmaXJzdEluZGV4IC09IDM7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLnBvaW50c19bbGFzdEluZGV4ICsgMl0gLSB0aGlzLnBvaW50c19bZmlyc3RJbmRleCArIDJdO1xuICAgIC8vIHdlIGRvbid0IHdhbnQgYSBkdXJhdGlvbiBvZiAwIChkaXZpZGUgYnkgemVybylcbiAgICAvLyB3ZSBhbHNvIG1ha2Ugc3VyZSB0aGUgdXNlciBwYW5uZWQgZm9yIGEgZHVyYXRpb24gb2YgYXQgbGVhc3Qgb25lIGZyYW1lXG4gICAgLy8gKDEvNjBzKSB0byBjb21wdXRlIHNhbmUgZGlzcGxhY2VtZW50IHZhbHVlc1xuICAgIGlmIChkdXJhdGlvbiA8IDEwMDAgLyA2MCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGR4ID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleF0gLSB0aGlzLnBvaW50c19bZmlyc3RJbmRleF07XG4gICAgY29uc3QgZHkgPSB0aGlzLnBvaW50c19bbGFzdEluZGV4ICsgMV0gLSB0aGlzLnBvaW50c19bZmlyc3RJbmRleCArIDFdO1xuICAgIHRoaXMuYW5nbGVfID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLyBkdXJhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsVmVsb2NpdHlfID4gdGhpcy5taW5WZWxvY2l0eV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBUb3RhbCBkaXN0YW5jZSB0cmF2ZWxsZWQgKHBpeGVscykuXG4gICAqL1xuICBnZXREaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gKHRoaXMubWluVmVsb2NpdHlfIC0gdGhpcy5pbml0aWFsVmVsb2NpdHlfKSAvIHRoaXMuZGVjYXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgb2YgdGhlIGtpbmV0aWMgcGFubmluZyBhbmltYXRpb24gKHJhZGlhbnMpLlxuICAgKi9cbiAgZ2V0QW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5nbGVfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtpbmV0aWM7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQge0RFVklDRV9QSVhFTF9SQVRJTywgRklSRUZPWH0gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCB7YWxsLCBhbHdheXMsIGZvY3VzV2l0aFRhYmluZGV4fSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsndHJhY2twYWQnIHwgJ3doZWVsJ30gTW9kZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5hbHdheXN9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25Gb2N1c09ubHk9ZmFsc2VdIFdoZW4gdGhlIG1hcCdzIHRhcmdldCBoYXMgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBzZXQsXG4gKiB0aGUgaW50ZXJhY3Rpb24gd2lsbCBvbmx5IGhhbmRsZSBldmVudHMgd2hlbiB0aGUgbWFwIGhhcyB0aGUgZm9jdXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heERlbHRhPTFdIE1heGltdW0gbW91c2Ugd2hlZWwgZGVsdGEuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZW91dD04MF0gTW91c2Ugd2hlZWwgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VBbmNob3I9dHJ1ZV0gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlJ3NcbiAqIGxvY2F0aW9uIGFzIHRoZSBhbmNob3IuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHpvb21pbmcgaW4gYW5kIG91dCB3aWxsIHpvb20gdG9cbiAqIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbiBpbnN0ZWFkIG9mIHpvb21pbmcgb24gdGhlIG1vdXNlJ3MgbG9jYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgbW91c2Ugd2hlZWwgem9vbVxuICogZXZlbnQgd2lsbCBhbHdheXMgYW5pbWF0ZSB0byB0aGUgY2xvc2VzdCB6b29tIGxldmVsIGFmdGVyIGFuIGludGVyYWN0aW9uO1xuICogZmFsc2UgbWVhbnMgaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbGxvd2VkLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBzY3JvbGxpbmcgdGhlIG1vdXNlIHdoZWVsLlxuICogQGFwaVxuICovXG5jbGFzcyBNb3VzZVdoZWVsWm9vbSBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIChvcHRpb25zKSxcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG90YWxEZWx0YV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdERlbHRhXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSBvcHRpb25zLm1heERlbHRhICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heERlbHRhIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lb3V0XyA9IG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1lb3V0IDogODA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlQW5jaG9yXyA9XG4gICAgICBvcHRpb25zLnVzZUFuY2hvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51c2VBbmNob3IgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fID1cbiAgICAgIG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICBjb25zdCBjb25kaXRpb24gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5vbkZvY3VzT25seVxuICAgICAgPyBhbGwoZm9jdXNXaXRoVGFiaW5kZXgsIGNvbmRpdGlvbilcbiAgICAgIDogY29uZGl0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNb2RlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2twYWQgZXZlbnRzIHNlcGFyYXRlZCBieSB0aGlzIGRlbGF5IHdpbGwgYmUgY29uc2lkZXJlZCBzZXBhcmF0ZVxuICAgICAqIGludGVyYWN0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50cmFja3BhZEV2ZW50R2FwXyA9IDQwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+fVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkZWx0YSB2YWx1ZXMgcGVyIHpvb20gbGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YVBlclpvb21fID0gMzAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbmRJbnRlcmFjdGlvbl8oKSB7XG4gICAgdGhpcy50cmFja3BhZFRpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB2aWV3LmVuZEludGVyYWN0aW9uKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5sYXN0RGVsdGFfID8gKHRoaXMubGFzdERlbHRhXyA+IDAgPyAxIDogLTEpIDogMCxcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPyBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLmxhc3RBbmNob3JfKSA6IG51bGwsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IChpZiBpdCB3YXMgYSBtb3VzZXdoZWVsLWV2ZW50KSBhbmQgZXZlbnR1YWxseVxuICAgKiB6b29tcyB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IG1hcEJyb3dzZXJFdmVudC50eXBlO1xuICAgIGlmICh0eXBlICE9PSBFdmVudFR5cGUuV0hFRUwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3Qgd2hlZWxFdmVudCA9IC8qKiBAdHlwZSB7V2hlZWxFdmVudH0gKi8gKFxuICAgICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICApO1xuICAgIHdoZWVsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICh0aGlzLnVzZUFuY2hvcl8pIHtcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgfVxuXG4gICAgLy8gRGVsdGEgbm9ybWFsaXNhdGlvbiBpbnNwaXJlZCBieVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2Jsb2IvMDAxYzdiOS9qcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzXG4gICAgbGV0IGRlbHRhO1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuV0hFRUwpIHtcbiAgICAgIGRlbHRhID0gd2hlZWxFdmVudC5kZWx0YVk7XG4gICAgICBpZiAoRklSRUZPWCAmJiB3aGVlbEV2ZW50LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgICAgZGVsdGEgLz0gREVWSUNFX1BJWEVMX1JBVElPO1xuICAgICAgfVxuICAgICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICAgIGRlbHRhICo9IDQwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3REZWx0YV8gPSBkZWx0YTtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAodGhpcy5zdGFydFRpbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubW9kZV8gfHwgbm93IC0gdGhpcy5zdGFydFRpbWVfID4gdGhpcy50cmFja3BhZEV2ZW50R2FwXykge1xuICAgICAgdGhpcy5tb2RlXyA9IE1hdGguYWJzKGRlbHRhKSA8IDQgPyAndHJhY2twYWQnIDogJ3doZWVsJztcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoXG4gICAgICB0aGlzLm1vZGVfID09PSAndHJhY2twYWQnICYmXG4gICAgICAhKHZpZXcuZ2V0Q29uc3RyYWluUmVzb2x1dGlvbigpIHx8IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8pXG4gICAgKSB7XG4gICAgICBpZiAodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhY2twYWRUaW1lb3V0SWRfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5iZWdpbkludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHNldFRpbWVvdXQoXG4gICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb25fLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMudGltZW91dF8sXG4gICAgICApO1xuICAgICAgdmlldy5hZGp1c3Rab29tKFxuICAgICAgICAtZGVsdGEgLyB0aGlzLmRlbHRhUGVyWm9vbV8sXG4gICAgICAgIHRoaXMubGFzdEFuY2hvcl8gPyBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLmxhc3RBbmNob3JfKSA6IG51bGwsXG4gICAgICApO1xuICAgICAgdGhpcy5zdGFydFRpbWVfID0gbm93O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudG90YWxEZWx0YV8gKz0gZGVsdGE7XG5cbiAgICBjb25zdCB0aW1lTGVmdCA9IE1hdGgubWF4KHRoaXMudGltZW91dF8gLSAobm93IC0gdGhpcy5zdGFydFRpbWVfKSwgMCk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KFxuICAgICAgdGhpcy5oYW5kbGVXaGVlbFpvb21fLmJpbmQodGhpcywgbWFwKSxcbiAgICAgIHRpbWVMZWZ0LFxuICAgICk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGhhbmRsZVdoZWVsWm9vbV8obWFwKSB7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBsZXQgZGVsdGEgPVxuICAgICAgLWNsYW1wKFxuICAgICAgICB0aGlzLnRvdGFsRGVsdGFfLFxuICAgICAgICAtdGhpcy5tYXhEZWx0YV8gKiB0aGlzLmRlbHRhUGVyWm9vbV8sXG4gICAgICAgIHRoaXMubWF4RGVsdGFfICogdGhpcy5kZWx0YVBlclpvb21fLFxuICAgICAgKSAvIHRoaXMuZGVsdGFQZXJab29tXztcbiAgICBpZiAodmlldy5nZXRDb25zdHJhaW5SZXNvbHV0aW9uKCkgfHwgdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXykge1xuICAgICAgLy8gdmlldyBoYXMgYSB6b29tIGNvbnN0cmFpbnQsIHpvb20gYnkgMVxuICAgICAgZGVsdGEgPSBkZWx0YSA/IChkZWx0YSA+IDAgPyAxIDogLTEpIDogMDtcbiAgICB9XG4gICAgem9vbUJ5RGVsdGEoXG4gICAgICB2aWV3LFxuICAgICAgZGVsdGEsXG4gICAgICB0aGlzLmxhc3RBbmNob3JfID8gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwodGhpcy5sYXN0QW5jaG9yXykgOiBudWxsLFxuICAgICAgdGhpcy5kdXJhdGlvbl8sXG4gICAgKTtcblxuICAgIHRoaXMubW9kZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3RhbERlbHRhXyA9IDA7XG4gICAgdGhpcy5sYXN0QW5jaG9yXyA9IG51bGw7XG4gICAgdGhpcy5zdGFydFRpbWVfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSB1c2luZyB0aGUgbW91c2UncyBsb2NhdGlvbiBhcyBhbiBhbmNob3Igd2hlbiB6b29taW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQW5jaG9yIHRydWUgdG8gem9vbSB0byB0aGUgbW91c2UncyBsb2NhdGlvbiwgZmFsc2VcbiAgICogdG8gem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSBtYXBcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TW91c2VBbmNob3IodXNlQW5jaG9yKSB7XG4gICAgdGhpcy51c2VBbmNob3JfID0gdXNlQW5jaG9yO1xuICAgIGlmICghdXNlQW5jaG9yKSB7XG4gICAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTW91c2VXaGVlbFpvb207XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtcbiAgY2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnMsXG59IGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtkaXNhYmxlfSBmcm9tICcuLi9yb3RhdGlvbmNvbnN0cmFpbnQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpblxuICogbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aHJlc2hvbGQ9MC4zXSBNaW5pbWFsIGFuZ2xlIGluIHJhZGlhbnMgdG8gc3RhcnQgYSByb3RhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byByb3RhdGUgdGhlIG1hcCBieSB0d2lzdGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgUGluY2hSb3RhdGUgZXh0ZW5kcyBQb2ludGVySW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIGNvbnN0IHBvaW50ZXJPcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gKFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICBpZiAoIXBvaW50ZXJPcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICBwb2ludGVyT3B0aW9ucy5zdG9wRG93biA9IEZBTFNFO1xuICAgIH1cblxuICAgIHN1cGVyKHBvaW50ZXJPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbkRlbHRhXyA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRocmVzaG9sZF8gPSBvcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aHJlc2hvbGQgOiAwLjM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGxldCByb3RhdGlvbkRlbHRhID0gMC4wO1xuXG4gICAgY29uc3QgdG91Y2gwID0gdGhpcy50YXJnZXRQb2ludGVyc1swXTtcbiAgICBjb25zdCB0b3VjaDEgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzFdO1xuXG4gICAgLy8gYW5nbGUgYmV0d2VlbiB0b3VjaGVzXG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgICAgdG91Y2gxLmNsaWVudFkgLSB0b3VjaDAuY2xpZW50WSxcbiAgICAgIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gwLmNsaWVudFgsXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVsdGEgPSBhbmdsZSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICAgIHRoaXMucm90YXRpb25EZWx0YV8gKz0gZGVsdGE7XG4gICAgICBpZiAoIXRoaXMucm90YXRpbmdfICYmIE1hdGguYWJzKHRoaXMucm90YXRpb25EZWx0YV8pID4gdGhpcy50aHJlc2hvbGRfKSB7XG4gICAgICAgIHRoaXMucm90YXRpbmdfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJvdGF0aW9uRGVsdGEgPSBkZWx0YTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QW5nbGVfID0gYW5nbGU7XG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpbnRzKCkucm90YXRpb24gPT09IGRpc2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByb3RhdGUgYW5jaG9yIHBvaW50LlxuICAgIC8vIEZJWE1FOiBzaG91bGQgYmUgdGhlIGludGVyc2VjdGlvbiBwb2ludCBiZXR3ZWVuIHRoZSBsaW5lczpcbiAgICAvLyAgICAgdG91Y2gwLHRvdWNoMSBhbmQgcHJldmlvdXNUb3VjaDAscHJldmlvdXNUb3VjaDFcbiAgICB0aGlzLmFuY2hvcl8gPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbEludGVybmFsKFxuICAgICAgbWFwLmdldEV2ZW50UGl4ZWwoY2VudHJvaWRGcm9tUG9pbnRlcnModGhpcy50YXJnZXRQb2ludGVycykpLFxuICAgICk7XG5cbiAgICAvLyByb3RhdGVcbiAgICBpZiAodGhpcy5yb3RhdGluZ18pIHtcbiAgICAgIG1hcC5yZW5kZXIoKTtcbiAgICAgIHZpZXcuYWRqdXN0Um90YXRpb25JbnRlcm5hbChyb3RhdGlvbkRlbHRhLCB0aGlzLmFuY2hvcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24odGhpcy5kdXJhdGlvbl8pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJvdGF0aW5nXyA9IGZhbHNlO1xuICAgICAgdGhpcy5yb3RhdGlvbkRlbHRhXyA9IDAuMDtcbiAgICAgIGlmICghdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaW5jaFJvdGF0ZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUGluY2hab29tXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtcbiAgY2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnMsXG59IGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249NDAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBwaW5jaGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgUGluY2hab29tIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBzdXBlcihwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiA0MDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHNjYWxlRGVsdGEgPSAxLjA7XG5cbiAgICBjb25zdCB0b3VjaDAgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzBdO1xuICAgIGNvbnN0IHRvdWNoMSA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMV07XG4gICAgY29uc3QgZHggPSB0b3VjaDAuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYO1xuICAgIGNvbnN0IGR5ID0gdG91Y2gwLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdG91Y2hlc1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgIGlmICh0aGlzLmxhc3REaXN0YW5jZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NhbGVEZWx0YSA9IHRoaXMubGFzdERpc3RhbmNlXyAvIGRpc3RhbmNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSBkaXN0YW5jZTtcblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG5cbiAgICBpZiAoc2NhbGVEZWx0YSAhPSAxLjApIHtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gc2NhbGVEZWx0YTtcbiAgICB9XG5cbiAgICAvLyBzY2FsZSBhbmNob3IgcG9pbnQuXG4gICAgdGhpcy5hbmNob3JfID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChcbiAgICAgIG1hcC5nZXRFdmVudFBpeGVsKGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRoaXMudGFyZ2V0UG9pbnRlcnMpKSxcbiAgICApO1xuXG4gICAgLy8gc2NhbGUsIGJ5cGFzcyB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50XG4gICAgbWFwLnJlbmRlcigpO1xuICAgIHZpZXcuYWRqdXN0UmVzb2x1dGlvbkludGVybmFsKHNjYWxlRGVsdGEsIHRoaXMuYW5jaG9yXyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmxhc3RTY2FsZURlbHRhXyA+IDEgPyAxIDogLTE7XG4gICAgICB2aWV3LmVuZEludGVyYWN0aW9uKHRoaXMuZHVyYXRpb25fLCBkaXJlY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gICAgICBpZiAoIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgICBtYXAuZ2V0VmlldygpLmJlZ2luSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGluY2hab29tO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9kZWZhdWx0c1xuICovXG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBEb3VibGVDbGlja1pvb20gZnJvbSAnLi9Eb3VibGVDbGlja1pvb20uanMnO1xuaW1wb3J0IERyYWdQYW4gZnJvbSAnLi9EcmFnUGFuLmpzJztcbmltcG9ydCBEcmFnUm90YXRlIGZyb20gJy4vRHJhZ1JvdGF0ZS5qcyc7XG5pbXBvcnQgRHJhZ1pvb20gZnJvbSAnLi9EcmFnWm9vbS5qcyc7XG5pbXBvcnQgS2V5Ym9hcmRQYW4gZnJvbSAnLi9LZXlib2FyZFBhbi5qcyc7XG5pbXBvcnQgS2V5Ym9hcmRab29tIGZyb20gJy4vS2V5Ym9hcmRab29tLmpzJztcbmltcG9ydCBLaW5ldGljIGZyb20gJy4uL0tpbmV0aWMuanMnO1xuaW1wb3J0IE1vdXNlV2hlZWxab29tIGZyb20gJy4vTW91c2VXaGVlbFpvb20uanMnO1xuaW1wb3J0IFBpbmNoUm90YXRlIGZyb20gJy4vUGluY2hSb3RhdGUuanMnO1xuaW1wb3J0IFBpbmNoWm9vbSBmcm9tICcuL1BpbmNoWm9vbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbHRTaGlmdERyYWdSb3RhdGU9dHJ1ZV0gV2hldGhlciBBbHQtU2hpZnQtZHJhZyByb3RhdGUgaXNcbiAqIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbkZvY3VzT25seT1mYWxzZV0gSW50ZXJhY3Qgb25seSB3aGVuIHRoZSBtYXAgaGFzIHRoZVxuICogZm9jdXMuIFRoaXMgYWZmZWN0cyB0aGUgYE1vdXNlV2hlZWxab29tYCBhbmQgYERyYWdQYW5gIGludGVyYWN0aW9ucyBhbmQgaXNcbiAqIHVzZWZ1bCB3aGVuIHBhZ2Ugc2Nyb2xsIGlzIGRlc2lyZWQgZm9yIG1hcHMgdGhhdCBkbyBub3QgaGF2ZSB0aGUgYnJvd3NlcidzXG4gKiBmb2N1cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RvdWJsZUNsaWNrWm9vbT10cnVlXSBXaGV0aGVyIGRvdWJsZSBjbGljayB6b29tIGlzXG4gKiBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBba2V5Ym9hcmQ9dHJ1ZV0gV2hldGhlciBrZXlib2FyZCBpbnRlcmFjdGlvbiBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbW91c2VXaGVlbFpvb209dHJ1ZV0gV2hldGhlciBtb3VzZXdoZWVsIHpvb20gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NoaWZ0RHJhZ1pvb209dHJ1ZV0gV2hldGhlciBTaGlmdC1kcmFnIHpvb20gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RyYWdQYW49dHJ1ZV0gV2hldGhlciBkcmFnIHBhbiBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGluY2hSb3RhdGU9dHJ1ZV0gV2hldGhlciBwaW5jaCByb3RhdGUgaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BpbmNoWm9vbT10cnVlXSBXaGV0aGVyIHBpbmNoIHpvb20gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbURlbHRhXSBab29tIGxldmVsIGRlbHRhIHdoZW4gdXNpbmcga2V5Ym9hcmQgb3IgZG91YmxlIGNsaWNrIHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21EdXJhdGlvbl0gRHVyYXRpb24gb2YgdGhlIHpvb20gYW5pbWF0aW9uIGluXG4gKiBtaWxsaXNlY29uZHMuXG4gKi9cblxuLyoqXG4gKiBTZXQgb2YgaW50ZXJhY3Rpb25zIGluY2x1ZGVkIGluIG1hcHMgYnkgZGVmYXVsdC4gU3BlY2lmaWMgaW50ZXJhY3Rpb25zIGNhbiBiZVxuICogZXhjbHVkZWQgYnkgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGUgb3B0aW9uIHRvIGZhbHNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICogb3B0aW9ucywgYnV0IHRoZSBvcmRlciBvZiB0aGUgaW50ZXJhY3Rpb25zIGlzIGZpeGVkLiAgSWYgeW91IHdhbnQgdG8gc3BlY2lmeVxuICogYSBkaWZmZXJlbnQgb3JkZXIgZm9yIGludGVyYWN0aW9ucywgeW91IHdpbGwgbmVlZCB0byBjcmVhdGUgeW91ciBvd25cbiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25+SW50ZXJhY3Rpb259IGluc3RhbmNlcyBhbmQgaW5zZXJ0XG4gKiB0aGVtIGludG8gYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaW4gdGhlIG9yZGVyIHlvdSB3YW50XG4gKiBiZWZvcmUgY3JlYXRpbmcgeW91ciB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGluc3RhbmNlLiBDaGFuZ2luZyB0aGUgb3JkZXIgY2FuXG4gKiBiZSBvZiBpbnRlcmVzdCBpZiB0aGUgZXZlbnQgcHJvcGFnYXRpb24gbmVlZHMgdG8gYmUgc3RvcHBlZCBhdCBhIHBvaW50LlxuICogVGhlIGRlZmF1bHQgc2V0IG9mIGludGVyYWN0aW9ucywgaW4gc2VxdWVuY2UsIGlzOlxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGV+RHJhZ1JvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb21+RG91YmxlQ2xpY2tab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdQYW5+RHJhZ1Bhbn1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZX5QaW5jaFJvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9QaW5jaFpvb21+UGluY2hab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFufktleWJvYXJkUGFufVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbX5LZXlib2FyZFpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb21+TW91c2VXaGVlbFpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21+RHJhZ1pvb219XG4gKlxuICogQHBhcmFtIHtEZWZhdWx0c09wdGlvbnN9IFtvcHRpb25zXSBEZWZhdWx0cyBvcHRpb25zLlxuICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICogQSBjb2xsZWN0aW9uIG9mIGludGVyYWN0aW9ucyB0byBiZSB1c2VkIHdpdGggdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH1cbiAqIGNvbnN0cnVjdG9yJ3MgYGludGVyYWN0aW9uc2Agb3B0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdHMob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgY29uc3QgaW50ZXJhY3Rpb25zID0gbmV3IENvbGxlY3Rpb24oKTtcblxuICBjb25zdCBraW5ldGljID0gbmV3IEtpbmV0aWMoLTAuMDA1LCAwLjA1LCAxMDApO1xuXG4gIGNvbnN0IGFsdFNoaWZ0RHJhZ1JvdGF0ZSA9XG4gICAgb3B0aW9ucy5hbHRTaGlmdERyYWdSb3RhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLmFsdFNoaWZ0RHJhZ1JvdGF0ZVxuICAgICAgOiB0cnVlO1xuICBpZiAoYWx0U2hpZnREcmFnUm90YXRlKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IERyYWdSb3RhdGUoKSk7XG4gIH1cblxuICBjb25zdCBkb3VibGVDbGlja1pvb20gPVxuICAgIG9wdGlvbnMuZG91YmxlQ2xpY2tab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA6IHRydWU7XG4gIGlmIChkb3VibGVDbGlja1pvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBEb3VibGVDbGlja1pvb20oe1xuICAgICAgICBkZWx0YTogb3B0aW9ucy56b29tRGVsdGEsXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBkcmFnUGFuID0gb3B0aW9ucy5kcmFnUGFuICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRyYWdQYW4gOiB0cnVlO1xuICBpZiAoZHJhZ1Bhbikge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKFxuICAgICAgbmV3IERyYWdQYW4oe1xuICAgICAgICBvbkZvY3VzT25seTogb3B0aW9ucy5vbkZvY3VzT25seSxcbiAgICAgICAga2luZXRpYzoga2luZXRpYyxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBwaW5jaFJvdGF0ZSA9XG4gICAgb3B0aW9ucy5waW5jaFJvdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waW5jaFJvdGF0ZSA6IHRydWU7XG4gIGlmIChwaW5jaFJvdGF0ZSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBQaW5jaFJvdGF0ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IHBpbmNoWm9vbSA9IG9wdGlvbnMucGluY2hab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBpbmNoWm9vbSA6IHRydWU7XG4gIGlmIChwaW5jaFpvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBQaW5jaFpvb20oe1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb24sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgY29uc3Qga2V5Ym9hcmQgPSBvcHRpb25zLmtleWJvYXJkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleWJvYXJkIDogdHJ1ZTtcbiAgaWYgKGtleWJvYXJkKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IEtleWJvYXJkUGFuKCkpO1xuICAgIGludGVyYWN0aW9ucy5wdXNoKFxuICAgICAgbmV3IEtleWJvYXJkWm9vbSh7XG4gICAgICAgIGRlbHRhOiBvcHRpb25zLnpvb21EZWx0YSxcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG1vdXNlV2hlZWxab29tID1cbiAgICBvcHRpb25zLm1vdXNlV2hlZWxab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vdXNlV2hlZWxab29tIDogdHJ1ZTtcbiAgaWYgKG1vdXNlV2hlZWxab29tKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2goXG4gICAgICBuZXcgTW91c2VXaGVlbFpvb20oe1xuICAgICAgICBvbkZvY3VzT25seTogb3B0aW9ucy5vbkZvY3VzT25seSxcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHNoaWZ0RHJhZ1pvb20gPVxuICAgIG9wdGlvbnMuc2hpZnREcmFnWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaGlmdERyYWdab29tIDogdHJ1ZTtcbiAgaWYgKHNoaWZ0RHJhZ1pvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBEcmFnWm9vbSh7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaW50ZXJhY3Rpb25zO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9NYXBcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgQ29tcG9zaXRlTWFwUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9Db21wb3NpdGUuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IExheWVyIGZyb20gJy4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IExheWVyR3JvdXAsIHtHcm91cEV2ZW50fSBmcm9tICcuL2xheWVyL0dyb3VwLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnQgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnQuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXIgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwRXZlbnQgZnJvbSAnLi9NYXBFdmVudC5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4vTWFwRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBQcm9wZXJ0eSBmcm9tICcuL01hcFByb3BlcnR5LmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IFBvaW50ZXJFdmVudFR5cGUgZnJvbSAnLi9wb2ludGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGlsZVF1ZXVlLCB7Z2V0VGlsZVByaW9yaXR5fSBmcm9tICcuL1RpbGVRdWV1ZS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuL1ZpZXcuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtERVZJQ0VfUElYRUxfUkFUSU8sIFBBU1NJVkVfRVZFTlRfTElTVEVORVJTfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLFxuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxufSBmcm9tICcuL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7XG4gIGNsb25lLFxuICBjcmVhdGVPclVwZGF0ZUVtcHR5LFxuICBlcXVhbHMgYXMgZXF1YWxzRXh0ZW50LFxuICBnZXRGb3JWaWV3QW5kU2l6ZSxcbiAgaXNFbXB0eSxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtkZWZhdWx0cyBhcyBkZWZhdWx0Q29udHJvbHN9IGZyb20gJy4vY29udHJvbC9kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2RlZmF1bHRzIGFzIGRlZmF1bHRJbnRlcmFjdGlvbnN9IGZyb20gJy4vaW50ZXJhY3Rpb24vZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4vYXJyYXkuanMnO1xuaW1wb3J0IHtmcm9tVXNlckNvb3JkaW5hdGUsIHRvVXNlckNvb3JkaW5hdGV9IGZyb20gJy4vcHJvai5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCB7aGFzQXJlYX0gZnJvbSAnLi9zaXplLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge3dhcm59IGZyb20gJy4vY29uc29sZS5qcyc7XG5cbi8qKlxuICogU3RhdGUgb2YgdGhlIGN1cnJlbnQgZnJhbWUuIE9ubHkgYHBpeGVsUmF0aW9gLCBgdGltZWAgYW5kIGB2aWV3U3RhdGVgIHNob3VsZFxuICogYmUgdXNlZCBpbiBhcHBsaWNhdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGcmFtZVN0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxSYXRpbyBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIGZyYW1lLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgVGhlIHRpbWUgd2hlbiByZW5kZXJpbmcgb2YgdGhlIGZyYW1lIHdhcyByZXF1ZXN0ZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVmlldy5qc1wiKS5TdGF0ZX0gdmlld1N0YXRlIFRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCB2aWV3LlxuICogQHByb3BlcnR5IHtib29sZWFufSBhbmltYXRlIEFuaW1hdGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0gQ29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0uXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGltcG9ydChcInJidXNoXCIpLmRlZmF1bHQ8aW1wb3J0KCcuL3JlbmRlci9jYW52YXMvRXhlY3V0b3IuanMnKS5EZWNsdXR0ZXJFbnRyeT4+fG51bGx9IGRlY2x1dHRlclxuICogRGVjbHV0dGVyIHRyZWVzIGJ5IGRlY2x1dHRlciBncm91cC5cbiAqIFdoZW4gbnVsbCwgbm8gZGVjbHV0dGVyaW5nIGlzIG5lZWRlZCBiZWNhdXNlIG5vIGxheWVycyBoYXZlIGRlY2x1dHRlcmluZyBlbmFibGVkLlxuICogQHByb3BlcnR5IHtudWxsfGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudCAoaW4gdmlldyBwcm9qZWN0aW9uIGNvb3JkaW5hdGVzKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbmV4dEV4dGVudF0gTmV4dCBleHRlbnQgZHVyaW5nIGFuIGFuaW1hdGlvbiBzZXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggSW5kZXguXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGU+fSBsYXllclN0YXRlc0FycmF5IExheWVyU3RhdGVzQXJyYXkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGF5ZXJJbmRleCBMYXllckluZGV4LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtIFBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLlxuICogQHByb3BlcnR5IHtBcnJheTxQb3N0UmVuZGVyRnVuY3Rpb24+fSBwb3N0UmVuZGVyRnVuY3Rpb25zIFBvc3RSZW5kZXJGdW5jdGlvbnMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFNpemUuXG4gKiBAcHJvcGVydHkge1RpbGVRdWV1ZX0gdGlsZVF1ZXVlIFRpbGVRdWV1ZS5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGJvb2xlYW4+Pn0gdXNlZFRpbGVzIFVzZWRUaWxlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdmlld0hpbnRzIFZpZXdIaW50cy5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGJvb2xlYW4+Pn0gd2FudGVkVGlsZXMgV2FudGVkVGlsZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWFwSWQgVGhlIGlkIG9mIHRoZSBtYXAuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSByZW5kZXJUYXJnZXRzIElkZW50aWZpZXJzIG9mIHByZXZpb3VzbHkgcmVuZGVyZWQgZWxlbWVudHMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oTWFwLCA/RnJhbWVTdGF0ZSk6IGFueX0gUG9zdFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdFBpeGVsT3B0aW9uc1xuICogQHByb3BlcnR5IHt1bmRlZmluZWR8ZnVuY3Rpb24oaW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vc291cmNlL1NvdXJjZVwiKS5kZWZhdWx0Pik6IGJvb2xlYW59IFtsYXllckZpbHRlcl0gTGF5ZXIgZmlsdGVyXG4gKiBmdW5jdGlvbi4gVGhlIGZpbHRlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgb25lIGFyZ3VtZW50LCB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXItY2FuZGlkYXRlfSBhbmQgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4gdmFsdWUuXG4gKiBPbmx5IGxheWVycyB3aGljaCBhcmUgdmlzaWJsZSBhbmQgZm9yIHdoaWNoIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWBcbiAqIHdpbGwgYmUgdGVzdGVkIGZvciBmZWF0dXJlcy4gQnkgZGVmYXVsdCwgYWxsIHZpc2libGUgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaXRUb2xlcmFuY2U9MF0gSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UgaW4gY3NzIHBpeGVscy4gUGl4ZWxzXG4gKiBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjaGVja1dyYXBwZWQ9dHJ1ZV0gQ2hlY2stV3JhcHBlZCBXaWxsIGNoZWNrIGZvciB3cmFwcGVkIGdlb21ldHJpZXMgaW5zaWRlIHRoZSByYW5nZSBvZlxuICogICArLy0gMSB3b3JsZCB3aWR0aC4gV29ya3Mgb25seSBpZiBhIHByb2plY3Rpb24gaXMgdXNlZCB0aGF0IGNhbiBiZSB3cmFwcGVkLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWFwT3B0aW9uc0ludGVybmFsXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IFtjb250cm9sc10gQ29udHJvbHMuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gW2ludGVyYWN0aW9uc10gSW50ZXJhY3Rpb25zLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxEb2N1bWVudH0ga2V5Ym9hcmRFdmVudFRhcmdldCBLZXlib2FyZEV2ZW50VGFyZ2V0LlxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gb3ZlcmxheXMgT3ZlcmxheXMuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXMgVmFsdWVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfCdjaGFuZ2U6bGF5ZXJncm91cCd8J2NoYW5nZTpzaXplJ3wnY2hhbmdlOnRhcmdldCd8J2NoYW5nZTp2aWV3J30gTWFwT2JqZWN0RXZlbnRUeXBlc1xuICovXG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPE1hcE9iamVjdEV2ZW50VHlwZXMsIGltcG9ydChcIi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudFR5cGVcIikuVHlwZXMsIGltcG9ydChcIi4vTWFwQnJvd3NlckV2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vTWFwRXZlbnRUeXBlXCIpLlR5cGVzLCBpbXBvcnQoXCIuL01hcEV2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5NYXBSZW5kZXJFdmVudFR5cGVzLCBpbXBvcnQoXCIuL3JlbmRlci9FdmVudFwiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfE1hcE9iamVjdEV2ZW50VHlwZXN8XG4gKiAgICAgIGltcG9ydChcIi4vTWFwQnJvd3NlckV2ZW50VHlwZVwiKS5UeXBlc3xpbXBvcnQoXCIuL01hcEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAgaW1wb3J0KFwiLi9yZW5kZXIvRXZlbnRUeXBlXCIpLk1hcFJlbmRlckV2ZW50VHlwZXMsIFJldHVybj59IE1hcEV2ZW50SGFuZGxlclxuICovXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBjb25maWcgb3B0aW9ucyBmb3IgdGhlIG1hcC5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gW2NvbnRyb2xzXVxuICogQ29udHJvbHMgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvZGVmYXVsdHMuZGVmYXVsdHN9IGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsUmF0aW89d2luZG93LmRldmljZVBpeGVsUmF0aW9dIFRoZSByYXRpbyBiZXR3ZWVuXG4gKiBwaHlzaWNhbCBwaXhlbHMgYW5kIGRldmljZS1pbmRlcGVuZGVudCBwaXhlbHMgKGRpcHMpIG9uIHRoZSBkZXZpY2UuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBbaW50ZXJhY3Rpb25zXVxuICogSW50ZXJhY3Rpb25zIHRoYXQgYXJlIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBJZiBub3Qgc3BlY2lmaWVkLFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9kZWZhdWx0cy5kZWZhdWx0c30gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR8c3RyaW5nfSBba2V5Ym9hcmRFdmVudFRhcmdldF0gVGhlIGVsZW1lbnQgdG9cbiAqIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24uIFRoaXMgZGV0ZXJtaW5lcyB3aGVuIHRoZSBgS2V5Ym9hcmRQYW5gIGFuZFxuICogYEtleWJvYXJkWm9vbWAgaW50ZXJhY3Rpb25zIHRyaWdnZXIuIEZvciBleGFtcGxlLCBpZiB0aGlzIG9wdGlvbiBpcyBzZXQgdG9cbiAqIGBkb2N1bWVudGAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9ucyB3aWxsIGFsd2F5cyB0cmlnZ2VyLiBJZiB0aGlzIG9wdGlvbiBpc1xuICogbm90IHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgdGhlIGxpYnJhcnkgbGlzdGVucyB0byBrZXlib2FyZCBldmVudHMgb24gaXMgdGhlXG4gKiBtYXAgdGFyZ2V0IChpLmUuIHRoZSB1c2VyLXByb3ZpZGVkIGRpdiBmb3IgdGhlIG1hcCkuIElmIHRoaXMgaXMgbm90XG4gKiBgZG9jdW1lbnRgLCB0aGUgdGFyZ2V0IGVsZW1lbnQgbmVlZHMgdG8gYmUgZm9jdXNlZCBmb3Iga2V5IGV2ZW50cyB0byBiZVxuICogZW1pdHRlZCwgcmVxdWlyaW5nIHRoYXQgdGhlIHRhcmdldCBlbGVtZW50IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58TGF5ZXJHcm91cH0gW2xheWVyc11cbiAqIExheWVycy4gSWYgdGhpcyBpcyBub3QgZGVmaW5lZCwgYSBtYXAgd2l0aCBubyBsYXllcnMgd2lsbCBiZSByZW5kZXJlZC4gTm90ZVxuICogdGhhdCBsYXllcnMgYXJlIHJlbmRlcmVkIGluIHRoZSBvcmRlciBzdXBwbGllZCwgc28gaWYgeW91IHdhbnQsIGZvciBleGFtcGxlLFxuICogYSB2ZWN0b3IgbGF5ZXIgdG8gYXBwZWFyIG9uIHRvcCBvZiBhIHRpbGUgbGF5ZXIsIGl0IG11c3QgY29tZSBhZnRlciB0aGUgdGlsZVxuICogbGF5ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFRpbGVzTG9hZGluZz0xNl0gTWF4aW11bSBudW1iZXIgdGlsZXMgdG8gbG9hZFxuICogc2ltdWx0YW5lb3VzbHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21vdmVUb2xlcmFuY2U9MV0gVGhlIG1pbmltdW0gZGlzdGFuY2UgaW4gcGl4ZWxzIHRoZVxuICogY3Vyc29yIG11c3QgbW92ZSB0byBiZSBkZXRlY3RlZCBhcyBhIG1hcCBtb3ZlIGV2ZW50IGluc3RlYWQgb2YgYSBjbGljay5cbiAqIEluY3JlYXNpbmcgdGhpcyB2YWx1ZSBjYW4gbWFrZSBpdCBlYXNpZXIgdG8gY2xpY2sgb24gdGhlIG1hcC5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBbb3ZlcmxheXNdXG4gKiBPdmVybGF5cyBpbml0aWFsbHkgYWRkZWQgdG8gdGhlIG1hcC4gQnkgZGVmYXVsdCwgbm8gb3ZlcmxheXMgYXJlIGFkZGVkLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFRoZSBjb250YWluZXIgZm9yIHRoZSBtYXAsIGVpdGhlciB0aGVcbiAqIGVsZW1lbnQgaXRzZWxmIG9yIHRoZSBgaWRgIG9mIHRoZSBlbGVtZW50LiBJZiBub3Qgc3BlY2lmaWVkIGF0IGNvbnN0cnVjdGlvblxuICogdGltZSwge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwI3NldFRhcmdldH0gbXVzdCBiZSBjYWxsZWQgZm9yIHRoZSBtYXAgdG8gYmVcbiAqIHJlbmRlcmVkLiBJZiBwYXNzZWQgYnkgZWxlbWVudCwgdGhlIGNvbnRhaW5lciBjYW4gYmUgaW4gYSBzZWNvbmRhcnkgZG9jdW1lbnQuXG4gKiBGb3IgYWNjZXNzaWJpbGl0eSAoZm9jdXMgYW5kIGtleWJvYXJkIGV2ZW50cyBmb3IgbWFwIG5hdmlnYXRpb24pLCB0aGUgYHRhcmdldGAgZWxlbWVudCBtdXN0IGhhdmUgYVxuICogIHByb3Blcmx5IGNvbmZpZ3VyZWQgYHRhYmluZGV4YCBhdHRyaWJ1dGUuIElmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGluc2lkZSBhIFNoYWRvdyBET00sIHRoZVxuICogIGB0YWJpbmRleGAgYXRyaWJ1dGUgbXVzdCBiZSBzZXQgb24gdGhlIGN1c3RvbSBlbGVtZW50J3MgaG9zdCBlbGVtZW50LlxuICogKipOb3RlOioqIENTUyBgdHJhbnNmb3JtYCBzdXBwb3J0IGZvciB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgbGltaXRlZCB0byBgc2NhbGVgLlxuICogQHByb3BlcnR5IHtWaWV3fFByb21pc2U8aW1wb3J0KFwiLi9WaWV3LmpzXCIpLlZpZXdPcHRpb25zPn0gW3ZpZXddIFRoZSBtYXAncyB2aWV3LiAgTm8gbGF5ZXIgc291cmNlcyB3aWxsIGJlXG4gKiBmZXRjaGVkIHVubGVzcyB0aGlzIGlzIHNwZWNpZmllZCBhdCBjb25zdHJ1Y3Rpb24gdGltZSBvciB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjc2V0Vmlld30uXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGF5ZXJNYXBQcm9wZXJ0eShsYXllcikge1xuICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikge1xuICAgIGxheWVyLnNldE1hcEludGVybmFsKG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgbGF5ZXIuZ2V0TGF5ZXJzKCkuZm9yRWFjaChyZW1vdmVMYXllck1hcFByb3BlcnR5KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICogQHBhcmFtIHtNYXB9IG1hcCBNYXAuXG4gKi9cbmZ1bmN0aW9uIHNldExheWVyTWFwUHJvcGVydHkobGF5ZXIsIG1hcCkge1xuICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikge1xuICAgIGxheWVyLnNldE1hcEludGVybmFsKG1hcCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICBjb25zdCBsYXllcnMgPSBsYXllci5nZXRMYXllcnMoKS5nZXRBcnJheSgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBzZXRMYXllck1hcFByb3BlcnR5KGxheWVyc1tpXSwgbWFwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaGUgbWFwIGlzIHRoZSBjb3JlIGNvbXBvbmVudCBvZiBPcGVuTGF5ZXJzLiBGb3IgYSBtYXAgdG8gcmVuZGVyLCBhIHZpZXcsXG4gKiBvbmUgb3IgbW9yZSBsYXllcnMsIGFuZCBhIHRhcmdldCBjb250YWluZXIgYXJlIG5lZWRlZDpcbiAqXG4gKiAgICAgaW1wb3J0IE1hcCBmcm9tICdvbC9NYXAuanMnO1xuICogICAgIGltcG9ydCBWaWV3IGZyb20gJ29sL1ZpZXcuanMnO1xuICogICAgIGltcG9ydCBUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVGlsZS5qcyc7XG4gKiAgICAgaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNLmpzJztcbiAqXG4gKiAgICAgY29uc3QgbWFwID0gbmV3IE1hcCh7XG4gKiAgICAgICB2aWV3OiBuZXcgVmlldyh7XG4gKiAgICAgICAgIGNlbnRlcjogWzAsIDBdLFxuICogICAgICAgICB6b29tOiAxLFxuICogICAgICAgfSksXG4gKiAgICAgICBsYXllcnM6IFtcbiAqICAgICAgICAgbmV3IFRpbGVMYXllcih7XG4gKiAgICAgICAgICAgc291cmNlOiBuZXcgT1NNKCksXG4gKiAgICAgICAgIH0pLFxuICogICAgICAgXSxcbiAqICAgICAgIHRhcmdldDogJ21hcCcsXG4gKiAgICAgfSk7XG4gKlxuICogVGhlIGFib3ZlIHNuaXBwZXQgY3JlYXRlcyBhIG1hcCB1c2luZyBhIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvVGlsZX5UaWxlTGF5ZXJ9IHRvXG4gKiBkaXNwbGF5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL09TTX5PU019IE9TTSBkYXRhIGFuZCByZW5kZXIgaXQgdG8gYSBET01cbiAqIGVsZW1lbnQgd2l0aCB0aGUgaWQgYG1hcGAuXG4gKlxuICogVGhlIGNvbnN0cnVjdG9yIHBsYWNlcyBhIHZpZXdwb3J0IGNvbnRhaW5lciAod2l0aCBDU1MgY2xhc3MgbmFtZVxuICogYG9sLXZpZXdwb3J0YCkgaW4gdGhlIHRhcmdldCBlbGVtZW50IChzZWUgYGdldFZpZXdwb3J0KClgKSwgYW5kIHRoZW4gdHdvXG4gKiBmdXJ0aGVyIGVsZW1lbnRzIHdpdGhpbiB0aGUgdmlld3BvcnQ6IG9uZSB3aXRoIENTUyBjbGFzcyBuYW1lXG4gKiBgb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnRgIGZvciBjb250cm9scyBhbmQgc29tZSBvdmVybGF5cywgYW5kIG9uZSB3aXRoXG4gKiBDU1MgY2xhc3MgbmFtZSBgb2wtb3ZlcmxheWNvbnRhaW5lcmAgZm9yIG90aGVyIG92ZXJsYXlzIChzZWUgdGhlIGBzdG9wRXZlbnRgXG4gKiBvcHRpb24gb2Yge0BsaW5rIG1vZHVsZTpvbC9PdmVybGF5fk92ZXJsYXl9IGZvciB0aGUgZGlmZmVyZW5jZSkuIFRoZSBtYXBcbiAqIGl0c2VsZiBpcyBwbGFjZWQgaW4gYSBmdXJ0aGVyIGVsZW1lbnQgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBMYXllcnMgYXJlIHN0b3JlZCBhcyBhIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBpblxuICogbGF5ZXJHcm91cHMuIEEgdG9wLWxldmVsIGdyb3VwIGlzIHByb3ZpZGVkIGJ5IHRoZSBsaWJyYXJ5LiBUaGlzIGlzIHdoYXQgaXNcbiAqIGFjY2Vzc2VkIGJ5IGBnZXRMYXllckdyb3VwYCBhbmQgYHNldExheWVyR3JvdXBgLiBMYXllcnMgZW50ZXJlZCBpbiB0aGVcbiAqIG9wdGlvbnMgYXJlIGFkZGVkIHRvIHRoaXMgZ3JvdXAsIGFuZCBgYWRkTGF5ZXJgIGFuZCBgcmVtb3ZlTGF5ZXJgIGNoYW5nZSB0aGVcbiAqIGxheWVyIGNvbGxlY3Rpb24gaW4gdGhlIGdyb3VwLiBgZ2V0TGF5ZXJzYCBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvclxuICogYGdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKWAuIE5vdGUgdGhhdCB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0dyb3VwfkxheWVyR3JvdXB9XG4gKiBpcyBhIHN1YmNsYXNzIG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZX5CYXNlTGF5ZXJ9LCBzbyBsYXllcnMgZW50ZXJlZCBpbiB0aGVcbiAqIG9wdGlvbnMgb3IgYWRkZWQgd2l0aCBgYWRkTGF5ZXJgIGNhbiBiZSBncm91cHMsIHdoaWNoIGNhbiBjb250YWluIGZ1cnRoZXJcbiAqIGdyb3VwcywgYW5kIHNvIG9uLlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudC5qc1wiKS5NYXBCcm93c2VyRXZlbnRcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEV2ZW50LmpzXCIpLk1hcEV2ZW50XG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9yZW5kZXIvRXZlbnQuanNcIikuZGVmYXVsdCNwcmVjb21wb3NlXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9yZW5kZXIvRXZlbnQuanNcIikuZGVmYXVsdCNwb3N0Y29tcG9zZVxuICogQGZpcmVzIGltcG9ydChcIi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHQjcmVuZGVyY29tcGxldGVcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTWFwIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge01hcE9wdGlvbnN9IFtvcHRpb25zXSBNYXAgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge01hcEV2ZW50SGFuZGxlcjxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge01hcEV2ZW50SGFuZGxlcjxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7TWFwRXZlbnRIYW5kbGVyPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBjb25zdCBvcHRpb25zSW50ZXJuYWwgPSBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyQ29tcGxldGVfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkXyA9IHRydWU7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50XyA9IHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhUaWxlc0xvYWRpbmdfID1cbiAgICAgIG9wdGlvbnMubWF4VGlsZXNMb2FkaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFRpbGVzTG9hZGluZyA6IDE2O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPVxuICAgICAgb3B0aW9ucy5waXhlbFJhdGlvICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnBpeGVsUmF0aW9cbiAgICAgICAgOiBERVZJQ0VfUElYRUxfUkFUSU87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25EZWxheUtleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfID0gdGhpcy5hbmltYXRpb25EZWxheV8uYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZUluZGV4XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RnJhbWVTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHRlbnQgYXQgdGhlIHByZXZpb3VzICdtb3ZlZW5kJyBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c0V4dGVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudmlld3BvcnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy52aWV3cG9ydF8uY2xhc3NOYW1lID1cbiAgICAgICdvbC12aWV3cG9ydCcgKyAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93ID8gJyBvbC10b3VjaCcgOiAnJyk7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLnpJbmRleCA9ICcwJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLmNsYXNzTmFtZSA9ICdvbC1vdmVybGF5Y29udGFpbmVyJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlDb250YWluZXJfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS56SW5kZXggPSAnMCc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5jbGFzc05hbWUgPSAnb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnQnO1xuICAgIHRoaXMudmlld3BvcnRfLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TWFwQnJvd3NlckV2ZW50SGFuZGxlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdmVUb2xlcmFuY2VfID0gb3B0aW9ucy5tb3ZlVG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0XyA9IG9wdGlvbnNJbnRlcm5hbC5rZXlib2FyZEV2ZW50VGFyZ2V0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldEVsZW1lbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1Jlc2l6ZU9ic2VydmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMudXBkYXRlU2l6ZSgpKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRyb2xzID0gb3B0aW9uc0ludGVybmFsLmNvbnRyb2xzIHx8IGRlZmF1bHRDb250cm9scygpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMgPVxuICAgICAgb3B0aW9uc0ludGVybmFsLmludGVyYWN0aW9ucyB8fFxuICAgICAgZGVmYXVsdEludGVyYWN0aW9ucyh7XG4gICAgICAgIG9uRm9jdXNPbmx5OiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlzXyA9IG9wdGlvbnNJbnRlcm5hbC5vdmVybGF5cztcblxuICAgIC8qKlxuICAgICAqIEEgbG9va3VwIG9mIG92ZXJsYXlzIGJ5IGlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlJZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vcmVuZGVyZXIvTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxQb3N0UmVuZGVyRnVuY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMucG9zdFJlbmRlckZ1bmN0aW9uc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1RpbGVRdWV1ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVRdWV1ZV8gPSBuZXcgVGlsZVF1ZXVlKFxuICAgICAgdGhpcy5nZXRUaWxlUHJpb3JpdHkuYmluZCh0aGlzKSxcbiAgICAgIHRoaXMuaGFuZGxlVGlsZUNoYW5nZV8uYmluZCh0aGlzKSxcbiAgICApO1xuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihcbiAgICAgIE1hcFByb3BlcnR5LkxBWUVSR1JPVVAsXG4gICAgICB0aGlzLmhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXyxcbiAgICApO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoTWFwUHJvcGVydHkuVklFVywgdGhpcy5oYW5kbGVWaWV3Q2hhbmdlZF8pO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoTWFwUHJvcGVydHkuU0laRSwgdGhpcy5oYW5kbGVTaXplQ2hhbmdlZF8pO1xuICAgIHRoaXMuYWRkQ2hhbmdlTGlzdGVuZXIoTWFwUHJvcGVydHkuVEFSR0VULCB0aGlzLmhhbmRsZVRhcmdldENoYW5nZWRfKTtcblxuICAgIC8vIHNldFByb3BlcnRpZXMgd2lsbCB0cmlnZ2VyIHRoZSByZW5kZXJpbmcgb2YgdGhlIG1hcCBpZiB0aGUgbWFwXG4gICAgLy8gaXMgXCJkZWZpbmVkXCIgYWxyZWFkeS5cbiAgICB0aGlzLnNldFByb3BlcnRpZXMob3B0aW9uc0ludGVybmFsLnZhbHVlcyk7XG5cbiAgICBjb25zdCBtYXAgPSB0aGlzO1xuICAgIGlmIChvcHRpb25zLnZpZXcgJiYgIShvcHRpb25zLnZpZXcgaW5zdGFuY2VvZiBWaWV3KSkge1xuICAgICAgb3B0aW9ucy52aWV3LnRoZW4oZnVuY3Rpb24gKHZpZXdPcHRpb25zKSB7XG4gICAgICAgIG1hcC5zZXRWaWV3KG5ldyBWaWV3KHZpZXdPcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnRcbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKHRoaXMpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5jb250cm9scy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9ucy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcCh0aGlzKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKG51bGwpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5vdmVybGF5c18uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLmFkZE92ZXJsYXlJbnRlcm5hbF8oZXZlbnQuZWxlbWVudCk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICB0aGlzLm92ZXJsYXlzXy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZXZlbnQuZWxlbWVudC5nZXRJZCgpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm92ZXJsYXlJZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAgICAgKi9cbiAgICAgIChjb250cm9sKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuc2V0TWFwKHRoaXMpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMuZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR9IGludGVyYWN0aW9uIEludGVyYWN0aW9uLlxuICAgICAgICovXG4gICAgICAoaW50ZXJhY3Rpb24pID0+IHtcbiAgICAgICAgaW50ZXJhY3Rpb24uc2V0TWFwKHRoaXMpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgdGhpcy5vdmVybGF5c18uZm9yRWFjaCh0aGlzLmFkZE92ZXJsYXlJbnRlcm5hbF8uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdH0gY29udHJvbCBDb250cm9sLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRDb250cm9sKGNvbnRyb2wpIHtcbiAgICB0aGlzLmdldENvbnRyb2xzKCkucHVzaChjb250cm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIGludGVyYWN0aW9uIHRvIHRoZSBtYXAuIElmIHlvdSB3YW50IHRvIGFkZCBhbiBpbnRlcmFjdGlvblxuICAgKiBhdCBhbm90aGVyIHBvaW50IG9mIHRoZSBjb2xsZWN0aW9uIHVzZSBgZ2V0SW50ZXJhY3Rpb25zKClgIGFuZCB0aGUgbWV0aG9kc1xuICAgKiBhdmFpbGFibGUgb24ge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG4gICAqIHN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uIGZyb20gdGhlIGhhbmRsZUV2ZW50IGZ1bmN0aW9uLiBUaGUgaW50ZXJhY3Rpb25zXG4gICAqIGdldCB0byBoYW5kbGUgdGhlIGV2ZW50cyBpbiB0aGUgcmV2ZXJzZSBvcmRlciBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fSBpbnRlcmFjdGlvbiBJbnRlcmFjdGlvbiB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5wdXNoKGludGVyYWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgdG9wIG9mIHRoaXMgbWFwLiBJZiB5b3Ugd2FudCB0byBhZGQgYSBsYXllclxuICAgKiBlbHNld2hlcmUgaW4gdGhlIHN0YWNrLCB1c2UgYGdldExheWVycygpYCBhbmQgdGhlIG1ldGhvZHMgYXZhaWxhYmxlIG9uXG4gICAqIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9Hcm91cC5qc1wiKS5Hcm91cEV2ZW50fSBldmVudCBUaGUgbGF5ZXIgYWRkIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJBZGRfKGV2ZW50KSB7XG4gICAgc2V0TGF5ZXJNYXBQcm9wZXJ0eShldmVudC5sYXllciwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBvdmVybGF5IHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRkT3ZlcmxheShvdmVybGF5KSB7XG4gICAgdGhpcy5nZXRPdmVybGF5cygpLnB1c2gob3ZlcmxheSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZWFscyB3aXRoIG1hcCdzIG92ZXJsYXkgY29sbGVjdGlvbiBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRPdmVybGF5SW50ZXJuYWxfKG92ZXJsYXkpIHtcbiAgICBjb25zdCBpZCA9IG92ZXJsYXkuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV0gPSBvdmVybGF5O1xuICAgIH1cbiAgICBvdmVybGF5LnNldE1hcCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy5jb250cm9scy5jbGVhcigpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5vdmVybGF5c18uY2xlYXIoKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5zZXRUYXJnZXQobnVsbCk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LCBhbmQgZXhlY3V0ZSBhXG4gICAqIGNhbGxiYWNrIHdpdGggZWFjaCBpbnRlcnNlY3RpbmcgZmVhdHVyZS4gTGF5ZXJzIGluY2x1ZGVkIGluIHRoZSBkZXRlY3Rpb24gY2FuXG4gICAqIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaCB0aGUgYGxheWVyRmlsdGVyYCBvcHRpb24gaW4gYG9wdGlvbnNgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgaW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vc291cmNlL1NvdXJjZVwiKS5kZWZhdWx0PiwgaW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50cy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIG9uZVxuICAgKiAgICAge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUgZmVhdHVyZX0gb3JcbiAgICogICAgIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV+UmVuZGVyRmVhdHVyZSByZW5kZXIgZmVhdHVyZX0gYXQgdGhlIHBpeGVsLCB0aGUgc2Vjb25kIGlzXG4gICAqICAgICB0aGUge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciBsYXllcn0gb2YgdGhlIGZlYXR1cmUgYW5kIHdpbGwgYmUgbnVsbCBmb3JcbiAgICogICAgIHVubWFuYWdlZCBsYXllcnMuIFRvIHN0b3AgZGV0ZWN0aW9uLCBjYWxsYmFjayBmdW5jdGlvbnMgY2FuIHJldHVybiBhXG4gICAqICAgICB0cnV0aHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7QXRQaXhlbE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LCBpLmUuIHRoZSByZXR1cm4gdmFsdWUgb2YgbGFzdFxuICAgKiBjYWxsYmFjayBleGVjdXRpb24sIG9yIHRoZSBmaXJzdCB0cnV0aHkgY2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfIHx8ICF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG4gICAgY29uc3QgaGl0VG9sZXJhbmNlID1cbiAgICAgIG9wdGlvbnMuaGl0VG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG4gICAgY29uc3QgbGF5ZXJGaWx0ZXIgPVxuICAgICAgb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYXllckZpbHRlciA6IFRSVUU7XG4gICAgY29uc3QgY2hlY2tXcmFwcGVkID0gb3B0aW9ucy5jaGVja1dyYXBwZWQgIT09IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsXG4gICAgICB0aGlzLmZyYW1lU3RhdGVfLFxuICAgICAgaGl0VG9sZXJhbmNlLFxuICAgICAgY2hlY2tXcmFwcGVkLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBudWxsLFxuICAgICAgbGF5ZXJGaWx0ZXIsXG4gICAgICBudWxsLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT59IFRoZSBkZXRlY3RlZCBmZWF0dXJlcyBvclxuICAgKiBhbiBlbXB0eSBhcnJheSBpZiBub25lIHdlcmUgZm91bmQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzQXRQaXhlbChwaXhlbCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgdGhpcy5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwoXG4gICAgICBwaXhlbCxcbiAgICAgIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGxheWVycyBmcm9tIGFsbCBsYXllciBncm91cHMuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdD59IExheWVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QWxsTGF5ZXJzKCkge1xuICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZExheWVyc0Zyb20obGF5ZXJHcm91cCkge1xuICAgICAgbGF5ZXJHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgICAgYWRkTGF5ZXJzRnJvbShsYXllci5nZXRMYXllcnMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgYWRkTGF5ZXJzRnJvbSh0aGlzLmdldExheWVycygpKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBmZWF0dXJlcyBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQuIExheWVycyBpbmNsdWRlZCBpbiB0aGVcbiAgICogZGV0ZWN0aW9uIGNhbiBiZSBjb25maWd1cmVkIHRocm91Z2ggdGhlIGBsYXllckZpbHRlcmAgb3B0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBwaXhlbD9cbiAgICogQGFwaVxuICAgKi9cbiAgaGFzRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8gfHwgIXRoaXMucmVuZGVyZXJfKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChwaXhlbCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCBsYXllckZpbHRlciA9XG4gICAgICBvcHRpb25zLmxheWVyRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxheWVyRmlsdGVyIDogVFJVRTtcbiAgICBjb25zdCBoaXRUb2xlcmFuY2UgPVxuICAgICAgb3B0aW9ucy5oaXRUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaGl0VG9sZXJhbmNlIDogMDtcbiAgICBjb25zdCBjaGVja1dyYXBwZWQgPSBvcHRpb25zLmNoZWNrV3JhcHBlZCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmhhc0ZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLFxuICAgICAgdGhpcy5mcmFtZVN0YXRlXyxcbiAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgIGNoZWNrV3JhcHBlZCxcbiAgICAgIGxheWVyRmlsdGVyLFxuICAgICAgbnVsbCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgaW4gdXNlciBwcm9qZWN0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFdmVudENvb3JkaW5hdGUoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMuZ2V0RXZlbnRQaXhlbChldmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgaW4gdmlldyBwcm9qZWN0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKi9cbiAgZ2V0RXZlbnRDb29yZGluYXRlSW50ZXJuYWwoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwodGhpcy5nZXRFdmVudFBpeGVsKGV2ZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWFwIHBpeGVsIHBvc2l0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge1VJRXZlbnR8e2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfX0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IFBpeGVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFdmVudFBpeGVsKGV2ZW50KSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0XztcbiAgICBjb25zdCB2aWV3cG9ydFBvc2l0aW9uID0gdmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgdmlld3BvcnRTaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgY29uc3Qgc2NhbGVYID0gdmlld3BvcnRQb3NpdGlvbi53aWR0aCAvIHZpZXdwb3J0U2l6ZVswXTtcbiAgICBjb25zdCBzY2FsZVkgPSB2aWV3cG9ydFBvc2l0aW9uLmhlaWdodCAvIHZpZXdwb3J0U2l6ZVsxXTtcbiAgICBjb25zdCBldmVudFBvc2l0aW9uID1cbiAgICAgIC8vRklYTUUgQXJlIHdlIHJlYWxseSBjYWxsaW5nIHRoaXMgd2l0aCBhIFRvdWNoRXZlbnQgYW55d2hlcmU/XG4gICAgICAnY2hhbmdlZFRvdWNoZXMnIGluIGV2ZW50XG4gICAgICAgID8gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyAoZXZlbnQpLmNoYW5nZWRUb3VjaGVzWzBdXG4gICAgICAgIDogLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAoZXZlbnQpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIChldmVudFBvc2l0aW9uLmNsaWVudFggLSB2aWV3cG9ydFBvc2l0aW9uLmxlZnQpIC8gc2NhbGVYLFxuICAgICAgKGV2ZW50UG9zaXRpb24uY2xpZW50WSAtIHZpZXdwb3J0UG9zaXRpb24udG9wKSAvIHNjYWxlWSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFyZ2V0IGluIHdoaWNoIHRoaXMgbWFwIGlzIHJlbmRlcmVkLlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHdoYXQgaXMgZW50ZXJlZCBhcyBhbiBvcHRpb24gb3IgaW4gc2V0VGFyZ2V0OlxuICAgKiBpZiB0aGF0IHdhcyBhbiBlbGVtZW50LCBpdCByZXR1cm5zIGFuIGVsZW1lbnQ7IGlmIGEgc3RyaW5nLCBpdCByZXR1cm5zIHRoYXQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fHN0cmluZ3x1bmRlZmluZWR9IFRoZSBFbGVtZW50IG9yIGlkIG9mIHRoZSBFbGVtZW50IHRoYXQgdGhlXG4gICAqICAgICBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChNYXBQcm9wZXJ0eS5UQVJHRVQpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIERPTSBlbGVtZW50IGludG8gd2hpY2ggdGhpcyBtYXAgaXMgcmVuZGVyZWQuIEluIGNvbnRyYXN0IHRvXG4gICAqIGBnZXRUYXJnZXRgIHRoaXMgbWV0aG9kIGFsd2F5cyByZXR1cm4gYW4gYEVsZW1lbnRgLCBvciBgbnVsbGAgaWYgdGhlXG4gICAqIG1hcCBoYXMgbm8gdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIGVsZW1lbnQgdGhhdCB0aGUgbWFwIGlzIHJlbmRlcmVkIGluLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUYXJnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldEVsZW1lbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBwaXhlbC4gIFRoaXMgcmV0dXJucyBhIGNvb3JkaW5hdGUgaW4gdGhlXG4gICAqIHVzZXIgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgZm9yIHRoZSBwaXhlbCBwb3NpdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0b1VzZXJDb29yZGluYXRlKFxuICAgICAgdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpLFxuICAgICAgdGhpcy5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb29yZGluYXRlIGZvciBhIGdpdmVuIHBpeGVsLiAgVGhpcyByZXR1cm5zIGEgY29vcmRpbmF0ZSBpbiB0aGVcbiAgICogbWFwIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgZm9yIHRoZSBwaXhlbCBwb3NpdGlvbi5cbiAgICovXG4gIGdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChwaXhlbCkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLCBwaXhlbC5zbGljZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBjb250cm9scy4gTW9kaWZ5aW5nIHRoaXMgY29sbGVjdGlvbiBjaGFuZ2VzIHRoZSBjb250cm9sc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gQ29udHJvbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbnRyb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIG92ZXJsYXlzLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIG92ZXJsYXlzXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gT3ZlcmxheXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE92ZXJsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb3ZlcmxheSBieSBpdHMgaWRlbnRpZmllciAodGhlIHZhbHVlIHJldHVybmVkIGJ5IG92ZXJsYXkuZ2V0SWQoKSkuXG4gICAqIE5vdGUgdGhhdCB0aGUgaW5kZXggdHJlYXRzIHN0cmluZyBhbmQgbnVtZXJpYyBpZGVudGlmaWVycyBhcyB0aGUgc2FtZS4gU29cbiAgICogYG1hcC5nZXRPdmVybGF5QnlJZCgyKWAgd2lsbCByZXR1cm4gYW4gb3ZlcmxheSB3aXRoIGlkIGAnMidgIG9yIGAyYC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCBPdmVybGF5IGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fG51bGx9IE92ZXJsYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE92ZXJsYXlCeUlkKGlkKSB7XG4gICAgY29uc3Qgb3ZlcmxheSA9IHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIHJldHVybiBvdmVybGF5ICE9PSB1bmRlZmluZWQgPyBvdmVybGF5IDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBpbnRlcmFjdGlvbnMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgaW50ZXJhY3Rpb25zXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKlxuICAgKiBJbnRlcmFjdGlvbnMgYXJlIHVzZWQgZm9yIGUuZy4gcGFuLCB6b29tIGFuZCByb3RhdGUuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gSW50ZXJhY3Rpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbnRlcmFjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXJncm91cCBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXAuXG4gICAqIEByZXR1cm4ge0xheWVyR3JvdXB9IEEgbGF5ZXIgZ3JvdXAgY29udGFpbmluZyB0aGUgbGF5ZXJzIGluIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXllckdyb3VwKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge0xheWVyR3JvdXB9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5MQVlFUkdST1VQKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYW55IGV4aXN0aW5nIGxheWVycyBhbmQgYWRkIGxheWVycyB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0PnxDb2xsZWN0aW9uPGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIFRoZSBsYXllcnMgdG8gYmUgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGF5ZXJzKGxheWVycykge1xuICAgIGNvbnN0IGdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKGxheWVycyBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIGdyb3VwLnNldExheWVycyhsYXllcnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBncm91cC5nZXRMYXllcnMoKTtcbiAgICBjb2xsZWN0aW9uLmNsZWFyKCk7XG4gICAgY29sbGVjdGlvbi5leHRlbmQobGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gb2YgbGF5ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBMYXllcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExheWVycygpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVycyBoYXZlIHNvdXJjZXMgdGhhdCBhcmUgc3RpbGwgbG9hZGluZy5cbiAgICovXG4gIGdldExvYWRpbmdPck5vdFJlYWR5KCkge1xuICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXNBcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGxheWVyU3RhdGVzQXJyYXlbaV07XG4gICAgICBpZiAoIXN0YXRlLnZpc2libGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlciA9IHN0YXRlLmxheWVyLmdldFJlbmRlcmVyKCk7XG4gICAgICBpZiAocmVuZGVyZXIgJiYgIXJlbmRlcmVyLnJlYWR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc291cmNlID0gc3RhdGUubGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICBpZiAoc291cmNlICYmIHNvdXJjZS5sb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwaXhlbCBmb3IgYSBjb29yZGluYXRlLiAgVGhpcyB0YWtlcyBhIGNvb3JkaW5hdGUgaW4gdGhlIHVzZXJcbiAgICogcHJvamVjdGlvbiBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBBIG1hcCBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBBIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgIGNvbnN0IHZpZXdDb29yZGluYXRlID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHRoaXMuZ2V0VmlldygpLmdldFByb2plY3Rpb24oKSxcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRnJvbUNvb3JkaW5hdGVJbnRlcm5hbCh2aWV3Q29vcmRpbmF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwaXhlbCBmb3IgYSBjb29yZGluYXRlLiAgVGhpcyB0YWtlcyBhIGNvb3JkaW5hdGUgaW4gdGhlIG1hcCB2aWV3XG4gICAqIHByb2plY3Rpb24gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQSBtYXAgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gQSBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKi9cbiAgZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZUludGVybmFsKGNvb3JkaW5hdGUpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oXG4gICAgICBmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLFxuICAgICAgY29vcmRpbmF0ZS5zbGljZSgwLCAyKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIHJlbmRlcmVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3JlbmRlcmVyL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IFJlbmRlcmVyXG4gICAqL1xuICBnZXRSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgbWFwIGluIHRoZSBET00uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChNYXBQcm9wZXJ0eS5TSVpFKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC4gQSB2aWV3IG1hbmFnZXMgcHJvcGVydGllcyBzdWNoIGFzXG4gICAqIGNlbnRlciBhbmQgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7Vmlld30gVGhlIHZpZXcgdGhhdCBjb250cm9scyB0aGlzIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VmlldygpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtWaWV3fSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuVklFVykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFZpZXdwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgdGhlIGNvbnRhaW5lciBmb3Igb3ZlcmxheXMuICBFbGVtZW50cyBhZGRlZCB0b1xuICAgKiB0aGlzIGNvbnRhaW5lciB3aWxsIGxldCBtb3VzZWRvd24gYW5kIHRvdWNoc3RhcnQgZXZlbnRzIHRocm91Z2ggdG8gdGhlIG1hcCxcbiAgICogc28gY2xpY2tzIGFuZCBnZXN0dXJlcyBvbiBhbiBvdmVybGF5IHdpbGwgdHJpZ2dlciB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9XG4gICAqIGV2ZW50cy5cbiAgICogQHJldHVybiB7IUhUTUxFbGVtZW50fSBUaGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIuXG4gICAqL1xuICBnZXRPdmVybGF5Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlDb250YWluZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyBhIGNvbnRhaW5lciBmb3Igb3ZlcmxheXMgdGhhdCBkb24ndCBhbGxvd1xuICAgKiBldmVudCBwcm9wYWdhdGlvbi4gRWxlbWVudHMgYWRkZWQgdG8gdGhpcyBjb250YWluZXIgd29uJ3QgbGV0IG1vdXNlZG93biBhbmRcbiAgICogdG91Y2hzdGFydCBldmVudHMgdGhyb3VnaCB0byB0aGUgbWFwLCBzbyBjbGlja3MgYW5kIGdlc3R1cmVzIG9uIGFuIG92ZXJsYXlcbiAgICogZG9uJ3QgdHJpZ2dlciBhbnkge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fS5cbiAgICogQHJldHVybiB7IUhUTUxFbGVtZW50fSBUaGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIgdGhhdCBzdG9wcyBldmVudHMuXG4gICAqL1xuICBnZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFEb2N1bWVudH0gVGhlIGRvY3VtZW50IHdoZXJlIHRoZSBtYXAgaXMgZGlzcGxheWVkLlxuICAgKi9cbiAgZ2V0T3duZXJEb2N1bWVudCgpIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG4gICAgcmV0dXJuIHRhcmdldEVsZW1lbnQgPyB0YXJnZXRFbGVtZW50Lm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlU291cmNlS2V5IFRpbGUgc291cmNlIGtleS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdGlsZUNlbnRlciBUaWxlIGNlbnRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGVSZXNvbHV0aW9uIFRpbGUgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHByaW9yaXR5LlxuICAgKi9cbiAgZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRpbGVTb3VyY2VLZXksIHRpbGVDZW50ZXIsIHRpbGVSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGdldFRpbGVQcmlvcml0eShcbiAgICAgIHRoaXMuZnJhbWVTdGF0ZV8sXG4gICAgICB0aWxlLFxuICAgICAgdGlsZVNvdXJjZUtleSxcbiAgICAgIHRpbGVDZW50ZXIsXG4gICAgICB0aWxlUmVzb2x1dGlvbixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VUlFdmVudH0gYnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVHlwZS5cbiAgICovXG4gIGhhbmRsZUJyb3dzZXJFdmVudChicm93c2VyRXZlbnQsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSB8fCBicm93c2VyRXZlbnQudHlwZTtcbiAgICBjb25zdCBtYXBCcm93c2VyRXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KHR5cGUsIHRoaXMsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5oYW5kbGVNYXBCcm93c2VyRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IFRoZSBldmVudCB0byBoYW5kbGUuXG4gICAqL1xuICBoYW5kbGVNYXBCcm93c2VyRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfKSB7XG4gICAgICAvLyBXaXRoIG5vIHZpZXcgZGVmaW5lZCwgd2UgY2Fubm90IHRyYW5zbGF0ZSBwaXhlbHMgaW50byBnZW9ncmFwaGljYWxcbiAgICAgIC8vIGNvb3JkaW5hdGVzIHNvIGludGVyYWN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7UG9pbnRlckV2ZW50fSAqLyAoXG4gICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICk7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gb3JpZ2luYWxFdmVudC50eXBlO1xuICAgIGlmIChcbiAgICAgIGV2ZW50VHlwZSA9PT0gUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRE9XTiB8fFxuICAgICAgZXZlbnRUeXBlID09PSBFdmVudFR5cGUuV0hFRUwgfHxcbiAgICAgIGV2ZW50VHlwZSA9PT0gRXZlbnRUeXBlLktFWURPV05cbiAgICApIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuZ2V0T3duZXJEb2N1bWVudCgpO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0aGlzLnZpZXdwb3J0Xy5nZXRSb290Tm9kZVxuICAgICAgICA/IHRoaXMudmlld3BvcnRfLmdldFJvb3ROb2RlKClcbiAgICAgICAgOiBkb2M7XG4gICAgICBjb25zdCB0YXJnZXQgPSAvKiogQHR5cGUge05vZGV9ICovIChvcmlnaW5hbEV2ZW50LnRhcmdldCk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnREb2MgPVxuICAgICAgICByb290Tm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3RcbiAgICAgICAgICA/IHJvb3ROb2RlLmhvc3QgPT09IHRhcmdldFxuICAgICAgICAgICAgPyByb290Tm9kZS5ob3N0Lm93bmVyRG9jdW1lbnRcbiAgICAgICAgICAgIDogcm9vdE5vZGVcbiAgICAgICAgICA6IHJvb3ROb2RlID09PSBkb2NcbiAgICAgICAgICAgID8gZG9jLmRvY3VtZW50RWxlbWVudFxuICAgICAgICAgICAgOiByb290Tm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gQWJvcnQgaWYgdGhlIHRhcmdldCBpcyBhIGNoaWxkIG9mIHRoZSBjb250YWluZXIgZm9yIGVsZW1lbnRzIHdob3NlIGV2ZW50cyBhcmUgbm90IG1lYW50XG4gICAgICAgIC8vIHRvIGJlIGhhbmRsZWQgYnkgbWFwIGludGVyYWN0aW9ucy5cbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5jb250YWlucyh0YXJnZXQpIHx8XG4gICAgICAgIC8vIEFib3J0IGlmIHRoZSBldmVudCB0YXJnZXQgaXMgYSBjaGlsZCBvZiB0aGUgY29udGFpbmVyIHRoYXQgaXMgbm8gbG9uZ2VyIGluIHRoZSBwYWdlLlxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIGZvciB0aGUgdGFyZ2V0IHRvIG5vIGxvbmdlciBiZSBpbiB0aGUgcGFnZSBpZiBpdCBoYXMgYmVlbiByZW1vdmVkIGluIGFuXG4gICAgICAgIC8vIGV2ZW50IGxpc3RlbmVyLCB0aGlzIG1pZ2h0IGhhcHBlbiBpbiBhIENvbnRyb2wgdGhhdCByZWNyZWF0ZXMgaXQncyBjb250ZW50IGJhc2VkIG9uXG4gICAgICAgIC8vIHVzZXIgaW50ZXJhY3Rpb24gZWl0aGVyIG1hbnVhbGx5IG9yIHZpYSBhIHJlbmRlciBpbiBzb21ldGhpbmcgbGlrZSBodHRwczovL3JlYWN0anMub3JnL1xuICAgICAgICAhY3VycmVudERvYy5jb250YWlucyh0YXJnZXQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXBCcm93c2VyRXZlbnQuZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hFdmVudChtYXBCcm93c2VyRXZlbnQpICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgaW50ZXJhY3Rpb25zQXJyYXkgPSB0aGlzLmdldEludGVyYWN0aW9ucygpLmdldEFycmF5KCkuc2xpY2UoKTtcbiAgICAgIGZvciAobGV0IGkgPSBpbnRlcmFjdGlvbnNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uc0FycmF5W2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaW50ZXJhY3Rpb24uZ2V0TWFwKCkgIT09IHRoaXMgfHxcbiAgICAgICAgICAhaW50ZXJhY3Rpb24uZ2V0QWN0aXZlKCkgfHxcbiAgICAgICAgICAhdGhpcy5nZXRUYXJnZXRFbGVtZW50KClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udCA9IGludGVyYWN0aW9uLmhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIGlmICghY29udCB8fCBtYXBCcm93c2VyRXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlUG9zdFJlbmRlcigpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcblxuICAgIC8vIE1hbmFnZSB0aGUgdGlsZSBxdWV1ZVxuICAgIC8vIEltYWdlIGxvYWRzIGFyZSBleHBlbnNpdmUgYW5kIGEgbGltaXRlZCByZXNvdXJjZSwgc28gdHJ5IHRvIHVzZSB0aGVtXG4gICAgLy8gZWZmaWNpZW50bHk6XG4gICAgLy8gKiBXaGVuIHRoZSB2aWV3IGlzIHN0YXRpYyB3ZSBhbGxvdyBhIGxhcmdlIG51bWJlciBvZiBwYXJhbGxlbCB0aWxlIGxvYWRzXG4gICAgLy8gICB0byBjb21wbGV0ZSB0aGUgZnJhbWUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgICAvLyAqIFdoZW4gYW5pbWF0aW5nIG9yIGludGVyYWN0aW5nLCBpbWFnZSBsb2FkcyBjYW4gY2F1c2UgamFua3MsIHNvIHdlIHJlZHVjZVxuICAgIC8vICAgdGhlIG1heGltdW0gbnVtYmVyIG9mIGxvYWRzIHBlciBmcmFtZSBhbmQgbGltaXQgdGhlIG51bWJlciBvZiBwYXJhbGxlbFxuICAgIC8vICAgdGlsZSBsb2FkcyB0byByZW1haW4gcmVhY3RpdmUgdG8gdmlldyBjaGFuZ2VzIGFuZCB0byByZWR1Y2UgdGhlIGNoYW5jZSBvZlxuICAgIC8vICAgbG9hZGluZyB0aWxlcyB0aGF0IHdpbGwgcXVpY2tseSBkaXNhcHBlYXIgZnJvbSB2aWV3LlxuICAgIGNvbnN0IHRpbGVRdWV1ZSA9IHRoaXMudGlsZVF1ZXVlXztcbiAgICBpZiAoIXRpbGVRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIGxldCBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLm1heFRpbGVzTG9hZGluZ187XG4gICAgICBsZXQgbWF4TmV3TG9hZHMgPSBtYXhUb3RhbExvYWRpbmc7XG4gICAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgICBjb25zdCBoaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgICAgICBpZiAoaGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSB8fCBoaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pIHtcbiAgICAgICAgICBjb25zdCBsb3dPbkZyYW1lQnVkZ2V0ID0gRGF0ZS5ub3coKSAtIGZyYW1lU3RhdGUudGltZSA+IDg7XG4gICAgICAgICAgbWF4VG90YWxMb2FkaW5nID0gbG93T25GcmFtZUJ1ZGdldCA/IDAgOiA4O1xuICAgICAgICAgIG1heE5ld0xvYWRzID0gbG93T25GcmFtZUJ1ZGdldCA/IDAgOiAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGlsZVF1ZXVlLmdldFRpbGVzTG9hZGluZygpIDwgbWF4VG90YWxMb2FkaW5nKSB7XG4gICAgICAgIHRpbGVRdWV1ZS5yZXByaW9yaXRpemUoKTsgLy8gRklYTUUgb25seSBjYWxsIGlmIHZpZXcgaGFzIGNoYW5nZWRcbiAgICAgICAgdGlsZVF1ZXVlLmxvYWRNb3JlVGlsZXMobWF4VG90YWxMb2FkaW5nLCBtYXhOZXdMb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lU3RhdGUgJiYgdGhpcy5yZW5kZXJlcl8gJiYgIWZyYW1lU3RhdGUuYW5pbWF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyQ29tcGxldGVfKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5SRU5ERVJDT01QTEVURSkpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyXy5kaXNwYXRjaFJlbmRlckV2ZW50KFxuICAgICAgICAgICAgUmVuZGVyRXZlbnRUeXBlLlJFTkRFUkNPTVBMRVRFLFxuICAgICAgICAgICAgZnJhbWVTdGF0ZSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZF8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZWRfID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgTWFwRXZlbnQoTWFwRXZlbnRUeXBlLkxPQURFTkQsIHRoaXMsIGZyYW1lU3RhdGUpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2FkZWRfID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9hZGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5MT0FEU1RBUlQsIHRoaXMsIGZyYW1lU3RhdGUpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBvc3RSZW5kZXJGdW5jdGlvbnMgPSB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc3RSZW5kZXJGdW5jdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uc1tpXSh0aGlzLCBmcmFtZVN0YXRlKTtcbiAgICB9XG4gICAgcG9zdFJlbmRlckZ1bmN0aW9ucy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTaXplQ2hhbmdlZF8oKSB7XG4gICAgaWYgKHRoaXMuZ2V0VmlldygpICYmICF0aGlzLmdldFZpZXcoKS5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5nZXRWaWV3KCkucmVzb2x2ZUNvbnN0cmFpbnRzKDApO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRhcmdldENoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLnRhcmdldENoYW5nZUhhbmRsZXJLZXlzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHVubGlzdGVuQnlLZXkodGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c19baV0pO1xuICAgICAgfVxuICAgICAgdGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c18gPSBudWxsO1xuICAgICAgdGhpcy52aWV3cG9ydF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLkNPTlRFWFRNRU5VLFxuICAgICAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50XyxcbiAgICAgICk7XG4gICAgICB0aGlzLnZpZXdwb3J0Xy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBFdmVudFR5cGUuV0hFRUwsXG4gICAgICAgIHRoaXMuYm91bmRIYW5kbGVCcm93c2VyRXZlbnRfLFxuICAgICAgKTtcbiAgICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG4gICAgICB0aGlzLnZpZXdwb3J0Xy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXJnZXRFbGVtZW50Xykge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlcl8udW5vYnNlcnZlKHRoaXMudGFyZ2V0RWxlbWVudF8pO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0aGlzLnRhcmdldEVsZW1lbnRfLmdldFJvb3ROb2RlKCk7XG4gICAgICBpZiAocm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLnVub2JzZXJ2ZShyb290Tm9kZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U2l6ZSh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIC8vIHRhcmdldCBtYXkgYmUgdW5kZWZpbmVkLCBudWxsLCBhIHN0cmluZyBvciBhbiBFbGVtZW50LlxuICAgIC8vIElmIGl0J3MgYSBzdHJpbmcgd2UgY29udmVydCBpdCB0byBhbiBFbGVtZW50IGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIC8vIElmIGl0J3Mgbm90IG5vdyBhbiBFbGVtZW50IHdlIHJlbW92ZSB0aGUgdmlld3BvcnQgZnJvbSB0aGUgRE9NLlxuICAgIC8vIElmIGl0J3MgYW4gRWxlbWVudCB3ZSBhcHBlbmQgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gaXQuXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPVxuICAgICAgdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpIDogdGFyZ2V0O1xuICAgIHRoaXMudGFyZ2V0RWxlbWVudF8gPSB0YXJnZXRFbGVtZW50O1xuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZXJfKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyk7XG4gICAgICAgIHRoaXMucG9zdFJlbmRlclRpbWVvdXRIYW5kbGVfID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucmVuZGVyZXJfLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlcl8gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy52aWV3cG9ydF8pO1xuICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyXyA9IG5ldyBDb21wb3NpdGVNYXBSZW5kZXJlcih0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXyA9IG5ldyBNYXBCcm93c2VyRXZlbnRIYW5kbGVyKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLm1vdmVUb2xlcmFuY2VfLFxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIE1hcEJyb3dzZXJFdmVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGVba2V5XSxcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hcEJyb3dzZXJFdmVudC5iaW5kKHRoaXMpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy52aWV3cG9ydF8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLkNPTlRFWFRNRU5VLFxuICAgICAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50XyxcbiAgICAgICAgZmFsc2UsXG4gICAgICApO1xuICAgICAgdGhpcy52aWV3cG9ydF8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLldIRUVMLFxuICAgICAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50XyxcbiAgICAgICAgUEFTU0lWRV9FVkVOVF9MSVNURU5FUlMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UsXG4gICAgICApO1xuXG4gICAgICBsZXQga2V5Ym9hcmRFdmVudFRhcmdldDtcbiAgICAgIGlmICghdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0Xykge1xuICAgICAgICAvLyBjaGVjayBpZiBtYXAgdGFyZ2V0IGlzIGluIHNoYWRvd0RPTSwgaWYgeWVzIHVzZSBob3N0IGVsZW1lbnQgYXMgdGFyZ2V0XG4gICAgICAgIGNvbnN0IHRhcmdldFJvb3QgPSB0YXJnZXRFbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldENhbmRpZGF0ZSA9XG4gICAgICAgICAgdGFyZ2V0Um9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyB0YXJnZXRSb290Lmhvc3QgOiB0YXJnZXRFbGVtZW50O1xuICAgICAgICBrZXlib2FyZEV2ZW50VGFyZ2V0ID0gdGFyZ2V0Q2FuZGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5Ym9hcmRFdmVudFRhcmdldCA9IHRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF87XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGFyZ2V0Q2hhbmdlSGFuZGxlcktleXNfID0gW1xuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAga2V5Ym9hcmRFdmVudFRhcmdldCxcbiAgICAgICAgICBFdmVudFR5cGUuS0VZRE9XTixcbiAgICAgICAgICB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICApLFxuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAga2V5Ym9hcmRFdmVudFRhcmdldCxcbiAgICAgICAgICBFdmVudFR5cGUuS0VZUFJFU1MsXG4gICAgICAgICAgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgKSxcbiAgICAgIF07XG4gICAgICBjb25zdCByb290Tm9kZSA9IHRhcmdldEVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIGlmIChyb290Tm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlcl8ub2JzZXJ2ZShyb290Tm9kZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLm9ic2VydmUodGFyZ2V0RWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgLy8gdXBkYXRlU2l6ZSBjYWxscyBzZXRTaXplLCBzbyBubyBuZWVkIHRvIGNhbGwgdGhpcy5yZW5kZXJcbiAgICAvLyBvdXJzZWx2ZXMgaGVyZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVGlsZUNoYW5nZV8oKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8oKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVmlld0NoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSB0aGlzLmdldFZpZXcoKTtcbiAgICBpZiAodmlldykge1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydFNpemVfKHRoaXMuZ2V0U2l6ZSgpKTtcblxuICAgICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBsaXN0ZW4oXG4gICAgICAgIHZpZXcsXG4gICAgICAgIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXyxcbiAgICAgICAgdGhpcyxcbiAgICAgICk7XG4gICAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBsaXN0ZW4oXG4gICAgICAgIHZpZXcsXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8sXG4gICAgICAgIHRoaXMsXG4gICAgICApO1xuXG4gICAgICB2aWV3LnJlc29sdmVDb25zdHJhaW50cygwKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJHcm91cENoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18pIHtcbiAgICAgIHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXJHcm91cCA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpO1xuICAgIGlmIChsYXllckdyb3VwKSB7XG4gICAgICB0aGlzLmhhbmRsZUxheWVyQWRkXyhuZXcgR3JvdXBFdmVudCgnYWRkbGF5ZXInLCBsYXllckdyb3VwKSk7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBbXG4gICAgICAgIGxpc3RlbihsYXllckdyb3VwLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsIHRoaXMucmVuZGVyLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGxheWVyR3JvdXAsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMucmVuZGVyLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGxheWVyR3JvdXAsICdhZGRsYXllcicsIHRoaXMuaGFuZGxlTGF5ZXJBZGRfLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGxheWVyR3JvdXAsICdyZW1vdmVsYXllcicsIHRoaXMuaGFuZGxlTGF5ZXJSZW1vdmVfLCB0aGlzKSxcbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgcmVuZGVyZWQuXG4gICAqL1xuICBpc1JlbmRlcmVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuZnJhbWVTdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFuaW1hdGlvbkRlbGF5XygpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkRlbGF5S2V5XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlbmRlckZyYW1lXyhEYXRlLm5vdygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbiBpbW1lZGlhdGUgcmVuZGVyIGluIGEgc3luY2hyb25vdXMgbWFubmVyLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW5kZXJTeW5jKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EZWxheUtleV8pO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbkRlbGF5XygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHJhd3MgYWxsIHRleHQgYWZ0ZXIgbmV3IGZvbnRzIGhhdmUgbG9hZGVkXG4gICAqL1xuICByZWRyYXdUZXh0KCkge1xuICAgIGNvbnN0IGxheWVyU3RhdGVzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJTdGF0ZXNBcnJheSgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxheWVyU3RhdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJTdGF0ZXNbaV0ubGF5ZXI7XG4gICAgICBpZiAobGF5ZXIuaGFzUmVuZGVyZXIoKSkge1xuICAgICAgICBsYXllci5nZXRSZW5kZXJlcigpLmhhbmRsZUZvbnRzQ2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGEgbWFwIHJlbmRlcmluZyAoYXQgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lKS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyXyAmJiB0aGlzLmFuaW1hdGlvbkRlbGF5S2V5XyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkRlbGF5S2V5XyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5Xyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdH0gY29udHJvbCBDb250cm9sLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgY29udHJvbCAob3IgdW5kZWZpbmVkXG4gICAqICAgICBpZiB0aGUgY29udHJvbCB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlQ29udHJvbChjb250cm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29udHJvbHMoKS5yZW1vdmUoY29udHJvbCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbnRlcmFjdGlvbiBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fSBpbnRlcmFjdGlvbiBJbnRlcmFjdGlvbiB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGludGVyYWN0aW9uIChvclxuICAgKiAgICAgdW5kZWZpbmVkIGlmIHRoZSBpbnRlcmFjdGlvbiB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5yZW1vdmUoaW50ZXJhY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgbGF5ZXIgKG9yIHVuZGVmaW5lZCBpZiB0aGVcbiAgICogICAgIGxheWVyIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpO1xuICAgIHJldHVybiBsYXllcnMucmVtb3ZlKGxheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvR3JvdXAuanNcIikuR3JvdXBFdmVudH0gZXZlbnQgVGhlIGxheWVyIHJlbW92ZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyUmVtb3ZlXyhldmVudCkge1xuICAgIHJlbW92ZUxheWVyTWFwUHJvcGVydHkoZXZlbnQubGF5ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gb3ZlcmxheSBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBvdmVybGF5IChvciB1bmRlZmluZWRcbiAgICogICAgIGlmIHRoZSBvdmVybGF5IHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVPdmVybGF5KG92ZXJsYXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPdmVybGF5cygpLnJlbW92ZShvdmVybGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVuZGVyRnJhbWVfKHRpbWUpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgY29uc3QgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIGNvbnN0IHByZXZpb3VzRnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgLyoqIEB0eXBlIHs/RnJhbWVTdGF0ZX0gKi9cbiAgICBsZXQgZnJhbWVTdGF0ZSA9IG51bGw7XG4gICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBoYXNBcmVhKHNpemUpICYmIHZpZXcgJiYgdmlldy5pc0RlZigpKSB7XG4gICAgICBjb25zdCB2aWV3SGludHMgPSB2aWV3LmdldEhpbnRzKFxuICAgICAgICB0aGlzLmZyYW1lU3RhdGVfID8gdGhpcy5mcmFtZVN0YXRlXy52aWV3SGludHMgOiB1bmRlZmluZWQsXG4gICAgICApO1xuICAgICAgY29uc3Qgdmlld1N0YXRlID0gdmlldy5nZXRTdGF0ZSgpO1xuICAgICAgZnJhbWVTdGF0ZSA9IHtcbiAgICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICAgIGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtOiB0aGlzLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtXyxcbiAgICAgICAgZGVjbHV0dGVyOiBudWxsLFxuICAgICAgICBleHRlbnQ6IGdldEZvclZpZXdBbmRTaXplKFxuICAgICAgICAgIHZpZXdTdGF0ZS5jZW50ZXIsXG4gICAgICAgICAgdmlld1N0YXRlLnJlc29sdXRpb24sXG4gICAgICAgICAgdmlld1N0YXRlLnJvdGF0aW9uLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICksXG4gICAgICAgIGluZGV4OiB0aGlzLmZyYW1lSW5kZXhfKyssXG4gICAgICAgIGxheWVySW5kZXg6IDAsXG4gICAgICAgIGxheWVyU3RhdGVzQXJyYXk6IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVyU3RhdGVzQXJyYXkoKSxcbiAgICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm06IHRoaXMucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1fLFxuICAgICAgICBwb3N0UmVuZGVyRnVuY3Rpb25zOiBbXSxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgdGlsZVF1ZXVlOiB0aGlzLnRpbGVRdWV1ZV8sXG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHVzZWRUaWxlczoge30sXG4gICAgICAgIHZpZXdTdGF0ZTogdmlld1N0YXRlLFxuICAgICAgICB2aWV3SGludHM6IHZpZXdIaW50cyxcbiAgICAgICAgd2FudGVkVGlsZXM6IHt9LFxuICAgICAgICBtYXBJZDogZ2V0VWlkKHRoaXMpLFxuICAgICAgICByZW5kZXJUYXJnZXRzOiB7fSxcbiAgICAgIH07XG4gICAgICBpZiAodmlld1N0YXRlLm5leHRDZW50ZXIgJiYgdmlld1N0YXRlLm5leHRSZXNvbHV0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gaXNOYU4odmlld1N0YXRlLm5leHRSb3RhdGlvbilcbiAgICAgICAgICA/IHZpZXdTdGF0ZS5yb3RhdGlvblxuICAgICAgICAgIDogdmlld1N0YXRlLm5leHRSb3RhdGlvbjtcblxuICAgICAgICBmcmFtZVN0YXRlLm5leHRFeHRlbnQgPSBnZXRGb3JWaWV3QW5kU2l6ZShcbiAgICAgICAgICB2aWV3U3RhdGUubmV4dENlbnRlcixcbiAgICAgICAgICB2aWV3U3RhdGUubmV4dFJlc29sdXRpb24sXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lU3RhdGVfID0gZnJhbWVTdGF0ZTtcbiAgICB0aGlzLnJlbmRlcmVyXy5yZW5kZXJGcmFtZShmcmFtZVN0YXRlKTtcblxuICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICBpZiAoZnJhbWVTdGF0ZS5hbmltYXRlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXyxcbiAgICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLFxuICAgICAgKTtcblxuICAgICAgaWYgKHByZXZpb3VzRnJhbWVTdGF0ZSkge1xuICAgICAgICBjb25zdCBtb3ZlU3RhcnQgPVxuICAgICAgICAgICF0aGlzLnByZXZpb3VzRXh0ZW50XyB8fFxuICAgICAgICAgICghaXNFbXB0eSh0aGlzLnByZXZpb3VzRXh0ZW50XykgJiZcbiAgICAgICAgICAgICFlcXVhbHNFeHRlbnQoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKSk7XG4gICAgICAgIGlmIChtb3ZlU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgTWFwRXZlbnQoTWFwRXZlbnRUeXBlLk1PVkVTVEFSVCwgdGhpcywgcHJldmlvdXNGcmFtZVN0YXRlKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucHJldmlvdXNFeHRlbnRfID0gY3JlYXRlT3JVcGRhdGVFbXB0eSh0aGlzLnByZXZpb3VzRXh0ZW50Xyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaWRsZSA9XG4gICAgICAgIHRoaXMucHJldmlvdXNFeHRlbnRfICYmXG4gICAgICAgICFmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddICYmXG4gICAgICAgICFmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10gJiZcbiAgICAgICAgIWVxdWFsc0V4dGVudChmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pO1xuXG4gICAgICBpZiAoaWRsZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5NT1ZFRU5ELCB0aGlzLCBmcmFtZVN0YXRlKSxcbiAgICAgICAgKTtcbiAgICAgICAgY2xvbmUoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5QT1NUUkVOREVSLCB0aGlzLCBmcmFtZVN0YXRlKSk7XG5cbiAgICB0aGlzLnJlbmRlckNvbXBsZXRlXyA9XG4gICAgICAodGhpcy5oYXNMaXN0ZW5lcihNYXBFdmVudFR5cGUuTE9BRFNUQVJUKSB8fFxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVyKE1hcEV2ZW50VHlwZS5MT0FERU5EKSB8fFxuICAgICAgICB0aGlzLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5SRU5ERVJDT01QTEVURSkpICYmXG4gICAgICAhdGhpcy50aWxlUXVldWVfLmdldFRpbGVzTG9hZGluZygpICYmXG4gICAgICAhdGhpcy50aWxlUXVldWVfLmdldENvdW50KCkgJiZcbiAgICAgICF0aGlzLmdldExvYWRpbmdPck5vdFJlYWR5KCk7XG5cbiAgICBpZiAoIXRoaXMucG9zdFJlbmRlclRpbWVvdXRIYW5kbGVfKSB7XG4gICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3N0UmVuZGVyKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXJncm91cCBvZiB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtMYXllckdyb3VwfSBsYXllckdyb3VwIEEgbGF5ZXIgZ3JvdXAgY29udGFpbmluZyB0aGUgbGF5ZXJzIGluIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllckdyb3VwKGxheWVyR3JvdXApIHtcbiAgICBjb25zdCBvbGRMYXllckdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKG9sZExheWVyR3JvdXApIHtcbiAgICAgIHRoaXMuaGFuZGxlTGF5ZXJSZW1vdmVfKG5ldyBHcm91cEV2ZW50KCdyZW1vdmVsYXllcicsIG9sZExheWVyR3JvdXApKTtcbiAgICB9XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuTEFZRVJHUk9VUCwgbGF5ZXJHcm91cCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2l6ZSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIG1hcCBpbiB0aGUgRE9NLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTaXplKHNpemUpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5TSVpFLCBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBlbGVtZW50IHRvIHJlbmRlciB0aGlzIG1hcCBpbnRvLlxuICAgKiBGb3IgYWNjZXNzaWJpbGl0eSAoZm9jdXMgYW5kIGtleWJvYXJkIGV2ZW50cyBmb3IgbWFwIG5hdmlnYXRpb24pLCB0aGUgYHRhcmdldGAgZWxlbWVudCBtdXN0IGhhdmUgYVxuICAgKiAgcHJvcGVybHkgY29uZmlndXJlZCBgdGFiaW5kZXhgIGF0dHJpYnV0ZS4gSWYgdGhlIGB0YXJnZXRgIGVsZW1lbnQgaXMgaW5zaWRlIGEgU2hhZG93IERPTSwgdGhlXG4gICAqICBgdGFiaW5kZXhgIGF0cmlidXRlIG11c3QgYmUgc2V0IG9uIHRoZSBjdXN0b20gZWxlbWVudCdzIGhvc3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFRoZSBFbGVtZW50IG9yIGlkIG9mIHRoZSBFbGVtZW50XG4gICAqICAgICB0aGF0IHRoZSBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5UQVJHRVQsIHRhcmdldCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2aWV3IGZvciB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtWaWV3fFByb21pc2U8aW1wb3J0KFwiLi9WaWV3LmpzXCIpLlZpZXdPcHRpb25zPn0gdmlldyBUaGUgdmlldyB0aGF0IGNvbnRyb2xzIHRoaXMgbWFwLlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gb3B0aW9ucyBmb3IgY29uc3RydWN0aW5nIGEgdmlldy4gIFRoaXNcbiAgICogYWx0ZXJuYXRpdmUgYWxsb3dzIHZpZXcgcHJvcGVydGllcyB0byBiZSByZXNvbHZlZCBieSBzb3VyY2VzIG9yIG90aGVyIGNvbXBvbmVudHMgdGhhdCBsb2FkXG4gICAqIHZpZXctcmVsYXRlZCBtZXRhZGF0YS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Vmlldyh2aWV3KSB7XG4gICAgaWYgKCF2aWV3IHx8IHZpZXcgaW5zdGFuY2VvZiBWaWV3KSB7XG4gICAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5WSUVXLCB2aWV3KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuVklFVywgbmV3IFZpZXcoKSk7XG5cbiAgICBjb25zdCBtYXAgPSB0aGlzO1xuICAgIHZpZXcudGhlbihmdW5jdGlvbiAodmlld09wdGlvbnMpIHtcbiAgICAgIG1hcC5zZXRWaWV3KG5ldyBWaWV3KHZpZXdPcHRpb25zKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgYSByZWNhbGN1bGF0aW9uIG9mIHRoZSBtYXAgdmlld3BvcnQgc2l6ZS4gIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCB3aGVuXG4gICAqIHRoaXJkLXBhcnR5IGNvZGUgY2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAYXBpXG4gICAqL1xuICB1cGRhdGVTaXplKCkge1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnQoKTtcblxuICAgIGxldCBzaXplID0gdW5kZWZpbmVkO1xuICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRFbGVtZW50KTtcbiAgICAgIGNvbnN0IHdpZHRoID1cbiAgICAgICAgdGFyZ2V0RWxlbWVudC5vZmZzZXRXaWR0aCAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyTGVmdFdpZHRoJ10pIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nTGVmdCddKSAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ1JpZ2h0J10pIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJSaWdodFdpZHRoJ10pO1xuICAgICAgY29uc3QgaGVpZ2h0ID1cbiAgICAgICAgdGFyZ2V0RWxlbWVudC5vZmZzZXRIZWlnaHQgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlclRvcFdpZHRoJ10pIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nVG9wJ10pIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nQm90dG9tJ10pIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJCb3R0b21XaWR0aCddKTtcbiAgICAgIGlmICghaXNOYU4od2lkdGgpICYmICFpc05hTihoZWlnaHQpKSB7XG4gICAgICAgIHNpemUgPSBbTWF0aC5tYXgoMCwgd2lkdGgpLCBNYXRoLm1heCgwLCBoZWlnaHQpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNBcmVhKHNpemUpICYmXG4gICAgICAgICAgISEoXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIHx8XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCB8fFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTm8gbWFwIHZpc2libGUgYmVjYXVzZSB0aGUgbWFwIGNvbnRhaW5lcidzIHdpZHRoIG9yIGhlaWdodCBhcmUgMC5cIixcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIGlmIChzaXplICYmICghb2xkU2l6ZSB8fCAhZXF1YWxzKHNpemUsIG9sZFNpemUpKSkge1xuICAgICAgdGhpcy5zZXRTaXplKHNpemUpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydFNpemVfKHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbXB1dGVzIHRoZSB2aWV3cG9ydCBzaXplIGFuZCBzYXZlIGl0IG9uIHRoZSB2aWV3IG9iamVjdCAoaWYgYW55KVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2l6ZSBUaGUgc2l6ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVZpZXdwb3J0U2l6ZV8oc2l6ZSkge1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLmdldFZpZXcoKTtcbiAgICBpZiAodmlldykge1xuICAgICAgdmlldy5zZXRWaWV3cG9ydFNpemUoc2l6ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtNYXBPcHRpb25zfSBvcHRpb25zIE1hcCBvcHRpb25zLlxuICogQHJldHVybiB7TWFwT3B0aW9uc0ludGVybmFsfSBJbnRlcm5hbCBtYXAgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc0ludGVybmFsKG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudHxEb2N1bWVudH1cbiAgICovXG4gIGxldCBrZXlib2FyZEV2ZW50VGFyZ2V0ID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAga2V5Ym9hcmRFdmVudFRhcmdldCA9XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldClcbiAgICAgICAgOiBvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fVxuICAgKi9cbiAgY29uc3QgdmFsdWVzID0ge307XG5cbiAgY29uc3QgbGF5ZXJHcm91cCA9XG4gICAgb3B0aW9ucy5sYXllcnMgJiZcbiAgICB0eXBlb2YgKC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMubGF5ZXJzKS5nZXRMYXllcnMpID09PSAnZnVuY3Rpb24nXG4gICAgICA/IC8qKiBAdHlwZSB7TGF5ZXJHcm91cH0gKi8gKG9wdGlvbnMubGF5ZXJzKVxuICAgICAgOiBuZXcgTGF5ZXJHcm91cCh7XG4gICAgICAgICAgbGF5ZXJzOlxuICAgICAgICAgICAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD59ICovIChcbiAgICAgICAgICAgICAgb3B0aW9ucy5sYXllcnNcbiAgICAgICAgICAgICksXG4gICAgICAgIH0pO1xuICB2YWx1ZXNbTWFwUHJvcGVydHkuTEFZRVJHUk9VUF0gPSBsYXllckdyb3VwO1xuXG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5UQVJHRVRdID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgdmFsdWVzW01hcFByb3BlcnR5LlZJRVddID1cbiAgICBvcHRpb25zLnZpZXcgaW5zdGFuY2VvZiBWaWV3ID8gb3B0aW9ucy52aWV3IDogbmV3IFZpZXcoKTtcblxuICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59ICovXG4gIGxldCBjb250cm9scztcbiAgaWYgKG9wdGlvbnMuY29udHJvbHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuY29udHJvbHMpKSB7XG4gICAgICBjb250cm9scyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMuY29udHJvbHMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvcHRpb25zLmNvbnRyb2xzKS5nZXRBcnJheSkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBgY29udHJvbHNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBvbC9Db2xsZWN0aW9uLmpzYCcsXG4gICAgICApO1xuICAgICAgY29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uXCIpLmRlZmF1bHQ+fSAqL1xuICBsZXQgaW50ZXJhY3Rpb25zO1xuICBpZiAob3B0aW9ucy5pbnRlcmFjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuaW50ZXJhY3Rpb25zKSkge1xuICAgICAgaW50ZXJhY3Rpb25zID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5pbnRlcmFjdGlvbnMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvcHRpb25zLmludGVyYWN0aW9ucykuZ2V0QXJyYXkpID09PVxuICAgICAgICAgICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBgaW50ZXJhY3Rpb25zYCB0byBiZSBhbiBhcnJheSBvciBhbiBgb2wvQ29sbGVjdGlvbi5qc2AnLFxuICAgICAgKTtcbiAgICAgIGludGVyYWN0aW9ucyA9IG9wdGlvbnMuaW50ZXJhY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59ICovXG4gIGxldCBvdmVybGF5cztcbiAgaWYgKG9wdGlvbnMub3ZlcmxheXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3ZlcmxheXMpKSB7XG4gICAgICBvdmVybGF5cyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMub3ZlcmxheXMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvcHRpb25zLm92ZXJsYXlzKS5nZXRBcnJheSkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBgb3ZlcmxheXNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBvbC9Db2xsZWN0aW9uLmpzYCcsXG4gICAgICApO1xuICAgICAgb3ZlcmxheXMgPSBvcHRpb25zLm92ZXJsYXlzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdmVybGF5cyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbnRyb2xzOiBjb250cm9scyxcbiAgICBpbnRlcmFjdGlvbnM6IGludGVyYWN0aW9ucyxcbiAgICBrZXlib2FyZEV2ZW50VGFyZ2V0OiBrZXlib2FyZEV2ZW50VGFyZ2V0LFxuICAgIG92ZXJsYXlzOiBvdmVybGF5cyxcbiAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVGlsZVByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSRUxPQUQ6ICdwcmVsb2FkJyxcbiAgVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1I6ICd1c2VJbnRlcmltVGlsZXNPbkVycm9yJyxcbn07XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0Jhc2VUaWxlXG4gKi9cbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBUaWxlUHJvcGVydHkgZnJvbSAnLi9UaWxlUHJvcGVydHkuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3xcbiAqICAgICBpbXBvcnQoXCIuL0xheWVyLmpzXCIpLkxheWVyRXZlbnRUeXBlfCdjaGFuZ2U6cHJlbG9hZCd8J2NoYW5nZTp1c2VJbnRlcmltVGlsZXNPbkVycm9yJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlXCIpLkxheWVyUmVuZGVyRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfFxuICogICBpbXBvcnQoXCIuL0xheWVyLmpzXCIpLkxheWVyRXZlbnRUeXBlfCdjaGFuZ2U6cHJlbG9hZCd8J2NoYW5nZTp1c2VJbnRlcmltVGlsZXNPbkVycm9yJ3xpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlXCIpLkxheWVyUmVuZGVyRXZlbnRUeXBlcywgUmV0dXJuPn0gQmFzZVRpbGVMYXllck9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IFRpbGVTb3VyY2VUeXBlXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbGF5ZXInXSBBIENTUyBjbGFzcyBuYW1lIHRvIHNldCB0byB0aGUgbGF5ZXIgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmVsb2FkPTBdIFByZWxvYWQuIExvYWQgbG93LXJlc29sdXRpb24gdGlsZXMgdXAgdG8gYHByZWxvYWRgIGxldmVscy4gYDBgXG4gKiBtZWFucyBubyBwcmVsb2FkaW5nLlxuICogQHByb3BlcnR5IHtUaWxlU291cmNlVHlwZX0gW3NvdXJjZV0gU291cmNlIGZvciB0aGlzIGxheWVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0I2FkZExheWVyIG1hcC5hZGRMYXllcigpfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VzZUludGVyaW1UaWxlc09uRXJyb3I9dHJ1ZV0gRGVwcmVjYXRlZC4gIFVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCAqPn0gW3Byb3BlcnRpZXNdIEFyYml0cmFyeSBvYnNlcnZhYmxlIHByb3BlcnRpZXMuIENhbiBiZSBhY2Nlc3NlZCB3aXRoIGAjZ2V0KClgIGFuZCBgI3NldCgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTUxMl0gVGhlIGludGVybmFsIHRpbGUgY2FjaGUgc2l6ZS4gIFRoaXMgbmVlZHMgdG8gYmUgbGFyZ2UgZW5vdWdoIHRvIHJlbmRlclxuICogdHdvIHpvb20gbGV2ZWxzIHdvcnRoIG9mIHRpbGVzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRm9yIGxheWVyIHNvdXJjZXMgdGhhdCBwcm92aWRlIHByZS1yZW5kZXJlZCwgdGlsZWQgaW1hZ2VzIGluIGdyaWRzIHRoYXQgYXJlXG4gKiBvcmdhbml6ZWQgYnkgem9vbSBsZXZlbHMgZm9yIHNwZWNpZmljIHJlc29sdXRpb25zLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZVNvdXJjZVR5cGVcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vcmVuZGVyZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gUmVuZGVyZXJUeXBlXG4gKiBAZXh0ZW5kcyB7TGF5ZXI8VGlsZVNvdXJjZVR5cGUsIFJlbmRlcmVyVHlwZT59XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEJhc2VUaWxlTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM8VGlsZVNvdXJjZVR5cGU+fSBbb3B0aW9uc10gVGlsZSBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgYmFzZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGNhY2hlU2l6ZSA9IG9wdGlvbnMuY2FjaGVTaXplO1xuICAgIGRlbGV0ZSBvcHRpb25zLmNhY2hlU2l6ZTtcblxuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5wcmVsb2FkO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51c2VJbnRlcmltVGlsZXNPbkVycm9yO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZVRpbGVMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VUaWxlTGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VUaWxlTGF5ZXJPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlU2l6ZV8gPSBjYWNoZVNpemU7XG5cbiAgICB0aGlzLnNldFByZWxvYWQob3B0aW9ucy5wcmVsb2FkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnByZWxvYWQgOiAwKTtcbiAgICB0aGlzLnNldFVzZUludGVyaW1UaWxlc09uRXJyb3IoXG4gICAgICBvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudXNlSW50ZXJpbVRpbGVzT25FcnJvclxuICAgICAgICA6IHRydWUsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgc3VnZ2VzdGVkIGNhY2hlIHNpemVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0Q2FjaGVTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZXZlbCBhcyBudW1iZXIgdG8gd2hpY2ggd2Ugd2lsbCBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZXZlbCB0byBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQcmVsb2FkKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KFRpbGVQcm9wZXJ0eS5QUkVMT0FEKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsZXZlbCBhcyBudW1iZXIgdG8gd2hpY2ggd2Ugd2lsbCBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJlbG9hZCBUaGUgbGV2ZWwgdG8gcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UHJlbG9hZChwcmVsb2FkKSB7XG4gICAgdGhpcy5zZXQoVGlsZVByb3BlcnR5LlBSRUxPQUQsIHByZWxvYWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuICBXaGV0aGVyIHdlIHVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoXG4gICAgICB0aGlzLmdldChUaWxlUHJvcGVydHkuVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1IpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiAgU2V0IHdoZXRoZXIgd2UgdXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlSW50ZXJpbVRpbGVzT25FcnJvciBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcih1c2VJbnRlcmltVGlsZXNPbkVycm9yKSB7XG4gICAgdGhpcy5zZXQoVGlsZVByb3BlcnR5LlVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SLCB1c2VJbnRlcmltVGlsZXNPbkVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSBmb3IgYSBwaXhlbCBsb2NhdGlvbi4gIFRoZSByZXR1cm4gdHlwZSBkZXBlbmRzIG9uIHRoZSBzb3VyY2UgZGF0YS4gIEZvciBpbWFnZSB0aWxlcyxcbiAgICogYSBmb3VyIGVsZW1lbnQgUkdCQSBhcnJheSB3aWxsIGJlIHJldHVybmVkLiAgRm9yIGRhdGEgdGlsZXMsIHRoZSBhcnJheSBsZW5ndGggd2lsbCBtYXRjaCB0aGVcbiAgICogbnVtYmVyIG9mIGJhbmRzIGluIHRoZSBkYXRhc2V0LiAgRm9yIHJlcXVlc3RzIG91dHNpZGUgdGhlIGxheWVyIGV4dGVudCwgYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIERhdGEgZm9yIGEgaW1hZ2UgdGlsZXMgY2FuIG9ubHkgYmUgcmV0cmlldmVkIGlmIHRoZSBzb3VyY2UncyBgY3Jvc3NPcmlnaW5gIHByb3BlcnR5IGlzIHNldC5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZGlzcGxheSBsYXllciBkYXRhIG9uIGV2ZXJ5IHBvaW50ZXIgbW92ZVxuICAgKiBtYXAub24oJ3BvaW50ZXJtb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cobGF5ZXIuZ2V0RGF0YShldmVudC5waXhlbCkpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWxcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5fEZsb2F0MzJBcnJheXxEYXRhVmlld3xudWxsfSBQaXhlbCBkYXRhLlxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0RGF0YShwaXhlbCkge1xuICAgIHJldHVybiBzdXBlci5nZXREYXRhKHBpeGVsKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlVGlsZUxheWVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9MYXllclxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9PYnNlcnZhYmxlLmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuXG5jb25zdCBtYXhTdGFsZUtleXMgPSA1O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXJUeXBlXG4gKi9cbmNsYXNzIExheWVyUmVuZGVyZXIgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TGF5ZXJUeXBlfSBsYXllciBMYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxheWVyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXJlciBpcyBpbml0aWFsaXplZCBhbmQgcmVhZHkgdG8gcmVuZGVyLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZUltYWdlQ2hhbmdlXyA9IHRoaXMuaGFuZGxlSW1hZ2VDaGFuZ2VfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtMYXllclR5cGV9XG4gICAgICovXG4gICAgdGhpcy5sYXllcl8gPSBsYXllcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zdGFsZUtleXNfID0gbmV3IEFycmF5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLm1heFN0YWxlS2V5cyA9IG1heFN0YWxlS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBHZXQgdGhlIGxpc3Qgb2Ygc3RhbGUga2V5cy5cbiAgICovXG4gIGdldFN0YWxlS2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFsZUtleXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5ldyBzdGFsZSBrZXkuXG4gICAqL1xuICBwcmVwZW5kU3RhbGVLZXkoa2V5KSB7XG4gICAgdGhpcy5zdGFsZUtleXNfLnVuc2hpZnQoa2V5KTtcbiAgICBpZiAodGhpcy5zdGFsZUtleXNfLmxlbmd0aCA+IHRoaXMubWF4U3RhbGVLZXlzKSB7XG4gICAgICB0aGlzLnN0YWxlS2V5c18ubGVuZ3RoID0gdGhpcy5tYXhTdGFsZUtleXM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBsYXllciBsZXZlbCBoaXQgZGV0ZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlXCIpLkZlYXR1cmVMaWtlPj59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoXG4gICAqIGFuIGFycmF5IG9mIGZlYXR1cmVzLlxuICAgKi9cbiAgZ2V0RmVhdHVyZXMocGl4ZWwpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheXxGbG9hdDMyQXJyYXl8RGF0YVZpZXd8bnVsbH0gUGl4ZWwgZGF0YS5cbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciByZW5kZXIgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVyIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGxheWVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxudWxsfSB0YXJnZXQgVGFyZ2V0IHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgdG8uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi92ZWN0b3IuanNcIikuRmVhdHVyZUNhbGxiYWNrPFQ+fSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTWFwLmpzXCIpLkhpdE1hdGNoPFQ+Pn0gbWF0Y2hlcyBUaGUgaGl0IGRldGVjdGVkIG1hdGNoZXMgd2l0aCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNhbGxiYWNrLFxuICAgIG1hdGNoZXMsXG4gICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TGF5ZXJUeXBlfSBMYXllci5cbiAgICovXG4gIGdldExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFjdGlvbiBuZWNlc3NhcnkgdG8gZ2V0IHRoZSBsYXllciByZW5kZXJlZCBhZnRlciBuZXcgZm9udHMgaGF2ZSBsb2FkZWRcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBoYW5kbGVGb250c0NoYW5nZWQoKSB7fVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgSW1hZ2UgY2hhbmdlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VDaGFuZ2VfKGV2ZW50KSB7XG4gICAgY29uc3QgaW1hZ2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL0ltYWdlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIGlmIChcbiAgICAgIGltYWdlLmdldFN0YXRlKCkgPT09IEltYWdlU3RhdGUuTE9BREVEIHx8XG4gICAgICBpbWFnZS5nZXRTdGF0ZSgpID09PSBJbWFnZVN0YXRlLkVSUk9SXG4gICAgKSB7XG4gICAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGltYWdlIGlmIG5vdCBhbHJlYWR5IGxvYWRlZCwgYW5kIHJlZ2lzdGVyIHRoZSBpbWFnZSBjaGFuZ2VcbiAgICogbGlzdGVuZXIgaWYgbmVlZGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlIEltYWdlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGltYWdlIGlzIGFscmVhZHkgbG9hZGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbG9hZEltYWdlKGltYWdlKSB7XG4gICAgbGV0IGltYWdlU3RhdGUgPSBpbWFnZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChpbWFnZVN0YXRlICE9IEltYWdlU3RhdGUuTE9BREVEICYmIGltYWdlU3RhdGUgIT0gSW1hZ2VTdGF0ZS5FUlJPUikge1xuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmJvdW5kSGFuZGxlSW1hZ2VDaGFuZ2VfKTtcbiAgICB9XG4gICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICBpbWFnZS5sb2FkKCk7XG4gICAgICBpbWFnZVN0YXRlID0gaW1hZ2UuZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcmVuZGVySWZSZWFkeUFuZFZpc2libGUoKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgaWYgKGxheWVyICYmIGxheWVyLmdldFZpc2libGUoKSAmJiBsYXllci5nZXRTb3VyY2VTdGF0ZSgpID09PSAncmVhZHknKSB7XG4gICAgICBsYXllci5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICByZW5kZXJEZWZlcnJlZChmcmFtZVN0YXRlKSB7fVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgZGVsZXRlIHRoaXMubGF5ZXJfO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyUmVuZGVyZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvWkluZGV4Q29udGV4dFxuICovXG5cbmltcG9ydCB7Z2V0U2hhcmVkQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuXG4vKiogQHR5cGVkZWYge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmIHtnbG9iYWxBbHBoYTogYW55fX0gWkluZGV4Q29udGV4dFByb3h5ICovXG5cbi8qKlxuICogQGV4dGVuZHMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xuY2xhc3MgWkluZGV4Q29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5PCo+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9uc18gPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1pJbmRleENvbnRleHRQcm94eX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRfID0gLyoqIEB0eXBlIHtaSW5kZXhDb250ZXh0UHJveHl9ICovIChcbiAgICAgIG5ldyBQcm94eShnZXRTaGFyZWRDYW52YXNDb250ZXh0MkQoKSwge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgeyp9ICovIChnZXRTaGFyZWRDYW52YXNDb250ZXh0MkQoKSlbcHJvcGVydHldKSAhPT1cbiAgICAgICAgICAgICdmdW5jdGlvbidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgYWNjZXB0IGNhbGxpbmcgZnVuY3Rpb25zIG9uIHRoZSBwcm94eSwgbm90IGFjY2Vzc2luZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10pIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnNfW3RoaXMuekluZGV4ICsgdGhpcy5vZmZzZXRfXS5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoTWV0aG9kQXJnc187XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLmluc3RydWN0aW9uc19bdGhpcy56SW5kZXggKyB0aGlzLm9mZnNldF9dKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RydWN0aW9uc19bdGhpcy56SW5kZXggKyB0aGlzLm9mZnNldF9dID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10ucHVzaChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmdzLlxuICAgKiBAcmV0dXJuIHtaSW5kZXhDb250ZXh0fSBUaGlzLlxuICAgKi9cbiAgcHVzaE1ldGhvZEFyZ3NfID0gKC4uLmFyZ3MpID0+IHtcbiAgICB0aGlzLmluc3RydWN0aW9uc19bdGhpcy56SW5kZXggKyB0aGlzLm9mZnNldF9dLnB1c2goYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggYSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdG8gdGhlIGNvbnRleHQgZGlyZWN0bHkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZH0gcmVuZGVyIEZ1bmN0aW9uLlxuICAgKi9cbiAgcHVzaEZ1bmN0aW9uKHJlbmRlcikge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zX1t0aGlzLnpJbmRleCArIHRoaXMub2Zmc2V0X10ucHVzaChyZW5kZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHByb3h5IGZvciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBnZXR0aW5nIHN0YXRlXG4gICAqIChlLmcuIGBjb250ZXh0Lmdsb2JhbEFscGhhYCwgd2hpY2ggd2lsbCByZXR1cm4gYHVuZGVmaW5lZGApLiBUbyBzZXQgc3RhdGUsIGlmIGl0IHJlbGllcyBvbiBhXG4gICAqIHByZXZpb3VzIHN0YXRlIChlLmcuIGBjb250ZXh0Lmdsb2JhbEFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYSAvIDJgKSwgc2V0IGEgZnVuY3Rpb24sXG4gICAqIGUuZy4gYGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAoY29udGV4dCkgPT4gY29udGV4dC5nbG9iYWxBbHBoYSAvIDJgLlxuICAgKiBAcmV0dXJuIHtaSW5kZXhDb250ZXh0UHJveHl9IENvbnRleHQuXG4gICAqL1xuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqL1xuICBkcmF3KGNvbnRleHQpIHtcbiAgICB0aGlzLmluc3RydWN0aW9uc18uZm9yRWFjaCgoaW5zdHJ1Y3Rpb25zQXRJbmRleCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5zdHJ1Y3Rpb25zQXRJbmRleC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gaW5zdHJ1Y3Rpb25zQXRJbmRleFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3BlcnR5KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uQXRJbmRleCA9IGluc3RydWN0aW9uc0F0SW5kZXhbKytpXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoLyoqIEB0eXBlIHsqfSAqLyAoY29udGV4dClbcHJvcGVydHldKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8qKiBAdHlwZSB7Kn0gKi8gKGNvbnRleHQpW3Byb3BlcnR5XSguLi5pbnN0cnVjdGlvbkF0SW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb25BdEluZGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyp9ICovIChjb250ZXh0KVtwcm9wZXJ0eV0gPSBpbnN0cnVjdGlvbkF0SW5kZXgoY29udGV4dCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEB0eXBlIHsqfSAqLyAoY29udGV4dClbcHJvcGVydHldID0gaW5zdHJ1Y3Rpb25BdEluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmluc3RydWN0aW9uc18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5vZmZzZXRfID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPZmZzZXRzIHRoZSB6SW5kZXggYnkgdGhlIGhpZ2hlc3QgY3VycmVudCB6SW5kZXguIFVzZWZ1bCBmb3IgcmVuZGVyaW5nIG11bHRpcGxlIHdvcmxkcyBvciB0aWxlcywgdG9cbiAgICogYXZvaWQgY29uZmxpY3RpbmcgY29udGV4dC5jbGlwKCkgb3IgY29udGV4dC5zYXZlKCkvcmVzdG9yZSgpIGNhbGxzLlxuICAgKi9cbiAgb2Zmc2V0KCkge1xuICAgIHRoaXMub2Zmc2V0XyA9IHRoaXMuaW5zdHJ1Y3Rpb25zXy5sZW5ndGg7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpJbmRleENvbnRleHQ7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9MYXllclxuICovXG5pbXBvcnQgTGF5ZXJSZW5kZXJlciBmcm9tICcuLi9MYXllci5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnQgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgWkluZGV4Q29udGV4dCBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzL1pJbmRleENvbnRleHQuanMnO1xuaW1wb3J0IHtcbiAgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sXG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbiAgbWFrZUludmVyc2UsXG4gIHRvU3RyaW5nIGFzIHRvVHJhbnNmb3JtU3RyaW5nLFxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi8uLi9jb2xvci5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge1xuICBnZXRCb3R0b21MZWZ0LFxuICBnZXRCb3R0b21SaWdodCxcbiAgZ2V0SGVpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRUb3BSaWdodCxcbiAgZ2V0V2lkdGgsXG59IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5cbi8qKlxuICogQHR5cGUge0FycmF5PEhUTUxDYW52YXNFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbnZhc1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICovXG5sZXQgcGl4ZWxDb250ZXh0ID0gbnVsbDtcblxuZnVuY3Rpb24gY3JlYXRlUGl4ZWxDb250ZXh0KCkge1xuICBwaXhlbENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSwgdW5kZWZpbmVkLCB7XG4gICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlLFxuICB9KTtcbn1cblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXJUeXBlXG4gKiBAZXh0ZW5kcyB7TGF5ZXJSZW5kZXJlcjxMYXllclR5cGU+fVxuICovXG5jbGFzcyBDYW52YXNMYXllclJlbmRlcmVyIGV4dGVuZHMgTGF5ZXJSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xheWVyVHlwZX0gbGF5ZXIgTGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsYXllcikge1xuICAgIHN1cGVyKGxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBBIHRlbXBvcmFyeSB0cmFuc2Zvcm0uICBUaGUgdmFsdWVzIGluIHRoaXMgdHJhbnNmb3JtIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gYVxuICAgICAqIGZ1bmN0aW9uIHRoYXQgc2V0cyB0aGUgdmFsdWVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRlbXBUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm0gZm9yIHJlbmRlcmVkIHBpeGVscyB0byB2aWV3cG9ydCBDU1MgcGl4ZWxzLiAgVGhpcyB0cmFuc2Zvcm0gbXVzdFxuICAgICAqIGJlIHNldCB3aGVuIHJlbmRlcmluZyBhIGZyYW1lIGFuZCBtYXkgYmUgdXNlZCBieSBvdGhlciBmdW5jdGlvbnMgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtIGZvciB2aWV3cG9ydCBDU1MgcGl4ZWxzIHRvIHJlbmRlcmVkIHBpeGVscy4gIFRoaXMgdHJhbnNmb3JtIG11c3RcbiAgICAgKiBiZSBzZXQgd2hlbiByZW5kZXJpbmcgYSBmcmFtZSBhbmQgbWF5IGJlIHVzZWQgYnkgb3RoZXIgZnVuY3Rpb25zIGFmdGVyIHJlbmRlcmluZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1pJbmRleENvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5kZWZlcnJlZENvbnRleHRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29udGFpbmVyUmV1c2VkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIEltYWdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8bnVsbH0gVGhlIGltYWdlIGRhdGEuXG4gICAqL1xuICBnZXRJbWFnZURhdGEoaW1hZ2UsIGNvbCwgcm93KSB7XG4gICAgaWYgKCFwaXhlbENvbnRleHQpIHtcbiAgICAgIGNyZWF0ZVBpeGVsQ29udGV4dCgpO1xuICAgIH1cbiAgICBwaXhlbENvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDEsIDEpO1xuXG4gICAgbGV0IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIHBpeGVsQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIGNvbCwgcm93LCAxLCAxLCAwLCAwLCAxLCAxKTtcbiAgICAgIGRhdGEgPSBwaXhlbENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwaXhlbENvbnRleHQgPSBudWxsO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9NYXAuanMnKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBnZXRCYWNrZ3JvdW5kKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBsZXQgYmFja2dyb3VuZCA9IGxheWVyLmdldEJhY2tncm91bmQoKTtcbiAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJhY2tncm91bmQgPSBiYWNrZ3JvdW5kKGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVuZGVyaW5nIGNvbnRhaW5lciBmcm9tIGFuIGV4aXN0aW5nIHRhcmdldCwgaWYgY29tcGF0aWJsZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IFBvdGVudGlhbCByZW5kZXIgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmb3JtIENTUyBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yXSBCYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgdXNlQ29udGFpbmVyKHRhcmdldCwgdHJhbnNmb3JtLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBjb25zdCBsYXllckNsYXNzTmFtZSA9IHRoaXMuZ2V0TGF5ZXIoKS5nZXRDbGFzc05hbWUoKTtcbiAgICBsZXQgY29udGFpbmVyLCBjb250ZXh0O1xuICAgIGlmIChcbiAgICAgIHRhcmdldCAmJlxuICAgICAgdGFyZ2V0LmNsYXNzTmFtZSA9PT0gbGF5ZXJDbGFzc05hbWUgJiZcbiAgICAgICghYmFja2dyb3VuZENvbG9yIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yICYmXG4gICAgICAgICAgZXF1YWxzKFxuICAgICAgICAgICAgYXNBcnJheSh0YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICAgIGFzQXJyYXkoYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICApKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRhcmdldC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGlmIChjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9PT0gdHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb250YWluZXIgb2YgdGhlIHByZXZpb3VzIGxheWVyIHJlbmRlcmVyIGNhbiBiZSB1c2VkLlxuICAgICAgdGhpcy5jb250YWluZXIgPSB0YXJnZXQ7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5jb250YWluZXJSZXVzZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIC8vIFByZXZpb3VzbHkgcmV1c2VkIGNvbnRhaW5lciBjYW5ub3QgYmUgdXNlZCBhbnkgbW9yZS5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRhaW5lclJldXNlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGxheWVyQ2xhc3NOYW1lO1xuICAgICAgbGV0IHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ3RvcCBsZWZ0JztcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIXRoaXMuY29udGFpbmVyUmV1c2VkICYmXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgJiZcbiAgICAgICF0aGlzLmNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICApIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgQ2xpcCBleHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNsaXBVbnJvdGF0ZWQoY29udGV4dCwgZnJhbWVTdGF0ZSwgZXh0ZW50KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG5cbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BMZWZ0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BSaWdodCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbUxlZnQpO1xuXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgdG9wTGVmdCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oaW52ZXJ0ZWQsIHRvcFJpZ2h0KTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGludmVydGVkLCBib3R0b21MZWZ0KTtcblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oTWF0aC5yb3VuZCh0b3BMZWZ0WzBdKSwgTWF0aC5yb3VuZCh0b3BMZWZ0WzFdKSk7XG4gICAgY29udGV4dC5saW5lVG8oTWF0aC5yb3VuZCh0b3BSaWdodFswXSksIE1hdGgucm91bmQodG9wUmlnaHRbMV0pKTtcbiAgICBjb250ZXh0LmxpbmVUbyhNYXRoLnJvdW5kKGJvdHRvbVJpZ2h0WzBdKSwgTWF0aC5yb3VuZChib3R0b21SaWdodFsxXSkpO1xuICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQoYm90dG9tTGVmdFswXSksIE1hdGgucm91bmQoYm90dG9tTGVmdFsxXSkpO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgdGhhdCBtYXkgYmUgdXNlZCB0byByZW5kZXIgY29udGVudCB0by5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJlcGFyZUNvbnRhaW5lcihmcmFtZVN0YXRlLCB0YXJnZXQpIHtcbiAgICBjb25zdCBleHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKChnZXRXaWR0aChleHRlbnQpIC8gcmVzb2x1dGlvbikgKiBwaXhlbFJhdGlvKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKChnZXRIZWlnaHQoZXh0ZW50KSAvIHJlc29sdXRpb24pICogcGl4ZWxSYXRpbyk7XG4gICAgLy8gc2V0IGZvcndhcmQgYW5kIGludmVyc2UgcGl4ZWwgdHJhbnNmb3Jtc1xuICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICB0aGlzLnBpeGVsVHJhbnNmb3JtLFxuICAgICAgZnJhbWVTdGF0ZS5zaXplWzBdIC8gMixcbiAgICAgIGZyYW1lU3RhdGUuc2l6ZVsxXSAvIDIsXG4gICAgICAxIC8gcGl4ZWxSYXRpbyxcbiAgICAgIDEgLyBwaXhlbFJhdGlvLFxuICAgICAgcm90YXRpb24sXG4gICAgICAtd2lkdGggLyAyLFxuICAgICAgLWhlaWdodCAvIDIsXG4gICAgKTtcbiAgICBtYWtlSW52ZXJzZSh0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSwgdGhpcy5waXhlbFRyYW5zZm9ybSk7XG5cbiAgICBjb25zdCBjYW52YXNUcmFuc2Zvcm0gPSB0b1RyYW5zZm9ybVN0cmluZyh0aGlzLnBpeGVsVHJhbnNmb3JtKTtcbiAgICB0aGlzLnVzZUNvbnRhaW5lcih0YXJnZXQsIGNhbnZhc1RyYW5zZm9ybSwgdGhpcy5nZXRCYWNrZ3JvdW5kKGZyYW1lU3RhdGUpKTtcblxuICAgIGlmICghdGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY29udGV4dC5jYW52YXM7XG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW52YXNUcmFuc2Zvcm0gIT09IGNhbnZhcy5zdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9IGNhbnZhc1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoUmVuZGVyRXZlbnRfKHR5cGUsIGNvbnRleHQsIGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFJlbmRlckV2ZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSxcbiAgICAgICAgZnJhbWVTdGF0ZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICk7XG4gICAgICBsYXllci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJlUmVuZGVyKGNvbnRleHQsIGZyYW1lU3RhdGUpIHtcbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlO1xuICAgIGlmIChmcmFtZVN0YXRlLmRlY2x1dHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QUkVSRU5ERVIsIGNvbnRleHQsIGZyYW1lU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHBvc3RSZW5kZXIoY29udGV4dCwgZnJhbWVTdGF0ZSkge1xuICAgIGlmIChmcmFtZVN0YXRlLmRlY2x1dHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QT1NUUkVOREVSLCBjb250ZXh0LCBmcmFtZVN0YXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyRGVmZXJyZWRJbnRlcm5hbChmcmFtZVN0YXRlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3JlbmRlci9jYW52YXMvWkluZGV4Q29udGV4dC5qcycpLlpJbmRleENvbnRleHRQcm94eX0gQ29udGV4dC5cbiAgICovXG4gIGdldFJlbmRlckNvbnRleHQoZnJhbWVTdGF0ZSkge1xuICAgIGlmIChmcmFtZVN0YXRlLmRlY2x1dHRlciAmJiAhdGhpcy5kZWZlcnJlZENvbnRleHRfKSB7XG4gICAgICB0aGlzLmRlZmVycmVkQ29udGV4dF8gPSBuZXcgWkluZGV4Q29udGV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhbWVTdGF0ZS5kZWNsdXR0ZXJcbiAgICAgID8gdGhpcy5kZWZlcnJlZENvbnRleHRfLmdldENvbnRleHQoKVxuICAgICAgOiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXJEZWZlcnJlZChmcmFtZVN0YXRlKSB7XG4gICAgaWYgKCFmcmFtZVN0YXRlLmRlY2x1dHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFxuICAgICAgUmVuZGVyRXZlbnRUeXBlLlBSRVJFTkRFUixcbiAgICAgIHRoaXMuY29udGV4dCxcbiAgICAgIGZyYW1lU3RhdGUsXG4gICAgKTtcbiAgICBpZiAoZnJhbWVTdGF0ZS5kZWNsdXR0ZXIgJiYgdGhpcy5kZWZlcnJlZENvbnRleHRfKSB7XG4gICAgICB0aGlzLmRlZmVycmVkQ29udGV4dF8uZHJhdyh0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5kZWZlcnJlZENvbnRleHRfLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyRGVmZXJyZWRJbnRlcm5hbChmcmFtZVN0YXRlKTtcbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnRfKFxuICAgICAgUmVuZGVyRXZlbnRUeXBlLlBPU1RSRU5ERVIsXG4gICAgICB0aGlzLmNvbnRleHQsXG4gICAgICBmcmFtZVN0YXRlLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nIHRvIGFuIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHJvdGF0ZWQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZW5kZXJlZCBlbGVtZW50IChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVuZGVyZWQgZWxlbWVudCAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggT2Zmc2V0IG9uIHRoZSB4LWF4aXMgaW4gdmlldyBjb29yZGluYXRlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gVHJhbnNmb3JtLlxuICAgKi9cbiAgZ2V0UmVuZGVyVHJhbnNmb3JtKFxuICAgIGNlbnRlcixcbiAgICByZXNvbHV0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG9mZnNldFgsXG4gICkge1xuICAgIGNvbnN0IGR4MSA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBkeTEgPSBoZWlnaHQgLyAyO1xuICAgIGNvbnN0IHN4ID0gcGl4ZWxSYXRpbyAvIHJlc29sdXRpb247XG4gICAgY29uc3Qgc3kgPSAtc3g7XG4gICAgY29uc3QgZHgyID0gLWNlbnRlclswXSArIG9mZnNldFg7XG4gICAgY29uc3QgZHkyID0gLWNlbnRlclsxXTtcbiAgICByZXR1cm4gY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIHRoaXMudGVtcFRyYW5zZm9ybSxcbiAgICAgIGR4MSxcbiAgICAgIGR5MSxcbiAgICAgIHN4LFxuICAgICAgc3ksXG4gICAgICAtcm90YXRpb24sXG4gICAgICBkeDIsXG4gICAgICBkeTIsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgZGVsZXRlIHRoaXMuZnJhbWVTdGF0ZTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNMYXllclJlbmRlcmVyO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlXG4gKi9cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IHtlYXNlSW59IGZyb20gJy4vZWFzaW5nLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL1RpbGV+VGlsZX0gZm9yIHRoZSB0aWxlIGFuZCBhXG4gKiBge3N0cmluZ31gIGZvciB0aGUgdXJsIGFzIGFyZ3VtZW50cy4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcbiAqICAgdGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH0pO1xuICogYGBgXG4gKiBGb3IgbW9yZSBmaW5lIGdyYWluZWQgY29udHJvbCwgdGhlIGxvYWQgZnVuY3Rpb24gY2FuIHVzZSBmZXRjaCBvciBYTUxIdHRwUmVxdWVzdCBhbmQgaW52b2x2ZVxuICogZXJyb3IgaGFuZGxpbmc6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBUaWxlU3RhdGUgZnJvbSAnb2wvVGlsZVN0YXRlLmpzJztcbiAqXG4gKiBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcbiAqICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gKiAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gKiAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKGV2dCkge1xuICogICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3BvbnNlO1xuICogICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAqICAgICAgIHRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICB0aWxlLnNldFN0YXRlKFRpbGVTdGF0ZS5FUlJPUik7XG4gKiAgICAgfVxuICogICB9KTtcbiAqICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICogICAgIHRpbGUuc2V0U3RhdGUoVGlsZVN0YXRlLkVSUk9SKTtcbiAqICAgfSk7XG4gKiAgIHhoci5vcGVuKCdHRVQnLCBzcmMpO1xuICogICB4aHIuc2VuZCgpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oVGlsZSwgc3RyaW5nKTogdm9pZH0gTG9hZEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IHNvdXJjZXMgdXNlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIHRvIGdldFxuICogdGhlIHVybCB0aGF0IHByb3ZpZGVzIGEgdGlsZSBmb3IgYSBnaXZlbiB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gZm9yIHRoZSB0aWxlXG4gKiBjb29yZGluYXRlLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSBwaXhlbCByYXRpbyBhbmQgYVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhcyBhcmd1bWVudHNcbiAqIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIHRpbGUgVVJMLCBvciB1bmRlZmluZWQgaWYgbm8gdGlsZVxuICogc2hvdWxkIGJlIHJlcXVlc3RlZCBmb3IgdGhlIHBhc3NlZCB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCwgbnVtYmVyLFxuICogICAgICAgICAgIGltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQpOiAoc3RyaW5nfHVuZGVmaW5lZCl9IFVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBBIGR1cmF0aW9uIGZvciB0aWxlIG9wYWNpdHlcbiAqIHRyYW5zaXRpb25zIGluIG1pbGxpc2Vjb25kcy4gQSBkdXJhdGlvbiBvZiAwIGRpc2FibGVzIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICogQGFwaVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3IgdGlsZXMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFRpbGUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gVGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZUNvb3JkLCBzdGF0ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ29vcmQgPSB0aWxlQ29vcmQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQSBrZXkgYXNzaWduZWQgdG8gdGhlIHRpbGUuIFRoaXMgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgc291cmNlIGtleVxuICAgICAqIHRvIGRldGVybWluZSBpZiBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgdGlsZSBtYXkgYmUgdXNlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIGZvciB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25fID1cbiAgICAgIG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkID8gMjUwIDogb3B0aW9ucy50cmFuc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIG9mIHN0YXJ0IHRpbWVzIGZvciByZW5kZXJpbmcgdHJhbnNpdGlvbnMuICBJZiB0aGUgc3RhcnQgdGltZSBpc1xuICAgICAqIGVxdWFsIHRvIC0xLCB0aGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSAhIW9wdGlvbnMuaW50ZXJwb2xhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY2hhbmdlZCgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGJ5IHRoZSB0aWxlIGNhY2hlIHdoZW4gdGhlIHRpbGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSBkdWUgdG8gZXhwaXJ5XG4gICAqL1xuICByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIC8vIHRvIHJlbW92ZSB0aGUgYGNoYW5nZWAgbGlzdGVuZXIgb24gdGhpcyB0aWxlIGluIGBvbC9UaWxlUXVldWUjaGFuZGxlVGlsZUNoYW5nZWBcbiAgICAgIHRoaXMuc2V0U3RhdGUoVGlsZVN0YXRlLkVNUFRZKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ICsgJy8nICsgdGhpcy50aWxlQ29vcmQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoaXMgdGlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlQ29vcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNvb3JkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9IFN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhpcyB0aWxlLiBJZiB5b3Ugd3JpdGUgeW91ciBvd24ge0BsaW5rIG1vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbiB0aWxlTG9hZEZ1bmN0aW9ufSAsXG4gICAqIGl0IGlzIGltcG9ydGFudCB0byBzZXQgdGhlIHN0YXRlIGNvcnJlY3RseSB0byB7QGxpbmsgbW9kdWxlOm9sL1RpbGVTdGF0ZX5FUlJPUn1cbiAgICogd2hlbiB0aGUgdGlsZSBjYW5ub3QgYmUgbG9hZGVkLiBPdGhlcndpc2UgdGhlIHRpbGUgY2Fubm90IGJlIHJlbW92ZWQgZnJvbVxuICAgKiB0aGUgdGlsZSBxdWV1ZSBhbmQgd2lsbCBibG9jayBvdGhlciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gVGlsZVN0YXRlLkVSUk9SICYmIHRoaXMuc3RhdGUgPiBzdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGxvYWQgc2VxdWVuY2UgdmlvbGF0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBvciByZXRyeSBpZiBsb2FkaW5nIHByZXZpb3VzbHkgZmFpbGVkLlxuICAgKiBMb2FkaW5nIGlzIHRha2VuIGNhcmUgb2YgYnkgdGhlIHRpbGUgcXVldWUsIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzXG4gICAqIG9ubHkgbmVlZGVkIGZvciBwcmVsb2FkaW5nIG9yIGZvciByZWxvYWRpbmcgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBhcGlcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFscGhhIHZhbHVlIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgcmVuZGVyIGZyYW1lIHRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgKi9cbiAgZ2V0QWxwaGEoaWQsIHRpbWUpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGxldCBzdGFydCA9IHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdO1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gdGltZTtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gc3RhcnQ7XG4gICAgfSBlbHNlIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gdGltZSAtIHN0YXJ0ICsgMTAwMCAvIDYwOyAvLyBhdm9pZCByZW5kZXJpbmcgYXQgMFxuICAgIGlmIChkZWx0YSA+PSB0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VJbihkZWx0YSAvIHRoaXMudHJhbnNpdGlvbl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHRpbGUgaXMgaW4gYW4gYWxwaGEgdHJhbnNpdGlvbi4gIEEgdGlsZSBpcyBjb25zaWRlcmVkIGluXG4gICAqIHRyYW5zaXRpb24gaWYgdGlsZS5nZXRBbHBoYSgpIGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkIG9yIGhhcyBiZWVuIGNhbGxlZFxuICAgKiBhbmQgcmV0dXJuZWQgMS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIGlzIGluIHRyYW5zaXRpb24uXG4gICAqL1xuICBpblRyYW5zaXRpb24oaWQpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdICE9PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIGEgdHJhbnNpdGlvbiBhcyBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqL1xuICBlbmRUcmFuc2l0aW9uKGlkKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMucmVsZWFzZSgpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGU7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL0RhdGFUaWxlXG4gKi9cbmltcG9ydCBUaWxlIGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuL2RvbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2VMaWtlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheXxGbG9hdDMyQXJyYXl8RGF0YVZpZXd9IEFycmF5TGlrZVxuICovXG5cbi8qKlxuICogRGF0YSB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYSBEYXRhVGlsZS5cbiAqIEB0eXBlZGVmIHtBcnJheUxpa2V8SW1hZ2VMaWtlfSBEYXRhXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEgVGlsZSBkYXRhLlxuICogQHJldHVybiB7SW1hZ2VMaWtlfG51bGx9IFRoZSBpbWFnZS1saWtlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0ltYWdlTGlrZShkYXRhKSB7XG4gIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW1hZ2UgfHxcbiAgICBkYXRhIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICBkYXRhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCB8fFxuICAgIGRhdGEgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcFxuICAgID8gZGF0YVxuICAgIDogbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RhdGF9IGRhdGEgVGlsZSBkYXRhLlxuICogQHJldHVybiB7QXJyYXlMaWtlfG51bGx9IFRoZSBhcnJheS1saWtlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0FycmF5TGlrZShkYXRhKSB7XG4gIHJldHVybiBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgIGRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSB8fFxuICAgIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICBkYXRhIGluc3RhbmNlb2YgRGF0YVZpZXdcbiAgICA/IGRhdGFcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBpcyBzZXQgYXMgdGhlIGNhbmNlbGxhdGlvbiByZWFzb24gd2hlbiBhIHRpbGUgaXMgZGlzcG9zZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBkaXNwb3NlZEVycm9yID0gbmV3IEVycm9yKCdkaXNwb3NlZCcpO1xuXG4vKipcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH1cbiAqL1xubGV0IHNoYXJlZENvbnRleHQgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7SW1hZ2VMaWtlfSBpbWFnZSBUaGUgaW1hZ2UuXG4gKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheX0gVGhlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGltYWdlKSB7XG4gIGlmICghc2hhcmVkQ29udGV4dCkge1xuICAgIHNoYXJlZENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICBpbWFnZS53aWR0aCxcbiAgICAgIGltYWdlLmhlaWdodCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHt3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWV9LFxuICAgICk7XG4gIH1cbiAgY29uc3QgY2FudmFzID0gc2hhcmVkQ29udGV4dC5jYW52YXM7XG4gIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gIGlmIChjYW52YXMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICBpZiAoY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBzaGFyZWRDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgc2hhcmVkQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICByZXR1cm4gc2hhcmVkQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3NpemUuanMnKS5TaXplfVxuICovXG5jb25zdCBkZWZhdWx0U2l6ZSA9IFsyNTYsIDI1Nl07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IFByb21pc2U8RGF0YT59IGxvYWRlciBEYXRhIGxvYWRlci4gIEZvciBsb2FkZXJzIHRoYXQgZ2VuZXJhdGUgaW1hZ2VzLFxuICogdGhlIHByb21pc2Ugc2hvdWxkIG5vdCByZXNvbHZlIHVudGlsIHRoZSBpbWFnZSBpcyBsb2FkZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBBIGR1cmF0aW9uIGZvciB0aWxlIG9wYWNpdHlcbiAqIHRyYW5zaXRpb25zIGluIG1pbGxpc2Vjb25kcy4gQSBkdXJhdGlvbiBvZiAwIGRpc2FibGVzIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vc2l6ZS5qcycpLlNpemV9IFtzaXplPVsyNTYsIDI1Nl1dIFRpbGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7QWJvcnRDb250cm9sbGVyfSBbY29udHJvbGxlcl0gQW4gYWJvcnQgY29udHJvbGxlci5cbiAqIEBhcGlcbiAqL1xuXG5jbGFzcyBEYXRhVGlsZSBleHRlbmRzIFRpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IFRpbGVTdGF0ZS5JRExFO1xuXG4gICAgc3VwZXIob3B0aW9ucy50aWxlQ29vcmQsIHN0YXRlLCB7XG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICBpbnRlcnBvbGF0ZTogb3B0aW9ucy5pbnRlcnBvbGF0ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbigpOiBQcm9taXNlPERhdGE+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJfID0gb3B0aW9ucy5sb2FkZXI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RGF0YX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGF0YV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Vycm9yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lcnJvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi9zaXplLmpzJykuU2l6ZXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG9wdGlvbnMuc2l6ZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fib3J0Q29udHJvbGxlcnxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jb250cm9sbGVyXyA9IG9wdGlvbnMuY29udHJvbGxlciB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBzaXplLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4vc2l6ZS5qcycpLlNpemV9IFRpbGUgc2l6ZS5cbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemVfO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBhc0ltYWdlTGlrZSh0aGlzLmRhdGFfKTtcbiAgICBpZiAoaW1hZ2VEYXRhKSB7XG4gICAgICByZXR1cm4gW2ltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodF07XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgZm9yIHRoZSB0aWxlLlxuICAgKiBAcmV0dXJuIHtEYXRhfSBUaWxlIGRhdGEuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFueSBsb2FkaW5nIGVycm9yLlxuICAgKiBAcmV0dXJuIHtFcnJvcn0gTG9hZGluZyBlcnJvci5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JfO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIHRpbGUgZGF0YS5cbiAgICogQGFwaVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFRpbGVTdGF0ZS5JRExFICYmIHRoaXMuc3RhdGUgIT09IFRpbGVTdGF0ZS5FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxvYWRlcl8oKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhXyA9IGRhdGE7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgICAgICBzZWxmLmNoYW5nZWQoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHNlbGYuZXJyb3JfID0gZXJyb3I7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIGlmICh0aGlzLmNvbnRyb2xsZXJfKSB7XG4gICAgICB0aGlzLmNvbnRyb2xsZXJfLmFib3J0KGRpc3Bvc2VkRXJyb3IpO1xuICAgICAgdGhpcy5jb250cm9sbGVyXyA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFUaWxlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9JbWFnZVRpbGVcbiAqL1xuaW1wb3J0IFRpbGUgZnJvbSAnLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuSW1hZ2V9IGZyb20gJy4vSW1hZ2UuanMnO1xuXG5jbGFzcyBJbWFnZVRpbGUgZXh0ZW5kcyBUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIEltYWdlIHNvdXJjZSBVUkkuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IHRpbGVMb2FkRnVuY3Rpb24gVGlsZSBsb2FkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5PcHRpb25zfSBbb3B0aW9uc10gVGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZUNvb3JkLCBzdGF0ZSwgc3JjLCBjcm9zc09yaWdpbiwgdGlsZUxvYWRGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIHN1cGVyKHRpbGVDb29yZCwgc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9IGNyb3NzT3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgVVJJXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zcmNfID0gc3JjO1xuXG4gICAgdGhpcy5rZXkgPSBzcmM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbmV3IEltYWdlKCk7XG4gICAgaWYgKGNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmltYWdlXy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9mdW5jdGlvbigpOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy51bmxpc3Rlbl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb25fID0gdGlsZUxvYWRGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIEhUTUwgaW1hZ2UgZWxlbWVudCBmb3IgdGhpcyB0aWxlIChtYXkgYmUgYSBDYW52YXMsIEltYWdlLCBvciBWaWRlbykuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gSW1hZ2UuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIEhUTUwgaW1hZ2UgZWxlbWVudCBmb3IgdGhpcyB0aWxlIChtYXkgYmUgYSBDYW52YXMgb3IgcHJlbG9hZGVkIEltYWdlKS5cbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gICAqL1xuICBzZXRJbWFnZShlbGVtZW50KSB7XG4gICAgdGhpcy5pbWFnZV8gPSBlbGVtZW50O1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja3MgbG9hZGluZyBvciByZWFkIGVycm9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgIHRoaXMuaW1hZ2VfID0gZ2V0QmxhbmtJbWFnZSgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBzdWNjZXNzZnVsIGltYWdlIGxvYWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVJbWFnZUxvYWRfKCkge1xuICAgIGNvbnN0IGltYWdlID0gLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAodGhpcy5pbWFnZV8pO1xuICAgIGlmIChpbWFnZS5uYXR1cmFsV2lkdGggJiYgaW1hZ2UubmF0dXJhbEhlaWdodCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgfVxuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBvciByZXRyeSBpZiBsb2FkaW5nIHByZXZpb3VzbHkgZmFpbGVkLlxuICAgKiBMb2FkaW5nIGlzIHRha2VuIGNhcmUgb2YgYnkgdGhlIHRpbGUgcXVldWUsIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzXG4gICAqIG9ubHkgbmVlZGVkIGZvciBwcmVsb2FkaW5nIG9yIGZvciByZWxvYWRpbmcgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICpcbiAgICogVG8gcmV0cnkgbG9hZGluZyB0aWxlcyBvbiBmYWlsZWQgcmVxdWVzdHMsIHVzZSBhIGN1c3RvbSBgdGlsZUxvYWRGdW5jdGlvbmBcbiAgICogdGhhdCBjaGVja3MgZm9yIGVycm9yIHN0YXR1cyBjb2RlcyBhbmQgcmVsb2FkcyBvbmx5IHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzXG4gICAqIDQwOCwgNDI5LCA1MDAsIDUwMiwgNTAzIGFuZCA1MDQsIGFuZCBvbmx5IHdoZW4gbm90IHRvbyBtYW55IHJldHJpZXMgaGF2ZSBiZWVuXG4gICAqIG1hZGUgYWxyZWFkeTpcbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgcmV0cnlDb2RlcyA9IFs0MDgsIDQyOSwgNTAwLCA1MDIsIDUwMywgNTA0XTtcbiAgICogY29uc3QgcmV0cmllcyA9IHt9O1xuICAgKiBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbigodGlsZSwgc3JjKSA9PiB7XG4gICAqICAgY29uc3QgaW1hZ2UgPSB0aWxlLmdldEltYWdlKCk7XG4gICAqICAgZmV0Y2goc3JjKVxuICAgKiAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAqICAgICAgIGlmIChyZXRyeUNvZGVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICogICAgICAgICByZXRyaWVzW3NyY10gPSAocmV0cmllc1tzcmNdIHx8IDApICsgMTtcbiAgICogICAgICAgICBpZiAocmV0cmllc1tzcmNdIDw9IDMpIHtcbiAgICogICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGlsZS5sb2FkKCksIHJldHJpZXNbc3JjXSAqIDEwMDApO1xuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICogICAgICAgfVxuICAgKiAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgKiAgICAgfSlcbiAgICogICAgIC50aGVuKChibG9iKSA9PiB7XG4gICAqICAgICAgIGNvbnN0IGltYWdlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICogICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VVcmw7XG4gICAqICAgICAgIHNldFRpbWVvdXQoKCkgPT4gVVJMLnJldm9rZU9iamVjdFVSTChpbWFnZVVybCksIDUwMDApO1xuICAgKiAgICAgfSlcbiAgICogICAgIC5jYXRjaCgoKSA9PiB0aWxlLnNldFN0YXRlKDMpKTsgLy8gZXJyb3JcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAYXBpXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbmV3IEltYWdlKCk7XG4gICAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luXztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyh0aGlzLCB0aGlzLnNyY18pO1xuICAgICAgdGhpcy51bmxpc3Rlbl8gPSBsaXN0ZW5JbWFnZShcbiAgICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAgIHRoaXMuaGFuZGxlSW1hZ2VMb2FkXy5iaW5kKHRoaXMpLFxuICAgICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfLmJpbmQodGhpcyksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyBldmVudCBoYW5kbGVycyB3aGljaCBsaXN0ZW4gZm9yIGxvYWQgY29tcGxldGlvbiBvciBlcnJvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlXygpIHtcbiAgICBpZiAodGhpcy51bmxpc3Rlbl8pIHtcbiAgICAgIHRoaXMudW5saXN0ZW5fKCk7XG4gICAgICB0aGlzLnVubGlzdGVuXyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmltYWdlXyA9IG51bGw7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSAxLXBpeGVsIGJsYW5rIGltYWdlLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEJsYW5rIGltYWdlLlxuICovXG5mdW5jdGlvbiBnZXRCbGFua0ltYWdlKCkge1xuICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG4gIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgcmV0dXJuIGN0eC5jYW52YXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlVGlsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9MUlVDYWNoZVxuICovXG5cbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5XyBLZXkuXG4gKiBAcHJvcGVydHkge0VudHJ5fG51bGx9IG5ld2VyIE5ld2VyLlxuICogQHByb3BlcnR5IHtFbnRyeXxudWxsfSBvbGRlciBPbGRlci5cbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfIFZhbHVlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50cyBhIExlYXN0LVJlY2VudGx5LVVzZWQgY2FjaGUgd2hlcmUgdGhlIGtleXMgZG8gbm90IGNvbmZsaWN0IHdpdGhcbiAqIE9iamVjdCdzIHByb3BlcnRpZXMgKGUuZy4gJ2hhc093blByb3BlcnR5JyBpcyBub3QgYWxsb3dlZCBhcyBhIGtleSkuIEV4cGlyaW5nXG4gKiBpdGVtcyBmcm9tIHRoZSBjYWNoZSBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHVzZXIuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hpZ2hXYXRlck1hcmtdIEhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhpZ2hXYXRlck1hcmspIHtcbiAgICAvKipcbiAgICAgKiBEZXNpcmVkIG1heCBjYWNoZSBzaXplIGFmdGVyIGV4cGlyZUNhY2hlKCkuIElmIHNldCB0byAwLCBubyBjYWNoZSBlbnRyaWVzXG4gICAgICogd2lsbCBiZSBwcnVuZWQgYXQgYWxsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gaGlnaFdhdGVyTWFyayA6IDIwNDg7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb3VudF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEVudHJ5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmVudHJpZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RW50cnl9XG4gICAgICovXG4gICAgdGhpcy5vbGRlc3RfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBjYW5FeHBpcmVDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoV2F0ZXJNYXJrID4gMCAmJiB0aGlzLmdldENvdW50KCkgPiB0aGlzLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogRXhwaXJlIHRoZSBjYWNoZS4gV2hlbiB0aGUgY2FjaGUgZW50cnkgaXMgYSB7QGxpbmsgbW9kdWxlOm9sL0Rpc3Bvc2FibGV+RGlzcG9zYWJsZX0sXG4gICAqIHRoZSBlbnRyeSB3aWxsIGJlIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gW2tlZXBdIEtleXMgdG8ga2VlcC4gVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlcy5cbiAgICovXG4gIGV4cGlyZUNhY2hlKGtlZXApIHtcbiAgICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMucG9wKCk7XG4gICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBEaXNwb3NhYmxlKSB7XG4gICAgICAgIGVudHJ5LmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNvdW50XyA9IDA7XG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMga2V5LlxuICAgKi9cbiAgY29udGFpbnNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc18uaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsIHN0cmluZywgTFJVQ2FjaGU8VD4pOiA/fSBmIFRoZSBmdW5jdGlvblxuICAgKiAgICAgdG8gY2FsbCBmb3IgZXZlcnkgZW50cnkgZnJvbSB0aGUgb2xkZXN0IHRvIHRoZSBuZXdlci4gVGhpcyBmdW5jdGlvbiB0YWtlc1xuICAgKiAgICAgMyBhcmd1bWVudHMgKHRoZSBlbnRyeSB2YWx1ZSwgdGhlIGVudHJ5IGtleSBhbmQgdGhlIExSVUNhY2hlIG9iamVjdCkuXG4gICAqICAgICBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqL1xuICBmb3JFYWNoKGYpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBmKGVudHJ5LnZhbHVlXywgZW50cnkua2V5XywgdGhpcyk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3B0aW9ucyAocmVzZXJ2ZWQgZm9yIHN1YmNsYXNzZXMpLlxuICAgKiBAcmV0dXJuIHtUfSBWYWx1ZS5cbiAgICovXG4gIGdldChrZXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoXG4gICAgICBlbnRyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgJ1RyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZScsXG4gICAgKTtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgICB9XG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovICh0aGlzLm9sZGVzdF8ubmV3ZXIpO1xuICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyID0gbnVsbDtcbiAgICBlbnRyeS5vbGRlciA9IHRoaXMubmV3ZXN0XztcbiAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBlbnRyeTtcbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgZW50cnkga2V5LlxuICAgKiBAcmV0dXJuIHtUfSBUaGUgcmVtb3ZlZCBlbnRyeS5cbiAgICovXG4gIHJlbW92ZShrZXkpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoXG4gICAgICBlbnRyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgJ1RyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZScsXG4gICAgKTtcbiAgICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5uZXdlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKGVudHJ5Lm9sZGVyKTtcbiAgICAgIGlmICh0aGlzLm5ld2VzdF8pIHtcbiAgICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gICAgICBpZiAodGhpcy5vbGRlc3RfKSB7XG4gICAgICAgIHRoaXMub2xkZXN0Xy5vbGRlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7XG4gICAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIC0tdGhpcy5jb3VudF87XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvdW50LlxuICAgKi9cbiAgZ2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY291bnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEtleXMuXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZW50cnk7XG4gICAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICAgIGtleXNbaSsrXSA9IGVudHJ5LmtleV87XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fSBWYWx1ZXMuXG4gICAqL1xuICBnZXRWYWx1ZXMoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuY291bnRfKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGVudHJ5O1xuICAgIGZvciAoZW50cnkgPSB0aGlzLm5ld2VzdF87IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm9sZGVyKSB7XG4gICAgICB2YWx1ZXNbaSsrXSA9IGVudHJ5LnZhbHVlXztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUfSBMYXN0IHZhbHVlLlxuICAgKi9cbiAgcGVla0xhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub2xkZXN0Xy52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBMYXN0IGtleS5cbiAgICovXG4gIHBlZWtMYXN0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8ua2V5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGtleSBvZiB0aGUgbmV3ZXN0IGl0ZW0gaW4gdGhlIGNhY2hlLiAgVGhyb3dzIGlmIHRoZSBjYWNoZSBpcyBlbXB0eS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmV3ZXN0IGtleS5cbiAgICovXG4gIHBlZWtGaXJzdEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdlc3RfLmtleV87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGVudHJ5IHdpdGhvdXQgdXBkYXRpbmcgbGVhc3QgcmVjZW50bHkgdXNlZCB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFZhbHVlLlxuICAgKi9cbiAgcGVlayhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzX1trZXldPy52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBwb3AoKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gICAgZGVsZXRlIHRoaXMuZW50cmllc19bZW50cnkua2V5X107XG4gICAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gICAgaWYgKCF0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMubmV3ZXN0XyA9IG51bGw7XG4gICAgfVxuICAgIC0tdGhpcy5jb3VudF87XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHJlcGxhY2Uoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuZ2V0KGtleSk7IC8vIHVwZGF0ZSBgbmV3ZXN0X2BcbiAgICB0aGlzLmVudHJpZXNfW2tleV0udmFsdWVfID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGFzc2VydChcbiAgICAgICEoa2V5IGluIHRoaXMuZW50cmllc18pLFxuICAgICAgJ1RyaWVkIHRvIHNldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGlzIHVzZWQgYWxyZWFkeScsXG4gICAgKTtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIGtleV86IGtleSxcbiAgICAgIG5ld2VyOiBudWxsLFxuICAgICAgb2xkZXI6IHRoaXMubmV3ZXN0XyxcbiAgICAgIHZhbHVlXzogdmFsdWUsXG4gICAgfTtcbiAgICBpZiAoIXRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gZW50cnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIH1cbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICB0aGlzLmVudHJpZXNfW2tleV0gPSBlbnRyeTtcbiAgICArK3RoaXMuY291bnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgZm9yIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQ2FjaGUgc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2l6ZShzaXplKSB7XG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gc2l6ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMUlVDYWNoZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIGFsbG93ZWQgdGhyZXNob2xkICAoaW4gcGl4ZWxzKSBmb3IgcmVwcm9qZWN0aW9uXG4gKiB0cmlhbmd1bGF0aW9uLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEVSUk9SX1RIUkVTSE9MRCA9IDAuNTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL1RyaWFuZ3VsYXRpb25cbiAqL1xuaW1wb3J0IHtcbiAgYm91bmRpbmdFeHRlbnQsXG4gIGNyZWF0ZUVtcHR5LFxuICBleHRlbmRDb29yZGluYXRlLFxuICBnZXRBcmVhLFxuICBnZXRCb3R0b21MZWZ0LFxuICBnZXRCb3R0b21SaWdodCxcbiAgZ2V0VG9wTGVmdCxcbiAgZ2V0VG9wUmlnaHQsXG4gIGdldFdpZHRoLFxuICBpbnRlcnNlY3RzLFxufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtnZXRUcmFuc2Zvcm19IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIFNpbmdsZSB0cmlhbmdsZTsgY29uc2lzdHMgb2YgMyBzb3VyY2UgcG9pbnRzIGFuZCAzIHRhcmdldCBwb2ludHMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmlhbmdsZVxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBzb3VyY2UgU291cmNlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSB0YXJnZXQgVGFyZ2V0LlxuICovXG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygc3ViZGl2aXNpb24gc3RlcHMgZHVyaW5nIHJhc3RlciByZXByb2plY3Rpb24gdHJpYW5ndWxhdGlvbi5cbiAqIFByZXZlbnRzIGhpZ2ggbWVtb3J5IHVzYWdlIGFuZCBsYXJnZSBudW1iZXIgb2YgcHJvajQgY2FsbHMgKGZvciBjZXJ0YWluXG4gKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGFyZWFzKS4gQXQgbW9zdCBgMiooMl50aGlzKWAgdHJpYW5nbGVzIGFyZSBjcmVhdGVkIGZvclxuICogZWFjaCB0cmlhbmd1bGF0ZWQgZXh0ZW50ICh0aWxlL2ltYWdlKS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9TVUJESVZJU0lPTiA9IDEwO1xuXG4vKipcbiAqIE1heGltdW0gYWxsb3dlZCBzaXplIG9mIHRyaWFuZ2xlIHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoLiBXaGVuIHRyYW5zZm9ybWluZ1xuICogY29ybmVycyBvZiB3b3JsZCBleHRlbnQgYmV0d2VlbiBjZXJ0YWluIHByb2plY3Rpb25zLCB0aGUgcmVzdWx0aW5nXG4gKiB0cmlhbmd1bGF0aW9uIHNlZW1zIHRvIGhhdmUgemVybyBlcnJvciBhbmQgbm8gc3ViZGl2aXNpb24gaXMgcGVyZm9ybWVkLiBJZlxuICogdGhlIHRyaWFuZ2xlIHdpZHRoIGlzIG1vcmUgdGhhbiB0aGlzIChyZWxhdGl2ZSB0byB3b3JsZCB3aWR0aDsgMC0xKSxcbiAqIHN1YmRpdmlzb24gaXMgZm9yY2VkICh1cCB0byBgTUFYX1NVQkRJVklTSU9OYCkuIERlZmF1bHQgaXMgYDAuMjVgLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX1RSSUFOR0xFX1dJRFRIID0gMC4yNTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBjb250YWluaW5nIHRyaWFuZ3VsYXRpb24gb2YgdGhlIGdpdmVuIHRhcmdldCBleHRlbnQuXG4gKiBVc2VkIGZvciBkZXRlcm1pbmluZyBzb3VyY2UgZGF0YSBhbmQgdGhlIHJlcHJvamVjdGlvbiBpdHNlbGYuXG4gKi9cbmNsYXNzIFRyaWFuZ3VsYXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudCB0byB0cmlhbmd1bGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhTb3VyY2VFeHRlbnQgTWF4aW1hbCBzb3VyY2UgZXh0ZW50IHRoYXQgY2FuIGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvclRocmVzaG9sZCBBY2NlcHRhYmxlIGVycm9yIChpbiBzb3VyY2UgdW5pdHMpLlxuICAgKiBAcGFyYW0gez9udW1iZXJ9IGRlc3RpbmF0aW9uUmVzb2x1dGlvbiBUaGUgKG9wdGlvbmFsKSByZXNvbHV0aW9uIG9mIHRoZSBkZXN0aW5hdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNvdXJjZVByb2osXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRFeHRlbnQsXG4gICAgbWF4U291cmNlRXh0ZW50LFxuICAgIGVycm9yVGhyZXNob2xkLFxuICAgIGRlc3RpbmF0aW9uUmVzb2x1dGlvbixcbiAgKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VQcm9qXyA9IHNvdXJjZVByb2o7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFByb2pfID0gdGFyZ2V0UHJvajtcblxuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovXG4gICAgbGV0IHRyYW5zZm9ybUludkNhY2hlID0ge307XG4gICAgY29uc3QgdHJhbnNmb3JtSW52ID0gZ2V0VHJhbnNmb3JtKHRoaXMudGFyZ2V0UHJval8sIHRoaXMuc291cmNlUHJval8pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgQSBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtSW52XyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBjb25zdCBrZXkgPSBjWzBdICsgJy8nICsgY1sxXTtcbiAgICAgIGlmICghdHJhbnNmb3JtSW52Q2FjaGVba2V5XSkge1xuICAgICAgICB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldID0gdHJhbnNmb3JtSW52KGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybUludkNhY2hlW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhTb3VyY2VFeHRlbnRfID0gbWF4U291cmNlRXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JUaHJlc2hvbGRTcXVhcmVkXyA9IGVycm9yVGhyZXNob2xkICogZXJyb3JUaHJlc2hvbGQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJpYW5nbGU+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmlhbmdsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgdHJpYW5ndWxhdGlvbiBjcm9zc2VzIGVkZ2Ugb2YgdGhlIHNvdXJjZSBwcm9qZWN0aW9uLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYW5XcmFwWEluU291cmNlXyA9XG4gICAgICB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICEhbWF4U291cmNlRXh0ZW50ICYmXG4gICAgICAhIXRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgJiZcbiAgICAgIGdldFdpZHRoKG1heFNvdXJjZUV4dGVudCkgPj0gZ2V0V2lkdGgodGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlV29ybGRXaWR0aF8gPSB0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpXG4gICAgICA/IGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8gPSB0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpXG4gICAgICA/IGdldFdpZHRoKHRoaXMudGFyZ2V0UHJval8uZ2V0RXh0ZW50KCkpXG4gICAgICA6IG51bGw7XG5cbiAgICBjb25zdCBkZXN0aW5hdGlvblRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Ub3BSaWdodCA9IGdldFRvcFJpZ2h0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Cb3R0b21SaWdodCA9IGdldEJvdHRvbVJpZ2h0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25Cb3R0b21MZWZ0ID0gZ2V0Qm90dG9tTGVmdCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IHNvdXJjZVRvcExlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BMZWZ0KTtcbiAgICBjb25zdCBzb3VyY2VUb3BSaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcFJpZ2h0KTtcbiAgICBjb25zdCBzb3VyY2VCb3R0b21SaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0KTtcbiAgICBjb25zdCBzb3VyY2VCb3R0b21MZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tTGVmdCk7XG5cbiAgICAvKlxuICAgICAqIFRoZSBtYXhTdWJkaXZpc2lvbiBjb250cm9scyBob3cgbWFueSBzcGxpdHRpbmdzIG9mIHRoZSB0YXJnZXQgYXJlYSBjYW5cbiAgICAgKiBiZSBkb25lLiBUaGUgaWRlYSBoZXJlIGlzIHRvIGRvIGEgbGluZWFyIG1hcHBpbmcgb2YgdGhlIHRhcmdldCBhcmVhc1xuICAgICAqIGJ1dCB0aGUgYWN0dWFsIG92ZXJhbGwgcmVwcm9qZWN0aW9uIChjYW4gYmUpIGV4dHJlbWVseSBub24tbGluZWFyLiBUaGVcbiAgICAgKiBkZWZhdWx0IHZhbHVlIG9mIE1BWF9TVUJESVZJU0lPTiB3YXMgY2hvc2VuIGJhc2VkIG9uIG1hcHBpbmcgYSAyNTZ4MjU2XG4gICAgICogdGlsZSBzaXplLiBIb3dldmVyIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyBjYWxsZWQgdG8gcmVtYXAgY2FudmFzIHJlbmRlcmVkXG4gICAgICogbGF5ZXJzIHdoaWNoIGNhbiBiZSBtdWNoIGxhcmdlci4gVGhpcyBjYWxjdWxhdGlvbiBpbmNyZWFzZXMgdGhlIG1heFN1YmRpdmlzaW9uXG4gICAgICogdmFsdWUgYnkgdGhlIHJpZ2h0IGZhY3RvciBzbyB0aGF0IGVhY2ggMjU2eDI1NiBwaXhlbCBhcmVhIGhhc1xuICAgICAqIE1BWF9TVUJESVZJU0lPTiBkaXZpc2lvbnMuXG4gICAgICovXG4gICAgY29uc3QgbWF4U3ViZGl2aXNpb24gPVxuICAgICAgTUFYX1NVQkRJVklTSU9OICtcbiAgICAgIChkZXN0aW5hdGlvblJlc29sdXRpb25cbiAgICAgICAgPyBNYXRoLm1heChcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgIE1hdGgubG9nMihcbiAgICAgICAgICAgICAgICBnZXRBcmVhKHRhcmdldEV4dGVudCkgL1xuICAgICAgICAgICAgICAgICAgKGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIDI1NiAqIDI1NiksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApLFxuICAgICAgICAgIClcbiAgICAgICAgOiAwKTtcblxuICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICBkZXN0aW5hdGlvblRvcExlZnQsXG4gICAgICBkZXN0aW5hdGlvblRvcFJpZ2h0LFxuICAgICAgZGVzdGluYXRpb25Cb3R0b21SaWdodCxcbiAgICAgIGRlc3RpbmF0aW9uQm90dG9tTGVmdCxcbiAgICAgIHNvdXJjZVRvcExlZnQsXG4gICAgICBzb3VyY2VUb3BSaWdodCxcbiAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0LFxuICAgICAgc291cmNlQm90dG9tTGVmdCxcbiAgICAgIG1heFN1YmRpdmlzaW9uLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy53cmFwc1hJblNvdXJjZV8pIHtcbiAgICAgIGxldCBsZWZ0Qm91bmQgPSBJbmZpbml0eTtcbiAgICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICAgIGxlZnRCb3VuZCA9IE1hdGgubWluKFxuICAgICAgICAgIGxlZnRCb3VuZCxcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMF1bMF0sXG4gICAgICAgICAgdHJpYW5nbGUuc291cmNlWzFdWzBdLFxuICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVsyXVswXSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaGlmdCB0cmlhbmdsZXMgdG8gYmUgYXMgY2xvc2UgdG8gYGxlZnRCb3VuZGAgYXMgcG9zc2libGVcbiAgICAgIC8vIChpZiB0aGUgZGlzdGFuY2UgaXMgbW9yZSB0aGFuIGB3b3JsZFdpZHRoIC8gMmAgaXQgY2FuIGJlIGNsb3Nlci5cbiAgICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKCh0cmlhbmdsZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMF1bMF0sXG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sXG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMl1bMF0sXG4gICAgICAgICAgKSAtXG4gICAgICAgICAgICBsZWZ0Qm91bmQgPlxuICAgICAgICAgIHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1RyaWFuZ2xlID0gW1xuICAgICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzBdWzFdXSxcbiAgICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVsxXV0sXG4gICAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzJdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMV1dLFxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKG5ld1RyaWFuZ2xlWzBdWzBdIC0gbGVmdEJvdW5kID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdUcmlhbmdsZVsxXVswXSAtIGxlZnRCb3VuZCA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3VHJpYW5nbGVbMl1bMF0gLSBsZWZ0Qm91bmQgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMl1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSYXJlbHkgKGlmIHRoZSBleHRlbnQgY29udGFpbnMgYm90aCB0aGUgZGF0ZWxpbmUgYW5kIHByaW1lIG1lcmlkaWFuKVxuICAgICAgICAgIC8vIHRoZSBzaGlmdCBjYW4gaW4gdHVybiBicmVhayBzb21lIHRyaWFuZ2xlcy5cbiAgICAgICAgICAvLyBEZXRlY3QgdGhpcyBoZXJlIGFuZCBkb24ndCBzaGlmdCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICAgIGNvbnN0IG1pblggPSBNYXRoLm1pbihcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG1heFggPSBNYXRoLm1heChcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChtYXhYIC0gbWluWCA8IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2UgPSBuZXdUcmlhbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybUludkNhY2hlID0ge307XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0cmlhbmdsZSB0byB0aGUgdHJpYW5ndWxhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGEgVGhlIHRhcmdldCBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFTcmMgVGhlIHNvdXJjZSBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZFRyaWFuZ2xlXyhhLCBiLCBjLCBhU3JjLCBiU3JjLCBjU3JjKSB7XG4gICAgdGhpcy50cmlhbmdsZXNfLnB1c2goe1xuICAgICAgc291cmNlOiBbYVNyYywgYlNyYywgY1NyY10sXG4gICAgICB0YXJnZXQ6IFthLCBiLCBjXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHF1YWQgKHBvaW50cyBpbiBjbG9jay13aXNlIG9yZGVyKSB0byB0aGUgdHJpYW5ndWxhdGlvblxuICAgKiAoYW5kIHJlcHJvamVjdHMgdGhlIHZlcnRpY2VzKSBpZiB2YWxpZC5cbiAgICogUGVyZm9ybXMgcXVhZCBzdWJkaXZpc2lvbiBpZiBuZWVkZWQgdG8gaW5jcmVhc2UgcHJlY2lzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGIgVGhlIHRhcmdldCBiIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIFRoZSB0YXJnZXQgYyBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZCBUaGUgdGFyZ2V0IGQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFTcmMgVGhlIHNvdXJjZSBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRTcmMgVGhlIHNvdXJjZSBkIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTdWJkaXZpc2lvbiBNYXhpbWFsIGFsbG93ZWQgc3ViZGl2aXNpb24gb2YgdGhlIHF1YWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRRdWFkXyhhLCBiLCBjLCBkLCBhU3JjLCBiU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbikge1xuICAgIGNvbnN0IHNvdXJjZVF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYVNyYywgYlNyYywgY1NyYywgZFNyY10pO1xuICAgIGNvbnN0IHNvdXJjZUNvdmVyYWdlWCA9IHRoaXMuc291cmNlV29ybGRXaWR0aF9cbiAgICAgID8gZ2V0V2lkdGgoc291cmNlUXVhZEV4dGVudCkgLyB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfXG4gICAgICA6IG51bGw7XG4gICAgY29uc3Qgc291cmNlV29ybGRXaWR0aCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zb3VyY2VXb3JsZFdpZHRoXyk7XG5cbiAgICAvLyB3aGVuIHRoZSBxdWFkIGlzIHdyYXBwZWQgaW4gdGhlIHNvdXJjZSBwcm9qZWN0aW9uXG4gICAgLy8gaXQgY292ZXJzIG1vc3Qgb2YgdGhlIHByb2plY3Rpb24gZXh0ZW50LCBidXQgbm90IGZ1bGx5XG4gICAgY29uc3Qgd3JhcHNYID1cbiAgICAgIHRoaXMuc291cmNlUHJval8uY2FuV3JhcFgoKSAmJlxuICAgICAgc291cmNlQ292ZXJhZ2VYID4gMC41ICYmXG4gICAgICBzb3VyY2VDb3ZlcmFnZVggPCAxO1xuXG4gICAgbGV0IG5lZWRzU3ViZGl2aXNpb24gPSBmYWxzZTtcblxuICAgIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldFByb2pfLmlzR2xvYmFsKCkgJiYgdGhpcy50YXJnZXRXb3JsZFdpZHRoXykge1xuICAgICAgICBjb25zdCB0YXJnZXRRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2EsIGIsIGMsIGRdKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q292ZXJhZ2VYID1cbiAgICAgICAgICBnZXRXaWR0aCh0YXJnZXRRdWFkRXh0ZW50KSAvIHRoaXMudGFyZ2V0V29ybGRXaWR0aF87XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPVxuICAgICAgICAgIHRhcmdldENvdmVyYWdlWCA+IE1BWF9UUklBTkdMRV9XSURUSCB8fCBuZWVkc1N1YmRpdmlzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKCF3cmFwc1ggJiYgdGhpcy5zb3VyY2VQcm9qXy5pc0dsb2JhbCgpICYmIHNvdXJjZUNvdmVyYWdlWCkge1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID1cbiAgICAgICAgICBzb3VyY2VDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEggfHwgbmVlZHNTdWJkaXZpc2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24gJiYgdGhpcy5tYXhTb3VyY2VFeHRlbnRfKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbMF0pICYmXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbMV0pICYmXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbMl0pICYmXG4gICAgICAgIGlzRmluaXRlKHNvdXJjZVF1YWRFeHRlbnRbM10pXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKHNvdXJjZVF1YWRFeHRlbnQsIHRoaXMubWF4U291cmNlRXh0ZW50XykpIHtcbiAgICAgICAgICAvLyB3aG9sZSBxdWFkIG91dHNpZGUgc291cmNlIHByb2plY3Rpb24gZXh0ZW50IC0+IGlnbm9yZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpc05vdEZpbml0ZSA9IDA7XG5cbiAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWlzRmluaXRlKGFTcmNbMF0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShhU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYlNyY1swXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGJTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShjU3JjWzBdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoY1NyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGRTcmNbMF0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShkU3JjWzFdKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdCBtaWdodCBiZSB0aGUgY2FzZSB0aGF0IG9ubHkgMSBvZiB0aGUgcG9pbnRzIGlzIGluZmluaXRlLiBJbiB0aGlzIGNhc2VcbiAgICAgICAgICAvLyB3ZSBjYW4gZHJhdyBhIHNpbmdsZSB0cmlhbmdsZSB3aXRoIHRoZSBvdGhlciB0aHJlZSBwb2ludHNcbiAgICAgICAgICBpc05vdEZpbml0ZSA9XG4gICAgICAgICAgICAoIWlzRmluaXRlKGFTcmNbMF0pIHx8ICFpc0Zpbml0ZShhU3JjWzFdKSA/IDggOiAwKSArXG4gICAgICAgICAgICAoIWlzRmluaXRlKGJTcmNbMF0pIHx8ICFpc0Zpbml0ZShiU3JjWzFdKSA/IDQgOiAwKSArXG4gICAgICAgICAgICAoIWlzRmluaXRlKGNTcmNbMF0pIHx8ICFpc0Zpbml0ZShjU3JjWzFdKSA/IDIgOiAwKSArXG4gICAgICAgICAgICAoIWlzRmluaXRlKGRTcmNbMF0pIHx8ICFpc0Zpbml0ZShkU3JjWzFdKSA/IDEgOiAwKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSAxICYmXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSAyICYmXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSA0ICYmXG4gICAgICAgICAgICBpc05vdEZpbml0ZSAhPSA4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IFsoYVswXSArIGNbMF0pIC8gMiwgKGFbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICBjb25zdCBjZW50ZXJTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oY2VudGVyKTtcblxuICAgICAgICBsZXQgZHg7XG4gICAgICAgIGlmICh3cmFwc1gpIHtcbiAgICAgICAgICBjb25zdCBjZW50ZXJTcmNFc3RpbVggPVxuICAgICAgICAgICAgKG1vZHVsbyhhU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKSArXG4gICAgICAgICAgICAgIG1vZHVsbyhjU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKSkgL1xuICAgICAgICAgICAgMjtcbiAgICAgICAgICBkeCA9IGNlbnRlclNyY0VzdGltWCAtIG1vZHVsbyhjZW50ZXJTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR4ID0gKGFTcmNbMF0gKyBjU3JjWzBdKSAvIDIgLSBjZW50ZXJTcmNbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHkgPSAoYVNyY1sxXSArIGNTcmNbMV0pIC8gMiAtIGNlbnRlclNyY1sxXTtcbiAgICAgICAgY29uc3QgY2VudGVyU3JjRXJyb3JTcXVhcmVkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSBjZW50ZXJTcmNFcnJvclNxdWFyZWQgPiB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF87XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgICBpZiAoTWF0aC5hYnMoYVswXSAtIGNbMF0pIDw9IE1hdGguYWJzKGFbMV0gLSBjWzFdKSkge1xuICAgICAgICAgIC8vIHNwbGl0IGhvcml6b250YWxseSAodG9wICYgYm90dG9tKVxuICAgICAgICAgIGNvbnN0IGJjID0gWyhiWzBdICsgY1swXSkgLyAyLCAoYlsxXSArIGNbMV0pIC8gMl07XG4gICAgICAgICAgY29uc3QgYmNTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oYmMpO1xuICAgICAgICAgIGNvbnN0IGRhID0gWyhkWzBdICsgYVswXSkgLyAyLCAoZFsxXSArIGFbMV0pIC8gMl07XG4gICAgICAgICAgY29uc3QgZGFTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oZGEpO1xuXG4gICAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYmMsXG4gICAgICAgICAgICBkYSxcbiAgICAgICAgICAgIGFTcmMsXG4gICAgICAgICAgICBiU3JjLFxuICAgICAgICAgICAgYmNTcmMsXG4gICAgICAgICAgICBkYVNyYyxcbiAgICAgICAgICAgIG1heFN1YmRpdmlzaW9uIC0gMSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBkYSxcbiAgICAgICAgICAgIGJjLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkYVNyYyxcbiAgICAgICAgICAgIGJjU3JjLFxuICAgICAgICAgICAgY1NyYyxcbiAgICAgICAgICAgIGRTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDEsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5IChsZWZ0ICYgcmlnaHQpXG4gICAgICAgICAgY29uc3QgYWIgPSBbKGFbMF0gKyBiWzBdKSAvIDIsIChhWzFdICsgYlsxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBhYlNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhhYik7XG4gICAgICAgICAgY29uc3QgY2QgPSBbKGNbMF0gKyBkWzBdKSAvIDIsIChjWzFdICsgZFsxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBjZFNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZCk7XG5cbiAgICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGFiLFxuICAgICAgICAgICAgY2QsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgYVNyYyxcbiAgICAgICAgICAgIGFiU3JjLFxuICAgICAgICAgICAgY2RTcmMsXG4gICAgICAgICAgICBkU3JjLFxuICAgICAgICAgICAgbWF4U3ViZGl2aXNpb24gLSAxLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICAgIGFiLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBjZCxcbiAgICAgICAgICAgIGFiU3JjLFxuICAgICAgICAgICAgYlNyYyxcbiAgICAgICAgICAgIGNTcmMsXG4gICAgICAgICAgICBjZFNyYyxcbiAgICAgICAgICAgIG1heFN1YmRpdmlzaW9uIC0gMSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod3JhcHNYKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuV3JhcFhJblNvdXJjZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEV4YWN0bHkgemVybyBvciBvbmUgb2YgKlNyYyBpcyBub3QgZmluaXRlXG4gICAgLy8gVGhlIHRyaWFuZ2xlcyBtdXN0IGhhdmUgdGhlIGRpYWdvbmFsIGxpbmUgYXMgdGhlIGZpcnN0IHNpZGVcbiAgICAvLyBUaGlzIGlzIHRvIGFsbG93IGVhc3kgY29kZSBpbiByZXByb2oucyB0byBtYWtlIGl0IHN0cmFpZ2h0IGZvciBicm9rZW5cbiAgICAvLyBicm93c2VycyB0aGF0IGNhbid0IGhhbmRsZSBkaWFnb25hbCBjbGlwcGluZ1xuICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGIpID09IDApIHtcbiAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGMsIGQsIGFTcmMsIGNTcmMsIGRTcmMpO1xuICAgIH1cbiAgICBpZiAoKGlzTm90RmluaXRlICYgMHhlKSA9PSAwKSB7XG4gICAgICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBjLCBiLCBhU3JjLCBjU3JjLCBiU3JjKTtcbiAgICB9XG4gICAgaWYgKGlzTm90RmluaXRlKSB7XG4gICAgICAvLyBUcnkgdGhlIG90aGVyIHR3byB0cmlhbmdsZXNcbiAgICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGQpID09IDApIHtcbiAgICAgICAgdGhpcy5hZGRUcmlhbmdsZV8oYiwgZCwgYSwgYlNyYywgZFNyYywgYVNyYyk7XG4gICAgICB9XG4gICAgICBpZiAoKGlzTm90RmluaXRlICYgMHg3KSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGIsIGQsIGMsIGJTcmMsIGRTcmMsIGNTcmMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGV4dGVudCBvZiB0aGUgYHNvdXJjZWAgY29vcmRpbmF0ZXMgZnJvbSBhbGwgdGhlIHRyaWFuZ2xlcy5cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gQ2FsY3VsYXRlZCBleHRlbnQuXG4gICAqL1xuICBjYWxjdWxhdGVTb3VyY2VFeHRlbnQoKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBjb25zdCBzcmMgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzBdKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMV0pO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1syXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PFRyaWFuZ2xlPn0gQXJyYXkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJpYW5nbGVzLlxuICAgKi9cbiAgZ2V0VHJpYW5nbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnRyaWFuZ2xlc187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJpYW5ndWxhdGlvbjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qXG4gKi9cbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlRW1wdHksXG4gIGV4dGVuZCxcbiAgZm9yRWFjaENvcm5lcixcbiAgZ2V0Q2VudGVyLFxuICBnZXRIZWlnaHQsXG4gIGdldFRvcExlZnQsXG4gIGdldFdpZHRoLFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRCwgcmVsZWFzZUNhbnZhc30gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtnZXRQb2ludFJlc29sdXRpb24sIHRyYW5zZm9ybX0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7c29sdmVMaW5lYXJTeXN0ZW19IGZyb20gJy4vbWF0aC5qcyc7XG5cbmxldCBicm9rZW5EaWFnb25hbFJlbmRlcmluZ187XG5cbi8qKlxuICogQHR5cGUge0FycmF5PEhUTUxDYW52YXNFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbnZhc1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBUaGlzIGRyYXdzIGEgc21hbGwgdHJpYW5nbGUgaW50byBhIGNhbnZhcyBieSBzZXR0aW5nIHRoZSB0cmlhbmdsZSBhcyB0aGUgY2xpcCByZWdpb25cbiAqIGFuZCB0aGVuIGRyYXdpbmcgYSAodG9vIGxhcmdlKSByZWN0YW5nbGVcbiAqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGRyYXcgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gdTEgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LiBUaGUgZmlyc3QgcG9pbnQgaXMgMCwwLlxuICogQHBhcmFtIHtudW1iZXJ9IHYxIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1MiBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0aGlyZCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2MiBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSB0aGlyZCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gZHJhd1Rlc3RUcmlhbmdsZShjdHgsIHUxLCB2MSwgdTIsIHYyKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgY3R4LmxpbmVUbyh1MSwgdjEpO1xuICBjdHgubGluZVRvKHUyLCB2Mik7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmNsaXAoKTtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIE1hdGgubWF4KHUxLCB1MikgKyAxLCBNYXRoLm1heCh2MSwgdjIpKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgZGF0YSBmcm9tIGdldEltYWdlRGF0YSwgc2VlIGlmIHRoZSByaWdodCB2YWx1ZXMgYXBwZWFyIGF0IHRoZSBwcm92aWRlZCBvZmZzZXQuXG4gKiBSZXR1cm5zIHRydWUgaWYgZWl0aGVyIHRoZSBjb2xvciBvciB0cmFuc3BhcmVuY3kgaXMgb2ZmXG4gKlxuICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheX0gZGF0YSBUaGUgZGF0YSByZXR1cm5lZCBmcm9tIGdldEltYWdlRGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgcGl4ZWwgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIGRhdGEuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBkaWFnb25hbCByZW5kZXJpbmcgaXMgYnJva2VuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeUJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKGRhdGEsIG9mZnNldCkge1xuICAvLyB0aGUgdmFsdWVzIG91Z2h0IHRvIGJlIGNsb3NlIHRvIHRoZSByZ2JhKDIxMCwgMCwgMCwgMC43NSlcbiAgcmV0dXJuIChcbiAgICBNYXRoLmFicyhkYXRhW29mZnNldCAqIDRdIC0gMjEwKSA+IDIgfHxcbiAgICBNYXRoLmFicyhkYXRhW29mZnNldCAqIDQgKyAzXSAtIDAuNzUgKiAyNTUpID4gMlxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBjb25maWd1cmF0aW9uIGNhbiByZW5kZXIgdHJpYW5ndWxhciBjbGlwIHJlZ2lvbnMgY29ycmVjdGx5LlxuICogVGhpcyB2YWx1ZSBpcyBjYWNoZWQgc28gdGhlIGZ1bmN0aW9uIGlzIG9ubHkgZXhwZW5zaXZlIHRoZSBmaXJzdCB0aW1lIGNhbGxlZC5cbiAqIEZpcmVmb3ggb24gV2luZG93cyAoYXMgb2Ygbm93KSBkb2VzIG5vdCBpZiBIV0EgaXMgZW5hYmxlZC4gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MDY5NzZcbiAqIENocm9tZSB3b3JrcywgYW5kIGV2ZXJ5dGhpbmcgc2VlbXMgdG8gd29yayBvbiBPU1ggYW5kIEFuZHJvaWQuIFRoaXMgZnVuY3Rpb24gY2FjaGVzIHRoZVxuICogcmVzdWx0LiBJIHN1cHBvc2UgdGhhdCBpdCBpcyBjb25jZWl2YWJseSBwb3NzaWJsZSB0aGF0IGEgYnJvd3NlciBtaWdodCBmbGlwIG1vZGVzIHdoaWxlIHRoZSBhcHAgaXNcbiAqIHJ1bm5pbmcsIGJ1dCBsZXRzIGhvcGUgbm90LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIERpYWdvbmFsIFJlbmRlcmluZyBpcyBicm9rZW4uXG4gKi9cbmZ1bmN0aW9uIGlzQnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoKSB7XG4gIGlmIChicm9rZW5EaWFnb25hbFJlbmRlcmluZ18gPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCg2LCA2LCBjYW52YXNQb29sKTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2xpZ2h0ZXInO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyMTAsIDAsIDAsIDAuNzUpJztcbiAgICBkcmF3VGVzdFRyaWFuZ2xlKGN0eCwgNCwgNSwgNCwgMCk7XG4gICAgZHJhd1Rlc3RUcmlhbmdsZShjdHgsIDQsIDUsIDAsIDUpO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDMsIDMpLmRhdGE7XG4gICAgYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfID1cbiAgICAgIHZlcmlmeUJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKGRhdGEsIDApIHx8XG4gICAgICB2ZXJpZnlCcm9rZW5EaWFnb25hbFJlbmRlcmluZyhkYXRhLCA0KSB8fFxuICAgICAgdmVyaWZ5QnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoZGF0YSwgOCk7XG4gICAgcmVsZWFzZUNhbnZhcyhjdHgpO1xuICAgIGNhbnZhc1Bvb2wucHVzaChjdHguY2FudmFzKTtcbiAgfVxuXG4gIHJldHVybiBicm9rZW5EaWFnb25hbFJlbmRlcmluZ187XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpZGVhbCByZXNvbHV0aW9uIHRvIHVzZSBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICogcGl4ZWwgbWFwcGluZyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byAxOjEgZHVyaW5nIHJlcHJvamVjdGlvbi5cbiAqIFRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgcmVnYXJkbGVzcyBvZiB3aGF0IHJlc29sdXRpb25zXG4gKiBhcmUgYWN0dWFsbHkgYXZhaWxhYmxlIGluIHRoZSBkYXRhc2V0IChUaWxlR3JpZCwgSW1hZ2UsIC4uLikuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdGFyZ2V0Q2VudGVyIFRhcmdldCBjZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJlc3QgcmVzb2x1dGlvbiB0byB1c2UuIENhbiBiZSArLUluZmluaXR5LCBOYU4gb3IgMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24oXG4gIHNvdXJjZVByb2osXG4gIHRhcmdldFByb2osXG4gIHRhcmdldENlbnRlcixcbiAgdGFyZ2V0UmVzb2x1dGlvbixcbikge1xuICBjb25zdCBzb3VyY2VDZW50ZXIgPSB0cmFuc2Zvcm0odGFyZ2V0Q2VudGVyLCB0YXJnZXRQcm9qLCBzb3VyY2VQcm9qKTtcblxuICAvLyBjYWxjdWxhdGUgdGhlIGlkZWFsIHJlc29sdXRpb24gb2YgdGhlIHNvdXJjZSBkYXRhXG4gIGxldCBzb3VyY2VSZXNvbHV0aW9uID0gZ2V0UG9pbnRSZXNvbHV0aW9uKFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICB0YXJnZXRDZW50ZXIsXG4gICk7XG5cbiAgY29uc3QgdGFyZ2V0TWV0ZXJzUGVyVW5pdCA9IHRhcmdldFByb2ouZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICBpZiAodGFyZ2V0TWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlUmVzb2x1dGlvbiAqPSB0YXJnZXRNZXRlcnNQZXJVbml0O1xuICB9XG4gIGNvbnN0IHNvdXJjZU1ldGVyc1BlclVuaXQgPSBzb3VyY2VQcm9qLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgaWYgKHNvdXJjZU1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVJlc29sdXRpb24gLz0gc291cmNlTWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8vIEJhc2VkIG9uIHRoZSBwcm9qZWN0aW9uIHByb3BlcnRpZXMsIHRoZSBwb2ludCByZXNvbHV0aW9uIGF0IHRoZSBzcGVjaWZpZWRcbiAgLy8gY29vcmRpbmF0ZXMgbWF5IGJlIHNsaWdodGx5IGRpZmZlcmVudC4gV2UgbmVlZCB0byByZXZlcnNlLWNvbXBlbnNhdGUgdGhpc1xuICAvLyBpbiBvcmRlciB0byBhY2hpZXZlIG9wdGltYWwgcmVzdWx0cy5cblxuICBjb25zdCBzb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICBpZiAoIXNvdXJjZUV4dGVudCB8fCBjb250YWluc0Nvb3JkaW5hdGUoc291cmNlRXh0ZW50LCBzb3VyY2VDZW50ZXIpKSB7XG4gICAgY29uc3QgY29tcGVuc2F0aW9uRmFjdG9yID1cbiAgICAgIGdldFBvaW50UmVzb2x1dGlvbihzb3VyY2VQcm9qLCBzb3VyY2VSZXNvbHV0aW9uLCBzb3VyY2VDZW50ZXIpIC9cbiAgICAgIHNvdXJjZVJlc29sdXRpb247XG4gICAgaWYgKGlzRmluaXRlKGNvbXBlbnNhdGlvbkZhY3RvcikgJiYgY29tcGVuc2F0aW9uRmFjdG9yID4gMCkge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiAvPSBjb21wZW5zYXRpb25GYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVJlc29sdXRpb247XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpZGVhbCByZXNvbHV0aW9uIHRvIHVzZSBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICogcGl4ZWwgbWFwcGluZyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byAxOjEgZHVyaW5nIHJlcHJvamVjdGlvbi5cbiAqIFRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgcmVnYXJkbGVzcyBvZiB3aGF0IHJlc29sdXRpb25zXG4gKiBhcmUgYWN0dWFsbHkgYXZhaWxhYmxlIGluIHRoZSBkYXRhc2V0IChUaWxlR3JpZCwgSW1hZ2UsIC4uLikuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJlc3QgcmVzb2x1dGlvbiB0byB1c2UuIENhbiBiZSArLUluZmluaXR5LCBOYU4gb3IgMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNvdXJjZUV4dGVudFJlc29sdXRpb24oXG4gIHNvdXJjZVByb2osXG4gIHRhcmdldFByb2osXG4gIHRhcmdldEV4dGVudCxcbiAgdGFyZ2V0UmVzb2x1dGlvbixcbikge1xuICBjb25zdCB0YXJnZXRDZW50ZXIgPSBnZXRDZW50ZXIodGFyZ2V0RXh0ZW50KTtcbiAgbGV0IHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICAgIHNvdXJjZVByb2osXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRDZW50ZXIsXG4gICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgKTtcblxuICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgIGZvckVhY2hDb3JuZXIodGFyZ2V0RXh0ZW50LCBmdW5jdGlvbiAoY29ybmVyKSB7XG4gICAgICBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihcbiAgICAgICAgc291cmNlUHJvaixcbiAgICAgICAgdGFyZ2V0UHJvaixcbiAgICAgICAgY29ybmVyLFxuICAgICAgICB0YXJnZXRSZXNvbHV0aW9uLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc0Zpbml0ZShzb3VyY2VSZXNvbHV0aW9uKSAmJiBzb3VyY2VSZXNvbHV0aW9uID4gMDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEltYWdlRXh0ZW50XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbY2xpcEV4dGVudF0gQ2xpcCBleHRlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gaW1hZ2UgSW1hZ2UuXG4gKi9cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzb3VyY2UgZGF0YSBpbnRvIG5ldyBjYW52YXMgYmFzZWQgb24gdGhlIHRyaWFuZ3VsYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gc291cmNlUmVzb2x1dGlvbiBTb3VyY2UgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBzb3VyY2VFeHRlbnQgRXh0ZW50IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzXCIpLmRlZmF1bHR9IHRyaWFuZ3VsYXRpb24gQ2FsY3VsYXRlZCB0cmlhbmd1bGF0aW9uLlxuICogQHBhcmFtIHtBcnJheTxJbWFnZUV4dGVudD59IHNvdXJjZXMgQXJyYXkgb2Ygc291cmNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2VzLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVuZGVyRWRnZXNdIFJlbmRlciByZXByb2plY3Rpb24gZWRnZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZV0gVXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdoZW4gcmVzYW1wbGluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RyYXdTaW5nbGVdIERyYXcgc2luZ2xlIHNvdXJjZSBpbWFnZXMgZGlyZWN0bHkgd2l0aG91dCBzdGl0Y2hDb250ZXh0LlxuICogQHBhcmFtIHtib29sZWFufSBbY2xpcEV4dGVudF0gQ2xpcCBzdGl0Y2hDb250ZXh0IHRvIHNvdXJjZUV4dGVudC5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgd2l0aCByZXByb2plY3RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXhlbFJhdGlvLFxuICBzb3VyY2VSZXNvbHV0aW9uLFxuICBzb3VyY2VFeHRlbnQsXG4gIHRhcmdldFJlc29sdXRpb24sXG4gIHRhcmdldEV4dGVudCxcbiAgdHJpYW5ndWxhdGlvbixcbiAgc291cmNlcyxcbiAgZ3V0dGVyLFxuICByZW5kZXJFZGdlcyxcbiAgaW50ZXJwb2xhdGUsXG4gIGRyYXdTaW5nbGUsXG4gIGNsaXBFeHRlbnQsXG4pIHtcbiAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiB3aWR0aCksXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogaGVpZ2h0KSxcbiAgICBjYW52YXNQb29sLFxuICApO1xuXG4gIGlmICghaW50ZXJwb2xhdGUpIHtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xuICB9XG5cbiAgY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblxuICBmdW5jdGlvbiBwaXhlbFJvdW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gIH1cblxuICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdsaWdodGVyJztcblxuICBjb25zdCBzb3VyY2VEYXRhRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMsIGksIGFycikge1xuICAgIGV4dGVuZChzb3VyY2VEYXRhRXh0ZW50LCBzcmMuZXh0ZW50KTtcbiAgfSk7XG5cbiAgbGV0IHN0aXRjaENvbnRleHQ7XG4gIGNvbnN0IHN0aXRjaFNjYWxlID0gcGl4ZWxSYXRpbyAvIHNvdXJjZVJlc29sdXRpb247XG4gIC8vIFJvdW5kIHVwIEZsb2F0MzIgc2NhbGUgdmFsdWVzIHRvIHByZXZlbnQgaW50ZXJwb2xhdGlvbiBpbiBGaXJlZm94LlxuICBjb25zdCBpbnZlcnNlU2NhbGUgPSAoaW50ZXJwb2xhdGUgPyAxIDogMSArIE1hdGgucG93KDIsIC0yNCkpIC8gc3RpdGNoU2NhbGU7XG5cbiAgaWYgKCFkcmF3U2luZ2xlIHx8IHNvdXJjZXMubGVuZ3RoICE9PSAxIHx8IGd1dHRlciAhPT0gMCkge1xuICAgIHN0aXRjaENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICBNYXRoLnJvdW5kKGdldFdpZHRoKHNvdXJjZURhdGFFeHRlbnQpICogc3RpdGNoU2NhbGUpLFxuICAgICAgTWF0aC5yb3VuZChnZXRIZWlnaHQoc291cmNlRGF0YUV4dGVudCkgKiBzdGl0Y2hTY2FsZSksXG4gICAgICBjYW52YXNQb29sLFxuICAgICk7XG5cbiAgICBpZiAoIWludGVycG9sYXRlKSB7XG4gICAgICBzdGl0Y2hDb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc291cmNlRXh0ZW50ICYmIGNsaXBFeHRlbnQpIHtcbiAgICAgIGNvbnN0IHhQb3MgPSAoc291cmNlRXh0ZW50WzBdIC0gc291cmNlRGF0YUV4dGVudFswXSkgKiBzdGl0Y2hTY2FsZTtcbiAgICAgIGNvbnN0IHlQb3MgPSAtKHNvdXJjZUV4dGVudFszXSAtIHNvdXJjZURhdGFFeHRlbnRbM10pICogc3RpdGNoU2NhbGU7XG4gICAgICBjb25zdCB3aWR0aCA9IGdldFdpZHRoKHNvdXJjZUV4dGVudCkgKiBzdGl0Y2hTY2FsZTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGdldEhlaWdodChzb3VyY2VFeHRlbnQpICogc3RpdGNoU2NhbGU7XG4gICAgICBzdGl0Y2hDb250ZXh0LnJlY3QoeFBvcywgeVBvcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICBzdGl0Y2hDb250ZXh0LmNsaXAoKTtcbiAgICB9XG5cbiAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNyYywgaSwgYXJyKSB7XG4gICAgICAvLyBUaGlzIHRlc3Qgc2hvdWxkIG5ldmVyIGZhaWwgLS0gYnV0IGl0IGRvZXMuIE5lZWQgdG8gZmluZCBhIGZpeCB0aGUgdXBzdHJlYW0gY29uZGl0aW9uXG4gICAgICBpZiAoc3JjLmltYWdlLndpZHRoID4gMCAmJiBzcmMuaW1hZ2UuaGVpZ2h0ID4gMCkge1xuICAgICAgICBpZiAoc3JjLmNsaXBFeHRlbnQpIHtcbiAgICAgICAgICBzdGl0Y2hDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb25zdCB4UG9zID0gKHNyYy5jbGlwRXh0ZW50WzBdIC0gc291cmNlRGF0YUV4dGVudFswXSkgKiBzdGl0Y2hTY2FsZTtcbiAgICAgICAgICBjb25zdCB5UG9zID0gLShzcmMuY2xpcEV4dGVudFszXSAtIHNvdXJjZURhdGFFeHRlbnRbM10pICogc3RpdGNoU2NhbGU7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBnZXRXaWR0aChzcmMuY2xpcEV4dGVudCkgKiBzdGl0Y2hTY2FsZTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQoc3JjLmNsaXBFeHRlbnQpICogc3RpdGNoU2NhbGU7XG4gICAgICAgICAgc3RpdGNoQ29udGV4dC5yZWN0KFxuICAgICAgICAgICAgaW50ZXJwb2xhdGUgPyB4UG9zIDogTWF0aC5yb3VuZCh4UG9zKSxcbiAgICAgICAgICAgIGludGVycG9sYXRlID8geVBvcyA6IE1hdGgucm91bmQoeVBvcyksXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZSA/IHdpZHRoIDogTWF0aC5yb3VuZCh4UG9zICsgd2lkdGgpIC0gTWF0aC5yb3VuZCh4UG9zKSxcbiAgICAgICAgICAgIGludGVycG9sYXRlID8gaGVpZ2h0IDogTWF0aC5yb3VuZCh5UG9zICsgaGVpZ2h0KSAtIE1hdGgucm91bmQoeVBvcyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGl0Y2hDb250ZXh0LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHhQb3MgPSAoc3JjLmV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF0pICogc3RpdGNoU2NhbGU7XG4gICAgICAgIGNvbnN0IHlQb3MgPSAtKHNyYy5leHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKSAqIHN0aXRjaFNjYWxlO1xuICAgICAgICBjb25zdCBzcmNXaWR0aCA9IGdldFdpZHRoKHNyYy5leHRlbnQpICogc3RpdGNoU2NhbGU7XG4gICAgICAgIGNvbnN0IHNyY0hlaWdodCA9IGdldEhlaWdodChzcmMuZXh0ZW50KSAqIHN0aXRjaFNjYWxlO1xuICAgICAgICBzdGl0Y2hDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICBzcmMuaW1hZ2UsXG4gICAgICAgICAgZ3V0dGVyLFxuICAgICAgICAgIGd1dHRlcixcbiAgICAgICAgICBzcmMuaW1hZ2Uud2lkdGggLSAyICogZ3V0dGVyLFxuICAgICAgICAgIHNyYy5pbWFnZS5oZWlnaHQgLSAyICogZ3V0dGVyLFxuICAgICAgICAgIGludGVycG9sYXRlID8geFBvcyA6IE1hdGgucm91bmQoeFBvcyksXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPyB5UG9zIDogTWF0aC5yb3VuZCh5UG9zKSxcbiAgICAgICAgICBpbnRlcnBvbGF0ZVxuICAgICAgICAgICAgPyBzcmNXaWR0aFxuICAgICAgICAgICAgOiBNYXRoLnJvdW5kKHhQb3MgKyBzcmNXaWR0aCkgLSBNYXRoLnJvdW5kKHhQb3MpLFxuICAgICAgICAgIGludGVycG9sYXRlXG4gICAgICAgICAgICA/IHNyY0hlaWdodFxuICAgICAgICAgICAgOiBNYXRoLnJvdW5kKHlQb3MgKyBzcmNIZWlnaHQpIC0gTWF0aC5yb3VuZCh5UG9zKSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoc3JjLmNsaXBFeHRlbnQpIHtcbiAgICAgICAgICBzdGl0Y2hDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRhcmdldFRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG5cbiAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgLyogQ2FsY3VsYXRlIGFmZmluZSB0cmFuc2Zvcm0gKHNyYyAtPiBkc3QpXG4gICAgICogUmVzdWx0aW5nIG1hdHJpeCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRpbmF0ZVxuICAgICAqIGZyb20gYHNvdXJjZVByb2plY3Rpb25gIHRvIGRlc3RpbmF0aW9uIHBpeGVscy5cbiAgICAgKlxuICAgICAqIFRvIG9wdGltaXplIG51bWJlciBvZiBjb250ZXh0IGNhbGxzIGFuZCBpbmNyZWFzZSBudW1lcmljYWwgc3RhYmlsaXR5LFxuICAgICAqIHdlIGFsc28gZG8gdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICAgICAqIHRyYW5zKC10b3BMZWZ0RXh0ZW50Q29ybmVyKSwgc2NhbGUoMSAvIHRhcmdldFJlc29sdXRpb24pLCBzY2FsZSgxLCAtMSlcbiAgICAgKiBoZXJlIGJlZm9yZSBzb2x2aW5nIHRoZSBsaW5lYXIgc3lzdGVtIHNvIFt1aSwgdmldIGFyZSBwaXhlbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIFNyYyBwb2ludHM6IHhpLCB5aVxuICAgICAqIERzdCBwb2ludHM6IHVpLCB2aVxuICAgICAqIEFmZmluZSBjb2VmZmljaWVudHM6IGFpalxuICAgICAqXG4gICAgICogfCB4MCB5MCAxICAwICAwIDAgfCAgIHxhMDB8ICAgfHUwfFxuICAgICAqIHwgeDEgeTEgMSAgMCAgMCAwIHwgICB8YTAxfCAgIHx1MXxcbiAgICAgKiB8IHgyIHkyIDEgIDAgIDAgMCB8IHggfGEwMnwgPSB8dTJ8XG4gICAgICogfCAgMCAgMCAwIHgwIHkwIDEgfCAgIHxhMTB8ICAgfHYwfFxuICAgICAqIHwgIDAgIDAgMCB4MSB5MSAxIHwgICB8YTExfCAgIHx2MXxcbiAgICAgKiB8ICAwICAwIDAgeDIgeTIgMSB8ICAgfGExMnwgICB8djJ8XG4gICAgICovXG4gICAgY29uc3Qgc291cmNlID0gdHJpYW5nbGUuc291cmNlO1xuICAgIGNvbnN0IHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICBsZXQgeDAgPSBzb3VyY2VbMF1bMF0sXG4gICAgICB5MCA9IHNvdXJjZVswXVsxXTtcbiAgICBsZXQgeDEgPSBzb3VyY2VbMV1bMF0sXG4gICAgICB5MSA9IHNvdXJjZVsxXVsxXTtcbiAgICBsZXQgeDIgPSBzb3VyY2VbMl1bMF0sXG4gICAgICB5MiA9IHNvdXJjZVsyXVsxXTtcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBldmVyeXRoaW5nIGlzIG9uIHBpeGVsIGJvdW5kYXJpZXNcbiAgICBjb25zdCB1MCA9IHBpeGVsUm91bmQoKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbik7XG4gICAgY29uc3QgdjAgPSBwaXhlbFJvdW5kKFxuICAgICAgLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb24sXG4gICAgKTtcbiAgICBjb25zdCB1MSA9IHBpeGVsUm91bmQoKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbik7XG4gICAgY29uc3QgdjEgPSBwaXhlbFJvdW5kKFxuICAgICAgLSh0YXJnZXRbMV1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb24sXG4gICAgKTtcbiAgICBjb25zdCB1MiA9IHBpeGVsUm91bmQoKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbik7XG4gICAgY29uc3QgdjIgPSBwaXhlbFJvdW5kKFxuICAgICAgLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb24sXG4gICAgKTtcblxuICAgIC8vIFNoaWZ0IGFsbCB0aGUgc291cmNlIHBvaW50cyB0byBpbXByb3ZlIG51bWVyaWNhbCBzdGFiaWxpdHlcbiAgICAvLyBvZiBhbGwgdGhlIHN1YnNlcXVlbnQgY2FsY3VsYXRpb25zLiBUaGUgW3gwLCB5MF0gaXMgdXNlZCBoZXJlLlxuICAgIC8vIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBsaW5lYXIgc3lzdGVtLlxuICAgIGNvbnN0IHNvdXJjZU51bWVyaWNhbFNoaWZ0WCA9IHgwO1xuICAgIGNvbnN0IHNvdXJjZU51bWVyaWNhbFNoaWZ0WSA9IHkwO1xuICAgIHgwID0gMDtcbiAgICB5MCA9IDA7XG4gICAgeDEgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRYO1xuICAgIHkxIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WTtcbiAgICB4MiAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFg7XG4gICAgeTIgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRZO1xuXG4gICAgY29uc3QgYXVnbWVudGVkTWF0cml4ID0gW1xuICAgICAgW3gxLCB5MSwgMCwgMCwgdTEgLSB1MF0sXG4gICAgICBbeDIsIHkyLCAwLCAwLCB1MiAtIHUwXSxcbiAgICAgIFswLCAwLCB4MSwgeTEsIHYxIC0gdjBdLFxuICAgICAgWzAsIDAsIHgyLCB5MiwgdjIgLSB2MF0sXG4gICAgXTtcbiAgICBjb25zdCBhZmZpbmVDb2VmcyA9IHNvbHZlTGluZWFyU3lzdGVtKGF1Z21lbnRlZE1hdHJpeCk7XG4gICAgaWYgKCFhZmZpbmVDb2Vmcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoaXNCcm9rZW5EaWFnb25hbFJlbmRlcmluZygpIHx8ICFpbnRlcnBvbGF0ZSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYWxsIGxpbmVzIGFyZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZGlhZ29uYWwgbGluZS4gRG8gaXQgaW4gNCBzdGVwc1xuICAgICAgY29uc3Qgc3RlcHMgPSA0O1xuICAgICAgY29uc3QgdWQgPSB1MCAtIHUxO1xuICAgICAgY29uc3QgdmQgPSB2MCAtIHYxO1xuICAgICAgZm9yIChsZXQgc3RlcCA9IDA7IHN0ZXAgPCBzdGVwczsgc3RlcCsrKSB7XG4gICAgICAgIC8vIEdvIGhvcml6b250YWxseVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICB1MSArIHBpeGVsUm91bmQoKChzdGVwICsgMSkgKiB1ZCkgLyBzdGVwcyksXG4gICAgICAgICAgdjEgKyBwaXhlbFJvdW5kKChzdGVwICogdmQpIC8gKHN0ZXBzIC0gMSkpLFxuICAgICAgICApO1xuICAgICAgICAvLyBHbyB2ZXJ0aWNhbGx5XG4gICAgICAgIGlmIChzdGVwICE9IHN0ZXBzIC0gMSkge1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgICAgICAgdTEgKyBwaXhlbFJvdW5kKCgoc3RlcCArIDEpICogdWQpIC8gc3RlcHMpLFxuICAgICAgICAgICAgdjEgKyBwaXhlbFJvdW5kKCgoc3RlcCArIDEpICogdmQpIC8gKHN0ZXBzIC0gMSkpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFyZSBhbG1vc3QgYXQgdTByLCB2MHJcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MCwgdjApO1xuICAgICAgY29udGV4dC5saW5lVG8odTIsIHYyKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgIGNvbnRleHQudHJhbnNmb3JtKFxuICAgICAgYWZmaW5lQ29lZnNbMF0sXG4gICAgICBhZmZpbmVDb2Vmc1syXSxcbiAgICAgIGFmZmluZUNvZWZzWzFdLFxuICAgICAgYWZmaW5lQ29lZnNbM10sXG4gICAgICB1MCxcbiAgICAgIHYwLFxuICAgICk7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgIHNvdXJjZURhdGFFeHRlbnRbMF0gLSBzb3VyY2VOdW1lcmljYWxTaGlmdFgsXG4gICAgICBzb3VyY2VEYXRhRXh0ZW50WzNdIC0gc291cmNlTnVtZXJpY2FsU2hpZnRZLFxuICAgICk7XG5cbiAgICBsZXQgaW1hZ2U7XG4gICAgaWYgKHN0aXRjaENvbnRleHQpIHtcbiAgICAgIGltYWdlID0gc3RpdGNoQ29udGV4dC5jYW52YXM7XG4gICAgICBjb250ZXh0LnNjYWxlKGludmVyc2VTY2FsZSwgLWludmVyc2VTY2FsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbMF07XG4gICAgICBjb25zdCBleHRlbnQgPSBzb3VyY2UuZXh0ZW50O1xuICAgICAgaW1hZ2UgPSBzb3VyY2UuaW1hZ2U7XG4gICAgICBjb250ZXh0LnNjYWxlKFxuICAgICAgICBnZXRXaWR0aChleHRlbnQpIC8gaW1hZ2Uud2lkdGgsXG4gICAgICAgIC1nZXRIZWlnaHQoZXh0ZW50KSAvIGltYWdlLmhlaWdodCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9KTtcblxuICBpZiAoc3RpdGNoQ29udGV4dCkge1xuICAgIHJlbGVhc2VDYW52YXMoc3RpdGNoQ29udGV4dCk7XG4gICAgY2FudmFzUG9vbC5wdXNoKHN0aXRjaENvbnRleHQuY2FudmFzKTtcbiAgfVxuXG4gIGlmIChyZW5kZXJFZGdlcykge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcblxuICAgIHRyaWFuZ3VsYXRpb24uZ2V0VHJpYW5nbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJpYW5nbGUsIGksIGFycikge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgICAgY29uc3QgdTAgPSAodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjAgPSAtKHRhcmdldFswXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHUxID0gKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYxID0gLSh0YXJnZXRbMV1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB1MiA9ICh0YXJnZXRbMl1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MiA9IC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8odTEsIHYxKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUwLCB2MCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MiwgdjIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5jYW52YXM7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9EYXRhVGlsZVxuICovXG5pbXBvcnQge0VSUk9SX1RIUkVTSE9MRH0gZnJvbSAnLi9jb21tb24uanMnO1xuXG5pbXBvcnQgRGF0YVRpbGUsIHthc0FycmF5TGlrZSwgYXNJbWFnZUxpa2UsIHRvQXJyYXl9IGZyb20gJy4uL0RhdGFUaWxlLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVHJpYW5ndWxhdGlvbiBmcm9tICcuL1RyaWFuZ3VsYXRpb24uanMnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlU291cmNlRXh0ZW50UmVzb2x1dGlvbixcbiAgY2FudmFzUG9vbCxcbiAgcmVuZGVyIGFzIHJlbmRlclJlcHJvamVjdGVkLFxufSBmcm9tICcuLi9yZXByb2ouanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRCwgcmVsZWFzZUNhbnZhc30gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7Z2V0QXJlYSwgZ2V0SW50ZXJzZWN0aW9uLCBnZXRXaWR0aCwgd3JhcEFuZFNsaWNlWH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIpIDogaW1wb3J0KFwiLi4vRGF0YVRpbGUuanNcIikuZGVmYXVsdH0gVGlsZUdldHRlclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGlsZU9mZnNldFxuICogQHByb3BlcnR5IHtEYXRhVGlsZX0gdGlsZSBUaWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBzb3VyY2VUaWxlR3JpZCBTb3VyY2UgdGlsZSBncmlkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGFyZ2V0VGlsZUdyaWQgVGFyZ2V0IHRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIENvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFt3cmFwcGVkVGlsZUNvb3JkXSBDb29yZGluYXRlIG9mIHRoZSB0aWxlIHdyYXBwZWQgaW4gWC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGd1dHRlciBHdXR0ZXIgb2YgdGhlIHNvdXJjZSB0aWxlcy5cbiAqIEBwcm9wZXJ0eSB7VGlsZUdldHRlcn0gZ2V0VGlsZUZ1bmN0aW9uIEZ1bmN0aW9uIHJldHVybmluZyBzb3VyY2UgdGlsZXMgKHosIHgsIHksIHBpeGVsUmF0aW8pLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9ZmFsc2VdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiB0aGUgbmVhcmVzdCBuZWlnaGJvciBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZXJyb3JUaHJlc2hvbGRdIEFjY2VwdGFibGUgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBweCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBBIGR1cmF0aW9uIGZvciB0aWxlIG9wYWNpdHlcbiAqIHRyYW5zaXRpb25zIGluIG1pbGxpc2Vjb25kcy4gQSBkdXJhdGlvbiBvZiAwIGRpc2FibGVzIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBlbmNhcHN1bGF0aW5nIHNpbmdsZSByZXByb2plY3RlZCBkYXRhIHRpbGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvRGF0YVRpbGV+RGF0YVRpbGVTb3VyY2V9LlxuICpcbiAqL1xuY2xhc3MgUmVwcm9qRGF0YVRpbGUgZXh0ZW5kcyBEYXRhVGlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgVGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIHRpbGVDb29yZDogb3B0aW9ucy50aWxlQ29vcmQsXG4gICAgICBsb2FkZXI6ICgpID0+IFByb21pc2UucmVzb2x2ZShuZXcgVWludDhDbGFtcGVkQXJyYXkoNCkpLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IG9wdGlvbnMucGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmd1dHRlcl8gPSBvcHRpb25zLmd1dHRlcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9EYXRhVGlsZS5qc1wiKS5EYXRhfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZXByb2pEYXRhXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RXJyb3J9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlcHJvakVycm9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi9zaXplLmpzJykuU2l6ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVwcm9qU2l6ZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlVGlsZUdyaWRfID0gb3B0aW9ucy5zb3VyY2VUaWxlR3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRUaWxlR3JpZF8gPSBvcHRpb25zLnRhcmdldFRpbGVHcmlkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfID0gb3B0aW9ucy53cmFwcGVkVGlsZUNvb3JkIHx8IG9wdGlvbnMudGlsZUNvb3JkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PFRpbGVPZmZzZXQ+fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlVGlsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VaXyA9IDA7XG5cbiAgICBjb25zdCBzb3VyY2VQcm9qID0gb3B0aW9ucy5zb3VyY2VQcm9qO1xuICAgIGNvbnN0IHNvdXJjZVByb2pFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgIGNvbnN0IHNvdXJjZVRpbGVHcmlkRXh0ZW50ID0gb3B0aW9ucy5zb3VyY2VUaWxlR3JpZC5nZXRFeHRlbnQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5jbGlwRXh0ZW50XyA9IHNvdXJjZVByb2ouY2FuV3JhcFgoKVxuICAgICAgPyBzb3VyY2VUaWxlR3JpZEV4dGVudFxuICAgICAgICA/IGdldEludGVyc2VjdGlvbihzb3VyY2VQcm9qRXh0ZW50LCBzb3VyY2VUaWxlR3JpZEV4dGVudClcbiAgICAgICAgOiBzb3VyY2VQcm9qRXh0ZW50XG4gICAgICA6IHNvdXJjZVRpbGVHcmlkRXh0ZW50O1xuXG4gICAgY29uc3QgdGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyxcbiAgICApO1xuICAgIGNvbnN0IG1heFRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldEV4dGVudCgpO1xuICAgIGxldCBtYXhTb3VyY2VFeHRlbnQgPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcblxuICAgIGNvbnN0IGxpbWl0ZWRUYXJnZXRFeHRlbnQgPSBtYXhUYXJnZXRFeHRlbnRcbiAgICAgID8gZ2V0SW50ZXJzZWN0aW9uKHRhcmdldEV4dGVudCwgbWF4VGFyZ2V0RXh0ZW50KVxuICAgICAgOiB0YXJnZXRFeHRlbnQ7XG5cbiAgICBpZiAoZ2V0QXJlYShsaW1pdGVkVGFyZ2V0RXh0ZW50KSA9PT0gMCkge1xuICAgICAgLy8gVGlsZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgcmFuZ2UgLT4gRU1QVFlcbiAgICAgIC8vIFRPRE86IGlzIGl0IGFjdHVhbGx5IGNvcnJlY3QgdGhhdCB0aGUgc291cmNlIGV2ZW4gY3JlYXRlcyB0aGUgdGlsZSA/XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VQcm9qRXh0ZW50KSB7XG4gICAgICBpZiAoIW1heFNvdXJjZUV4dGVudCkge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qRXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKG1heFNvdXJjZUV4dGVudCwgc291cmNlUHJvakV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFJlc29sdXRpb24oXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdLFxuICAgICk7XG5cbiAgICBjb25zdCB0YXJnZXRQcm9qID0gb3B0aW9ucy50YXJnZXRQcm9qO1xuICAgIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VFeHRlbnRSZXNvbHV0aW9uKFxuICAgICAgc291cmNlUHJvaixcbiAgICAgIHRhcmdldFByb2osXG4gICAgICBsaW1pdGVkVGFyZ2V0RXh0ZW50LFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICApO1xuXG4gICAgaWYgKCFpc0Zpbml0ZShzb3VyY2VSZXNvbHV0aW9uKSB8fCBzb3VyY2VSZXNvbHV0aW9uIDw9IDApIHtcbiAgICAgIC8vIGludmFsaWQgc291cmNlUmVzb2x1dGlvbiAtPiBFTVBUWVxuICAgICAgLy8gcHJvYmFibHkgZWRnZXMgb2YgdGhlIHByb2plY3Rpb25zIHdoZW4gbm8gZXh0ZW50IGlzIGRlZmluZWRcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JUaHJlc2hvbGRJblBpeGVscyA9XG4gICAgICBvcHRpb25zLmVycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmVycm9yVGhyZXNob2xkXG4gICAgICAgIDogRVJST1JfVEhSRVNIT0xEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4vVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5ndWxhdGlvbl8gPSBuZXcgVHJpYW5ndWxhdGlvbihcbiAgICAgIHNvdXJjZVByb2osXG4gICAgICB0YXJnZXRQcm9qLFxuICAgICAgbGltaXRlZFRhcmdldEV4dGVudCxcbiAgICAgIG1heFNvdXJjZUV4dGVudCxcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gKiBlcnJvclRocmVzaG9sZEluUGl4ZWxzLFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICApO1xuXG4gICAgaWYgKHRoaXMudHJpYW5ndWxhdGlvbl8uZ2V0VHJpYW5nbGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBubyB2YWxpZCB0cmlhbmdsZXMgLT4gRU1QVFlcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VaXyA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFpGb3JSZXNvbHV0aW9uKHNvdXJjZVJlc29sdXRpb24pO1xuICAgIGxldCBzb3VyY2VFeHRlbnQgPSB0aGlzLnRyaWFuZ3VsYXRpb25fLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCgpO1xuXG4gICAgaWYgKG1heFNvdXJjZUV4dGVudCkge1xuICAgICAgaWYgKHNvdXJjZVByb2ouY2FuV3JhcFgoKSkge1xuICAgICAgICBzb3VyY2VFeHRlbnRbMV0gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFszXSxcbiAgICAgICAgKTtcbiAgICAgICAgc291cmNlRXh0ZW50WzNdID0gY2xhbXAoXG4gICAgICAgICAgc291cmNlRXh0ZW50WzNdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFsxXSxcbiAgICAgICAgICBtYXhTb3VyY2VFeHRlbnRbM10sXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oc291cmNlRXh0ZW50LCBtYXhTb3VyY2VFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2V0QXJlYShzb3VyY2VFeHRlbnQpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgd29ybGRXaWR0aCA9IDA7XG4gICAgICBsZXQgd29ybGRzQXdheSA9IDA7XG4gICAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAgIHdvcmxkV2lkdGggPSBnZXRXaWR0aChzb3VyY2VQcm9qRXh0ZW50KTtcbiAgICAgICAgd29ybGRzQXdheSA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgKHNvdXJjZUV4dGVudFswXSAtIHNvdXJjZVByb2pFeHRlbnRbMF0pIC8gd29ybGRXaWR0aCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc291cmNlRXh0ZW50cyA9IHdyYXBBbmRTbGljZVgoXG4gICAgICAgIHNvdXJjZUV4dGVudC5zbGljZSgpLFxuICAgICAgICBzb3VyY2VQcm9qLFxuICAgICAgICB0cnVlLFxuICAgICAgKTtcbiAgICAgIHNvdXJjZUV4dGVudHMuZm9yRWFjaCgoZXh0ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVJhbmdlID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgICBleHRlbnQsXG4gICAgICAgICAgdGhpcy5zb3VyY2VaXyxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZ2V0VGlsZSA9IG9wdGlvbnMuZ2V0VGlsZUZ1bmN0aW9uO1xuICAgICAgICBmb3IgKGxldCBzcmNYID0gc291cmNlUmFuZ2UubWluWDsgc3JjWCA8PSBzb3VyY2VSYW5nZS5tYXhYOyBzcmNYKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBzcmNZID0gc291cmNlUmFuZ2UubWluWTsgc3JjWSA8PSBzb3VyY2VSYW5nZS5tYXhZOyBzcmNZKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGUgPSBnZXRUaWxlKHRoaXMuc291cmNlWl8sIHNyY1gsIHNyY1ksIHRoaXMucGl4ZWxSYXRpb18pO1xuICAgICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd29ybGRzQXdheSAqIHdvcmxkV2lkdGg7XG4gICAgICAgICAgICAgIHRoaXMuc291cmNlVGlsZXNfLnB1c2goe3RpbGUsIG9mZnNldH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICArK3dvcmxkc0F3YXk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgc2l6ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi9zaXplLmpzJykuU2l6ZX0gVGlsZSBzaXplLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwcm9qU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIGZvciB0aGUgdGlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRGF0YVRpbGUuanNcIikuRGF0YX0gVGlsZSBkYXRhLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwcm9qRGF0YV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFueSBsb2FkaW5nIGVycm9yLlxuICAgKiBAcmV0dXJuIHtFcnJvcn0gTG9hZGluZyBlcnJvci5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXByb2pFcnJvcl87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcHJvamVjdF8oKSB7XG4gICAgY29uc3QgZGF0YVNvdXJjZXMgPSBbXTtcbiAgICBsZXQgaW1hZ2VMaWtlID0gZmFsc2U7XG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICBjb25zdCB0aWxlID0gc291cmNlLnRpbGU7XG4gICAgICBpZiAoIXRpbGUgfHwgdGlsZS5nZXRTdGF0ZSgpICE9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aWxlLmdldFNpemUoKTtcbiAgICAgIGNvbnN0IGd1dHRlciA9IHRoaXMuZ3V0dGVyXztcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2ltcG9ydChcIi4uL0RhdGFUaWxlLmpzXCIpLkFycmF5TGlrZX1cbiAgICAgICAqL1xuICAgICAgbGV0IHRpbGVEYXRhO1xuICAgICAgY29uc3QgYXJyYXlEYXRhID0gYXNBcnJheUxpa2UodGlsZS5nZXREYXRhKCkpO1xuICAgICAgaWYgKGFycmF5RGF0YSkge1xuICAgICAgICB0aWxlRGF0YSA9IGFycmF5RGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlTGlrZSA9IHRydWU7XG4gICAgICAgIHRpbGVEYXRhID0gdG9BcnJheShhc0ltYWdlTGlrZSh0aWxlLmdldERhdGEoKSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGl4ZWxTaXplID0gW3NpemVbMF0gKyAyICogZ3V0dGVyLCBzaXplWzFdICsgMiAqIGd1dHRlcl07XG4gICAgICBjb25zdCBpc0Zsb2F0ID0gdGlsZURhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk7XG4gICAgICBjb25zdCBwaXhlbENvdW50ID0gcGl4ZWxTaXplWzBdICogcGl4ZWxTaXplWzFdO1xuICAgICAgY29uc3QgRGF0YVR5cGUgPSBpc0Zsb2F0ID8gRmxvYXQzMkFycmF5IDogVWludDhDbGFtcGVkQXJyYXk7XG4gICAgICBjb25zdCB0aWxlRGF0YVIgPSBuZXcgRGF0YVR5cGUodGlsZURhdGEuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGJ5dGVzUGVyRWxlbWVudCA9IERhdGFUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgY29uc3QgYnl0ZXNQZXJQaXhlbCA9IChieXRlc1BlckVsZW1lbnQgKiB0aWxlRGF0YVIubGVuZ3RoKSAvIHBpeGVsQ291bnQ7XG4gICAgICBjb25zdCBieXRlc1BlclJvdyA9IHRpbGVEYXRhUi5ieXRlTGVuZ3RoIC8gcGl4ZWxTaXplWzFdO1xuICAgICAgY29uc3QgYmFuZENvdW50ID0gTWF0aC5mbG9vcihcbiAgICAgICAgYnl0ZXNQZXJSb3cgLyBieXRlc1BlckVsZW1lbnQgLyBwaXhlbFNpemVbMF0sXG4gICAgICApO1xuICAgICAgY29uc3QgcGFja2VkTGVuZ3RoID0gcGl4ZWxDb3VudCAqIGJhbmRDb3VudDtcbiAgICAgIGxldCBwYWNrZWREYXRhID0gdGlsZURhdGFSO1xuICAgICAgaWYgKHRpbGVEYXRhUi5sZW5ndGggIT09IHBhY2tlZExlbmd0aCkge1xuICAgICAgICBwYWNrZWREYXRhID0gbmV3IERhdGFUeXBlKHBhY2tlZExlbmd0aCk7XG4gICAgICAgIGxldCBkYXRhSW5kZXggPSAwO1xuICAgICAgICBsZXQgcm93T2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgY29sQ291bnQgPSBwaXhlbFNpemVbMF0gKiBiYW5kQ291bnQ7XG4gICAgICAgIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBwaXhlbFNpemVbMV07ICsrcm93SW5kZXgpIHtcbiAgICAgICAgICBmb3IgKGxldCBjb2xJbmRleCA9IDA7IGNvbEluZGV4IDwgY29sQ291bnQ7ICsrY29sSW5kZXgpIHtcbiAgICAgICAgICAgIHBhY2tlZERhdGFbZGF0YUluZGV4KytdID0gdGlsZURhdGFSW3Jvd09mZnNldCArIGNvbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm93T2Zmc2V0ICs9IGJ5dGVzUGVyUm93IC8gYnl0ZXNQZXJFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBleHRlbnQgPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS50aWxlQ29vcmQpO1xuICAgICAgZXh0ZW50WzBdICs9IHNvdXJjZS5vZmZzZXQ7XG4gICAgICBleHRlbnRbMl0gKz0gc291cmNlLm9mZnNldDtcbiAgICAgIGNvbnN0IGNsaXBFeHRlbnQgPSB0aGlzLmNsaXBFeHRlbnRfPy5zbGljZSgpO1xuICAgICAgaWYgKGNsaXBFeHRlbnQpIHtcbiAgICAgICAgY2xpcEV4dGVudFswXSArPSBzb3VyY2Uub2Zmc2V0O1xuICAgICAgICBjbGlwRXh0ZW50WzJdICs9IHNvdXJjZS5vZmZzZXQ7XG4gICAgICB9XG4gICAgICBkYXRhU291cmNlcy5wdXNoKHtcbiAgICAgICAgZXh0ZW50OiBleHRlbnQsXG4gICAgICAgIGNsaXBFeHRlbnQ6IGNsaXBFeHRlbnQsXG4gICAgICAgIGRhdGE6IG5ldyBVaW50OENsYW1wZWRBcnJheShwYWNrZWREYXRhLmJ1ZmZlciksXG4gICAgICAgIGRhdGFUeXBlOiBEYXRhVHlwZSxcbiAgICAgICAgYnl0ZXNQZXJQaXhlbDogYnl0ZXNQZXJQaXhlbCxcbiAgICAgICAgcGl4ZWxTaXplOiBwaXhlbFNpemUsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKGRhdGFTb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHogPSB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlU2l6ZSh6KTtcbiAgICBjb25zdCB0YXJnZXRXaWR0aCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzBdO1xuICAgIGNvbnN0IHRhcmdldEhlaWdodCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzFdO1xuICAgIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHopO1xuICAgIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHRoaXMuc291cmNlWl8pO1xuXG4gICAgY29uc3QgdGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyxcbiAgICApO1xuXG4gICAgbGV0IGRhdGFSLCBkYXRhVTtcblxuICAgIGNvbnN0IGJ5dGVzUGVyUGl4ZWwgPSBkYXRhU291cmNlc1swXS5ieXRlc1BlclBpeGVsO1xuXG4gICAgY29uc3QgcmVwcm9qcyA9IE1hdGguY2VpbChieXRlc1BlclBpeGVsIC8gMyk7XG4gICAgZm9yIChsZXQgcmVwcm9qID0gcmVwcm9qcyAtIDE7IHJlcHJvaiA+PSAwOyAtLXJlcHJvaikge1xuICAgICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRhdGFTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBkYXRhU291cmNlc1tpXTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gZGF0YVNvdXJjZS5kYXRhO1xuICAgICAgICBjb25zdCBwaXhlbFNpemUgPSBkYXRhU291cmNlLnBpeGVsU2l6ZTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwaXhlbFNpemVbMF07XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBpeGVsU2l6ZVsxXTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCh3aWR0aCwgaGVpZ2h0LCBjYW52YXNQb29sKTtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHJlcHJvaiAqIDM7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGxlbjsgaiArPSA0KSB7XG4gICAgICAgICAgZGF0YVtqXSA9IGJ1ZmZlcltvZmZzZXRdO1xuICAgICAgICAgIGRhdGFbaiArIDFdID0gYnVmZmVyW29mZnNldCArIDFdO1xuICAgICAgICAgIGRhdGFbaiArIDJdID0gYnVmZmVyW29mZnNldCArIDJdO1xuICAgICAgICAgIGRhdGFbaiArIDNdID0gMjU1O1xuICAgICAgICAgIG9mZnNldCArPSBieXRlc1BlclBpeGVsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgIHNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgZXh0ZW50OiBkYXRhU291cmNlLmV4dGVudCxcbiAgICAgICAgICBjbGlwRXh0ZW50OiBkYXRhU291cmNlLmNsaXBFeHRlbnQsXG4gICAgICAgICAgaW1hZ2U6IGNvbnRleHQuY2FudmFzLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FudmFzID0gcmVuZGVyUmVwcm9qZWN0ZWQoXG4gICAgICAgIHRhcmdldFdpZHRoLFxuICAgICAgICB0YXJnZXRIZWlnaHQsXG4gICAgICAgIHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb24sXG4gICAgICAgIHRoaXMuc291cmNlVGlsZUdyaWRfLmdldEV4dGVudCgpLFxuICAgICAgICB0YXJnZXRSZXNvbHV0aW9uLFxuICAgICAgICB0YXJnZXRFeHRlbnQsXG4gICAgICAgIHRoaXMudHJpYW5ndWxhdGlvbl8sXG4gICAgICAgIHNvdXJjZXMsXG4gICAgICAgIHRoaXMuZ3V0dGVyXyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHNvdXJjZXNbaV0uaW1hZ2U7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgcmVsZWFzZUNhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgY2FudmFzUG9vbC5wdXNoKGNvbnRleHQuY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgcmVsZWFzZUNhbnZhcyhjb250ZXh0KTtcbiAgICAgIGNhbnZhc1Bvb2wucHVzaChjYW52YXMpO1xuXG4gICAgICBpZiAoIWRhdGFSKSB7XG4gICAgICAgIGRhdGFVID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFxuICAgICAgICAgIGJ5dGVzUGVyUGl4ZWwgKiBpbWFnZURhdGEud2lkdGggKiBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICApO1xuICAgICAgICBkYXRhUiA9IG5ldyBkYXRhU291cmNlc1swXS5kYXRhVHlwZShkYXRhVS5idWZmZXIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICBsZXQgb2Zmc2V0ID0gcmVwcm9qICogMztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGlmIChkYXRhW2kgKyAzXSA9PT0gMjU1KSB7XG4gICAgICAgICAgZGF0YVVbb2Zmc2V0XSA9IGRhdGFbaV07XG4gICAgICAgICAgZGF0YVVbb2Zmc2V0ICsgMV0gPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICBkYXRhVVtvZmZzZXQgKyAyXSA9IGRhdGFbaSArIDJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFVW29mZnNldF0gPSAwO1xuICAgICAgICAgIGRhdGFVW29mZnNldCArIDFdID0gMDtcbiAgICAgICAgICBkYXRhVVtvZmZzZXQgKyAyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGJ5dGVzUGVyUGl4ZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGltYWdlTGlrZSkge1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCh0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEoZGF0YVIsIHRhcmdldFdpZHRoKTtcbiAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICB0aGlzLnJlcHJvakRhdGFfID0gY29udGV4dC5jYW52YXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVwcm9qRGF0YV8gPSBkYXRhUjtcbiAgICB9XG4gICAgdGhpcy5yZXByb2pTaXplXyA9IFtcbiAgICAgIE1hdGgucm91bmQodGFyZ2V0V2lkdGggKiB0aGlzLnBpeGVsUmF0aW9fKSxcbiAgICAgIE1hdGgucm91bmQodGFyZ2V0SGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvXyksXG4gICAgXTtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBUaWxlU3RhdGUuSURMRSAmJiB0aGlzLnN0YXRlICE9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FESU5HO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuXG4gICAgbGV0IGxlZnRUb0xvYWQgPSAwO1xuXG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IFtdO1xuICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goKHt0aWxlfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdGUgIT09IFRpbGVTdGF0ZS5JRExFICYmIHN0YXRlICE9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZWZ0VG9Mb2FkKys7XG5cbiAgICAgIGNvbnN0IHNvdXJjZUxpc3RlbktleSA9IGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICAgICApIHtcbiAgICAgICAgICB1bmxpc3RlbkJ5S2V5KHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLnB1c2goc291cmNlTGlzdGVuS2V5KTtcbiAgICB9KTtcblxuICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMucmVwcm9qZWN0Xy5iaW5kKHRoaXMpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbiAoe3RpbGV9KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICB0aWxlLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlblNvdXJjZXNfKCkge1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXByb2pEYXRhVGlsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL1RpbGVcbiAqL1xuaW1wb3J0IHtFUlJPUl9USFJFU0hPTER9IGZyb20gJy4vY29tbW9uLmpzJztcblxuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUaWxlIGZyb20gJy4uL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IFRyaWFuZ3VsYXRpb24gZnJvbSAnLi9Ucmlhbmd1bGF0aW9uLmpzJztcbmltcG9ydCB7XG4gIGNhbGN1bGF0ZVNvdXJjZUV4dGVudFJlc29sdXRpb24sXG4gIGNhbnZhc1Bvb2wsXG4gIHJlbmRlciBhcyByZW5kZXJSZXByb2plY3RlZCxcbn0gZnJvbSAnLi4vcmVwcm9qLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtnZXRBcmVhLCBnZXRJbnRlcnNlY3Rpb24sIGdldFdpZHRoLCB3cmFwQW5kU2xpY2VYfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge3JlbGVhc2VDYW52YXN9IGZyb20gJy4uL2RvbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcikgOiAoaW1wb3J0KFwiLi4vSW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHQpfSBGdW5jdGlvblR5cGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbGVPZmZzZXRcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vSW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgZW5jYXBzdWxhdGluZyBzaW5nbGUgcmVwcm9qZWN0ZWQgdGlsZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlSW1hZ2V+VGlsZUltYWdlfS5cbiAqXG4gKi9cbmNsYXNzIFJlcHJvalRpbGUgZXh0ZW5kcyBUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gc291cmNlVGlsZUdyaWQgU291cmNlIHRpbGUgZ3JpZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0YXJnZXRUaWxlR3JpZCBUYXJnZXQgdGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHdyYXBwZWRUaWxlQ29vcmQgQ29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB3cmFwcGVkIGluIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIEd1dHRlciBvZiB0aGUgc291cmNlIHRpbGVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uVHlwZX0gZ2V0VGlsZUZ1bmN0aW9uXG4gICAqICAgICBGdW5jdGlvbiByZXR1cm5pbmcgc291cmNlIHRpbGVzICh6LCB4LCB5LCBwaXhlbFJhdGlvKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlcnJvclRocmVzaG9sZF0gQWNjZXB0YWJsZSByZXByb2plY3Rpb24gZXJyb3IgKGluIHB4KS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVuZGVyRWRnZXNdIFJlbmRlciByZXByb2plY3Rpb24gZWRnZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5PcHRpb25zfSBbb3B0aW9uc10gVGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc291cmNlUHJvaixcbiAgICBzb3VyY2VUaWxlR3JpZCxcbiAgICB0YXJnZXRQcm9qLFxuICAgIHRhcmdldFRpbGVHcmlkLFxuICAgIHRpbGVDb29yZCxcbiAgICB3cmFwcGVkVGlsZUNvb3JkLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgZ3V0dGVyLFxuICAgIGdldFRpbGVGdW5jdGlvbixcbiAgICBlcnJvclRocmVzaG9sZCxcbiAgICByZW5kZXJFZGdlcyxcbiAgICBvcHRpb25zLFxuICApIHtcbiAgICBzdXBlcih0aWxlQ29vcmQsIFRpbGVTdGF0ZS5JRExFLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJFZGdlc18gPSByZW5kZXJFZGdlcyAhPT0gdW5kZWZpbmVkID8gcmVuZGVyRWRnZXMgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmd1dHRlcl8gPSBndXR0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVRpbGVHcmlkXyA9IHNvdXJjZVRpbGVHcmlkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFRpbGVHcmlkXyA9IHRhcmdldFRpbGVHcmlkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfID0gd3JhcHBlZFRpbGVDb29yZCA/IHdyYXBwZWRUaWxlQ29vcmQgOiB0aWxlQ29vcmQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8VGlsZU9mZnNldD59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVpfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5jbGlwRXh0ZW50XyA9IHNvdXJjZVByb2ouY2FuV3JhcFgoKVxuICAgICAgPyBzb3VyY2VQcm9qLmdldEV4dGVudCgpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRhcmdldFRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8sXG4gICAgKTtcbiAgICBjb25zdCBtYXhUYXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcbiAgICBsZXQgbWF4U291cmNlRXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG5cbiAgICBjb25zdCBsaW1pdGVkVGFyZ2V0RXh0ZW50ID0gbWF4VGFyZ2V0RXh0ZW50XG4gICAgICA/IGdldEludGVyc2VjdGlvbih0YXJnZXRFeHRlbnQsIG1heFRhcmdldEV4dGVudClcbiAgICAgIDogdGFyZ2V0RXh0ZW50O1xuXG4gICAgaWYgKGdldEFyZWEobGltaXRlZFRhcmdldEV4dGVudCkgPT09IDApIHtcbiAgICAgIC8vIFRpbGUgaXMgY29tcGxldGVseSBvdXRzaWRlIHJhbmdlIC0+IEVNUFRZXG4gICAgICAvLyBUT0RPOiBpcyBpdCBhY3R1YWxseSBjb3JyZWN0IHRoYXQgdGhlIHNvdXJjZSBldmVuIGNyZWF0ZXMgdGhlIHRpbGUgP1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VQcm9qRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgICBpZiAoc291cmNlUHJvakV4dGVudCkge1xuICAgICAgaWYgKCFtYXhTb3VyY2VFeHRlbnQpIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gc291cmNlUHJvakV4dGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heFNvdXJjZUV4dGVudCA9IGdldEludGVyc2VjdGlvbihtYXhTb3VyY2VFeHRlbnQsIHNvdXJjZVByb2pFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSB0YXJnZXRUaWxlR3JpZC5nZXRSZXNvbHV0aW9uKFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXSxcbiAgICApO1xuXG4gICAgY29uc3Qgc291cmNlUmVzb2x1dGlvbiA9IGNhbGN1bGF0ZVNvdXJjZUV4dGVudFJlc29sdXRpb24oXG4gICAgICBzb3VyY2VQcm9qLFxuICAgICAgdGFyZ2V0UHJvaixcbiAgICAgIGxpbWl0ZWRUYXJnZXRFeHRlbnQsXG4gICAgICB0YXJnZXRSZXNvbHV0aW9uLFxuICAgICk7XG5cbiAgICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgICAgLy8gaW52YWxpZCBzb3VyY2VSZXNvbHV0aW9uIC0+IEVNUFRZXG4gICAgICAvLyBwcm9iYWJseSBlZGdlcyBvZiB0aGUgcHJvamVjdGlvbnMgd2hlbiBubyBleHRlbnQgaXMgZGVmaW5lZFxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvclRocmVzaG9sZEluUGl4ZWxzID1cbiAgICAgIGVycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBlcnJvclRocmVzaG9sZCA6IEVSUk9SX1RIUkVTSE9MRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFpbXBvcnQoXCIuL1RyaWFuZ3VsYXRpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ3VsYXRpb25fID0gbmV3IFRyaWFuZ3VsYXRpb24oXG4gICAgICBzb3VyY2VQcm9qLFxuICAgICAgdGFyZ2V0UHJvaixcbiAgICAgIGxpbWl0ZWRUYXJnZXRFeHRlbnQsXG4gICAgICBtYXhTb3VyY2VFeHRlbnQsXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uICogZXJyb3JUaHJlc2hvbGRJblBpeGVscyxcbiAgICAgIHRhcmdldFJlc29sdXRpb24sXG4gICAgKTtcblxuICAgIGlmICh0aGlzLnRyaWFuZ3VsYXRpb25fLmdldFRyaWFuZ2xlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gbm8gdmFsaWQgdHJpYW5nbGVzIC0+IEVNUFRZXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlWl8gPSBzb3VyY2VUaWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbihzb3VyY2VSZXNvbHV0aW9uKTtcbiAgICBsZXQgc291cmNlRXh0ZW50ID0gdGhpcy50cmlhbmd1bGF0aW9uXy5jYWxjdWxhdGVTb3VyY2VFeHRlbnQoKTtcblxuICAgIGlmIChtYXhTb3VyY2VFeHRlbnQpIHtcbiAgICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgICAgc291cmNlRXh0ZW50WzFdID0gY2xhbXAoXG4gICAgICAgICAgc291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFsxXSxcbiAgICAgICAgICBtYXhTb3VyY2VFeHRlbnRbM10sXG4gICAgICAgICk7XG4gICAgICAgIHNvdXJjZUV4dGVudFszXSA9IGNsYW1wKFxuICAgICAgICAgIHNvdXJjZUV4dGVudFszXSxcbiAgICAgICAgICBtYXhTb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzNdLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHNvdXJjZUV4dGVudCwgbWF4U291cmNlRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdldEFyZWEoc291cmNlRXh0ZW50KSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHdvcmxkV2lkdGggPSAwO1xuICAgICAgbGV0IHdvcmxkc0F3YXkgPSAwO1xuICAgICAgaWYgKHNvdXJjZVByb2ouY2FuV3JhcFgoKSkge1xuICAgICAgICB3b3JsZFdpZHRoID0gZ2V0V2lkdGgoc291cmNlUHJvakV4dGVudCk7XG4gICAgICAgIHdvcmxkc0F3YXkgPSBNYXRoLmZsb29yKFxuICAgICAgICAgIChzb3VyY2VFeHRlbnRbMF0gLSBzb3VyY2VQcm9qRXh0ZW50WzBdKSAvIHdvcmxkV2lkdGgsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNvdXJjZUV4dGVudHMgPSB3cmFwQW5kU2xpY2VYKFxuICAgICAgICBzb3VyY2VFeHRlbnQuc2xpY2UoKSxcbiAgICAgICAgc291cmNlUHJvaixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICk7XG4gICAgICBzb3VyY2VFeHRlbnRzLmZvckVhY2goKGV4dGVudCkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2VSYW5nZSA9IHNvdXJjZVRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgICAgZXh0ZW50LFxuICAgICAgICAgIHRoaXMuc291cmNlWl8sXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChsZXQgc3JjWCA9IHNvdXJjZVJhbmdlLm1pblg7IHNyY1ggPD0gc291cmNlUmFuZ2UubWF4WDsgc3JjWCsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgc3JjWSA9IHNvdXJjZVJhbmdlLm1pblk7IHNyY1kgPD0gc291cmNlUmFuZ2UubWF4WTsgc3JjWSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0aWxlID0gZ2V0VGlsZUZ1bmN0aW9uKHRoaXMuc291cmNlWl8sIHNyY1gsIHNyY1ksIHBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd29ybGRzQXdheSAqIHdvcmxkV2lkdGg7XG4gICAgICAgICAgICAgIHRoaXMuc291cmNlVGlsZXNfLnB1c2goe3RpbGUsIG9mZnNldH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICArK3dvcmxkc0F3YXk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIEhUTUwgQ2FudmFzIGVsZW1lbnQgZm9yIHRoaXMgdGlsZS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcy5cbiAgICovXG4gIGdldEltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhc187XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcHJvamVjdF8oKSB7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgY29uc3QgdGlsZSA9IHNvdXJjZS50aWxlO1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGUudGlsZUNvb3JkKTtcbiAgICAgICAgZXh0ZW50WzBdICs9IHNvdXJjZS5vZmZzZXQ7XG4gICAgICAgIGV4dGVudFsyXSArPSBzb3VyY2Uub2Zmc2V0O1xuICAgICAgICBjb25zdCBjbGlwRXh0ZW50ID0gdGhpcy5jbGlwRXh0ZW50Xz8uc2xpY2UoKTtcbiAgICAgICAgaWYgKGNsaXBFeHRlbnQpIHtcbiAgICAgICAgICBjbGlwRXh0ZW50WzBdICs9IHNvdXJjZS5vZmZzZXQ7XG4gICAgICAgICAgY2xpcEV4dGVudFsyXSArPSBzb3VyY2Uub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgZXh0ZW50OiBleHRlbnQsXG4gICAgICAgICAgY2xpcEV4dGVudDogY2xpcEV4dGVudCxcbiAgICAgICAgICBpbWFnZTogdGlsZS5nZXRJbWFnZSgpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVSUk9SO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB6ID0gdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXTtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlU2l6ZSh6KTtcbiAgICAgIGNvbnN0IHdpZHRoID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVsxXTtcbiAgICAgIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHopO1xuICAgICAgY29uc3Qgc291cmNlUmVzb2x1dGlvbiA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFJlc29sdXRpb24oXG4gICAgICAgIHRoaXMuc291cmNlWl8sXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0YXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQoXG4gICAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8sXG4gICAgICApO1xuXG4gICAgICB0aGlzLmNhbnZhc18gPSByZW5kZXJSZXByb2plY3RlZChcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgc291cmNlUmVzb2x1dGlvbixcbiAgICAgICAgdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCksXG4gICAgICAgIHRhcmdldFJlc29sdXRpb24sXG4gICAgICAgIHRhcmdldEV4dGVudCxcbiAgICAgICAgdGhpcy50cmlhbmd1bGF0aW9uXyxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgdGhpcy5ndXR0ZXJfLFxuICAgICAgICB0aGlzLnJlbmRlckVkZ2VzXyxcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcblxuICAgICAgbGV0IGxlZnRUb0xvYWQgPSAwO1xuXG4gICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gW107XG4gICAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKCh7dGlsZX0pID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSB8fCBzdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgICAgIGxlZnRUb0xvYWQrKztcblxuICAgICAgICAgIGNvbnN0IHNvdXJjZUxpc3RlbktleSA9IGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLCAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5MT0FERUQgfHxcbiAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SIHx8XG4gICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHVubGlzdGVuQnlLZXkoc291cmNlTGlzdGVuS2V5KTtcbiAgICAgICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgICAgICBpZiAobGVmdFRvTG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5saXN0ZW5Tb3VyY2VzXygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXy5wdXNoKHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGVmdFRvTG9hZCA9PT0gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucmVwcm9qZWN0Xy5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24gKHt0aWxlfSwgaSwgYXJyKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aWxlLmxvYWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5saXN0ZW5Tb3VyY2VzXygpIHtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGZyb20gdGhlIGNhY2hlIGR1ZSB0byBleHBpcnlcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLmNhbnZhc18pIHtcbiAgICAgIHJlbGVhc2VDYW52YXModGhpcy5jYW52YXNfLmdldENvbnRleHQoJzJkJykpO1xuICAgICAgY2FudmFzUG9vbC5wdXNoKHRoaXMuY2FudmFzXyk7XG4gICAgICB0aGlzLmNhbnZhc18gPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5yZWxlYXNlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVwcm9qVGlsZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVJhbmdlXG4gKi9cblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29udGlndW91cyBibG9jayBvZiB0aWxlcy4gIEEgdGlsZSByYW5nZSBpcyBzcGVjaWZpZWRcbiAqIGJ5IGl0cyBtaW4vbWF4IHRpbGUgY29vcmRpbmF0ZXMgYW5kIGlzIGluY2x1c2l2ZSBvZiBjb29yZGluYXRlcy5cbiAqL1xuY2xhc3MgVGlsZVJhbmdlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWSBNaW5pbXVtIFkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWCA9IG1pblg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWSA9IG1pblk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIHRpbGUgY29vcmRpbmF0ZS5cbiAgICovXG4gIGNvbnRhaW5zKHRpbGVDb29yZCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zWFkodGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMuXG4gICAqL1xuICBjb250YWluc1RpbGVSYW5nZSh0aWxlUmFuZ2UpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5taW5YIDw9IHRpbGVSYW5nZS5taW5YICYmXG4gICAgICB0aWxlUmFuZ2UubWF4WCA8PSB0aGlzLm1heFggJiZcbiAgICAgIHRoaXMubWluWSA8PSB0aWxlUmFuZ2UubWluWSAmJlxuICAgICAgdGlsZVJhbmdlLm1heFkgPD0gdGhpcy5tYXhZXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGNvb3JkaW5hdGUuXG4gICAqL1xuICBjb250YWluc1hZKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YIDw9IHggJiYgeCA8PSB0aGlzLm1heFggJiYgdGhpcy5taW5ZIDw9IHkgJiYgeSA8PSB0aGlzLm1heFk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBFcXVhbHMuXG4gICAqL1xuICBlcXVhbHModGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWluWCA9PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICAgdGhpcy5taW5ZID09IHRpbGVSYW5nZS5taW5ZICYmXG4gICAgICB0aGlzLm1heFggPT0gdGlsZVJhbmdlLm1heFggJiZcbiAgICAgIHRoaXMubWF4WSA9PSB0aWxlUmFuZ2UubWF4WVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZXh0ZW5kKHRpbGVSYW5nZSkge1xuICAgIGlmICh0aWxlUmFuZ2UubWluWCA8IHRoaXMubWluWCkge1xuICAgICAgdGhpcy5taW5YID0gdGlsZVJhbmdlLm1pblg7XG4gICAgfVxuICAgIGlmICh0aWxlUmFuZ2UubWF4WCA+IHRoaXMubWF4WCkge1xuICAgICAgdGhpcy5tYXhYID0gdGlsZVJhbmdlLm1heFg7XG4gICAgfVxuICAgIGlmICh0aWxlUmFuZ2UubWluWSA8IHRoaXMubWluWSkge1xuICAgICAgdGhpcy5taW5ZID0gdGlsZVJhbmdlLm1pblk7XG4gICAgfVxuICAgIGlmICh0aWxlUmFuZ2UubWF4WSA+IHRoaXMubWF4WSkge1xuICAgICAgdGhpcy5tYXhZID0gdGlsZVJhbmdlLm1heFk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0LlxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1heFkgLSB0aGlzLm1pblkgKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gW3RoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKV07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLm1heFggLSB0aGlzLm1pblggKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSW50ZXJzZWN0cy5cbiAgICovXG4gIGludGVyc2VjdHModGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWluWCA8PSB0aWxlUmFuZ2UubWF4WCAmJlxuICAgICAgdGhpcy5tYXhYID49IHRpbGVSYW5nZS5taW5YICYmXG4gICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1heFkgJiZcbiAgICAgIHRoaXMubWF4WSA+PSB0aWxlUmFuZ2UubWluWVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WCBNYXhpbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWSBNaW5pbXVtIFkuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gKiBAcGFyYW0ge1RpbGVSYW5nZX0gW3RpbGVSYW5nZV0gVGlsZVJhbmdlLlxuICogQHJldHVybiB7VGlsZVJhbmdlfSBUaWxlIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGlsZVJhbmdlKSB7XG4gIGlmICh0aWxlUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbGVSYW5nZS5taW5YID0gbWluWDtcbiAgICB0aWxlUmFuZ2UubWF4WCA9IG1heFg7XG4gICAgdGlsZVJhbmdlLm1pblkgPSBtaW5ZO1xuICAgIHRpbGVSYW5nZS5tYXhZID0gbWF4WTtcbiAgICByZXR1cm4gdGlsZVJhbmdlO1xuICB9XG4gIHJldHVybiBuZXcgVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlUmFuZ2U7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVjb29yZFxuICovXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgdGhyZWUgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgdGlsZSBpbiBhIHRpbGVcbiAqIGdyaWQuIFRoZSBvcmRlciBpcyBgemAgKHpvb20gbGV2ZWwpLCBgeGAgKGNvbHVtbiksIGFuZCBgeWAgKHJvdykuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gVGlsZUNvb3JkXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gW3RpbGVDb29yZF0gVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZSh6LCB4LCB5LCB0aWxlQ29vcmQpIHtcbiAgaWYgKHRpbGVDb29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGlsZUNvb3JkWzBdID0gejtcbiAgICB0aWxlQ29vcmRbMV0gPSB4O1xuICAgIHRpbGVDb29yZFsyXSA9IHk7XG4gICAgcmV0dXJuIHRpbGVDb29yZDtcbiAgfVxuICByZXR1cm4gW3osIHgsIHldO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5WlhZKHosIHgsIHkpIHtcbiAgcmV0dXJuIHogKyAnLycgKyB4ICsgJy8nICsgeTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGtleSBmb3IgYSB0aWxlIGNvb3JkLlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IHRpbGVDb29yZCBUaGUgdGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5KHRpbGVDb29yZCkge1xuICByZXR1cm4gZ2V0S2V5WlhZKHRpbGVDb29yZFswXSwgdGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdGlsZSBjYWNoZSBrZXkgZm9yIGEgdGlsZSBrZXkgb2J0YWluZWQgdGhyb3VnaCBgdGlsZS5nZXRLZXkoKWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGlsZUtleSBUaGUgdGlsZSBrZXkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjYWNoZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWNoZUtleUZvclRpbGVLZXkodGlsZUtleSkge1xuICBjb25zdCBbeiwgeCwgeV0gPSB0aWxlS2V5XG4gICAgLnN1YnN0cmluZyh0aWxlS2V5Lmxhc3RJbmRleE9mKCcvJykgKyAxLCB0aWxlS2V5Lmxlbmd0aClcbiAgICAuc3BsaXQoJywnKVxuICAgIC5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIGdldEtleVpYWSh6LCB4LCB5KTtcbn1cblxuLyoqXG4gKiBHZXQgYSB0aWxlIGNvb3JkIGdpdmVuIGEga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgdGlsZSBjb29yZCBrZXkuXG4gKiBAcmV0dXJuIHtUaWxlQ29vcmR9IFRoZSB0aWxlIGNvb3JkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUtleShrZXkpIHtcbiAgcmV0dXJuIGtleS5zcGxpdCgnLycpLm1hcChOdW1iZXIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge251bWJlcn0gSGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2godGlsZUNvb3JkKSB7XG4gIHJldHVybiBoYXNoWlhZKHRpbGVDb29yZFswXSwgdGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFRoZSB0aWxlIHogY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB0aWxlIHggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB0aWxlIHkgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gSGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2haWFkoeiwgeCwgeSkge1xuICByZXR1cm4gKHggPDwgeikgKyB5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaWxlIGNvb3JkaW5hdGUgaXMgd2l0aGluIGV4dGVudCBhbmQgem9vbSBsZXZlbCByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbkV4dGVudEFuZFoodGlsZUNvb3JkLCB0aWxlR3JpZCkge1xuICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICBjb25zdCB4ID0gdGlsZUNvb3JkWzFdO1xuICBjb25zdCB5ID0gdGlsZUNvb3JkWzJdO1xuXG4gIGlmICh0aWxlR3JpZC5nZXRNaW5ab29tKCkgPiB6IHx8IHogPiB0aWxlR3JpZC5nZXRNYXhab29tKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0RnVsbFRpbGVSYW5nZSh6KTtcbiAgaWYgKCF0aWxlUmFuZ2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGlsZVJhbmdlLmNvbnRhaW5zWFkoeCwgeSk7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgRGF0YVRpbGUsIHthc0ltYWdlTGlrZX0gZnJvbSAnLi4vLi4vRGF0YVRpbGUuanMnO1xuaW1wb3J0IEltYWdlVGlsZSBmcm9tICcuLi8uLi9JbWFnZVRpbGUuanMnO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4uLy4uL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IFJlcHJvakRhdGFUaWxlIGZyb20gJy4uLy4uL3JlcHJvai9EYXRhVGlsZS5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi8uLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlIGZyb20gJy4uLy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uLy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge1xuICBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSxcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHthc2NlbmRpbmd9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlRW1wdHksXG4gIGVxdWFscyxcbiAgZ2V0SW50ZXJzZWN0aW9uLFxuICBnZXRUb3BMZWZ0LFxuICBpbnRlcnNlY3RzLFxufSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVUaWxlQ29vcmQsIGdldEtleVpYWX0gZnJvbSAnLi4vLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7ZnJvbVVzZXJFeHRlbnR9IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uLy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VLZXkgVGhlIHNvdXJjZSBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaGUgdGlsZSB6IGxldmVsLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHRpbGUgeCBsZXZlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB0aWxlIHkgbGV2ZWwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjYWNoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldENhY2hlS2V5KHNvdXJjZUtleSwgeiwgeCwgeSkge1xuICByZXR1cm4gYCR7c291cmNlS2V5fSwke2dldEtleVpYWSh6LCB4LCB5KX1gO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3Q8bnVtYmVyLCBTZXQ8aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pj59IFRpbGVMb29rdXBcbiAqL1xuXG4vKipcbiAqIEFkZCBhIHRpbGUgdG8gdGhlIGxvb2t1cC5cbiAqIEBwYXJhbSB7VGlsZUxvb2t1cH0gdGlsZXNCeVogTG9va3VwIG9mIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBBIHRpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaGUgem9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHdhcyBhZGRlZCB0byB0aGUgbG9va3VwLlxuICovXG5mdW5jdGlvbiBhZGRUaWxlVG9Mb29rdXAodGlsZXNCeVosIHRpbGUsIHopIHtcbiAgaWYgKCEoeiBpbiB0aWxlc0J5WikpIHtcbiAgICB0aWxlc0J5Wlt6XSA9IG5ldyBTZXQoW3RpbGVdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzZXQgPSB0aWxlc0J5Wlt6XTtcbiAgY29uc3QgZXhpc3RpbmcgPSBzZXQuaGFzKHRpbGUpO1xuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgc2V0LmFkZCh0aWxlKTtcbiAgfVxuICByZXR1cm4gIWV4aXN0aW5nO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHRpbGUgZnJvbSB0aGUgbG9va3VwLlxuICogQHBhcmFtIHtUaWxlTG9va3VwfSB0aWxlc0J5WiBMb29rdXAgb2YgdGlsZXMgYnkgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIEEgdGlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFRoZSB6b29tIGxldmVsLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgd2FzIHJlbW92ZWQgZnJvbSB0aGUgbG9va3VwLlxuICovXG5mdW5jdGlvbiByZW1vdmVUaWxlRnJvbUxvb2t1cCh0aWxlc0J5WiwgdGlsZSwgeikge1xuICBjb25zdCBzZXQgPSB0aWxlc0J5Wlt6XTtcbiAgaWYgKHNldCkge1xuICAgIHJldHVybiBzZXQuZGVsZXRlKHRpbGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGZyYW1lIGV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEZyYW1lIGV4dGVudCBpbnRlcnNlY3RlZCB3aXRoIGxheWVyIGV4dGVudHMuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlckV4dGVudChmcmFtZVN0YXRlLCBleHRlbnQpIHtcbiAgY29uc3QgbGF5ZXJTdGF0ZSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheVtmcmFtZVN0YXRlLmxheWVySW5kZXhdO1xuICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQpIHtcbiAgICBleHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oXG4gICAgICBleHRlbnQsXG4gICAgICBmcm9tVXNlckV4dGVudChsYXllclN0YXRlLmV4dGVudCwgZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbiksXG4gICAgKTtcbiAgfVxuICBjb25zdCBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICBsYXllclN0YXRlLmxheWVyLmdldFJlbmRlclNvdXJjZSgpXG4gICk7XG4gIGlmICghc291cmNlLmdldFdyYXBYKCkpIHtcbiAgICBjb25zdCBncmlkRXh0ZW50ID0gc291cmNlXG4gICAgICAuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24pXG4gICAgICAuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKGdyaWRFeHRlbnQpIHtcbiAgICAgIGV4dGVudCA9IGdldEludGVyc2VjdGlvbihleHRlbnQsIGdyaWRFeHRlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTUxMl0gVGhlIGNhY2hlIHNpemUuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgcmVuZGVyZXIgZm9yIHRpbGUgbGF5ZXJzLlxuICogQGFwaVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSBbTGF5ZXJUeXBlPWltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0PnxpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHRdXG4gKiBAZXh0ZW5kcyB7Q2FudmFzTGF5ZXJSZW5kZXJlcjxMYXllclR5cGU+fVxuICovXG5jbGFzcyBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciBleHRlbmRzIENhbnZhc0xheWVyUmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtMYXllclR5cGV9IHRpbGVMYXllciBUaWxlIGxheWVyLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZUxheWVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIodGlsZUxheWVyKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyZWQgZXh0ZW50IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBwcmV2aW91cyBgcmVuZGVyRnJhbWUoKWAgY2FsbFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50Q2hhbmdlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBjYWxsIHRvIGByZW5kZXJGcmFtZWAgd2FzIGNvbXBsZXRlZCB3aXRoIGFsbCB0aWxlcyBsb2FkZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckNvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb24gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXk8aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVGlsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkU291cmNlS2V5XztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkU291cmNlUmV2aXNpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMudGVtcEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRlbXBUaWxlUmFuZ2VfID0gbmV3IFRpbGVSYW5nZSgwLCAwLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50ZW1wVGlsZUNvb3JkXyA9IGNyZWF0ZVRpbGVDb29yZCgwLCAwLCAwKTtcblxuICAgIGNvbnN0IGNhY2hlU2l6ZSA9IG9wdGlvbnMuY2FjaGVTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNhY2hlU2l6ZSA6IDUxMjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zdHJ1Y3RzL0xSVUNhY2hlLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNhY2hlXyA9IG5ldyBMUlVDYWNoZShjYWNoZVNpemUpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5tYXhTdGFsZUtleXMgPSBjYWNoZVNpemUgKiAwLjU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TFJVQ2FjaGV9IFRpbGUgY2FjaGUuXG4gICAqL1xuICBnZXRUaWxlQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0aWxlIGZyb20gdGhlIGNhY2hlIG9yIGNyZWF0ZSBvbmUgaWYgbmVlZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR8bnVsbH0gVGlsZSAob3IgbnVsbCBpZiBvdXRzaWRlIHNvdXJjZSBleHRlbnQpLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRPckNyZWF0ZVRpbGUoeiwgeCwgeSwgZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMudGlsZUNhY2hlXztcbiAgICBjb25zdCB0aWxlTGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgY29uc3QgdGlsZVNvdXJjZSA9IHRpbGVMYXllci5nZXRTb3VyY2UoKTtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KHRpbGVTb3VyY2UuZ2V0S2V5KCksIHosIHgsIHkpO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovXG4gICAgbGV0IHRpbGU7XG5cbiAgICBpZiAodGlsZUNhY2hlLmNvbnRhaW5zS2V5KGNhY2hlS2V5KSkge1xuICAgICAgdGlsZSA9IHRpbGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlID0gdGlsZVNvdXJjZS5nZXRUaWxlKFxuICAgICAgICB6LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmcmFtZVN0YXRlLnBpeGVsUmF0aW8sXG4gICAgICAgIGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24sXG4gICAgICApO1xuICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGlsZUNhY2hlLnNldChjYWNoZUtleSwgdGlsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIChvciBudWxsIGlmIG91dHNpZGUgc291cmNlIGV4dGVudCkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGUoeiwgeCwgeSwgZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IHRpbGUgPSB0aGlzLmdldE9yQ3JlYXRlVGlsZSh6LCB4LCB5LCBmcmFtZVN0YXRlKTtcbiAgICBpZiAoIXRpbGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl9IERhdGEgYXQgdGhlIHBpeGVsIGxvY2F0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgY29uc3QgY29vcmRpbmF0ZSA9IGFwcGx5VHJhbnNmb3JtKFxuICAgICAgZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSxcbiAgICAgIHBpeGVsLnNsaWNlKCksXG4gICAgKTtcblxuICAgIGNvbnN0IGxheWVyRXh0ZW50ID0gbGF5ZXIuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKGxheWVyRXh0ZW50KSB7XG4gICAgICBpZiAoIWNvbnRhaW5zQ29vcmRpbmF0ZShsYXllckV4dGVudCwgY29vcmRpbmF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3Qgc291cmNlID0gbGF5ZXIuZ2V0UmVuZGVyU291cmNlKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHZpZXdTdGF0ZS5wcm9qZWN0aW9uKTtcbiAgICBjb25zdCB0aWxlUGl4ZWxSYXRpbyA9IHNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhmcmFtZVN0YXRlLnBpeGVsUmF0aW8pO1xuXG4gICAgZm9yIChcbiAgICAgIGxldCB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24odmlld1N0YXRlLnJlc29sdXRpb24pO1xuICAgICAgeiA+PSB0aWxlR3JpZC5nZXRNaW5ab29tKCk7XG4gICAgICAtLXpcbiAgICApIHtcbiAgICAgIGNvbnN0IHRpbGVDb29yZCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjb29yZGluYXRlLCB6KTtcbiAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLmdldFRpbGUoeiwgdGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0sIGZyYW1lU3RhdGUpO1xuICAgICAgaWYgKCF0aWxlIHx8IHRpbGUuZ2V0U3RhdGUoKSAhPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGlsZU9yaWdpbiA9IHRpbGVHcmlkLmdldE9yaWdpbih6KTtcbiAgICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRpbGVHcmlkLmdldFRpbGVTaXplKHopKTtcbiAgICAgIGNvbnN0IHRpbGVSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih6KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX1cbiAgICAgICAqL1xuICAgICAgbGV0IGltYWdlO1xuICAgICAgaWYgKHRpbGUgaW5zdGFuY2VvZiBJbWFnZVRpbGUgfHwgdGlsZSBpbnN0YW5jZW9mIFJlcHJvalRpbGUpIHtcbiAgICAgICAgaW1hZ2UgPSB0aWxlLmdldEltYWdlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRpbGUgaW5zdGFuY2VvZiBEYXRhVGlsZSkge1xuICAgICAgICBpbWFnZSA9IGFzSW1hZ2VMaWtlKHRpbGUuZ2V0RGF0YSgpKTtcbiAgICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29sID0gTWF0aC5mbG9vcihcbiAgICAgICAgdGlsZVBpeGVsUmF0aW8gKlxuICAgICAgICAgICgoY29vcmRpbmF0ZVswXSAtIHRpbGVPcmlnaW5bMF0pIC8gdGlsZVJlc29sdXRpb24gLVxuICAgICAgICAgICAgdGlsZUNvb3JkWzFdICogdGlsZVNpemVbMF0pLFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihcbiAgICAgICAgdGlsZVBpeGVsUmF0aW8gKlxuICAgICAgICAgICgodGlsZU9yaWdpblsxXSAtIGNvb3JkaW5hdGVbMV0pIC8gdGlsZVJlc29sdXRpb24gLVxuICAgICAgICAgICAgdGlsZUNvb3JkWzJdICogdGlsZVNpemVbMV0pLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgZ3V0dGVyID0gTWF0aC5yb3VuZChcbiAgICAgICAgdGlsZVBpeGVsUmF0aW8gKiBzb3VyY2UuZ2V0R3V0dGVyRm9yUHJvamVjdGlvbih2aWV3U3RhdGUucHJvamVjdGlvbiksXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5nZXRJbWFnZURhdGEoaW1hZ2UsIGNvbCArIGd1dHRlciwgcm93ICsgZ3V0dGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciByZW5kZXIgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gTGF5ZXIgaXMgcmVhZHkgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZWRQcm9qZWN0aW9uXykge1xuICAgICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb25fID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICB9IGVsc2UgaWYgKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24gIT09IHRoaXMucmVuZGVyZWRQcm9qZWN0aW9uXykge1xuICAgICAgdGhpcy50aWxlQ2FjaGVfLmNsZWFyKCk7XG4gICAgICB0aGlzLnJlbmRlcmVkUHJvamVjdGlvbl8gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VSZXZpc2lvbiA9IHNvdXJjZS5nZXRSZXZpc2lvbigpO1xuICAgIGlmICghdGhpcy5yZW5kZXJlZFJldmlzaW9uXykge1xuICAgICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9IHNvdXJjZVJldmlzaW9uO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJlZFJldmlzaW9uXyAhPT0gc291cmNlUmV2aXNpb24pIHtcbiAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPSBzb3VyY2VSZXZpc2lvbjtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkU291cmNlS2V5XyA9PT0gc291cmNlLmdldEtleSgpKSB7XG4gICAgICAgIHRoaXMudGlsZUNhY2hlXy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbFogVGhlIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7VGlsZUxvb2t1cH0gdGlsZXNCeVogTG9va3VwIG9mIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVsb2FkIE51bWJlciBvZiBhZGRpdGlvbmFsIGxldmVscyB0byBsb2FkLlxuICAgKi9cbiAgZW5xdWV1ZVRpbGVzKGZyYW1lU3RhdGUsIGV4dGVudCwgaW5pdGlhbFosIHRpbGVzQnlaLCBwcmVsb2FkKSB7XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3QgdGlsZUxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGNvbnN0IHRpbGVTb3VyY2UgPSB0aWxlTGF5ZXIuZ2V0UmVuZGVyU291cmNlKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSB0aWxlU291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbih2aWV3U3RhdGUucHJvamVjdGlvbik7XG5cbiAgICBjb25zdCB0aWxlU291cmNlS2V5ID0gZ2V0VWlkKHRpbGVTb3VyY2UpO1xuICAgIGlmICghKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS53YW50ZWRUaWxlcykpIHtcbiAgICAgIGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV0gPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCB3YW50ZWRUaWxlcyA9IGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV07XG5cbiAgICBjb25zdCBtYXAgPSB0aWxlTGF5ZXIuZ2V0TWFwSW50ZXJuYWwoKTtcbiAgICBjb25zdCBtaW5aID0gTWF0aC5tYXgoXG4gICAgICBpbml0aWFsWiAtIHByZWxvYWQsXG4gICAgICB0aWxlR3JpZC5nZXRNaW5ab29tKCksXG4gICAgICB0aWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbihcbiAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgdGlsZUxheWVyLmdldE1heFJlc29sdXRpb24oKSxcbiAgICAgICAgICBtYXBcbiAgICAgICAgICAgID8gbWFwXG4gICAgICAgICAgICAgICAgLmdldFZpZXcoKVxuICAgICAgICAgICAgICAgIC5nZXRSZXNvbHV0aW9uRm9yWm9vbShNYXRoLm1heCh0aWxlTGF5ZXIuZ2V0TWluWm9vbSgpLCAwKSlcbiAgICAgICAgICAgIDogdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbigwKSxcbiAgICAgICAgKSxcbiAgICAgICAgdGlsZVNvdXJjZS56RGlyZWN0aW9uLFxuICAgICAgKSxcbiAgICApO1xuICAgIGZvciAobGV0IHogPSBpbml0aWFsWjsgeiA+PSBtaW5aOyAtLXopIHtcbiAgICAgIGNvbnN0IHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgIGV4dGVudCxcbiAgICAgICAgeixcbiAgICAgICAgdGhpcy50ZW1wVGlsZVJhbmdlXyxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRpbGVSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih6KTtcblxuICAgICAgZm9yIChsZXQgeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5nZXRUaWxlKHosIHgsIHksIGZyYW1lU3RhdGUpO1xuICAgICAgICAgIGlmICghdGlsZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFkZGVkID0gYWRkVGlsZVRvTG9va3VwKHRpbGVzQnlaLCB0aWxlLCB6KTtcbiAgICAgICAgICBpZiAoIWFkZGVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0aWxlUXVldWVLZXkgPSB0aWxlLmdldEtleSgpO1xuICAgICAgICAgIHdhbnRlZFRpbGVzW3RpbGVRdWV1ZUtleV0gPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIGlmICghZnJhbWVTdGF0ZS50aWxlUXVldWUuaXNLZXlRdWV1ZWQodGlsZVF1ZXVlS2V5KSkge1xuICAgICAgICAgICAgICBjb25zdCB0aWxlQ29vcmQgPSBjcmVhdGVUaWxlQ29vcmQoeiwgeCwgeSwgdGhpcy50ZW1wVGlsZUNvb3JkXyk7XG4gICAgICAgICAgICAgIGZyYW1lU3RhdGUudGlsZVF1ZXVlLmVucXVldWUoW1xuICAgICAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICAgICAgdGlsZVNvdXJjZUtleSxcbiAgICAgICAgICAgICAgICB0aWxlR3JpZC5nZXRUaWxlQ29vcmRDZW50ZXIodGlsZUNvb3JkKSxcbiAgICAgICAgICAgICAgICB0aWxlUmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgZm9yIHRpbGVzIGNvdmVyaW5nIHRoZSBwcm92aWRlZCB0aWxlIGNvb3JkaW5hdGUgYXQgYW4gYWx0ZXJuYXRlXG4gICAqIHpvb20gbGV2ZWwuICBMb2FkZWQgdGlsZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgcHJvdmlkZWQgdGlsZSB0ZXh0dXJlIGxvb2t1cC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGhlIHRhcmdldCB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7VGlsZUxvb2t1cH0gdGlsZXNCeVogTG9va3VwIG9mIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIGNvb3JkaW5hdGUgaXMgY292ZXJlZCBieSBsb2FkZWQgdGlsZXMgYXQgdGhlIGFsdGVybmF0ZSB6b29tIGxldmVsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmluZFN0YWxlVGlsZV8odGlsZUNvb3JkLCB0aWxlc0J5Wikge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMudGlsZUNhY2hlXztcbiAgICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICAgIGNvbnN0IHggPSB0aWxlQ29vcmRbMV07XG4gICAgY29uc3QgeSA9IHRpbGVDb29yZFsyXTtcbiAgICBjb25zdCBzdGFsZUtleXMgPSB0aGlzLmdldFN0YWxlS2V5cygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhbGVLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KHN0YWxlS2V5c1tpXSwgeiwgeCwgeSk7XG4gICAgICBpZiAodGlsZUNhY2hlLmNvbnRhaW5zS2V5KGNhY2hlS2V5KSkge1xuICAgICAgICBjb25zdCB0aWxlID0gdGlsZUNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICB0aWxlLmVuZFRyYW5zaXRpb24oZ2V0VWlkKHRoaXMpKTtcbiAgICAgICAgICBhZGRUaWxlVG9Mb29rdXAodGlsZXNCeVosIHRpbGUsIHopO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIGZvciB0aWxlcyBjb3ZlcmluZyB0aGUgcHJvdmlkZWQgdGlsZSBjb29yZGluYXRlIGF0IGFuIGFsdGVybmF0ZVxuICAgKiB6b29tIGxldmVsLiAgTG9hZGVkIHRpbGVzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHByb3ZpZGVkIHRpbGUgdGV4dHVyZSBsb29rdXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGhlIHRpbGUgZ3JpZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGhlIHRhcmdldCB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbHRaIFRoZSBhbHRlcm5hdGUgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtUaWxlTG9va3VwfSB0aWxlc0J5WiBMb29rdXAgb2YgdGlsZXMgYnkgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgY29vcmRpbmF0ZSBpcyBjb3ZlcmVkIGJ5IGxvYWRlZCB0aWxlcyBhdCB0aGUgYWx0ZXJuYXRlIHpvb20gbGV2ZWwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmaW5kQWx0VGlsZXNfKHRpbGVHcmlkLCB0aWxlQ29vcmQsIGFsdFosIHRpbGVzQnlaKSB7XG4gICAgY29uc3QgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yVGlsZUNvb3JkQW5kWihcbiAgICAgIHRpbGVDb29yZCxcbiAgICAgIGFsdFosXG4gICAgICB0aGlzLnRlbXBUaWxlUmFuZ2VfLFxuICAgICk7XG5cbiAgICBpZiAoIXRpbGVSYW5nZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjb3ZlcmVkID0gdHJ1ZTtcbiAgICBjb25zdCB0aWxlQ2FjaGUgPSB0aGlzLnRpbGVDYWNoZV87XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRMYXllcigpLmdldFJlbmRlclNvdXJjZSgpO1xuICAgIGNvbnN0IHNvdXJjZUtleSA9IHNvdXJjZS5nZXRLZXkoKTtcbiAgICBmb3IgKGxldCB4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgICAgZm9yIChsZXQgeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShzb3VyY2VLZXksIGFsdFosIHgsIHkpO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aWxlQ2FjaGUuY29udGFpbnNLZXkoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgY29uc3QgdGlsZSA9IHRpbGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICAgIGFkZFRpbGVUb0xvb2t1cCh0aWxlc0J5WiwgdGlsZSwgYWx0Wik7XG4gICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgIGNvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY292ZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGxheWVyLlxuICAgKlxuICAgKiBUaGUgZnJhbWUgcmVuZGVyaW5nIGxvZ2ljIGhhcyB0aHJlZSBwYXJ0czpcbiAgICpcbiAgICogIDEuIEVucXVldWUgdGlsZXNcbiAgICogIDIuIEZpbmQgYWx0IHRpbGVzIGZvciB0aG9zZSB0aGF0IGFyZSBub3QgeWV0IGxvYWRlZFxuICAgKiAgMy4gUmVuZGVyIGxvYWRlZCB0aWxlc1xuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgdG8uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgcmVuZGVyZWQgZWxlbWVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZW5kZXJGcmFtZShmcmFtZVN0YXRlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnJlbmRlckNvbXBsZXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRPRE86XG4gICAgICogICogbWF5YmUgc2tpcCB0cmFuc2l0aW9uIHdoZW4gbm90IGZ1bGx5IG9wYXF1ZVxuICAgICAqICAqIGRlY2lkZSBpZiB0aGlzLnJlbmRlckNvbXBsZXRlIGlzIHVzZWZ1bFxuICAgICAqL1xuXG4gICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheVtmcmFtZVN0YXRlLmxheWVySW5kZXhdO1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICBjb25zdCB2aWV3UmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHZpZXdDZW50ZXIgPSB2aWV3U3RhdGUuY2VudGVyO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG5cbiAgICBjb25zdCB0aWxlTGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgY29uc3QgdGlsZVNvdXJjZSA9IHRpbGVMYXllci5nZXRTb3VyY2UoKTtcbiAgICBjb25zdCBzb3VyY2VSZXZpc2lvbiA9IHRpbGVTb3VyY2UuZ2V0UmV2aXNpb24oKTtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHRpbGVTb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHogPSB0aWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbih2aWV3UmVzb2x1dGlvbiwgdGlsZVNvdXJjZS56RGlyZWN0aW9uKTtcbiAgICBjb25zdCB0aWxlUmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG5cbiAgICBjb25zdCBzb3VyY2VLZXkgPSB0aWxlU291cmNlLmdldEtleSgpO1xuICAgIGlmICghdGhpcy5yZW5kZXJlZFNvdXJjZUtleV8pIHtcbiAgICAgIHRoaXMucmVuZGVyZWRTb3VyY2VLZXlfID0gc291cmNlS2V5O1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJlZFNvdXJjZUtleV8gIT09IHNvdXJjZUtleSkge1xuICAgICAgdGhpcy5wcmVwZW5kU3RhbGVLZXkodGhpcy5yZW5kZXJlZFNvdXJjZUtleV8pO1xuICAgICAgdGhpcy5yZW5kZXJlZFNvdXJjZUtleV8gPSBzb3VyY2VLZXk7XG4gICAgfVxuXG4gICAgbGV0IGZyYW1lRXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG4gICAgY29uc3QgdGlsZVBpeGVsUmF0aW8gPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuXG4gICAgdGhpcy5wcmVwYXJlQ29udGFpbmVyKGZyYW1lU3RhdGUsIHRhcmdldCk7XG5cbiAgICAvLyBkZXNpcmVkIGRpbWVuc2lvbnMgb2YgdGhlIGNhbnZhcyBpbiBwaXhlbHNcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY29udGV4dC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jb250ZXh0LmNhbnZhcy5oZWlnaHQ7XG5cbiAgICBjb25zdCBsYXllckV4dGVudCA9XG4gICAgICBsYXllclN0YXRlLmV4dGVudCAmJiBmcm9tVXNlckV4dGVudChsYXllclN0YXRlLmV4dGVudCwgcHJvamVjdGlvbik7XG4gICAgaWYgKGxheWVyRXh0ZW50KSB7XG4gICAgICBmcmFtZUV4dGVudCA9IGdldEludGVyc2VjdGlvbihcbiAgICAgICAgZnJhbWVFeHRlbnQsXG4gICAgICAgIGZyb21Vc2VyRXh0ZW50KGxheWVyU3RhdGUuZXh0ZW50LCBwcm9qZWN0aW9uKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZHggPSAodGlsZVJlc29sdXRpb24gKiB3aWR0aCkgLyAyIC8gdGlsZVBpeGVsUmF0aW87XG4gICAgY29uc3QgZHkgPSAodGlsZVJlc29sdXRpb24gKiBoZWlnaHQpIC8gMiAvIHRpbGVQaXhlbFJhdGlvO1xuICAgIGNvbnN0IGNhbnZhc0V4dGVudCA9IFtcbiAgICAgIHZpZXdDZW50ZXJbMF0gLSBkeCxcbiAgICAgIHZpZXdDZW50ZXJbMV0gLSBkeSxcbiAgICAgIHZpZXdDZW50ZXJbMF0gKyBkeCxcbiAgICAgIHZpZXdDZW50ZXJbMV0gKyBkeSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbGVMb29rdXB9XG4gICAgICovXG4gICAgY29uc3QgdGlsZXNCeVogPSB7fTtcblxuICAgIHRoaXMucmVuZGVyZWRUaWxlcy5sZW5ndGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogUGFydCAxOiBFbnF1ZXVlIHRpbGVzXG4gICAgICovXG5cbiAgICBjb25zdCBwcmVsb2FkID0gdGlsZUxheWVyLmdldFByZWxvYWQoKTtcbiAgICBpZiAoZnJhbWVTdGF0ZS5uZXh0RXh0ZW50KSB7XG4gICAgICBjb25zdCB0YXJnZXRaID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24oXG4gICAgICAgIHZpZXdTdGF0ZS5uZXh0UmVzb2x1dGlvbixcbiAgICAgICAgdGlsZVNvdXJjZS56RGlyZWN0aW9uLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG5leHRFeHRlbnQgPSBnZXRSZW5kZXJFeHRlbnQoZnJhbWVTdGF0ZSwgZnJhbWVTdGF0ZS5uZXh0RXh0ZW50KTtcbiAgICAgIHRoaXMuZW5xdWV1ZVRpbGVzKGZyYW1lU3RhdGUsIG5leHRFeHRlbnQsIHRhcmdldFosIHRpbGVzQnlaLCBwcmVsb2FkKTtcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJFeHRlbnQgPSBnZXRSZW5kZXJFeHRlbnQoZnJhbWVTdGF0ZSwgZnJhbWVFeHRlbnQpO1xuICAgIHRoaXMuZW5xdWV1ZVRpbGVzKGZyYW1lU3RhdGUsIHJlbmRlckV4dGVudCwgeiwgdGlsZXNCeVosIDApO1xuICAgIGlmIChwcmVsb2FkID4gMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZVRpbGVzKFxuICAgICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgICAgcmVuZGVyRXh0ZW50LFxuICAgICAgICAgIHogLSAxLFxuICAgICAgICAgIHRpbGVzQnlaLFxuICAgICAgICAgIHByZWxvYWQgLSAxLFxuICAgICAgICApO1xuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgaWYgKCEoeiBpbiB0aWxlc0J5WikpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0IDI6IEZpbmQgYWx0IHRpbGVzIGZvciB0aG9zZSB0aGF0IGFyZSBub3QgeWV0IGxvYWRlZFxuICAgICAqL1xuXG4gICAgY29uc3QgdWlkID0gZ2V0VWlkKHRoaXMpO1xuICAgIGNvbnN0IHRpbWUgPSBmcmFtZVN0YXRlLnRpbWU7XG5cbiAgICAvLyBsb29rIGZvciBjYWNoZWQgdGlsZXMgdG8gdXNlIGlmIGEgdGFyZ2V0IHRpbGUgaXMgbm90IHJlYWR5XG4gICAgZm9yIChjb25zdCB0aWxlIG9mIHRpbGVzQnlaW3pdKSB7XG4gICAgICBjb25zdCB0aWxlU3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoXG4gICAgICAgICh0aWxlIGluc3RhbmNlb2YgUmVwcm9qVGlsZSB8fCB0aWxlIGluc3RhbmNlb2YgUmVwcm9qRGF0YVRpbGUpICYmXG4gICAgICAgIHRpbGVTdGF0ZSA9PT0gVGlsZVN0YXRlLkVNUFRZXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0aWxlQ29vcmQgPSB0aWxlLnRpbGVDb29yZDtcblxuICAgICAgaWYgKHRpbGVTdGF0ZSA9PT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICBjb25zdCBhbHBoYSA9IHRpbGUuZ2V0QWxwaGEodWlkLCB0aW1lKTtcbiAgICAgICAgaWYgKGFscGhhID09PSAxKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZCB0byBsb29rIGZvciBhbHQgdGlsZXNcbiAgICAgICAgICB0aWxlLmVuZFRyYW5zaXRpb24odWlkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgICBjb25zdCBoYXNTdGFsZVRpbGUgPSB0aGlzLmZpbmRTdGFsZVRpbGVfKHRpbGVDb29yZCwgdGlsZXNCeVopO1xuICAgICAgaWYgKGhhc1N0YWxlVGlsZSkge1xuICAgICAgICAvLyB1c2UgdGhlIHN0YWxlIHRpbGUgYmVmb3JlIHRoZSBuZXcgdGlsZSdzIHRyYW5zaXRpb24gaGFzIGNvbXBsZXRlZFxuICAgICAgICByZW1vdmVUaWxlRnJvbUxvb2t1cCh0aWxlc0J5WiwgdGlsZSwgeik7XG4gICAgICAgIGZyYW1lU3RhdGUuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXJzdCBsb29rIGZvciBjaGlsZCB0aWxlcyAoYXQgeiArIDEpXG4gICAgICBjb25zdCBjb3ZlcmVkQnlDaGlsZHJlbiA9IHRoaXMuZmluZEFsdFRpbGVzXyhcbiAgICAgICAgdGlsZUdyaWQsXG4gICAgICAgIHRpbGVDb29yZCxcbiAgICAgICAgeiArIDEsXG4gICAgICAgIHRpbGVzQnlaLFxuICAgICAgKTtcblxuICAgICAgaWYgKGNvdmVyZWRCeUNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXh0IGxvb2sgZm9yIHBhcmVudCB0aWxlc1xuICAgICAgY29uc3QgbWluWm9vbSA9IHRpbGVHcmlkLmdldE1pblpvb20oKTtcbiAgICAgIGZvciAobGV0IHBhcmVudFogPSB6IC0gMTsgcGFyZW50WiA+PSBtaW5ab29tOyAtLXBhcmVudFopIHtcbiAgICAgICAgY29uc3QgY292ZXJlZEJ5UGFyZW50ID0gdGhpcy5maW5kQWx0VGlsZXNfKFxuICAgICAgICAgIHRpbGVHcmlkLFxuICAgICAgICAgIHRpbGVDb29yZCxcbiAgICAgICAgICBwYXJlbnRaLFxuICAgICAgICAgIHRpbGVzQnlaLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChjb3ZlcmVkQnlQYXJlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnQgMzogUmVuZGVyIGxvYWRlZCB0aWxlc1xuICAgICAqL1xuXG4gICAgY29uc3QgY2FudmFzU2NhbGUgPVxuICAgICAgKCh0aWxlUmVzb2x1dGlvbiAvIHZpZXdSZXNvbHV0aW9uKSAqIHBpeGVsUmF0aW8pIC8gdGlsZVBpeGVsUmF0aW87XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRSZW5kZXJDb250ZXh0KGZyYW1lU3RhdGUpO1xuXG4gICAgLy8gc2V0IHNjYWxlIHRyYW5zZm9ybSBmb3IgY2FsY3VsYXRpbmcgdGlsZSBwb3NpdGlvbnMgb24gdGhlIGNhbnZhc1xuICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICB0aGlzLnRlbXBUcmFuc2Zvcm0sXG4gICAgICB3aWR0aCAvIDIsXG4gICAgICBoZWlnaHQgLyAyLFxuICAgICAgY2FudmFzU2NhbGUsXG4gICAgICBjYW52YXNTY2FsZSxcbiAgICAgIDAsXG4gICAgICAtd2lkdGggLyAyLFxuICAgICAgLWhlaWdodCAvIDIsXG4gICAgKTtcblxuICAgIGlmIChsYXllclN0YXRlLmV4dGVudCkge1xuICAgICAgdGhpcy5jbGlwVW5yb3RhdGVkKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyRXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIXRpbGVTb3VyY2UuZ2V0SW50ZXJwb2xhdGUoKSkge1xuICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZVJlbmRlcihjb250ZXh0LCBmcmFtZVN0YXRlKTtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCB6cyA9IE9iamVjdC5rZXlzKHRpbGVzQnlaKS5tYXAoTnVtYmVyKTtcbiAgICB6cy5zb3J0KGFzY2VuZGluZyk7XG5cbiAgICBsZXQgY3VycmVudENsaXA7XG4gICAgY29uc3QgY2xpcHMgPSBbXTtcbiAgICBjb25zdCBjbGlwWnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0genMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRaID0genNbaV07XG4gICAgICBjb25zdCBjdXJyZW50VGlsZVBpeGVsU2l6ZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZVBpeGVsU2l6ZShcbiAgICAgICAgY3VycmVudFosXG4gICAgICAgIHBpeGVsUmF0aW8sXG4gICAgICAgIHByb2plY3Rpb24sXG4gICAgICApO1xuICAgICAgY29uc3QgY3VycmVudFJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKGN1cnJlbnRaKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IGN1cnJlbnRSZXNvbHV0aW9uIC8gdGlsZVJlc29sdXRpb247XG4gICAgICBjb25zdCBkeCA9IGN1cnJlbnRUaWxlUGl4ZWxTaXplWzBdICogY3VycmVudFNjYWxlICogY2FudmFzU2NhbGU7XG4gICAgICBjb25zdCBkeSA9IGN1cnJlbnRUaWxlUGl4ZWxTaXplWzFdICogY3VycmVudFNjYWxlICogY2FudmFzU2NhbGU7XG4gICAgICBjb25zdCBvcmlnaW5UaWxlQ29vcmQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFooXG4gICAgICAgIGdldFRvcExlZnQoY2FudmFzRXh0ZW50KSxcbiAgICAgICAgY3VycmVudFosXG4gICAgICApO1xuICAgICAgY29uc3Qgb3JpZ2luVGlsZUV4dGVudCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChvcmlnaW5UaWxlQ29vcmQpO1xuICAgICAgY29uc3Qgb3JpZ2luID0gYXBwbHlUcmFuc2Zvcm0odGhpcy50ZW1wVHJhbnNmb3JtLCBbXG4gICAgICAgICh0aWxlUGl4ZWxSYXRpbyAqIChvcmlnaW5UaWxlRXh0ZW50WzBdIC0gY2FudmFzRXh0ZW50WzBdKSkgL1xuICAgICAgICAgIHRpbGVSZXNvbHV0aW9uLFxuICAgICAgICAodGlsZVBpeGVsUmF0aW8gKiAoY2FudmFzRXh0ZW50WzNdIC0gb3JpZ2luVGlsZUV4dGVudFszXSkpIC9cbiAgICAgICAgICB0aWxlUmVzb2x1dGlvbixcbiAgICAgIF0pO1xuICAgICAgY29uc3QgdGlsZUd1dHRlciA9XG4gICAgICAgIHRpbGVQaXhlbFJhdGlvICogdGlsZVNvdXJjZS5nZXRHdXR0ZXJGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRpbGVzQnlaW2N1cnJlbnRaXSkge1xuICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpICE9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGlsZUNvb3JkID0gdGlsZS50aWxlQ29vcmQ7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGludGVnZXIgcG9zaXRpb25zIGFuZCBzaXplcyBzbyB0aGF0IHRpbGVzIGFsaWduXG4gICAgICAgIGNvbnN0IHhJbmRleCA9IG9yaWdpblRpbGVDb29yZFsxXSAtIHRpbGVDb29yZFsxXTtcbiAgICAgICAgY29uc3QgbmV4dFggPSBNYXRoLnJvdW5kKG9yaWdpblswXSAtICh4SW5kZXggLSAxKSAqIGR4KTtcbiAgICAgICAgY29uc3QgeUluZGV4ID0gb3JpZ2luVGlsZUNvb3JkWzJdIC0gdGlsZUNvb3JkWzJdO1xuICAgICAgICBjb25zdCBuZXh0WSA9IE1hdGgucm91bmQob3JpZ2luWzFdIC0gKHlJbmRleCAtIDEpICogZHkpO1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChvcmlnaW5bMF0gLSB4SW5kZXggKiBkeCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKG9yaWdpblsxXSAtIHlJbmRleCAqIGR5KTtcbiAgICAgICAgY29uc3QgdyA9IG5leHRYIC0geDtcbiAgICAgICAgY29uc3QgaCA9IG5leHRZIC0geTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHpzLmxlbmd0aCA9PT0gMTtcblxuICAgICAgICBsZXQgY29udGV4dFNhdmVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ2xpcCBtYXNrIGZvciByZWdpb25zIGluIHRoaXMgdGlsZSB0aGF0IGFscmVhZHkgZmlsbGVkIGJ5IGEgaGlnaGVyIHogdGlsZVxuICAgICAgICBjdXJyZW50Q2xpcCA9IFt4LCB5LCB4ICsgdywgeSwgeCArIHcsIHkgKyBoLCB4LCB5ICsgaF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNsaXBzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICBpZiAoIXRyYW5zaXRpb24gJiYgY3VycmVudFogPCBjbGlwWnNbaV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaXAgPSBjbGlwc1tpXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaW50ZXJzZWN0cyhcbiAgICAgICAgICAgICAgICBbeCwgeSwgeCArIHcsIHkgKyBoXSxcbiAgICAgICAgICAgICAgICBbY2xpcFswXSwgY2xpcFszXSwgY2xpcFs0XSwgY2xpcFs3XV0sXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoIWNvbnRleHRTYXZlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRTYXZlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2UgKG91dGVyIHJpbmcpIGZvciBjdXJyZW50IHRpbGVcbiAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY3VycmVudENsaXBbMF0sIGN1cnJlbnRDbGlwWzFdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbMl0sIGN1cnJlbnRDbGlwWzNdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbNF0sIGN1cnJlbnRDbGlwWzVdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbNl0sIGN1cnJlbnRDbGlwWzddKTtcbiAgICAgICAgICAgICAgLy8gY2xvY2t3aXNlIChpbm5lciByaW5nKSBmb3IgaGlnaGVyIHogdGlsZVxuICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjbGlwWzZdLCBjbGlwWzddKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFs0XSwgY2xpcFs1XSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbMl0sIGNsaXBbM10pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzBdLCBjbGlwWzFdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsaXBzLnB1c2goY3VycmVudENsaXApO1xuICAgICAgICBjbGlwWnMucHVzaChjdXJyZW50Wik7XG5cbiAgICAgICAgdGhpcy5kcmF3VGlsZSh0aWxlLCBmcmFtZVN0YXRlLCB4LCB5LCB3LCBoLCB0aWxlR3V0dGVyLCB0cmFuc2l0aW9uKTtcbiAgICAgICAgaWYgKGNvbnRleHRTYXZlZCkge1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy51bnNoaWZ0KHRpbGUpO1xuXG4gICAgICAgIC8vIFRPRE86IGRlY2lkZSBpZiB0aGlzIGlzIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLnVwZGF0ZVVzZWRUaWxlcyhmcmFtZVN0YXRlLnVzZWRUaWxlcywgdGlsZVNvdXJjZSwgdGlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uID0gc291cmNlUmV2aXNpb247XG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gPSB0aWxlUmVzb2x1dGlvbjtcbiAgICB0aGlzLmV4dGVudENoYW5nZWQgPVxuICAgICAgIXRoaXMucmVuZGVyZWRFeHRlbnRfIHx8ICFlcXVhbHModGhpcy5yZW5kZXJlZEV4dGVudF8sIGNhbnZhc0V4dGVudCk7XG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBjYW52YXNFeHRlbnQ7XG4gICAgdGhpcy5yZW5kZXJlZFBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMucmVuZGVyZWRQcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcblxuICAgIHRoaXMucG9zdFJlbmRlcih0aGlzLmNvbnRleHQsIGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKGxheWVyU3RhdGUuZXh0ZW50KSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSGVyZSB3ZSB1bmNvbmRpdGlvbmFsbHkgZXhwaXJlIHRoZSBzb3VyY2UgY2FjaGUgc2luY2UgdGhlIHJlbmRlcmVyIG1haW50YWluc1xuICAgICAqIGl0cyBvd24gY2FjaGUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbnN0IHBvc3RSZW5kZXJGdW5jdGlvbiA9IChtYXAsIGZyYW1lU3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgICBjb25zdCB3YW50ZWRUaWxlcyA9IGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV07XG4gICAgICBjb25zdCB0aWxlc0NvdW50ID0gd2FudGVkVGlsZXMgPyBPYmplY3Qua2V5cyh3YW50ZWRUaWxlcykubGVuZ3RoIDogMDtcbiAgICAgIHRoaXMudXBkYXRlQ2FjaGVTaXplKHRpbGVzQ291bnQpO1xuICAgICAgdGhpcy50aWxlQ2FjaGVfLmV4cGlyZUNhY2hlKCk7XG4gICAgfTtcblxuICAgIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucy5wdXNoKHBvc3RSZW5kZXJGdW5jdGlvbik7XG5cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSBjYWNoZSBzaXplIGlmIG5lZWRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlsZUNvdW50IE1pbmltdW0gbnVtYmVyIG9mIHRpbGVzIG5lZWRlZC5cbiAgICovXG4gIHVwZGF0ZUNhY2hlU2l6ZSh0aWxlQ291bnQpIHtcbiAgICB0aGlzLnRpbGVDYWNoZV8uaGlnaFdhdGVyTWFyayA9IE1hdGgubWF4KFxuICAgICAgdGhpcy50aWxlQ2FjaGVfLmhpZ2hXYXRlck1hcmssXG4gICAgICB0aWxlQ291bnQgKiAyLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTGVmdCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVG9wIG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdyBXaWR0aCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIFRpbGUgZ3V0dGVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zaXRpb24gQXBwbHkgYW4gYWxwaGEgdHJhbnNpdGlvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZHJhd1RpbGUodGlsZSwgZnJhbWVTdGF0ZSwgeCwgeSwgdywgaCwgZ3V0dGVyLCB0cmFuc2l0aW9uKSB7XG4gICAgbGV0IGltYWdlO1xuICAgIGlmICh0aWxlIGluc3RhbmNlb2YgRGF0YVRpbGUpIHtcbiAgICAgIGltYWdlID0gYXNJbWFnZUxpa2UodGlsZS5nZXREYXRhKCkpO1xuICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmluZyBhcnJheSBkYXRhIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGltYWdlID0gdGhpcy5nZXRUaWxlSW1hZ2UoXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vSW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0UmVuZGVyQ29udGV4dChmcmFtZVN0YXRlKTtcbiAgICBjb25zdCB1aWQgPSBnZXRVaWQodGhpcyk7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheVtmcmFtZVN0YXRlLmxheWVySW5kZXhdO1xuICAgIGNvbnN0IGFscGhhID1cbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSAqXG4gICAgICAodHJhbnNpdGlvbiA/IHRpbGUuZ2V0QWxwaGEodWlkLCBmcmFtZVN0YXRlLnRpbWUpIDogMSk7XG4gICAgY29uc3QgYWxwaGFDaGFuZ2VkID0gYWxwaGEgIT09IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgaWYgKGFscGhhQ2hhbmdlZCkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgaW1hZ2UsXG4gICAgICBndXR0ZXIsXG4gICAgICBndXR0ZXIsXG4gICAgICBpbWFnZS53aWR0aCAtIDIgKiBndXR0ZXIsXG4gICAgICBpbWFnZS5oZWlnaHQgLSAyICogZ3V0dGVyLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3LFxuICAgICAgaCxcbiAgICApO1xuXG4gICAgaWYgKGFscGhhQ2hhbmdlZCkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChhbHBoYSAhPT0gbGF5ZXJTdGF0ZS5vcGFjaXR5KSB7XG4gICAgICBmcmFtZVN0YXRlLmFuaW1hdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdGlsZS5lbmRUcmFuc2l0aW9uKHVpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZVxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuY2FudmFzIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGZyb20gYSB0aWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gSW1hZ2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGVJbWFnZSh0aWxlKSB7XG4gICAgcmV0dXJuIHRpbGUuZ2V0SW1hZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PHN0cmluZywgYm9vbGVhbj4+fSB1c2VkVGlsZXMgVXNlZCB0aWxlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vVGlsZS5qcycpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlVXNlZFRpbGVzKHVzZWRUaWxlcywgdGlsZVNvdXJjZSwgdGlsZSkge1xuICAgIC8vIEZJWE1FIHNob3VsZCB3ZSB1c2UgdGlsZXNUb0RyYXdCeVogaW5zdGVhZD9cbiAgICBjb25zdCB0aWxlU291cmNlS2V5ID0gZ2V0VWlkKHRpbGVTb3VyY2UpO1xuICAgIGlmICghKHRpbGVTb3VyY2VLZXkgaW4gdXNlZFRpbGVzKSkge1xuICAgICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldID0ge307XG4gICAgfVxuICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XVt0aWxlLmdldEtleSgpXSA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1RpbGVcbiAqL1xuaW1wb3J0IEJhc2VUaWxlTGF5ZXIgZnJvbSAnLi9CYXNlVGlsZS5qcyc7XG5pbXBvcnQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgZnJvbSAnLi4vcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRm9yIGxheWVyIHNvdXJjZXMgdGhhdCBwcm92aWRlIHByZS1yZW5kZXJlZCwgdGlsZWQgaW1hZ2VzIGluIGdyaWRzIHRoYXQgYXJlXG4gKiBvcmdhbml6ZWQgYnkgem9vbSBsZXZlbHMgZm9yIHNwZWNpZmljIHJlc29sdXRpb25zLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gW1RpbGVTb3VyY2VUeXBlPWltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHRdXG4gKiBAZXh0ZW5kcyBCYXNlVGlsZUxheWVyPFRpbGVTb3VyY2VUeXBlLCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcj5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVGlsZUxheWVyIGV4dGVuZHMgQmFzZVRpbGVMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQmFzZVRpbGUuanNcIikuT3B0aW9uczxUaWxlU291cmNlVHlwZT59IFtvcHRpb25zXSBUaWxlIGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gbmV3IENhbnZhc1RpbGVMYXllclJlbmRlcmVyKHRoaXMsIHtcbiAgICAgIGNhY2hlU2l6ZTogdGhpcy5nZXRDYWNoZVNpemUoKSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlTGF5ZXI7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgc3RhcnRzIGxvYWRpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGUuVGlsZVNvdXJjZUV2ZW50I3RpbGVsb2Fkc3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURTVEFSVDogJ3RpbGVsb2Fkc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgZmluaXNoZXMgbG9hZGluZywgZWl0aGVyIHdoZW4gaXRzIGRhdGEgaXMgbG9hZGVkLFxuICAgKiBvciB3aGVuIGxvYWRpbmcgd2FzIGFib3J0ZWQgYmVjYXVzZSB0aGUgdGlsZSBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BREVORDogJ3RpbGVsb2FkZW5kJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGlmIHRpbGUgbG9hZGluZyByZXN1bHRzIGluIGFuIGVycm9yLiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgdGhlXG4gICAqIHJpZ2h0IHBsYWNlIHRvIHJlLWZldGNoIHRpbGVzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC9JbWFnZVRpbGV+SW1hZ2VUaWxlI2xvYWR9XG4gICAqIGZvciBkZXRhaWxzLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FERVJST1I6ICd0aWxlbG9hZGVycm9yJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeyd0aWxlbG9hZHN0YXJ0J3wndGlsZWxvYWRlbmQnfCd0aWxlbG9hZGVycm9yJ30gVGlsZVNvdXJjZUV2ZW50VHlwZXNcbiAqL1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvU291cmNlXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3VuZGVmaW5lZCcgfCAnbG9hZGluZycgfCAncmVhZHknIHwgJ2Vycm9yJ30gU3RhdGVcbiAqIFN0YXRlIG9mIHRoZSBzb3VyY2UsIG9uZSBvZiAndW5kZWZpbmVkJywgJ2xvYWRpbmcnLCAncmVhZHknIG9yICdlcnJvcicuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBhbmQgcmV0dXJucyBhIHN0cmluZyBvclxuICogYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgc291cmNlIGF0dHJpYnV0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50KTogKHN0cmluZ3xBcnJheTxzdHJpbmc+KX0gQXR0cmlidXRpb25cbiAqL1xuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYXR0cmlidXRpb24gaW5mb3JtYXRpb24gZm9yIGRhdGEgc291cmNlcy5cbiAqXG4gKiBJdCByZXByZXNlbnRzIGVpdGhlclxuICogKiBhIHNpbXBsZSBzdHJpbmcgKGUuZy4gYCdcdTAwQTkgQWNtZSBJbmMuJ2ApXG4gKiAqIGFuIGFycmF5IG9mIHNpbXBsZSBzdHJpbmdzIChlLmcuIGBbJ1x1MDBBOSBBY21lIEluYy4nLCAnXHUwMEE5IEJhY21lIEluYy4nXWApXG4gKiAqIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgKHtAbGluayBtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn0pXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xBcnJheTxzdHJpbmc+fEF0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbkxpa2VcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi4gRGVmYXVsdCBpcyB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX0gW3N0YXRlPSdyZWFkeSddIFN0YXRlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXBYLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9ZmFsc2VdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiB0aGUgbmVhcmVzdCBuZWlnaGJvciBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXJ9IHNvdXJjZXMuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlIGNoYW5nZXMuXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU291cmNlIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgU291cmNlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/QXR0cmlidXRpb259XG4gICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNfID0gYWRhcHRBdHRyaWJ1dGlvbnMob3B0aW9ucy5hdHRyaWJ1dGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXyA9IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUgPz8gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgc291cmNlIGlzIGN1cnJlbnRseSBsb2FkaW5nIGRhdGEuIFNvdXJjZXMgdGhhdCBkZWZlciBsb2FkaW5nIHRvIHRoZVxuICAgICAqIG1hcCdzIHRpbGUgcXVldWUgbmV2ZXIgc2V0IHRoaXMgdG8gYHRydWVgLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZV8gPSBvcHRpb25zLnN0YXRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0YXRlIDogJ3JlYWR5JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy53cmFwWF8gPSBvcHRpb25zLndyYXBYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBYIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVfID0gISFvcHRpb25zLmludGVycG9sYXRlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlZpZXdPcHRpb25zKTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMudmlld1Jlc29sdmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oRXJyb3IpOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy52aWV3UmVqZWN0b3IgPSBudWxsO1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlZpZXdPcHRpb25zPn1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdQcm9taXNlXyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNlbGYudmlld1Jlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIHNlbGYudmlld1JlamVjdG9yID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXR0cmlidXRpb24gZnVuY3Rpb24gZm9yIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4gez9BdHRyaWJ1dGlvbn0gQXR0cmlidXRpb24gZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF0dHJpYnV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByb2plY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8bnVsbH0gUHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uXCIpLmRlZmF1bHR9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFJlc29sdXRpb25zLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMocHJvamVjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3T3B0aW9ucz59IEEgcHJvbWlzZSBmb3Igdmlldy1yZWxhdGVkIHByb3BlcnRpZXMuXG4gICAqL1xuICBnZXRWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdQcm9taXNlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UsIHNlZSB7QGxpbmsgaW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IGZvciBwb3NzaWJsZSBzdGF0ZXMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBTdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBXcmFwIFguXG4gICAqL1xuICBnZXRXcmFwWCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwWF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdoZW4gcmVzYW1wbGluZy5cbiAgICovXG4gIGdldEludGVycG9sYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvdXJjZS4gVGhlIHNvdXJjZSB3aWxsIGJlIGNsZWFyZWQsIGFuZCBkYXRhIGZyb20gdGhlIHNlcnZlciB3aWxsIGJlIHJlbG9hZGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXR0cmlidXRpb25zIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7QXR0cmlidXRpb25MaWtlfHVuZGVmaW5lZH0gYXR0cmlidXRpb25zIEF0dHJpYnV0aW9ucy5cbiAgICogICAgIENhbiBiZSBwYXNzZWQgYXMgYHN0cmluZ2AsIGBBcnJheTxzdHJpbmc+YCwge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufSxcbiAgICogICAgIG9yIGB1bmRlZmluZWRgLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBdHRyaWJ1dGlvbnMoYXR0cmlidXRpb25zKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNfID0gYWRhcHRBdHRyaWJ1dGlvbnMoYXR0cmlidXRpb25zKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbi8qKlxuICogVHVybnMgdGhlIGF0dHJpYnV0aW9ucyBvcHRpb24gaW50byBhbiBhdHRyaWJ1dGlvbnMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0F0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9uTGlrZSBUaGUgYXR0cmlidXRpb24gb3B0aW9uLlxuICogQHJldHVybiB7QXR0cmlidXRpb258bnVsbH0gQW4gYXR0cmlidXRpb24gZnVuY3Rpb24gKG9yIG51bGwpLlxuICovXG5mdW5jdGlvbiBhZGFwdEF0dHJpYnV0aW9ucyhhdHRyaWJ1dGlvbkxpa2UpIHtcbiAgaWYgKCFhdHRyaWJ1dGlvbkxpa2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIGF0dHJpYnV0aW9uTGlrZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhdHRyaWJ1dGlvbkxpa2U7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9uTGlrZSkpIHtcbiAgICBhdHRyaWJ1dGlvbkxpa2UgPSBbYXR0cmlidXRpb25MaWtlXTtcbiAgfVxuICByZXR1cm4gKGZyYW1lU3RhdGUpID0+IGF0dHJpYnV0aW9uTGlrZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU291cmNlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9UaWxlR3JpZFxuICovXG5pbXBvcnQgVGlsZVJhbmdlLCB7XG4gIGNyZWF0ZU9yVXBkYXRlIGFzIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlLFxufSBmcm9tICcuLi9UaWxlUmFuZ2UuanMnO1xuaW1wb3J0IHtERUZBVUxUX1RJTEVfU0laRX0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjZWlsLCBjbGFtcCwgZmxvb3J9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZ2V0VG9wTGVmdH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmR9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lYXJSaW5nfSBmcm9tICcuLi9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyc7XG5pbXBvcnQge2lzU29ydGVkLCBsaW5lYXJGaW5kTmVhcmVzdH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAqL1xuY29uc3QgdG1wVGlsZUNvb3JkID0gWzAsIDAsIDBdO1xuXG4vKipcbiAqIE51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cyB0byBjb25zaWRlciBpbiBpbnRlZ2VyIHZhbHVlcyB3aGVuIHJvdW5kaW5nLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgREVDSU1BTFMgPSA1O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50IGZvciB0aGUgdGlsZSBncmlkLiBObyB0aWxlcyBvdXRzaWRlIHRoaXNcbiAqIGV4dGVudCB3aWxsIGJlIHJlcXVlc3RlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IHNvdXJjZXMuIFdoZW4gbm8gYG9yaWdpbmAgb3JcbiAqIGBvcmlnaW5zYCBhcmUgY29uZmlndXJlZCwgdGhlIGBvcmlnaW5gIHdpbGwgYmUgc2V0IHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW29yaWdpbl0gVGhlIHRpbGUgZ3JpZCBvcmlnaW4sIGkuZS4gd2hlcmUgdGhlIGB4YFxuICogYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKS4gVGlsZSBjb29yZGluYXRlcyBpbmNyZWFzZSBsZWZ0IHRvIHJpZ2h0IGFuZCBkb3dud2FyZHMuIElmIG5vdFxuICogc3BlY2lmaWVkLCBgZXh0ZW50YCBvciBgb3JpZ2luc2AgbXVzdCBiZSBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gW29yaWdpbnNdIFRpbGUgZ3JpZCBvcmlnaW5zLCBpLmUuIHdoZXJlXG4gKiB0aGUgYHhgIGFuZCBgeWAgYXhlcyBtZWV0IChgW3osIDAsIDBdYCksIGZvciBlYWNoIHpvb20gbGV2ZWwuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIG9yaWdpbi4gVGlsZSBjb29yZGluYXRlcyBpbmNyZWFzZSBsZWZ0IHRvIHJpZ2h0IGFuZCBkb3dud2FyZHMuIElmIG5vdCBzcGVjaWZpZWQsIGBleHRlbnRgIG9yXG4gKiBgb3JpZ2luYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHshQXJyYXk8bnVtYmVyPn0gcmVzb2x1dGlvbnMgUmVzb2x1dGlvbnMuIFRoZSBhcnJheSBpbmRleCBvZiBlYWNoIHJlc29sdXRpb24gbmVlZHNcbiAqIHRvIG1hdGNoIHRoZSB6b29tIGxldmVsLiBUaGlzIG1lYW5zIHRoYXQgZXZlbiBpZiBhIGBtaW5ab29tYCBpcyBjb25maWd1cmVkLCB0aGUgcmVzb2x1dGlvbnNcbiAqIGFycmF5IHdpbGwgaGF2ZSBhIGxlbmd0aCBvZiBgbWF4Wm9vbSArIDFgLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemU+fSBbc2l6ZXNdIE51bWJlciBvZiB0aWxlIHJvd3MgYW5kIGNvbHVtbnNcbiAqIG9mIHRoZSBncmlkIGZvciBlYWNoIHpvb20gbGV2ZWwuIElmIHNwZWNpZmllZCB0aGUgdmFsdWVzXG4gKiBkZWZpbmUgZWFjaCB6b29tIGxldmVsJ3MgZXh0ZW50IHRvZ2V0aGVyIHdpdGggdGhlIGBvcmlnaW5gIG9yIGBvcmlnaW5zYC5cbiAqIEEgZ3JpZCBgZXh0ZW50YCBjYW4gYmUgY29uZmlndXJlZCBpbiBhZGRpdGlvbiwgYW5kIHdpbGwgZnVydGhlciBsaW1pdCB0aGUgZXh0ZW50XG4gKiBmb3Igd2hpY2ggdGlsZSByZXF1ZXN0cyBhcmUgbWFkZSBieSBzb3VyY2VzLiBJZiB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mXG4gKiBhbiBleHRlbnQgaXMgdXNlZCBhcyBgb3JpZ2luYCBvciBgb3JpZ2luc2AsIHRoZW4gdGhlIGB5YCB2YWx1ZSBtdXN0IGJlXG4gKiBuZWdhdGl2ZSBiZWNhdXNlIE9wZW5MYXllcnMgdGlsZSBjb29yZGluYXRlcyB1c2UgdGhlIHRvcCBsZWZ0IGFzIHRoZSBvcmlnaW4uXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplLlxuICogRGVmYXVsdCBpcyBgWzI1NiwgMjU2XWAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemU+fSBbdGlsZVNpemVzXSBUaWxlIHNpemVzLiBJZiBnaXZlbiwgdGhlIGFycmF5IGxlbmd0aFxuICogc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS4gZWFjaCByZXNvbHV0aW9uIGNhbiBoYXZlIGEgZGlmZmVyZW50XG4gKiB0aWxlIHNpemUuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciBzZXR0aW5nIHRoZSBncmlkIHBhdHRlcm4gZm9yIHNvdXJjZXMgYWNjZXNzaW5nIHRpbGVkLWltYWdlXG4gKiBzZXJ2ZXJzLlxuICogQGFwaVxuICovXG5jbGFzcyBUaWxlR3JpZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgVGlsZSBncmlkIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5ab29tID0gb3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblpvb20gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zO1xuICAgIGFzc2VydChcbiAgICAgIGlzU29ydGVkKFxuICAgICAgICB0aGlzLnJlc29sdXRpb25zXyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhIEZpcnN0IHJlc29sdXRpb25cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGIgU2Vjb25kIHJlc29sdXRpb25cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBDb21wYXJpc29uIHJlc3VsdFxuICAgICAgICAgKi9cbiAgICAgICAgKGEsIGIpID0+IGIgLSBhLFxuICAgICAgICB0cnVlLFxuICAgICAgKSxcbiAgICAgICdgcmVzb2x1dGlvbnNgIG11c3QgYmUgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXInLFxuICAgICk7XG5cbiAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYSBjb25zaXN0ZW50IHpvb20gZmFjdG9yIGFuZCBvcmlnaW5cbiAgICBsZXQgem9vbUZhY3RvcjtcbiAgICBpZiAoIW9wdGlvbnMub3JpZ2lucykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgaWYgKCF6b29tRmFjdG9yKSB7XG4gICAgICAgICAgem9vbUZhY3RvciA9IHRoaXMucmVzb2x1dGlvbnNfW2ldIC8gdGhpcy5yZXNvbHV0aW9uc19baSArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXSAhPT0gem9vbUZhY3Rvcikge1xuICAgICAgICAgICAgem9vbUZhY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHpvb21GYWN0b3I7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFpvb20gPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gb3B0aW9ucy5vcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3JpZ2luIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5zXyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMub3JpZ2lucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9yaWdpbnNfID0gb3B0aW9ucy5vcmlnaW5zO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0aGlzLm9yaWdpbnNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAgICdOdW1iZXIgb2YgYG9yaWdpbnNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWwnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbnQgPSBvcHRpb25zLmV4dGVudDtcblxuICAgIGlmIChleHRlbnQgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSB7XG4gICAgICB0aGlzLm9yaWdpbl8gPSBnZXRUb3BMZWZ0KGV4dGVudCk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KFxuICAgICAgKCF0aGlzLm9yaWdpbl8gJiYgdGhpcy5vcmlnaW5zXykgfHwgKHRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXyksXG4gICAgICAnRWl0aGVyIGBvcmlnaW5gIG9yIGBvcmlnaW5zYCBtdXN0IGJlIGNvbmZpZ3VyZWQsIG5ldmVyIGJvdGgnLFxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVTaXplc18gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLnRpbGVTaXplcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRpbGVTaXplc18gPSBvcHRpb25zLnRpbGVTaXplcztcbiAgICAgIGFzc2VydChcbiAgICAgICAgdGhpcy50aWxlU2l6ZXNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAgICdOdW1iZXIgb2YgYHRpbGVTaXplc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbCcsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50aWxlU2l6ZV8gPVxuICAgICAgb3B0aW9ucy50aWxlU2l6ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy50aWxlU2l6ZVxuICAgICAgICA6ICF0aGlzLnRpbGVTaXplc19cbiAgICAgICAgICA/IERFRkFVTFRfVElMRV9TSVpFXG4gICAgICAgICAgOiBudWxsO1xuICAgIGFzc2VydChcbiAgICAgICghdGhpcy50aWxlU2l6ZV8gJiYgdGhpcy50aWxlU2l6ZXNfKSB8fFxuICAgICAgICAodGhpcy50aWxlU2l6ZV8gJiYgIXRoaXMudGlsZVNpemVzXyksXG4gICAgICAnRWl0aGVyIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoJyxcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBleHRlbnQgIT09IHVuZGVmaW5lZCA/IGV4dGVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMudG1wU2l6ZV8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMudG1wRXh0ZW50XyA9IFswLCAwLCAwLCAwXTtcblxuICAgIGlmIChvcHRpb25zLnNpemVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gb3B0aW9ucy5zaXplcy5tYXAoKHNpemUsIHopID0+IHtcbiAgICAgICAgY29uc3QgdGlsZVJhbmdlID0gbmV3IFRpbGVSYW5nZShcbiAgICAgICAgICBNYXRoLm1pbigwLCBzaXplWzBdKSxcbiAgICAgICAgICBNYXRoLm1heChzaXplWzBdIC0gMSwgLTEpLFxuICAgICAgICAgIE1hdGgubWluKDAsIHNpemVbMV0pLFxuICAgICAgICAgIE1hdGgubWF4KHNpemVbMV0gLSAxLCAtMSksXG4gICAgICAgICk7XG4gICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICBjb25zdCByZXN0cmljdGVkVGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gICAgICAgICAgdGlsZVJhbmdlLm1pblggPSBNYXRoLm1heChyZXN0cmljdGVkVGlsZVJhbmdlLm1pblgsIHRpbGVSYW5nZS5taW5YKTtcbiAgICAgICAgICB0aWxlUmFuZ2UubWF4WCA9IE1hdGgubWluKHJlc3RyaWN0ZWRUaWxlUmFuZ2UubWF4WCwgdGlsZVJhbmdlLm1heFgpO1xuICAgICAgICAgIHRpbGVSYW5nZS5taW5ZID0gTWF0aC5tYXgocmVzdHJpY3RlZFRpbGVSYW5nZS5taW5ZLCB0aWxlUmFuZ2UubWluWSk7XG4gICAgICAgICAgdGlsZVJhbmdlLm1heFkgPSBNYXRoLm1pbihyZXN0cmljdGVkVGlsZVJhbmdlLm1heFksIHRpbGVSYW5nZS5tYXhZKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZVJhbmdlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChleHRlbnQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdpdGggZWFjaCB0aWxlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gZXh0ZW50IGFuZCB6b29tIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkKTogdm9pZH0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2hUaWxlQ29vcmQoZXh0ZW50LCB6b29tLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHpvb20pO1xuICAgIGZvciAobGV0IGkgPSB0aWxlUmFuZ2UubWluWCwgaWkgPSB0aWxlUmFuZ2UubWF4WDsgaSA8PSBpaTsgKytpKSB7XG4gICAgICBmb3IgKGxldCBqID0gdGlsZVJhbmdlLm1pblksIGpqID0gdGlsZVJhbmdlLm1heFk7IGogPD0gamo7ICsraikge1xuICAgICAgICBjYWxsYmFjayhbem9vbSwgaSwgal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGNhbGxiYWNrIENhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBbdGVtcFRpbGVSYW5nZV0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0IG9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbdGVtcEV4dGVudF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDYWxsYmFjayBzdWNjZWVkZWQuXG4gICAqL1xuICBmb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlKFxuICAgIHRpbGVDb29yZCxcbiAgICBjYWxsYmFjayxcbiAgICB0ZW1wVGlsZVJhbmdlLFxuICAgIHRlbXBFeHRlbnQsXG4gICkge1xuICAgIGxldCB0aWxlUmFuZ2UsIHgsIHk7XG4gICAgbGV0IHRpbGVDb29yZEV4dGVudCA9IG51bGw7XG4gICAgbGV0IHogPSB0aWxlQ29vcmRbMF0gLSAxO1xuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICB4ID0gdGlsZUNvb3JkWzFdO1xuICAgICAgeSA9IHRpbGVDb29yZFsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0ZW1wRXh0ZW50KTtcbiAgICB9XG4gICAgd2hpbGUgKHogPj0gdGhpcy5taW5ab29tKSB7XG4gICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkICYmIHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4ID0gTWF0aC5mbG9vcih4IC8gMik7XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHkgLyAyKTtcbiAgICAgICAgdGlsZVJhbmdlID0gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoeCwgeCwgeSwgeSwgdGVtcFRpbGVSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgICAgdGlsZUNvb3JkRXh0ZW50LFxuICAgICAgICAgIHosXG4gICAgICAgICAgdGVtcFRpbGVSYW5nZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayh6LCB0aWxlUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLS16O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLCBpZiBpdCB3YXMgY29uZmlndXJlZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGdyaWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4IHpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4Wm9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGdyaWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluIHpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWm9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbiBmb3IgdGhlIGdyaWQgYXQgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBPcmlnaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9yaWdpbih6KSB7XG4gICAgaWYgKHRoaXMub3JpZ2luXykge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luc19bel07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb24oeikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zX1t6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgcmVzb2x1dGlvbnMgZm9yIHRoZSB0aWxlIGdyaWQuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJlc29sdXRpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBbdGVtcFRpbGVSYW5nZV0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0IG9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbdGVtcEV4dGVudF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UodGlsZUNvb3JkLCB0ZW1wVGlsZVJhbmdlLCB0ZW1wRXh0ZW50KSB7XG4gICAgaWYgKHRpbGVDb29yZFswXSA8IHRoaXMubWF4Wm9vbSkge1xuICAgICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICAgICAgY29uc3QgbWluWCA9IHRpbGVDb29yZFsxXSAqIDI7XG4gICAgICAgIGNvbnN0IG1pblkgPSB0aWxlQ29vcmRbMl0gKiAyO1xuICAgICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoXG4gICAgICAgICAgbWluWCxcbiAgICAgICAgICBtaW5YICsgMSxcbiAgICAgICAgICBtaW5ZLFxuICAgICAgICAgIG1pblkgKyAxLFxuICAgICAgICAgIHRlbXBUaWxlUmFuZ2UsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgICAgdGlsZUNvb3JkLFxuICAgICAgICB0ZW1wRXh0ZW50IHx8IHRoaXMudG1wRXh0ZW50XyxcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICB0aWxlQ29vcmRFeHRlbnQsXG4gICAgICAgIHRpbGVDb29yZFswXSArIDEsXG4gICAgICAgIHRlbXBUaWxlUmFuZ2UsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gW3RlbXBUaWxlUmFuZ2VdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fG51bGx9IFRpbGUgcmFuZ2UuXG4gICAqL1xuICBnZXRUaWxlUmFuZ2VGb3JUaWxlQ29vcmRBbmRaKHRpbGVDb29yZCwgeiwgdGVtcFRpbGVSYW5nZSkge1xuICAgIGlmICh6ID4gdGhpcy5tYXhab29tIHx8IHogPCB0aGlzLm1pblpvb20pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbGVDb29yZFogPSB0aWxlQ29vcmRbMF07XG4gICAgY29uc3QgdGlsZUNvb3JkWCA9IHRpbGVDb29yZFsxXTtcbiAgICBjb25zdCB0aWxlQ29vcmRZID0gdGlsZUNvb3JkWzJdO1xuXG4gICAgaWYgKHogPT09IHRpbGVDb29yZFopIHtcbiAgICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShcbiAgICAgICAgdGlsZUNvb3JkWCxcbiAgICAgICAgdGlsZUNvb3JkWSxcbiAgICAgICAgdGlsZUNvb3JkWCxcbiAgICAgICAgdGlsZUNvb3JkWSxcbiAgICAgICAgdGVtcFRpbGVSYW5nZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8pIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgucG93KHRoaXMuem9vbUZhY3Rvcl8sIHogLSB0aWxlQ29vcmRaKTtcbiAgICAgIGNvbnN0IG1pblggPSBNYXRoLmZsb29yKHRpbGVDb29yZFggKiBmYWN0b3IpO1xuICAgICAgY29uc3QgbWluWSA9IE1hdGguZmxvb3IodGlsZUNvb3JkWSAqIGZhY3Rvcik7XG4gICAgICBpZiAoeiA8IHRpbGVDb29yZFopIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1pblgsIG1pblksIG1pblksIHRlbXBUaWxlUmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXhYID0gTWF0aC5mbG9vcihmYWN0b3IgKiAodGlsZUNvb3JkWCArIDEpKSAtIDE7XG4gICAgICBjb25zdCBtYXhZID0gTWF0aC5mbG9vcihmYWN0b3IgKiAodGlsZUNvb3JkWSArIDEpKSAtIDE7XG4gICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGVtcFRpbGVSYW5nZSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0aGlzLnRtcEV4dGVudF8pO1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFoodGlsZUNvb3JkRXh0ZW50LCB6LCB0ZW1wVGlsZVJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0aWxlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gZXh0ZW50IGFuZCBpbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBbdGVtcFRpbGVSYW5nZV0gVGVtcG9yYXJ5IHRpbGUgcmFuZ2Ugb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gVGlsZSByYW5nZS5cbiAgICovXG4gIGdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6LCB0ZW1wVGlsZVJhbmdlKSB7XG4gICAgdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKGV4dGVudFswXSwgZXh0ZW50WzNdLCB6LCBmYWxzZSwgdG1wVGlsZUNvb3JkKTtcbiAgICBjb25zdCBtaW5YID0gdG1wVGlsZUNvb3JkWzFdO1xuICAgIGNvbnN0IG1pblkgPSB0bXBUaWxlQ29vcmRbMl07XG4gICAgdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKGV4dGVudFsyXSwgZXh0ZW50WzFdLCB6LCB0cnVlLCB0bXBUaWxlQ29vcmQpO1xuICAgIGNvbnN0IG1heFggPSB0bXBUaWxlQ29vcmRbMV07XG4gICAgY29uc3QgbWF4WSA9IHRtcFRpbGVDb29yZFsyXTtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGVtcFRpbGVSYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRpbGUgY2VudGVyLlxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGVDb29yZCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHRpbGVDb29yZFswXSk7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUodGlsZUNvb3JkWzBdKSwgdGhpcy50bXBTaXplXyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG9yaWdpblswXSArICh0aWxlQ29vcmRbMV0gKyAwLjUpICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uLFxuICAgICAgb3JpZ2luWzFdIC0gKHRpbGVDb29yZFsyXSArIDAuNSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb24sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiBhIHRpbGUgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFt0ZW1wRXh0ZW50XSBUZW1wb3JhcnkgZXh0ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0ZW1wRXh0ZW50KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHRpbGVDb29yZFswXSk7XG4gICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgICBjb25zdCBtaW5YID0gb3JpZ2luWzBdICsgdGlsZUNvb3JkWzFdICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IG1pblkgPSBvcmlnaW5bMV0gLSAodGlsZUNvb3JkWzJdICsgMSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWF4WCA9IG1pblggKyB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWF4WSA9IG1pblkgKyB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIHRlbXBFeHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBjb29yZGluYXRlIGZvciB0aGUgZ2l2ZW4gbWFwIGNvb3JkaW5hdGUgYW5kIHJlc29sdXRpb24uICBUaGlzXG4gICAqIG1ldGhvZCBjb25zaWRlcnMgdGhhdCBjb29yZGluYXRlcyB0aGF0IGludGVyc2VjdCB0aWxlIGJvdW5kYXJpZXMgc2hvdWxkIGJlXG4gICAqIGFzc2lnbmVkIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFtvcHRfdGlsZUNvb3JkXSBEZXN0aW5hdGlvbiBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlQ29vcmRGb3JDb29yZEFuZFJlc29sdXRpb24oY29vcmRpbmF0ZSwgcmVzb2x1dGlvbiwgb3B0X3RpbGVDb29yZCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oXG4gICAgICBjb29yZGluYXRlWzBdLFxuICAgICAgY29vcmRpbmF0ZVsxXSxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdF90aWxlQ29vcmQsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZm9yIHJlc29sdXRpb25zIHRoYXQgY29ycmVzcG9uZFxuICAgKiB0byBhbiBpbnRlZ2VyIHpvb20gbGV2ZWwuICBJbnN0ZWFkIGNhbGwgdGhlIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFpfYCBtZXRob2QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24gKGZvciBhIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWwpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgSW5zdGVhZCBvZiBsZXR0aW5nIGVkZ2VcbiAgICogICAgIGludGVyc2VjdGlvbnMgZ28gdG8gdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUsIGxldCBlZGdlIGludGVyc2VjdGlvbnNcbiAgICogICAgIGdvIHRvIHRoZSBsb3dlciB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gW29wdF90aWxlQ29vcmRdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uXyhcbiAgICB4LFxuICAgIHksXG4gICAgcmVzb2x1dGlvbixcbiAgICByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5LFxuICAgIG9wdF90aWxlQ29vcmQsXG4gICkge1xuICAgIGNvbnN0IHogPSB0aGlzLmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIGNvbnN0IHNjYWxlID0gcmVzb2x1dGlvbiAvIHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICAgIGxldCB0aWxlQ29vcmRYID0gKHNjYWxlICogKHggLSBvcmlnaW5bMF0pKSAvIHJlc29sdXRpb24gLyB0aWxlU2l6ZVswXTtcbiAgICBsZXQgdGlsZUNvb3JkWSA9IChzY2FsZSAqIChvcmlnaW5bMV0gLSB5KSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMV07XG5cbiAgICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgICAgdGlsZUNvb3JkWCA9IGNlaWwodGlsZUNvb3JkWCwgREVDSU1BTFMpIC0gMTtcbiAgICAgIHRpbGVDb29yZFkgPSBjZWlsKHRpbGVDb29yZFksIERFQ0lNQUxTKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZFggPSBmbG9vcih0aWxlQ29vcmRYLCBERUNJTUFMUyk7XG4gICAgICB0aWxlQ29vcmRZID0gZmxvb3IodGlsZUNvb3JkWSwgREVDSU1BTFMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHRob3VnaCB0aGVyZSBpcyByZXBldGl0aW9uIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fYCxcbiAgICogdGhleSBzaG91bGQgaGF2ZSBzZXBhcmF0ZSBpbXBsZW1lbnRhdGlvbnMuICBUaGlzIG1ldGhvZCBpcyBmb3IgaW50ZWdlciB6b29tXG4gICAqIGxldmVscy4gIFRoZSBvdGhlciBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyBjb3JyZXNwb25kaW5nXG4gICAqIHRvIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBNYXAgeCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBNYXAgeSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICAgKiAgICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICAgKiAgICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRUaWxlQ29vcmRGb3JYWUFuZFpfKHgsIHksIHosIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksIG9wdF90aWxlQ29vcmQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuXG4gICAgbGV0IHRpbGVDb29yZFggPSAoeCAtIG9yaWdpblswXSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMF07XG4gICAgbGV0IHRpbGVDb29yZFkgPSAob3JpZ2luWzFdIC0geSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMV07XG5cbiAgICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgICAgdGlsZUNvb3JkWCA9IGNlaWwodGlsZUNvb3JkWCwgREVDSU1BTFMpIC0gMTtcbiAgICAgIHRpbGVDb29yZFkgPSBjZWlsKHRpbGVDb29yZFksIERFQ0lNQUxTKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZFggPSBmbG9vcih0aWxlQ29vcmRYLCBERUNJTUFMUyk7XG4gICAgICB0aWxlQ29vcmRZID0gZmxvb3IodGlsZUNvb3JkWSwgREVDSU1BTFMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0aWxlIGNvb3JkaW5hdGUgZ2l2ZW4gYSBtYXAgY29vcmRpbmF0ZSBhbmQgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLCBlLmcuIHRoZSByZXN1bHQgb2YgYSBgZ2V0WkZvclJlc29sdXRpb24oKWAgbWV0aG9kIGNhbGxcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNvb3JkaW5hdGUsIHosIG9wdF90aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKFxuICAgICAgY29vcmRpbmF0ZVswXSxcbiAgICAgIGNvb3JkaW5hdGVbMV0sXG4gICAgICB6LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRfdGlsZUNvb3JkLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldFRpbGVDb29yZFJlc29sdXRpb24odGlsZUNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3RpbGVDb29yZFswXV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIHNpemUgZm9yIGEgem9vbSBsZXZlbC4gVGhlIHR5cGUgb2YgdGhlIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZVxuICAgKiBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIHRoYXQgdGhlIHRpbGUgZ3JpZCB3YXMgY29uZmlndXJlZCB3aXRoLiBUbyBhbHdheXNcbiAgICogZ2V0IGFuIHtAbGluayBpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9LCBydW4gdGhlIHJlc3VsdCB0aHJvdWdoIHtAbGluayBtb2R1bGU6b2wvc2l6ZS50b1NpemV9LlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBUaWxlIHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVTaXplKHopIHtcbiAgICBpZiAodGhpcy50aWxlU2l6ZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplXztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlsZVNpemVzX1t6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdHxudWxsfSBFeHRlbnQgdGlsZSByYW5nZSBmb3IgdGhlIHNwZWNpZmllZCB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0RnVsbFRpbGVSYW5nZSh6KSB7XG4gICAgaWYgKCF0aGlzLmZ1bGxUaWxlUmFuZ2VzXykge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50X1xuICAgICAgICA/IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWih0aGlzLmV4dGVudF8sIHopXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRpbGVSYW5nZXNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW29wdF9kaXJlY3Rpb25dXG4gICAqICAgICBJZiAwLCB0aGUgbmVhcmVzdCByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC5cbiAgICogICAgIElmIDEsIHRoZSBuZWFyZXN0IGhpZ2hlciByZXNvbHV0aW9uIChsb3dlciBaKSB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGVcbiAgICogICAgIG5lYXJlc3QgbG93ZXIgcmVzb2x1dGlvbiAoaGlnaGVyIFopIHdpbGwgYmUgdXNlZC4gRGVmYXVsdCBpcyAwLlxuICAgKiAgICAgVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9hcnJheX5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IGZvciBtb3JlIHByZWNpc2UgY29udHJvbC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUgdG8gY2hhbmdlIHRpbGUgWiBhdCB0aGUgbWlkcG9pbnQgb2Ygem9vbSBsZXZlbHNcbiAgICogYGBganNcbiAgICogZnVuY3Rpb24odmFsdWUsIGhpZ2gsIGxvdykge1xuICAgKiAgIHJldHVybiB2YWx1ZSAtIGxvdyAqIE1hdGguc3FydChoaWdoIC8gbG93KTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7bnVtYmVyfSBaLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeiA9IGxpbmVhckZpbmROZWFyZXN0KFxuICAgICAgdGhpcy5yZXNvbHV0aW9uc18sXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgb3B0X2RpcmVjdGlvbiB8fCAwLFxuICAgICk7XG4gICAgcmV0dXJuIGNsYW1wKHosIHRoaXMubWluWm9vbSwgdGhpcy5tYXhab29tKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGlsZSB3aXRoIHRoZSBwcm92aWRlZCB0aWxlIGNvb3JkaW5hdGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi90aWxlY29vcmQuanMnKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gdmlld3BvcnQgVmlld3BvcnQgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudC5nZXRSb3RhdGVkVmlld3BvcnR9LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSB3aXRoIHRoZSBwcm92aWRlZCB0aWxlIGNvb3JkaW5hdGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gdmlld3BvcnQuXG4gICAqL1xuICB0aWxlQ29vcmRJbnRlcnNlY3RzVmlld3BvcnQodGlsZUNvb3JkLCB2aWV3cG9ydCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZWFyUmluZyhcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgMCxcbiAgICAgIHZpZXdwb3J0Lmxlbmd0aCxcbiAgICAgIDIsXG4gICAgICB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudCBmb3IgdGhpcyB0aWxlIGdyaWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVUaWxlUmFuZ2VzXyhleHRlbnQpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGg7XG4gICAgY29uc3QgZnVsbFRpbGVSYW5nZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCB6ID0gdGhpcy5taW5ab29tOyB6IDwgbGVuZ3RoOyArK3opIHtcbiAgICAgIGZ1bGxUaWxlUmFuZ2VzW3pdID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gICAgfVxuICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gZnVsbFRpbGVSYW5nZXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUdyaWQ7XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkXG4gKi9cbmltcG9ydCBUaWxlR3JpZCBmcm9tICcuL3RpbGVncmlkL1RpbGVHcmlkLmpzJztcbmltcG9ydCB7REVGQVVMVF9NQVhfWk9PTSwgREVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vdGlsZWdyaWQvY29tbW9uLmpzJztcbmltcG9ydCB7TUVURVJTX1BFUl9VTklULCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlT3JVcGRhdGUsXG4gIGdldENvcm5lcixcbiAgZ2V0SGVpZ2h0LFxuICBnZXRXaWR0aCxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4vc2l6ZS5qcyc7XG5cbmV4cG9ydCB7VGlsZUdyaWR9O1xuZXhwb3J0IHtkZWZhdWx0IGFzIFdNVFN9IGZyb20gJy4vdGlsZWdyaWQvV01UUy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IERlZmF1bHQgdGlsZSBncmlkIGZvciB0aGVcbiAqIHBhc3NlZCBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGxldCB0aWxlR3JpZCA9IHByb2plY3Rpb24uZ2V0RGVmYXVsdFRpbGVHcmlkKCk7XG4gIGlmICghdGlsZUdyaWQpIHtcbiAgICB0aWxlR3JpZCA9IGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgcHJvamVjdGlvbi5zZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiB0aWxlR3JpZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIGNvbnN0IGNlbnRlciA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpO1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGlmICghY29udGFpbnNDb29yZGluYXRlKHByb2plY3Rpb25FeHRlbnQsIGNlbnRlcikpIHtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgY29uc3Qgd29ybGRzQXdheSA9IE1hdGguY2VpbChcbiAgICAgIChwcm9qZWN0aW9uRXh0ZW50WzBdIC0gY2VudGVyWzBdKSAvIHdvcmxkV2lkdGgsXG4gICAgKTtcbiAgICBjZW50ZXJbMF0gKz0gd29ybGRXaWR0aCAqIHdvcmxkc0F3YXk7XG4gICAgcmV0dXJuIHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjZW50ZXIsIHopO1xuICB9XG4gIHJldHVybiB0aWxlQ29vcmQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkNvcm5lcn0gW2Nvcm5lcl0gRXh0ZW50IGNvcm5lciAoZGVmYXVsdCBpcyBgJ3RvcC1sZWZ0J2ApLlxuICogQHJldHVybiB7IVRpbGVHcmlkfSBUaWxlR3JpZCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvckV4dGVudChleHRlbnQsIG1heFpvb20sIHRpbGVTaXplLCBjb3JuZXIpIHtcbiAgY29ybmVyID0gY29ybmVyICE9PSB1bmRlZmluZWQgPyBjb3JuZXIgOiAndG9wLWxlZnQnO1xuXG4gIGNvbnN0IHJlc29sdXRpb25zID0gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUpO1xuXG4gIHJldHVybiBuZXcgVGlsZUdyaWQoe1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG9yaWdpbjogZ2V0Q29ybmVyKGV4dGVudCwgY29ybmVyKSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnMsXG4gICAgdGlsZVNpemU6IHRpbGVTaXplLFxuICB9KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYWVpPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50IGZvciB0aGUgdGlsZSBncmlkLiBUaGUgb3JpZ2luIGZvciBhbiBYWVogdGlsZSBncmlkIGlzIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBleHRlbnQuIElmIGBtYXhSZXNvbHV0aW9uYCBpcyBub3QgcHJvdmlkZWQgdGhlIHplcm8gbGV2ZWwgb2YgdGhlIGdyaWQgaXMgZGVmaW5lZCBieSB0aGUgcmVzb2x1dGlvblxuICogYXQgd2hpY2ggb25lIHRpbGUgZml0cyBpbiB0aGUgcHJvdmlkZWQgZXh0ZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBleHRlbnQgb2YgdGhlIEVQU0c6Mzg1NyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFJlc29sdXRpb24gYXQgbGV2ZWwgemVyby5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tLiBUaGUgZGVmYXVsdCBpcyBgNDJgLiBUaGlzIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBsZXZlbHNcbiAqIGluIHRoZSBncmlkIHNldC4gRm9yIGV4YW1wbGUsIGEgYG1heFpvb21gIG9mIDIxIG1lYW5zIHRoZXJlIGFyZSAyMiBsZXZlbHMgaW4gdGhlIGdyaWQgc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGlsZSBzaXplIGluIHBpeGVscy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aWxlIGdyaWQgd2l0aCBhIHN0YW5kYXJkIFhZWiB0aWxpbmcgc2NoZW1lLlxuICogQHBhcmFtIHtYWVpPcHRpb25zfSBbb3B0aW9uc10gVGlsZSBncmlkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGUgZ3JpZCBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhZWihvcHRpb25zKSB7XG4gIGNvbnN0IHh5ek9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGV4dGVudCA9IHh5ek9wdGlvbnMuZXh0ZW50IHx8IGdldFByb2plY3Rpb24oJ0VQU0c6Mzg1NycpLmdldEV4dGVudCgpO1xuXG4gIGNvbnN0IGdyaWRPcHRpb25zID0ge1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG1pblpvb206IHh5ek9wdGlvbnMubWluWm9vbSxcbiAgICB0aWxlU2l6ZTogeHl6T3B0aW9ucy50aWxlU2l6ZSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnNGcm9tRXh0ZW50KFxuICAgICAgZXh0ZW50LFxuICAgICAgeHl6T3B0aW9ucy5tYXhab29tLFxuICAgICAgeHl6T3B0aW9ucy50aWxlU2l6ZSxcbiAgICAgIHh5ek9wdGlvbnMubWF4UmVzb2x1dGlvbixcbiAgICApLFxuICB9O1xuICByZXR1cm4gbmV3IFRpbGVHcmlkKGdyaWRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZXNvbHV0aW9ucyBhcnJheSBmcm9tIGFuIGV4dGVudC4gIEEgem9vbSBmYWN0b3Igb2YgMiBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heFJlc29sdXRpb25dIFJlc29sdXRpb24gYXQgbGV2ZWwgemVyby5cbiAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBSZXNvbHV0aW9ucyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUsIG1heFJlc29sdXRpb24pIHtcbiAgbWF4Wm9vbSA9IG1heFpvb20gIT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBERUZBVUxUX01BWF9aT09NO1xuICB0aWxlU2l6ZSA9IHRvU2l6ZSh0aWxlU2l6ZSAhPT0gdW5kZWZpbmVkID8gdGlsZVNpemUgOiBERUZBVUxUX1RJTEVfU0laRSk7XG5cbiAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIGNvbnN0IHdpZHRoID0gZ2V0V2lkdGgoZXh0ZW50KTtcblxuICBtYXhSZXNvbHV0aW9uID1cbiAgICBtYXhSZXNvbHV0aW9uID4gMFxuICAgICAgPyBtYXhSZXNvbHV0aW9uXG4gICAgICA6IE1hdGgubWF4KHdpZHRoIC8gdGlsZVNpemVbMF0sIGhlaWdodCAvIHRpbGVTaXplWzFdKTtcblxuICBjb25zdCBsZW5ndGggPSBtYXhab29tICsgMTtcbiAgY29uc3QgcmVzb2x1dGlvbnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgeiA9IDA7IHogPCBsZW5ndGg7ICsreikge1xuICAgIHJlc29sdXRpb25zW3pdID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KDIsIHopO1xuICB9XG4gIHJldHVybiByZXNvbHV0aW9ucztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5Db3JuZXJ9IFtjb3JuZXJdIEV4dGVudCBjb3JuZXIgKGRlZmF1bHQgaXMgYCd0b3AtbGVmdCdgKS5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gVGlsZUdyaWQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24sIG1heFpvb20sIHRpbGVTaXplLCBjb3JuZXIpIHtcbiAgY29uc3QgZXh0ZW50ID0gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIHJldHVybiBjcmVhdGVGb3JFeHRlbnQoZXh0ZW50LCBtYXhab29tLCB0aWxlU2l6ZSwgY29ybmVyKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRpbGUgZ3JpZCBleHRlbnQgZnJvbSBhIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBoYXMgYW5cbiAqIGV4dGVudCwgaXQgaXMgdXNlZC4gIElmIG5vdCwgYSBnbG9iYWwgZXh0ZW50IGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBsZXQgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgaWYgKCFleHRlbnQpIHtcbiAgICBjb25zdCBoYWxmID1cbiAgICAgICgxODAgKiBNRVRFUlNfUEVSX1VOSVQuZGVncmVlcykgLyBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZSgtaGFsZiwgLWhhbGYsIGhhbGYsIGhhbGYpO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlXG4gKi9cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IFNvdXJjZSBmcm9tICcuL1NvdXJjZS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0LCBnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtcbiAgZ2V0Rm9yUHJvamVjdGlvbiBhcyBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24sXG4gIHdyYXBYLFxufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5pbXBvcnQge3NjYWxlIGFzIHNjYWxlU2l6ZSwgdG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcbmltcG9ydCB7d2l0aGluRXh0ZW50QW5kWn0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vVGlsZUV2ZW50VHlwZVwiKS5UaWxlU291cmNlRXZlbnRUeXBlcywgVGlsZVNvdXJjZUV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgaW1wb3J0KFwiLi9UaWxlRXZlbnRUeXBlXCIpLlRpbGVTb3VyY2VFdmVudFR5cGVzLCBSZXR1cm4+fSBUaWxlU291cmNlT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdIERlcHJlY2F0ZWQuICBVc2UgdGhlIGNhY2hlU2l6ZSBvcHRpb24gb24gdGhlIGxheWVyIGluc3RlYWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXSBUaWxlUGl4ZWxSYXRpby5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGVdIFN0YXRlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGVHcmlkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXBYLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBUcmFuc2l0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldIEtleS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF0gWkRpcmVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPWZhbHNlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogdGhlIG5lYXJlc3QgbmVpZ2hib3IgaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyBpbWFnZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkLlxuICpcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBbVGlsZVR5cGU9aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0XVxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRpbGVTb3VyY2UgZXh0ZW5kcyBTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFNvdXJjZVRpbGUgc291cmNlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgIH0pO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtUaWxlU291cmNlT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VGlsZVNvdXJjZU9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VGlsZVNvdXJjZU9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWxlUGl4ZWxSYXRpb18gPVxuICAgICAgb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLnRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6IG51bGw7XG5cbiAgICBjb25zdCB0aWxlU2l6ZSA9IFsyNTYsIDI1Nl07XG4gICAgaWYgKHRoaXMudGlsZUdyaWQpIHtcbiAgICAgIHRvU2l6ZSh0aGlzLnRpbGVHcmlkLmdldFRpbGVTaXplKHRoaXMudGlsZUdyaWQuZ2V0TWluWm9vbSgpKSwgdGlsZVNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMudG1wU2l6ZSA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleV8gPSBvcHRpb25zLmtleSB8fCBnZXRVaWQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuT3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVPcHRpb25zID0ge1xuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHpEaXJlY3Rpb24gaGludCwgcmVhZCBieSB0aGUgcmVuZGVyZXIuIEluZGljYXRlcyB3aGljaCByZXNvbHV0aW9uIHNob3VsZCBiZSB1c2VkXG4gICAgICogYnkgYSByZW5kZXJlciBpZiB0aGUgdmlld3MgcmVzb2x1dGlvbiBkb2VzIG5vdCBtYXRjaCBhbnkgcmVzb2x1dGlvbiBvZiB0aGUgdGlsZSBzb3VyY2UuXG4gICAgICogSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb25cbiAgICAgKiB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGUgbmVhcmVzdCBoaWdoZXIgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy56RGlyZWN0aW9uID0gb3B0aW9ucy56RGlyZWN0aW9uID8gb3B0aW9ucy56RGlyZWN0aW9uIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgZ2V0R3V0dGVyRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBrZXkgdG8gYmUgdXNlZCBmb3IgYWxsIHRpbGVzIGluIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGtleSBmb3IgYWxsIHRpbGVzLlxuICAgKi9cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLmtleV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSB0byBiZSB1c2VkIGFzIHRoZSBrZXkgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgZm9yIHRpbGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXRLZXkoa2V5KSB7XG4gICAgaWYgKHRoaXMua2V5XyAhPT0ga2V5KSB7XG4gICAgICB0aGlzLmtleV8gPSBrZXk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb25cIikuZGVmYXVsdH0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58bnVsbH0gUmVzb2x1dGlvbnMuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMocHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVHcmlkID0gcHJvamVjdGlvblxuICAgICAgPyB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKVxuICAgICAgOiB0aGlzLnRpbGVHcmlkO1xuICAgIGlmICghdGlsZUdyaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7VGlsZVR5cGV8bnVsbH0gVGlsZS5cbiAgICovXG4gIGdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBncmlkIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIGdyaWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICovXG4gIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLnRpbGVHcmlkKSB7XG4gICAgICByZXR1cm4gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgcGl4ZWwgcmF0aW8gZm9yIHRoaXMgc291cmNlLiBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzXG4gICAqIG1ldGhvZCwgd2hpY2ggaXMgbWVhbnQgdG8gcmV0dXJuIGEgc3VwcG9ydGVkIHBpeGVsIHJhdGlvIHRoYXQgbWF0Y2hlcyB0aGVcbiAgICogcHJvdmlkZWQgYHBpeGVsUmF0aW9gIGFzIGNsb3NlIGFzIHBvc3NpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHBpeGVsIHJhdGlvLlxuICAgKi9cbiAgZ2V0VGlsZVBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiB0aGlzLnRpbGVQaXhlbFJhdGlvXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFRpbGUgc2l6ZS5cbiAgICovXG4gIGdldFRpbGVQaXhlbFNpemUoeiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgY29uc3QgdGlsZVBpeGVsUmF0aW8gPSB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRpbGVHcmlkLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemUpO1xuICAgIGlmICh0aWxlUGl4ZWxSYXRpbyA9PSAxKSB7XG4gICAgICByZXR1cm4gdGlsZVNpemU7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZVNpemUodGlsZVNpemUsIHRpbGVQaXhlbFJhdGlvLCB0aGlzLnRtcFNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0aWxlIGNvb3JkaW5hdGUgd3JhcHBlZCBhcm91bmQgdGhlIHgtYXhpcy4gV2hlbiB0aGUgdGlsZSBjb29yZGluYXRlXG4gICAqIGlzIG91dHNpZGUgdGhlIHJlc29sdXRpb24gYW5kIGV4dGVudCByYW5nZSBvZiB0aGUgdGlsZSBncmlkLCBgbnVsbGAgd2lsbCBiZVxuICAgKiByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlIHRvIGJlIHBhc3NlZCB0byB0aGUgdGlsZVVybEZ1bmN0aW9uIG9yXG4gICAqICAgICBudWxsIGlmIG5vIHRpbGUgVVJMIHNob3VsZCBiZSBjcmVhdGVkIGZvciB0aGUgcGFzc2VkIGB0aWxlQ29vcmRgLlxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcHJvamVjdGlvbikge1xuICAgIHByb2plY3Rpb24gPSBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAodGhpcy5nZXRXcmFwWCgpICYmIHByb2plY3Rpb24uaXNHbG9iYWwoKSkge1xuICAgICAgdGlsZUNvb3JkID0gd3JhcFgodGlsZUdyaWQsIHRpbGVDb29yZCwgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpID8gdGlsZUNvb3JkIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGNhY2hlZCByZXByb2plY3RlZCB0aWxlcyBmcm9tIHRoZSBzb3VyY2UuIFRoZSBuZXh0IHJlbmRlciBjeWNsZSB3aWxsIGNyZWF0ZSBuZXcgdGlsZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsZWFyKCkge31cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBzdXBlci5yZWZyZXNoKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaWxlU291cmNlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaGUgdGlsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHRpbGUpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aWxlIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudGlsZSA9IHRpbGU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVNvdXJjZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvdXJpXG4gKi9cblxuaW1wb3J0IHtoYXNoWlhZfSBmcm9tICcuL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcblxuLyoqXG4gKiBBcHBlbmRzIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSBUaGUgb3JpZ2luYWwgVVJJLCB3aGljaCBtYXkgYWxyZWFkeSBoYXZlIHF1ZXJ5IGRhdGEuXG4gKiBAcGFyYW0geyFPYmplY3R9IHBhcmFtcyBBbiBvYmplY3Qgd2hlcmUga2V5cyBhcmUgVVJJLWVuY29kZWQgcGFyYW1ldGVyIGtleXMsXG4gKiAgICAgYW5kIHRoZSB2YWx1ZXMgYXJlIGFyYml0cmFyeSB0eXBlcyBvciBhcnJheXMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuZXcgVVJJLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kUGFyYW1zKHVyaSwgcGFyYW1zKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3Qga2V5UGFyYW1zID0gW107XG4gIC8vIFNraXAgYW55IG51bGwgb3IgdW5kZWZpbmVkIHBhcmFtZXRlciB2YWx1ZXNcbiAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKHBhcmFtc1trXSAhPT0gbnVsbCAmJiBwYXJhbXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5UGFyYW1zLnB1c2goayArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba10pKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBxcyA9IGtleVBhcmFtcy5qb2luKCcmJyk7XG4gIC8vIHJlbW92ZSBhbnkgdHJhaWxpbmcgPyBvciAmXG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9bPyZdJC8sICcnKTtcbiAgLy8gYXBwZW5kID8gb3IgJiBkZXBlbmRpbmcgb24gd2hldGhlciB1cmkgaGFzIGV4aXN0aW5nIHBhcmFtZXRlcnNcbiAgdXJpICs9IHVyaS5pbmNsdWRlcygnPycpID8gJyYnIDogJz8nO1xuICByZXR1cm4gdXJpICsgcXM7XG59XG5cbmNvbnN0IHpSZWdFeCA9IC9cXHt6XFx9L2c7XG5jb25zdCB4UmVnRXggPSAvXFx7eFxcfS9nO1xuY29uc3QgeVJlZ0V4ID0gL1xce3lcXH0vZztcbmNvbnN0IGRhc2hZUmVnRXggPSAvXFx7LXlcXH0vZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVGhlIFVSTCB0ZW1wbGF0ZS4gIFNob3VsZCBoYXZlIGB7eH1gLCBge3l9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy4gIElmXG4gKiB0aGUgdGVtcGxhdGUgaGFzIGEgYHsteX1gIHBsYWNlaG9sZGVyLCB0aGUgYG1heFlgIHBhcmFtZXRlciBtdXN0IGJlIHN1cHBsaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIHRpbGUgeiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHRpbGUgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHRpbGUgeSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhZXSBUaGUgbWF4aW11bSB5IGNvb3JkaW5hdGUgYXQgdGhlIGdpdmVuIHogbGV2ZWwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJYWVpUZW1wbGF0ZSh0ZW1wbGF0ZSwgeiwgeCwgeSwgbWF4WSkge1xuICByZXR1cm4gdGVtcGxhdGVcbiAgICAucmVwbGFjZSh6UmVnRXgsIHoudG9TdHJpbmcoKSlcbiAgICAucmVwbGFjZSh4UmVnRXgsIHgudG9TdHJpbmcoKSlcbiAgICAucmVwbGFjZSh5UmVnRXgsIHkudG9TdHJpbmcoKSlcbiAgICAucmVwbGFjZShkYXNoWVJlZ0V4LCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWF4WSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSWYgdGhlIFVSTCB0ZW1wbGF0ZSBoYXMgYSB7LXl9IHBsYWNlaG9sZGVyLCB0aGUgZ3JpZCBleHRlbnQgbXVzdCBiZSBrbm93bicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1heFkgLSB5KS50b1N0cmluZygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdXJscyBMaXN0IG9mIFVSTHMuXG4gKiBAcGFyYW0ge251bWJlcn0geiBUaGUgdGlsZSB6IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgdGlsZSB4IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgdGlsZSB5IGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjaG9zZW4gVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlja1VybCh1cmxzLCB6LCB4LCB5KSB7XG4gIGNvbnN0IGhhc2ggPSBoYXNoWlhZKHosIHgsIHkpO1xuICBjb25zdCBpbmRleCA9IG1vZHVsbyhoYXNoLCB1cmxzLmxlbmd0aCk7XG4gIHJldHVybiB1cmxzW2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTC5cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEFycmF5IG9mIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRVcmwodXJsKSB7XG4gIGNvbnN0IHVybHMgPSBbXTtcbiAgbGV0IG1hdGNoID0gL1xceyhbYS16XSktKFthLXpdKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBjaGFyIHJhbmdlXG4gICAgY29uc3Qgc3RhcnRDaGFyQ29kZSA9IG1hdGNoWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3Qgc3RvcENoYXJDb2RlID0gbWF0Y2hbMl0uY2hhckNvZGVBdCgwKTtcbiAgICBsZXQgY2hhckNvZGU7XG4gICAgZm9yIChjaGFyQ29kZSA9IHN0YXJ0Q2hhckNvZGU7IGNoYXJDb2RlIDw9IHN0b3BDaGFyQ29kZTsgKytjaGFyQ29kZSkge1xuICAgICAgdXJscy5wdXNoKHVybC5yZXBsYWNlKG1hdGNoWzBdLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICBtYXRjaCA9IC9cXHsoXFxkKyktKFxcZCspXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIG51bWJlciByYW5nZVxuICAgIGNvbnN0IHN0b3AgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuICAgIGZvciAobGV0IGkgPSBwYXJzZUludChtYXRjaFsxXSwgMTApOyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgdXJscy5wdXNoKHVybC5yZXBsYWNlKG1hdGNoWzBdLCBpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgdXJscy5wdXNoKHVybCk7XG4gIHJldHVybiB1cmxzO1xufVxuIiwgIi8qKlxuICogQG1vZHVsZSBvbC90aWxldXJsZnVuY3Rpb25cbiAqL1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge3JlbmRlclhZWlRlbXBsYXRlfSBmcm9tICcuL3VyaS5qcyc7XG5pbXBvcnQge2hhc2ggYXMgdGlsZUNvb3JkSGFzaH0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUZW1wbGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fG51bGx9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHRpbGVHcmlkKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxldCBtYXhZO1xuICAgICAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgIGlmICh0aWxlR3JpZCkge1xuICAgICAgICAvLyBUaGUgYHsteX1gIHBsYWNlaG9sZGVyIG9ubHkgd29ya3MgZm9yIHNvdXJjZXMgdGhhdCBoYXZlIGEgdGlsZSBncmlkIGF0IGNvbnN0cnVjdGlvblxuICAgICAgICBjb25zdCByYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIG1heFkgPSByYW5nZS5nZXRIZWlnaHQoKSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZW5kZXJYWVpUZW1wbGF0ZSh0ZW1wbGF0ZSwgeiwgdGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0sIG1heFkpO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHRlbXBsYXRlcyBUZW1wbGF0ZXMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZW1wbGF0ZXModGVtcGxhdGVzLCB0aWxlR3JpZCkge1xuICBjb25zdCBsZW4gPSB0ZW1wbGF0ZXMubGVuZ3RoO1xuICBjb25zdCB0aWxlVXJsRnVuY3Rpb25zID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0aWxlVXJsRnVuY3Rpb25zW2ldID0gY3JlYXRlRnJvbVRlbXBsYXRlKHRlbXBsYXRlc1tpXSwgdGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbj59IHRpbGVVcmxGdW5jdGlvbnMgVGlsZSBVUkwgRnVuY3Rpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zKHRpbGVVcmxGdW5jdGlvbnMpIHtcbiAgaWYgKHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRpbGVVcmxGdW5jdGlvbnNbMF07XG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgaCA9IHRpbGVDb29yZEhhc2godGlsZUNvb3JkKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gbW9kdWxvKGgsIHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zW2luZGV4XSh0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxUaWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVE9ETzogVXBkYXRlIG9sLW1hcGJveC1zdHlsZSB0byBpbXBvcnQgdGhpcyBmcm9tIHRoZSB1cmkuanMgbW9kdWxlLlxuICovXG5leHBvcnQge2V4cGFuZFVybH0gZnJvbSAnLi91cmkuanMnO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVXJsVGlsZVxuICovXG5pbXBvcnQgVGlsZUV2ZW50VHlwZSBmcm9tICcuL1RpbGVFdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVTb3VyY2UsIHtUaWxlU291cmNlRXZlbnR9IGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUZyb21UZW1wbGF0ZXN9IGZyb20gJy4uL3RpbGV1cmxmdW5jdGlvbi5qcyc7XG5pbXBvcnQge2V4cGFuZFVybH0gZnJvbSAnLi4vdXJpLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXSBEZXByZWNhdGVkLiAgVXNlIHRoZSBjYWNoZVNpemUgb3B0aW9uIG9uIHRoZSBsYXllciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IFtzdGF0ZV0gU3RhdGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFt0aWxlR3JpZF0gVGlsZUdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGVMb2FkRnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXSBUaWxlUGl4ZWxSYXRpby5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGFuZCBwcm92aWRlIGEgZnVuY3Rpb25cbiAqIGZvciB0aGUgdXJsIG9wdGlvbiBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVybC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIFVybHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwWC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gVHJhbnNpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XSBLZXkuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9hcnJheS5qc1wiKS5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IFt6RGlyZWN0aW9uPTBdIFpEaXJlY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT1mYWxzZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIHRoZSBuZWFyZXN0IG5laWdoYm9yIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLlxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBvbC9zb3VyY2UvSW1hZ2VUaWxlLmpzIGluc3RlYWQuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vVGlsZS5qc1wiKS5UaWxlU291cmNlRXZlbnRcbiAqL1xuY2xhc3MgVXJsVGlsZSBleHRlbmRzIFRpbGVTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEltYWdlIHRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgdGlsZUdyaWQ6IG9wdGlvbnMudGlsZUdyaWQsXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUsXG4gICAgICB6RGlyZWN0aW9uOiBvcHRpb25zLnpEaXJlY3Rpb24sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2VuZXJhdGVUaWxlVXJsRnVuY3Rpb25fID1cbiAgICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID09PSBVcmxUaWxlLnByb3RvdHlwZS50aWxlVXJsRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbjtcblxuICAgIGlmIChvcHRpb25zLnRpbGVVcmxGdW5jdGlvbikge1xuICAgICAgdGhpcy50aWxlVXJsRnVuY3Rpb24gPSBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy51cmxzID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLnVybHMpIHtcbiAgICAgIHRoaXMuc2V0VXJscyhvcHRpb25zLnVybHMpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgIHRoaXMuc2V0VXJsKG9wdGlvbnMudXJsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZGluZ0tleXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGluc3RlYWQuXG4gICAqIFJldHVybiB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBUaWxlTG9hZEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVMb2FkRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUxvYWRGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiAgVXNlIGFuIEltYWdlVGlsZSBzb3VyY2UgaW5zdGVhZC5cbiAgICogUmV0dXJuIHRoZSB0aWxlIFVSTCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlVXJsRnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZVVybEZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykudGlsZVVybEZ1bmN0aW9uID09PSB0aGlzLnRpbGVVcmxGdW5jdGlvblxuICAgICAgPyB0aGlzLnRpbGVVcmxGdW5jdGlvbi5iaW5kKHRoaXMpXG4gICAgICA6IHRoaXMudGlsZVVybEZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBpbnN0ZWFkLlxuICAgKiBSZXR1cm4gdGhlIFVSTHMgdXNlZCBmb3IgdGhpcyBzb3VyY2UuXG4gICAqIFdoZW4gYSB0aWxlVXJsRnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIHVybCBvciB1cmxzLFxuICAgKiBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fG51bGx9IFVSTHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJscztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGlsZSBjaGFuZ2UgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlVGlsZUNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgY29uc3QgdWlkID0gZ2V0VWlkKHRpbGUpO1xuICAgIGNvbnN0IHRpbGVTdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgdHlwZTtcbiAgICBpZiAodGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXSA9IHRydWU7XG4gICAgICB0eXBlID0gVGlsZUV2ZW50VHlwZS5USUxFTE9BRFNUQVJUO1xuICAgIH0gZWxzZSBpZiAodWlkIGluIHRoaXMudGlsZUxvYWRpbmdLZXlzXykge1xuICAgICAgZGVsZXRlIHRoaXMudGlsZUxvYWRpbmdLZXlzX1t1aWRdO1xuICAgICAgdHlwZSA9XG4gICAgICAgIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1JcbiAgICAgICAgICA/IFRpbGVFdmVudFR5cGUuVElMRUxPQURFUlJPUlxuICAgICAgICAgIDogdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FERURcbiAgICAgICAgICAgID8gVGlsZUV2ZW50VHlwZS5USUxFTE9BREVORFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUaWxlU291cmNlRXZlbnQodHlwZSwgdGlsZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkLiAgVXNlIGFuIEltYWdlVGlsZSBzb3VyY2UgaW5zdGVhZC5cbiAgICogU2V0IHRoZSB0aWxlIGxvYWQgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlIGxvYWQgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVMb2FkRnVuY3Rpb24odGlsZUxvYWRGdW5jdGlvbikge1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IHRpbGVMb2FkRnVuY3Rpb247XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGluc3RlYWQuXG4gICAqIFNldCB0aGUgdGlsZSBVUkwgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSB0aWxlVXJsRnVuY3Rpb24gVGlsZSBVUkwgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBPcHRpb25hbCBuZXcgdGlsZSBrZXkgZm9yIHRoZSBzb3VyY2UuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVVcmxGdW5jdGlvbih0aWxlVXJsRnVuY3Rpb24sIGtleSkge1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGlsZVVybEZ1bmN0aW9uO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zZXRLZXkoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRVcmwodXJsKSB7XG4gICAgY29uc3QgdXJscyA9IGV4cGFuZFVybCh1cmwpO1xuICAgIHRoaXMudXJscyA9IHVybHM7XG4gICAgdGhpcy5zZXRVcmxzKHVybHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBpbnN0ZWFkLlxuICAgKiBTZXQgdGhlIFVSTHMgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzIFVSTHMuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFVybHModXJscykge1xuICAgIHRoaXMudXJscyA9IHVybHM7XG4gICAgY29uc3Qga2V5ID0gdXJscy5qb2luKCdcXG4nKTtcbiAgICBpZiAodGhpcy5nZW5lcmF0ZVRpbGVVcmxGdW5jdGlvbl8pIHtcbiAgICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKGNyZWF0ZUZyb21UZW1wbGF0ZXModXJscywgdGhpcy50aWxlR3JpZCksIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0S2V5KGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAqL1xuICB0aWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVcmxUaWxlO1xuIiwgIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUltYWdlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVXJsVGlsZSBmcm9tICcuL1VybFRpbGUuanMnO1xuaW1wb3J0IHtlcXVpdmFsZW50LCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2dldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gRGVwcmVjYXRlZC4gIFVzZSB0aGUgY2FjaGVTaXplIG9wdGlvbiBvbiB0aGUgbGF5ZXIgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9dHJ1ZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLiAgU2V0IHRvIGZhbHNlIHRvIHVzZSB0aGUgbmVhcmVzdCBuZWlnaGJvciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi4gRGVmYXVsdCBpcyB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGVdIFNvdXJjZSBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGltcG9ydChcIi4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSBbdGlsZUNsYXNzXSBDbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIGltYWdlIHRpbGVzLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL0ltYWdlVGlsZX5JbWFnZVRpbGV9LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuIEZvciBleGFtcGxlLCBpZiB0aGUgdGlsZVxuICogc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIERlcHJlY2F0ZWQuICBVc2UgYW4gSW1hZ2VUaWxlIHNvdXJjZSBhbmQgcHJvdmlkZSBhIGZ1bmN0aW9uXG4gKiBmb3IgdGhlIHVybCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLCBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLlxuICogQSBgez8tP31gIHRlbXBsYXRlIHBhdHRlcm4sIGZvciBleGFtcGxlIGBzdWJkb21haW57YS1mfS5kb21haW4uY29tYCwgbWF5IGJlXG4gKiB1c2VkIGluc3RlYWQgb2YgZGVmaW5pbmcgZWFjaCBvbmUgc2VwYXJhdGVseSBpbiB0aGUgYHVybHNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIEFuIGFycmF5IG9mIFVSTCB0ZW1wbGF0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWF0gV2hldGhlciB0byB3cmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuIFRoZSBkZWZhdWx0LCBpcyB0b1xuICogcmVxdWVzdCBvdXQtb2YtYm91bmRzIHRpbGVzIGZyb20gdGhlIHNlcnZlci4gV2hlbiBzZXQgdG8gYGZhbHNlYCwgb25seSBvbmVcbiAqIHdvcmxkIHdpbGwgYmUgcmVuZGVyZWQuIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGlsZXMgd2lsbCBiZSByZXF1ZXN0ZWQgZm9yIG9uZVxuICogd29ybGQgb25seSwgYnV0IHRoZXkgd2lsbCBiZSB3cmFwcGVkIGhvcml6b250YWxseSB0byByZW5kZXIgbXVsdGlwbGUgd29ybGRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBEdXJhdGlvbiBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uIGZvciByZW5kZXJpbmcuXG4gKiBUbyBkaXNhYmxlIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24sIHBhc3MgYHRyYW5zaXRpb246IDBgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldIE9wdGlvbmFsIHRpbGUga2V5IGZvciBwcm9wZXIgY2FjaGUgZmV0Y2hpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF1cbiAqIENob29zZSB3aGV0aGVyIHRvIHVzZSB0aWxlcyB3aXRoIGEgaGlnaGVyIG9yIGxvd2VyIHpvb20gbGV2ZWwgd2hlbiBiZXR3ZWVuIGludGVnZXJcbiAqIHpvb20gbGV2ZWxzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5UaWxlR3JpZCNnZXRaRm9yUmVzb2x1dGlvbn0uXG4gKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIG9sL3NvdXJjZS9JbWFnZVRpbGUuanMgaW5zdGVhZC5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9UaWxlLmpzXCIpLlRpbGVTb3VyY2VFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBUaWxlSW1hZ2UgZXh0ZW5kcyBVcmxUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9wdGlvbnN9IG9wdGlvbnMgSW1hZ2UgdGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB0aWxlR3JpZDogb3B0aW9ucy50aWxlR3JpZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvblxuICAgICAgICA/IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvblxuICAgICAgICA6IGRlZmF1bHRUaWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB0aWxlVXJsRnVuY3Rpb246IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgaW50ZXJwb2xhdGU6XG4gICAgICAgIG9wdGlvbnMuaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGUgOiB0cnVlLFxuICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgekRpcmVjdGlvbjogb3B0aW9ucy56RGlyZWN0aW9uLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPVxuICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc09yaWdpbiA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge3R5cGVvZiBJbWFnZVRpbGV9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2xhc3MgPVxuICAgICAgb3B0aW9ucy50aWxlQ2xhc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZUNsYXNzIDogSW1hZ2VUaWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZF8gPSBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0R3V0dGVyRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiZcbiAgICAgIHByb2plY3Rpb24gJiZcbiAgICAgICFlcXVpdmFsZW50KHRoaXMuZ2V0UHJvamVjdGlvbigpLCBwcm9qZWN0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEd1dHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgZ2V0R3V0dGVyKCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUga2V5IHRvIGJlIHVzZWQgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBrZXkgZm9yIGFsbCB0aWxlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgbGV0IGtleSA9IHN1cGVyLmdldEtleSgpO1xuICAgIGlmICghdGhpcy5nZXRJbnRlcnBvbGF0ZSgpKSB7XG4gICAgICBrZXkgKz0gJzpkaXNhYmxlLWludGVycG9sYXRpb24nO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHRoaXMudGlsZUdyaWQgJiYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICAgIH1cbiAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pO1xuICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24pKSB7XG4gICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9XG4gICAgICAgIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uW3Byb2pLZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBzZXQgb24gdGhlIHRpbGUuXG4gICAqIEByZXR1cm4geyFJbWFnZVRpbGV9IFRpbGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpIHtcbiAgICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgY29uc3QgdXJsVGlsZUNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24oXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICBwcm9qZWN0aW9uLFxuICAgICk7XG4gICAgY29uc3QgdGlsZVVybCA9IHVybFRpbGVDb29yZFxuICAgICAgPyB0aGlzLnRpbGVVcmxGdW5jdGlvbih1cmxUaWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB0aWxlID0gbmV3IHRoaXMudGlsZUNsYXNzKFxuICAgICAgdGlsZUNvb3JkLFxuICAgICAgdGlsZVVybCAhPT0gdW5kZWZpbmVkID8gVGlsZVN0YXRlLklETEUgOiBUaWxlU3RhdGUuRU1QVFksXG4gICAgICB0aWxlVXJsICE9PSB1bmRlZmluZWQgPyB0aWxlVXJsIDogJycsXG4gICAgICB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGhpcy50aWxlT3B0aW9ucyxcbiAgICApO1xuICAgIHRpbGUua2V5ID0ga2V5O1xuICAgIHRpbGUuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IShJbWFnZVRpbGV8UmVwcm9qVGlsZSl9IFRpbGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGlmIChcbiAgICAgICFzb3VyY2VQcm9qZWN0aW9uIHx8XG4gICAgICAhcHJvamVjdGlvbiB8fFxuICAgICAgZXF1aXZhbGVudChzb3VyY2VQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUludGVybmFsKFxuICAgICAgICB6LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwaXhlbFJhdGlvLFxuICAgICAgICBzb3VyY2VQcm9qZWN0aW9uIHx8IHByb2plY3Rpb24sXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICBjb25zdCBzb3VyY2VUaWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHNvdXJjZVByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRhcmdldFRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgY29uc3Qgd3JhcHBlZFRpbGVDb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uKFxuICAgICAgdGlsZUNvb3JkLFxuICAgICAgcHJvamVjdGlvbixcbiAgICApO1xuICAgIGNvbnN0IHRpbGUgPSBuZXcgUmVwcm9qVGlsZShcbiAgICAgIHNvdXJjZVByb2plY3Rpb24sXG4gICAgICBzb3VyY2VUaWxlR3JpZCxcbiAgICAgIHByb2plY3Rpb24sXG4gICAgICB0YXJnZXRUaWxlR3JpZCxcbiAgICAgIHRpbGVDb29yZCxcbiAgICAgIHdyYXBwZWRUaWxlQ29vcmQsXG4gICAgICB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pLFxuICAgICAgdGhpcy5nZXRHdXR0ZXIoKSxcbiAgICAgICh6LCB4LCB5LCBwaXhlbFJhdGlvKSA9PlxuICAgICAgICB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uKSxcbiAgICAgIHRoaXMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfLFxuICAgICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18sXG4gICAgICB0aGlzLnRpbGVPcHRpb25zLFxuICAgICk7XG4gICAgdGlsZS5rZXkgPSBrZXk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFJbWFnZVRpbGV9IFRpbGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byByZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzIG9yIG5vdCAodXN1YWxseSBmb3IgZGVidWdnaW5nKS5cbiAgICogQHBhcmFtIHtib29sZWFufSByZW5kZXIgUmVuZGVyIHRoZSBlZGdlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVuZGVyUmVwcm9qZWN0aW9uRWRnZXMocmVuZGVyKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID09IHJlbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IHJlbmRlcjtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aWxlIGdyaWQgdG8gdXNlIHdoZW4gcmVwcm9qZWN0aW5nIHRoZSB0aWxlcyB0byB0aGUgZ2l2ZW5cbiAgICogcHJvamVjdGlvbiBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IHRpbGUgZ3JpZCBmb3IgdGhlIHByb2plY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSBkZWZhdWx0IHRpbGUgZ3JpZCBjYW5ub3QgYmUgY3JlYXRlZFxuICAgKiAoZS5nLiBwcm9qZWN0aW9uIGhhcyBubyBleHRlbnQgZGVmaW5lZCkgb3JcbiAgICogZm9yIG9wdGltaXphdGlvbiByZWFzb25zIChjdXN0b20gdGlsZSBzaXplLCByZXNvbHV0aW9ucywgLi4uKS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZWdyaWQgVGlsZSBncmlkIHRvIHVzZSBmb3IgdGhlIHByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uLCB0aWxlZ3JpZCkge1xuICAgIGNvbnN0IHByb2ogPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmIChwcm9qKSB7XG4gICAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2opO1xuICAgICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbikpIHtcbiAgICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPSB0aWxlZ3JpZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlVGlsZX0gaW1hZ2VUaWxlIEltYWdlIHRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChpbWFnZVRpbGUuZ2V0SW1hZ2UoKSkuc3JjID1cbiAgICBzcmM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVJbWFnZTtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1hZWlxuICovXG5cbmltcG9ydCBUaWxlSW1hZ2UgZnJvbSAnLi9UaWxlSW1hZ2UuanMnO1xuaW1wb3J0IHtjcmVhdGVYWVosIGV4dGVudEZyb21Qcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gRGVwcmVjYXRlZC4gIFVzZSB0aGUgY2FjaGVTaXplIG9wdGlvbiBvbiB0aGUgbGF5ZXIgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9dHJ1ZV0gVXNlIGludGVycG9sYXRlZCB2YWx1ZXMgd2hlbiByZXNhbXBsaW5nLiAgQnkgZGVmYXVsdCxcbiAqIGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHVzZWQgd2hlbiByZXNhbXBsaW5nLiAgU2V0IHRvIGZhbHNlIHRvIHVzZSB0aGUgbmVhcmVzdCBuZWlnaGJvciBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J10gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTQyXSBPcHRpb25hbCBtYXggem9vbSBsZXZlbC4gTm90IHVzZWQgaWYgYHRpbGVHcmlkYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBPcHRpb25hbCBtaW4gem9vbSBsZXZlbC4gTm90IHVzZWQgaWYgYHRpbGVHcmlkYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gT3B0aW9uYWwgdGlsZSBncmlkIHJlc29sdXRpb24gYXQgbGV2ZWwgemVyby4gTm90IHVzZWQgaWYgYHRpbGVHcmlkYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gW3RpbGVHcmlkXSBUaWxlIGdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIHdpdGggYSBsb2FkZXJcbiAqIGluc3RlYWQuICBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpbGUgc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZT1bMjU2LCAyNTZdXSBUaGUgdGlsZSBzaXplIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS5cbiAqIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2d1dHRlcj0wXSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGd1dHRlciBhcm91bmQgaW1hZ2UgdGlsZXMgdG8gaWdub3JlLlxuICogVGhpcyBhbGxvd3MgYXJ0aWZhY3RzIG9mIHJlbmRlcmluZyBhdCB0aWxlIGVkZ2VzIHRvIGJlIGlnbm9yZWQuXG4gKiBTdXBwb3J0ZWQgaW1hZ2VzIHNob3VsZCBiZSB3aWRlciBhbmQgdGFsbGVyIHRoYW4gdGhlIHRpbGUgc2l6ZSBieSBhIHZhbHVlIG9mIGAyIHggZ3V0dGVyYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGFuZCBwcm92aWRlIGEgZnVuY3Rpb25cbiAqIGZvciB0aGUgdXJsIG9wdGlvbiBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsXG4gKiBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLiBBIGB7Py0/fWAgdGVtcGxhdGUgcGF0dGVybiwgZm9yIGV4YW1wbGUgYHN1YmRvbWFpbnthLWZ9LmRvbWFpbi5jb21gLFxuICogbWF5IGJlIHVzZWQgaW5zdGVhZCBvZiBkZWZpbmluZyBlYWNoIG9uZSBzZXBhcmF0ZWx5IGluIHRoZSBgdXJsc2Agb3B0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbdXJsc10gRGVwcmVjYXRlZC4gIFVzZSBhbiBJbWFnZVRpbGUgc291cmNlIGFuZCBwcm92aWRlIGFuIGFycmF5IG9mIFVSTHMgZm9yIHRoZVxuICogdXJsIG9wdGlvbiBpbnN0ZWFkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV2hldGhlciB0byB3cmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBEdXJhdGlvbiBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uIGZvciByZW5kZXJpbmcuXG4gKiBUbyBkaXNhYmxlIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24sIHBhc3MgYHRyYW5zaXRpb246IDBgLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vYXJyYXkuanNcIikuTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufSBbekRpcmVjdGlvbj0wXVxuICogQ2hvb3NlIHdoZXRoZXIgdG8gdXNlIHRpbGVzIHdpdGggYSBoaWdoZXIgb3IgbG93ZXIgem9vbSBsZXZlbCB3aGVuIGJldHdlZW4gaW50ZWdlclxuICogem9vbSBsZXZlbHMuIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkflRpbGVHcmlkI2dldFpGb3JSZXNvbHV0aW9ufS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExheWVyIHNvdXJjZSBmb3IgdGlsZSBkYXRhIHdpdGggVVJMcyBpbiBhIHNldCBYWVogZm9ybWF0IHRoYXQgYXJlXG4gKiBkZWZpbmVkIGluIGEgVVJMIHRlbXBsYXRlLiBCeSBkZWZhdWx0LCB0aGlzIGZvbGxvd3MgdGhlIHdpZGVseS11c2VkXG4gKiBHb29nbGUgZ3JpZCB3aGVyZSBgeGAgMCBhbmQgYHlgIDAgYXJlIGluIHRoZSB0b3AgbGVmdC4gR3JpZHMgbGlrZVxuICogVE1TIHdoZXJlIGB4YCAwIGFuZCBgeWAgMCBhcmUgaW4gdGhlIGJvdHRvbSBsZWZ0IGNhbiBiZSB1c2VkIGJ5XG4gKiB1c2luZyB0aGUgYHsteX1gIHBsYWNlaG9sZGVyIGluIHRoZSBVUkwgdGVtcGxhdGUsIHNvIGxvbmcgYXMgdGhlXG4gKiBzb3VyY2UgZG9lcyBub3QgaGF2ZSBhIGN1c3RvbSB0aWxlIGdyaWQuIEluIHRoaXMgY2FzZVxuICogYSBgdGlsZVVybEZ1bmN0aW9uYCBjYW4gYmUgdXNlZCwgc3VjaCBhczpcbiAqIGBgYGpzXG4gKiAgdGlsZVVybEZ1bmN0aW9uOiBmdW5jdGlvbihjb29yZGluYXRlKSB7XG4gKiAgICByZXR1cm4gJ2h0dHA6Ly9tYXBzZXJ2ZXIuY29tLycgKyBjb29yZGluYXRlWzBdICsgJy8nICtcbiAqICAgICAgY29vcmRpbmF0ZVsxXSArICcvJyArICgtY29vcmRpbmF0ZVsyXSAtIDEpICsgJy5wbmcnO1xuICogIH1cbiAqIGBgYFxuICogQGFwaVxuICovXG5jbGFzcyBYWVogZXh0ZW5kcyBUaWxlSW1hZ2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gWFlaIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uID1cbiAgICAgIG9wdGlvbnMucHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1Nyc7XG5cbiAgICBjb25zdCB0aWxlR3JpZCA9XG4gICAgICBvcHRpb25zLnRpbGVHcmlkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnRpbGVHcmlkXG4gICAgICAgIDogY3JlYXRlWFlaKHtcbiAgICAgICAgICAgIGV4dGVudDogZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbiksXG4gICAgICAgICAgICBtYXhSZXNvbHV0aW9uOiBvcHRpb25zLm1heFJlc29sdXRpb24sXG4gICAgICAgICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20sXG4gICAgICAgICAgICBtaW5ab29tOiBvcHRpb25zLm1pblpvb20sXG4gICAgICAgICAgICB0aWxlU2l6ZTogb3B0aW9ucy50aWxlU2l6ZSxcbiAgICAgICAgICB9KTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgY3Jvc3NPcmlnaW46IG9wdGlvbnMuY3Jvc3NPcmlnaW4sXG4gICAgICBpbnRlcnBvbGF0ZTogb3B0aW9ucy5pbnRlcnBvbGF0ZSxcbiAgICAgIHByb2plY3Rpb246IHByb2plY3Rpb24sXG4gICAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICAgIHRpbGVHcmlkOiB0aWxlR3JpZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHRpbGVQaXhlbFJhdGlvOiBvcHRpb25zLnRpbGVQaXhlbFJhdGlvLFxuICAgICAgdGlsZVVybEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbixcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICB1cmxzOiBvcHRpb25zLnVybHMsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IHRydWUsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSxcbiAgICAgIHpEaXJlY3Rpb246IG9wdGlvbnMuekRpcmVjdGlvbixcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmd1dHRlcl8gPSBvcHRpb25zLmd1dHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5ndXR0ZXIgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEd1dHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ndXR0ZXJfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFhZWjtcbiIsICIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL09TTVxuICovXG5cbmltcG9ydCBYWVogZnJvbSAnLi9YWVouanMnO1xuXG4vKipcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250YWluaW5nIGEgbGluayB0byB0aGUgT3BlblN0cmVldE1hcCBDb3B5cmlnaHQgYW5kIExpY2Vuc2VcbiAqIHBhZ2UuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBBVFRSSUJVVElPTiA9XG4gICcmIzE2OTsgJyArXG4gICc8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCIgdGFyZ2V0PVwiX2JsYW5rXCI+T3BlblN0cmVldE1hcDwvYT4gJyArXG4gICdjb250cmlidXRvcnMuJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdIERlcHJlY2F0ZWQuICBVc2UgdGhlIGNhY2hlU2l6ZSBvcHRpb24gb24gdGhlIGxheWVyIGluc3RlYWQuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW49J2Fub255bW91cyddIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPXRydWVdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy4gIFNldCB0byBmYWxzZSB0byB1c2UgdGhlIG5lYXJlc3QgbmVpZ2hib3IgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT0xOV0gTWF4IHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkPTAuNV0gTWF4aW11bSBhbGxvd2VkIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcGl4ZWxzKS5cbiAqIEhpZ2hlciB2YWx1ZXMgY2FuIGluY3JlYXNlIHJlcHJvamVjdGlvbiBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBEdXJhdGlvbiBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uIGZvciByZW5kZXJpbmcuXG4gKiBUbyBkaXNhYmxlIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24sIHBhc3MgYHRyYW5zaXRpb246IDBgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmw9J2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnXSBVUkwgdGVtcGxhdGUuXG4gKiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vYXJyYXkuanNcIikuTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufSBbekRpcmVjdGlvbj0wXVxuICogQ2hvb3NlIHdoZXRoZXIgdG8gdXNlIHRpbGVzIHdpdGggYSBoaWdoZXIgb3IgbG93ZXIgem9vbSBsZXZlbCB3aGVuIGJldHdlZW4gaW50ZWdlclxuICogem9vbSBsZXZlbHMuIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkflRpbGVHcmlkI2dldFpGb3JSZXNvbHV0aW9ufS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExheWVyIHNvdXJjZSBmb3IgdGhlIE9wZW5TdHJlZXRNYXAgdGlsZSBzZXJ2ZXIuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE9TTSBleHRlbmRzIFhZWiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcGVuIFN0cmVldCBNYXAgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGxldCBhdHRyaWJ1dGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IG9wdGlvbnMuYXR0cmlidXRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGlvbnMgPSBbQVRUUklCVVRJT05dO1xuICAgIH1cblxuICAgIGNvbnN0IGNyb3NzT3JpZ2luID1cbiAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiAnYW5vbnltb3VzJztcblxuICAgIGNvbnN0IHVybCA9XG4gICAgICBvcHRpb25zLnVybCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy51cmxcbiAgICAgICAgOiAnaHR0cHM6Ly90aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZyc7XG5cbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IGF0dHJpYnV0aW9ucyxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBmYWxzZSxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICBpbnRlcnBvbGF0ZTogb3B0aW9ucy5pbnRlcnBvbGF0ZSxcbiAgICAgIG1heFpvb206IG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhab29tIDogMTksXG4gICAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIHVybDogdXJsLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICB6RGlyZWN0aW9uOiBvcHRpb25zLnpEaXJlY3Rpb24sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT1NNO1xuIiwgImltcG9ydCAnLi8uLi8uLi9jc3Mvb2wuY3NzJ1xuaW1wb3J0IE1hcCBmcm9tICdvbC9NYXAuanMnO1xuaW1wb3J0IFZpZXcgZnJvbSAnb2wvVmlldy5qcyc7XG5pbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUuanMnO1xuaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNLmpzJztcbmltcG9ydCB7XG4gICAgU3R5bGUsXG4gICAgRmlsbCxcbiAgICBTdHJva2UsXG4gICAgQ2lyY2xlLFxuICAgIFRleHRcbn0gZnJvbSAnb2wvc3R5bGUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXBDb21wb25lbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVnZW5kT3BlbmVkOiBmYWxzZSxcbiAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuJHJlZnMubWFwLFxuICAgICAgICAgICAgICAgIGxheWVyczogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVGlsZUxheWVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbmV3IE9TTSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdPcGVuU3RyZWV0TWFwJyxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB2aWV3OiBuZXcgVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb246ICdFUFNHOjQzMjYnLFxuICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogMixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlRnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZSh7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAyNTUsIDI1NSwgMSknXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDE5MiwgMTkyLCAxOTIsIDEpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRleHQ6IG5ldyBUZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgZm9udDogJzEycHggc2Fucy1zZXJpZicsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmZWF0dXJlLmdldCgnbmFtZScpLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiAtMTUsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IDUsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRGaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC41KScsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyMjcsIDIyNywgMjI3LCAxKScsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBbNSwgMiwgMiwgNV1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZ290b0ZlYXR1cmUoZmVhdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0VmlldygpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIGNlbnRlcjogZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldENvb3JkaW5hdGVzKCksXG4gICAgICAgICAgICAgICAgem9vbTogMTAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDIwMDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7O0FBY0EsSUFBTSxZQUFOLE1BQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJZCxZQUFZLE1BQU07QUFJaEIsU0FBSztBQUtMLFNBQUs7QUFPTCxTQUFLLE9BQU87QUFPWixTQUFLLFNBQVM7QUFBQSxFQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLGlCQUFpQjtBQUNmLFNBQUssbUJBQW1CO0FBQUEsRUFDMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsa0JBQWtCO0FBQ2hCLFNBQUsscUJBQXFCO0FBQUEsRUFDNUI7QUFDRjtBQWdCQSxJQUFPLGdCQUFROzs7QUNyRWYsSUFBTywwQkFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1iLGdCQUFnQjtBQUNsQjs7O0FDTkEsSUFBTSxhQUFOLE1BQWlCO0FBQUEsRUFDZixjQUFjO0FBTVosU0FBSyxXQUFXO0FBQUEsRUFDbEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFVBQVU7QUFDUixRQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2xCLFdBQUssV0FBVztBQUNoQixXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxrQkFB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QUssSUFBSSxHQUFHO0FBQUEsRUFDdkIsYUFBYSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsRUFDekIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDdkIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDdkIsWUFBWSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsRUFDekIsV0FBVyxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsRUFDdkIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDM0IsYUFBYSxDQUFDLElBQUksS0FBSyxFQUFFO0FBQUEsRUFDekIsU0FBUyxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsRUFDckIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDekIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDMUIsTUFBTSxDQUFDLEtBQUssS0FBSyxDQUFDO0FBQUEsRUFDbEIsV0FBVyxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsRUFDeEIsTUFBTSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDcEIsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQUEsRUFDakIsYUFBYSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsRUFDMUIsTUFBTSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDcEIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDeEIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDdkIsV0FBVyxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsRUFDdkIsUUFBUSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsRUFDbkIsT0FBTyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDckIsT0FBTyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDckIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDeEIsZUFBZSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsRUFDN0IsV0FBVyxDQUFDLEtB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QSxFQUNuQixNQUFNLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxFQUNwQixNQUFNLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxFQUNwQixZQUFZLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxFQUMxQixRQUFRLENBQUMsS0FBSyxHQUFHLEdBQUc7QUFBQSxFQUNwQixlQUFlLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxFQUM1QixLQUFLLENBQUMsS0FBSyxHQUFHLENBQUM7QUFBQSxFQUNmLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3pCLFdBQVcsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLEVBQ3hCLGFBQWEsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLEVBQ3pCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3RCLFlBQVksQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLEVBQ3pCLFVBQVUsQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUFBLEVBQ3RCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3hCLFFBQVEsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLEVBQ3BCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3RCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3ZCLFdBQVcsQ0FBQyxLQUFLLElBQUksR0FBRztBQUFBLEVBQ3hCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3pCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3pCLE1BQU0sQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ3BCLGFBQWEsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLEVBQ3pCLFdBQVcsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLEVBQ3hCLEtBQUssQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLEVBQ25CLE1BQU0sQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLEVBQ2xCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFB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QUFBQSxJQUNkLGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxJQUNYLGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxJQUNULGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxJQUNULGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxJQUNULGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxJQUNYLGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxJQUFJLEdBQUc7QUFBQSxJQUNWLGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxJQUNYLGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxJQUNULGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxJQUNULGFBQWEsR0FBRyxDQUFDO0FBQUEsSUFDakIsZUFBZSxVQUFVO0FBQUEsRUFDM0I7QUFBQSxFQUNBLENBQUMsSUFBSSxJQUFJLEdBQUc7QUFBQSxJQUNWLGFBQWEsR0FBRyxDQUFDO0FBQUEs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IkV2ZW50VHlwZV9kZWZhdWx0IiwgIlJBRElVUyIsICJFWFRFTlQiLCAiTUVURVJTX1BFUl9VTklUIiwgIlBST0pFQ1RJT05TIiwgImFkZCIsICJnZXQiLCAidHJhbnNmb3JtIiwgImNvb3JkaW5hdGVzIiwgImVxdWFscyIsICJleHRlbmQiLCAiaXNFbXB0eSIsICJpc0VtcHR5IiwgImludGVyc2VjdHMiLCAiaXNFbXB0eSIsICJjb29yZGluYXRlcyIsICJhZGQiLCAiZXF1YWxzIiwgInNjYWxlIiwgIndyYXBYIiwgImRpc2FibGUiLCAiYWRkIiwgImdldCIsICJ0b0VQU0c0MzI2IiwgImdldCIsICJnZXQiLCAiZXF1YWxzIiwgIlBST0pFQ1RJT05TIiwgIm5vbmUiLCAidHJhbnNmb3JtIiwgInRyYW5zZm9ybSIsICJ0cmFuc2Zvcm0iLCAicm90YXRlIiwgInNjYWxlIiwgInRyYW5zZm9ybSIsICJjbG9uZSIsICJleHRlbnQiLCAiZ2V0IiwgInNjYWxlIiwgImNvb3JkaW5hdGVzIiwgInJvdGF0ZSIsICJzY2FsZSIsICJzcXVhcmVkRGlzdGFuY2UiLCAiY29vcmRpbmF0ZXMiLCAic3F1YXJlZERpc3RhbmNlIiwgImNvb3JkaW5hdGVzIiwgImNvb3JkaW5hdGVzIiwgImNvb3JkaW5hdGVzIiwgInNxdWFyZWREaXN0YW5jZSIsICJjb29yZGluYXRlcyIsICJsaW5lYXJSaW5nIiwgImxpbmVhclJpbmdzIiwgImlzRW1wdHkiLCAiYWRkIiwgImlzRW1wdHkiLCAidXNlclByb2plY3Rpb24iLCAiZXF1YWxzIiwgIm5vbmUiLCAibGF5ZXJTdGF0ZSIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJpbnRlcnNlY3RzIiwgImxldmVsIiwgImV4dGVuZCIsICJzY2FsZSIsICJzY2FsZSIsICJ0b1N0cmluZyIsICJjYWNoZSIsICJjYW52YXNQb29sIiwgImdldCIsICJ0b1N0cmluZyIsICJnZXQiLCAic2NhbGUiLCAiYWRkIiwgInNjYWxlIiwgImdldCIsICJzY2FsZSIsICJnZXQiLCAiaW1hZ2UiLCAic2NhbGUiLCAicGFyc2UiLCAicGFyc2UiLCAiY29udGV4dCIsICJ0b1N0cmluZyIsICJjb250ZXh0IiwgIlByb3BlcnR5IiwgIndyYXBYIiwgImNvb3JkaW5hdGVzIiwgImNhbGxiYWNrIiwgIkV2ZW50X2RlZmF1bHQiLCAiRXZlbnRfZGVmYXVsdCIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJQcm9wZXJ0eSIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJuZXdFdmVudCIsICJ0cmFuc2Zvcm0iLCAiY29udGFpbnMiLCAiUHJvcGVydHlfZGVmYXVsdCIsICJQcm9wZXJ0eV9kZWZhdWx0IiwgImFsd2F5cyIsICJjZW50cm9pZCIsICJtYXAiLCAiY29vcmRpbmF0ZXMiLCAiYWx3YXlzIiwgImRlZmF1bHRzIiwgImRlZmF1bHRzIiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgImlzRW1wdHkiLCAiZXF1YWxzIiwgIk1hcF9kZWZhdWx0IiwgImNhY2hlU2l6ZSIsICJMYXllcl9kZWZhdWx0IiwgInJlbmRlciIsICJMYXllcl9kZWZhdWx0IiwgInRyYW5zZm9ybSIsICJFdmVudF9kZWZhdWx0IiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgInNlbGYiLCAiZXh0ZW5kIiwgIndpZHRoIiwgImhlaWdodCIsICJ4UG9zIiwgInlQb3MiLCAic291cmNlIiwgInNpemUiLCAiYnl0ZXNQZXJQaXhlbCIsICJjb250ZXh0IiwgImltYWdlRGF0YSIsICJkYXRhIiwgIm9mZnNldCIsICJsZW4iLCAiY2FudmFzIiwgInN0YXRlIiwgIkRhdGFUaWxlX2RlZmF1bHQiLCAic3RhdGUiLCAiVGlsZV9kZWZhdWx0IiwgImNyZWF0ZU9yVXBkYXRlIiwgImNyZWF0ZU9yVXBkYXRlIiwgImdldENhY2hlS2V5IiwgIkxheWVyX2RlZmF1bHQiLCAiY3JlYXRlT3JVcGRhdGUiLCAiY2FjaGVTaXplIiwgIlRpbGVfZGVmYXVsdCIsICJEYXRhVGlsZV9kZWZhdWx0IiwgImR4IiwgImR5IiwgImkiLCAiZXF1YWxzIiwgImZyYW1lU3RhdGUiLCAiVGlsZV9kZWZhdWx0IiwgImdldCIsICJzZWxmIiwgImNyZWF0ZU9yVXBkYXRlIiwgInNjYWxlIiwgIndyYXBYIiwgImdldCIsICJzY2FsZSIsICJ3cmFwWCIsICJUaWxlX2RlZmF1bHQiLCAiVGlsZV9kZWZhdWx0IiwgIlRpbGVfZGVmYXVsdCIsICJ6IiwgIngiLCAieSIsICJwaXhlbFJhdGlvIiwgInJlbmRlciIsICJnZXQiLCAiTWFwX2RlZmF1bHQiLCAiVGlsZV9kZWZhdWx0Il0KfQo=
